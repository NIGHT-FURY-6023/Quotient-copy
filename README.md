├── LICENSE
├── README.md
├── __pycache__
    ├── config.cpython-312.pyc
    └── constants.cpython-312.pyc
├── aerich.ini
├── bot.py
├── cogs
    ├── esports
    │   ├── __init__.py
    │   ├── errors.py
    │   ├── events
    │   │   ├── __init__.py
    │   │   ├── scrims.py
    │   │   ├── slots.py
    │   │   ├── ssverify.py
    │   │   ├── tags.py
    │   │   └── tourneys.py
    │   ├── helpers
    │   │   ├── __init__.py
    │   │   ├── converters.py
    │   │   ├── image.py
    │   │   ├── tourney.py
    │   │   └── utils.py
    │   ├── menus.py
    │   ├── slash
    │   │   ├── __init__.py
    │   │   └── scrims.py
    │   └── views
    │   │   ├── __init__.py
    │   │   ├── base.py
    │   │   ├── groupm
    │   │       ├── __init__.py
    │   │       ├── _paginator.py
    │   │       ├── _refresh.py
    │   │       └── main.py
    │   │   ├── idp
    │   │       └── __init__.py
    │   │   ├── paginator
    │   │       └── __init__.py
    │   │   ├── points
    │   │       ├── __init__.py
    │   │       ├── conts.py
    │   │       └── main.py
    │   │   ├── scrims
    │   │       ├── __init__.py
    │   │       ├── _ac.py
    │   │       ├── _ban.py
    │   │       ├── _base.py
    │   │       ├── _btns.py
    │   │       ├── _cdn.py
    │   │       ├── _days.py
    │   │       ├── _design.py
    │   │       ├── _edit.py
    │   │       ├── _formatter.py
    │   │       ├── _pages.py
    │   │       ├── _reserve.py
    │   │       ├── _slotlist.py
    │   │       ├── _toggle.py
    │   │       ├── _wiz.py
    │   │       ├── main.py
    │   │       └── selector.py
    │   │   ├── slotm
    │   │       ├── __init__.py
    │   │       ├── editor.py
    │   │       ├── public
    │   │       │   ├── __init__.py
    │   │       │   ├── _cancel.py
    │   │       │   ├── _claim.py
    │   │       │   ├── _idp.py
    │   │       │   └── _reminder.py
    │   │       ├── scrimsedit.py
    │   │       ├── setup.py
    │   │       └── time.py
    │   │   ├── smslotlist
    │   │       ├── __init__.py
    │   │       ├── button.py
    │   │       ├── editor.py
    │   │       └── select.py
    │   │   ├── ssmod
    │   │       ├── __init__.py
    │   │       ├── _buttons.py
    │   │       ├── _edit.py
    │   │       ├── _setup.py
    │   │       ├── _type.py
    │   │       └── _wiz.py
    │   │   ├── tagcheck
    │   │       └── __init__.py
    │   │   └── tourney
    │   │       ├── __init__.py
    │   │       ├── _base.py
    │   │       ├── _buttons.py
    │   │       ├── _editor.py
    │   │       ├── _partner.py
    │   │       ├── _select.py
    │   │       ├── _wiz.py
    │   │       ├── groups.py
    │   │       ├── main.py
    │   │       └── slotm.py
    ├── events
    │   ├── __init__.py
    │   ├── cmds.py
    │   ├── errors.py
    │   ├── interaction.py
    │   ├── logs.py
    │   ├── main.py
    │   ├── tasks.py
    │   └── votes.py
    ├── mod
    │   ├── __init__.py
    │   ├── events
    │   │   ├── __init__.py
    │   │   ├── lockdown.py
    │   │   └── roles.py
    │   ├── utils.py
    │   └── views
    │   │   ├── __init__.py
    │   │   └── role.py
    ├── premium
    │   ├── __init__.py
    │   ├── expire.py
    │   └── views.py
    ├── quomisc
    │   ├── __init__.py
    │   ├── alerts.py
    │   ├── dev.py
    │   ├── helper.py
    │   └── views.py
    ├── reminder
    │   └── __init__.py
    └── utility
    │   ├── __init__.py
    │   ├── events
    │       ├── __init__.py
    │       ├── autopurge.py
    │       └── reminder.py
    │   ├── functions.py
    │   └── views
    │       ├── __init__.py
    │       └── embeds.py
├── config.py
├── constants.py
├── core
    ├── Bot.py
    ├── Cog.py
    ├── Context.py
    ├── Help.py
    ├── __init__.py
    ├── __pycache__
    │   ├── Bot.cpython-312.pyc
    │   ├── Cog.cpython-312.pyc
    │   ├── Context.cpython-312.pyc
    │   ├── Help.cpython-312.pyc
    │   ├── __init__.cpython-312.pyc
    │   ├── cache.cpython-312.pyc
    │   ├── cooldown.cpython-312.pyc
    │   ├── decorators.cpython-312.pyc
    │   └── views.cpython-312.pyc
    ├── _pages.py
    ├── cache.py
    ├── cooldown.py
    ├── decorators.py
    ├── embeds.py
    └── views.py
├── data
    ├── font
    │   ├── Ubuntu-Regular.ttf
    │   ├── robo-bold.ttf
    │   └── robo-italic.ttf
    └── img
    │   ├── ptable1.jpg
    │   ├── ptable10.jpg
    │   ├── ptable11.jpg
    │   ├── ptable12.jpg
    │   ├── ptable13.jpg
    │   ├── ptable14.jpg
    │   ├── ptable15.jpg
    │   ├── ptable16.jpg
    │   ├── ptable17.jpg
    │   ├── ptable18.jpg
    │   ├── ptable19.jpg
    │   ├── ptable2.jpg
    │   ├── ptable20.jpg
    │   ├── ptable3.jpg
    │   ├── ptable4.jpg
    │   ├── ptable5.jpg
    │   ├── ptable6.jpg
    │   ├── ptable7.jpg
    │   ├── ptable8.jpg
    │   ├── ptable9.jpg
    │   ├── rect2.png
    │   ├── rect3.png
    │   └── rectangle.png
├── example_config.py
├── models
    ├── __init__.py
    ├── __pycache__
    │   └── __init__.cpython-312.pyc
    ├── esports
    │   ├── __init__.py
    │   ├── __pycache__
    │   │   ├── __init__.cpython-312.pyc
    │   │   ├── scrims.cpython-312.pyc
    │   │   ├── slotm.cpython-312.pyc
    │   │   ├── ssverify.cpython-312.pyc
    │   │   ├── tagcheck.cpython-312.pyc
    │   │   └── tourney.cpython-312.pyc
    │   ├── ptable.py
    │   ├── reserve.py
    │   ├── scrims.py
    │   ├── slotm.py
    │   ├── ssverify.py
    │   ├── tagcheck.py
    │   └── tourney.py
    ├── helpers
    │   ├── __init__.py
    │   ├── __pycache__
    │   │   ├── __init__.cpython-312.pyc
    │   │   ├── cfields.cpython-312.pyc
    │   │   ├── functions.cpython-312.pyc
    │   │   └── validators.cpython-312.pyc
    │   ├── cfields.py
    │   ├── functions.py
    │   └── validators.py
    └── misc
    │   ├── AutoPurge.py
    │   ├── Autorole.py
    │   ├── Commands.py
    │   ├── Lockdown.py
    │   ├── Snipe.py
    │   ├── Tag.py
    │   ├── Timer.py
    │   ├── User.py
    │   ├── Votes.py
    │   ├── __init__.py
    │   ├── __pycache__
    │       ├── AutoPurge.cpython-312.pyc
    │       ├── Autorole.cpython-312.pyc
    │       ├── Commands.cpython-312.pyc
    │       ├── Lockdown.cpython-312.pyc
    │       ├── Snipe.cpython-312.pyc
    │       ├── Tag.cpython-312.pyc
    │       ├── Timer.cpython-312.pyc
    │       ├── User.cpython-312.pyc
    │       ├── Votes.cpython-312.pyc
    │       ├── __init__.cpython-312.pyc
    │       ├── alerts.cpython-312.pyc
    │       ├── block.cpython-312.pyc
    │       ├── guild.cpython-312.pyc
    │       └── premium.cpython-312.pyc
    │   ├── alerts.py
    │   ├── block.py
    │   ├── guild.py
    │   └── premium.py
├── requirements.txt
├── server
    ├── __init__.py
    ├── app
    │   ├── __init__.py
    │   └── payment.py
    └── templates
    │   ├── payu.html
    │   └── response.html
├── sockets
    ├── __init__.py
    ├── app
    │   ├── __init__.py
    │   └── app.py
    ├── events
    │   ├── __init__.py
    │   ├── dashgate.py
    │   ├── guilds.py
    │   ├── premium.py
    │   ├── scrims.py
    │   ├── settings.py
    │   └── tourney.py
    └── schemas
    │   ├── __init__.py
    │   ├── _guild.py
    │   ├── _resp.py
    │   ├── _scrim.py
    │   └── _tourney.py
└── utils
    ├── __init__.py
    ├── __pycache__
        ├── __init__.cpython-312.pyc
        ├── buttons.cpython-312.pyc
        ├── converters.cpython-312.pyc
        ├── default.cpython-312.pyc
        ├── emote.cpython-312.pyc
        ├── exceptions.cpython-312.pyc
        ├── formats.cpython-312.pyc
        ├── inputs.cpython-312.pyc
        ├── paginator.cpython-312.pyc
        ├── regex.cpython-312.pyc
        └── time.cpython-312.pyc
    ├── buttons.py
    ├── checks.py
    ├── converters.py
    ├── default.py
    ├── emote.py
    ├── exceptions.py
    ├── formats.py
    ├── inputs.py
    ├── paginator.py
    ├── regex.py
    └── time.py


/LICENSE:
--------------------------------------------------------------------------------
 1 | MIT License
 2 | 
 3 | Copyright (c) 2025 ₦ł₵₭  ₣ɄⱤɎ
 4 | 
 5 | Permission is hereby granted, free of charge, to any person obtaining a copy
 6 | of this software and associated documentation files (the "Software"), to deal
 7 | in the Software without restriction, including without limitation the rights
 8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 9 | copies of the Software, and to permit persons to whom the Software is
10 | furnished to do so, subject to the following conditions:
11 | 
12 | The above copyright notice and this permission notice shall be included in all
13 | copies or substantial portions of the Software.
14 | 
15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
21 | SOFTWARE.
22 | 


--------------------------------------------------------------------------------
/README.md:
--------------------------------------------------------------------------------
    1 | # Quotient-copy
    2 | its not my code the code is open source on Quotient is the ultimate open-source discord bot designed to empower E sports communities
    3 | 
    4 | 
    5 | ├── LICENSE
    6 | ├── README.md
    7 | ├── __pycache__
    8 |     ├── config.cpython-312.pyc
    9 |     └── constants.cpython-312.pyc
   10 | ├── aerich.ini
   11 | ├── bot.py
   12 | ├── cogs
   13 |     ├── esports
   14 |     │   ├── __init__.py
   15 |     │   ├── errors.py
   16 |     │   ├── events
   17 |     │   │   ├── __init__.py
   18 |     │   │   ├── scrims.py
   19 |     │   │   ├── slots.py
   20 |     │   │   ├── ssverify.py
   21 |     │   │   ├── tags.py
   22 |     │   │   └── tourneys.py
   23 |     │   ├── helpers
   24 |     │   │   ├── __init__.py
   25 |     │   │   ├── converters.py
   26 |     │   │   ├── image.py
   27 |     │   │   ├── tourney.py
   28 |     │   │   └── utils.py
   29 |     │   ├── menus.py
   30 |     │   ├── slash
   31 |     │   │   ├── __init__.py
   32 |     │   │   └── scrims.py
   33 |     │   └── views
   34 |     │   │   ├── __init__.py
   35 |     │   │   ├── base.py
   36 |     │   │   ├── groupm
   37 |     │   │       ├── __init__.py
   38 |     │   │       ├── _paginator.py
   39 |     │   │       ├── _refresh.py
   40 |     │   │       └── main.py
   41 |     │   │   ├── idp
   42 |     │   │       └── __init__.py
   43 |     │   │   ├── paginator
   44 |     │   │       └── __init__.py
   45 |     │   │   ├── points
   46 |     │   │       ├── __init__.py
   47 |     │   │       ├── conts.py
   48 |     │   │       └── main.py
   49 |     │   │   ├── scrims
   50 |     │   │       ├── __init__.py
   51 |     │   │       ├── _ac.py
   52 |     │   │       ├── _ban.py
   53 |     │   │       ├── _base.py
   54 |     │   │       ├── _btns.py
   55 |     │   │       ├── _cdn.py
   56 |     │   │       ├── _days.py
   57 |     │   │       ├── _design.py
   58 |     │   │       ├── _edit.py
   59 |     │   │       ├── _formatter.py
   60 |     │   │       ├── _pages.py
   61 |     │   │       ├── _reserve.py
   62 |     │   │       ├── _slotlist.py
   63 |     │   │       ├── _toggle.py
   64 |     │   │       ├── _wiz.py
   65 |     │   │       ├── main.py
   66 |     │   │       └── selector.py
   67 |     │   │   ├── slotm
   68 |     │   │       ├── __init__.py
   69 |     │   │       ├── editor.py
   70 |     │   │       ├── public
   71 |     │   │       │   ├── __init__.py
   72 |     │   │       │   ├── _cancel.py
   73 |     │   │       │   ├── _claim.py
   74 |     │   │       │   ├── _idp.py
   75 |     │   │       │   └── _reminder.py
   76 |     │   │       ├── scrimsedit.py
   77 |     │   │       ├── setup.py
   78 |     │   │       └── time.py
   79 |     │   │   ├── smslotlist
   80 |     │   │       ├── __init__.py
   81 |     │   │       ├── button.py
   82 |     │   │       ├── editor.py
   83 |     │   │       └── select.py
   84 |     │   │   ├── ssmod
   85 |     │   │       ├── __init__.py
   86 |     │   │       ├── _buttons.py
   87 |     │   │       ├── _edit.py
   88 |     │   │       ├── _setup.py
   89 |     │   │       ├── _type.py
   90 |     │   │       └── _wiz.py
   91 |     │   │   ├── tagcheck
   92 |     │   │       └── __init__.py
   93 |     │   │   └── tourney
   94 |     │   │       ├── __init__.py
   95 |     │   │       ├── _base.py
   96 |     │   │       ├── _buttons.py
   97 |     │   │       ├── _editor.py
   98 |     │   │       ├── _partner.py
   99 |     │   │       ├── _select.py
  100 |     │   │       ├── _wiz.py
  101 |     │   │       ├── groups.py
  102 |     │   │       ├── main.py
  103 |     │   │       └── slotm.py
  104 |     ├── events
  105 |     │   ├── __init__.py
  106 |     │   ├── cmds.py
  107 |     │   ├── errors.py
  108 |     │   ├── interaction.py
  109 |     │   ├── logs.py
  110 |     │   ├── main.py
  111 |     │   ├── tasks.py
  112 |     │   └── votes.py
  113 |     ├── mod
  114 |     │   ├── __init__.py
  115 |     │   ├── events
  116 |     │   │   ├── __init__.py
  117 |     │   │   ├── lockdown.py
  118 |     │   │   └── roles.py
  119 |     │   ├── utils.py
  120 |     │   └── views
  121 |     │   │   ├── __init__.py
  122 |     │   │   └── role.py
  123 |     ├── premium
  124 |     │   ├── __init__.py
  125 |     │   ├── expire.py
  126 |     │   └── views.py
  127 |     ├── quomisc
  128 |     │   ├── __init__.py
  129 |     │   ├── alerts.py
  130 |     │   ├── dev.py
  131 |     │   ├── helper.py
  132 |     │   └── views.py
  133 |     ├── reminder
  134 |     │   └── __init__.py
  135 |     └── utility
  136 |     │   ├── __init__.py
  137 |     │   ├── events
  138 |     │       ├── __init__.py
  139 |     │       ├── autopurge.py
  140 |     │       └── reminder.py
  141 |     │   ├── functions.py
  142 |     │   └── views
  143 |     │       ├── __init__.py
  144 |     │       └── embeds.py
  145 | ├── config.py
  146 | ├── constants.py
  147 | ├── core
  148 |     ├── Bot.py
  149 |     ├── Cog.py
  150 |     ├── Context.py
  151 |     ├── Help.py
  152 |     ├── __init__.py
  153 |     ├── __pycache__
  154 |     │   ├── Bot.cpython-312.pyc
  155 |     │   ├── Cog.cpython-312.pyc
  156 |     │   ├── Context.cpython-312.pyc
  157 |     │   ├── Help.cpython-312.pyc
  158 |     │   ├── __init__.cpython-312.pyc
  159 |     │   ├── cache.cpython-312.pyc
  160 |     │   ├── cooldown.cpython-312.pyc
  161 |     │   ├── decorators.cpython-312.pyc
  162 |     │   └── views.cpython-312.pyc
  163 |     ├── _pages.py
  164 |     ├── cache.py
  165 |     ├── cooldown.py
  166 |     ├── decorators.py
  167 |     ├── embeds.py
  168 |     └── views.py
  169 | ├── data
  170 |     ├── font
  171 |     │   ├── Ubuntu-Regular.ttf
  172 |     │   ├── robo-bold.ttf
  173 |     │   └── robo-italic.ttf
  174 |     └── img
  175 |     │   ├── ptable1.jpg
  176 |     │   ├── ptable10.jpg
  177 |     │   ├── ptable11.jpg
  178 |     │   ├── ptable12.jpg
  179 |     │   ├── ptable13.jpg
  180 |     │   ├── ptable14.jpg
  181 |     │   ├── ptable15.jpg
  182 |     │   ├── ptable16.jpg
  183 |     │   ├── ptable17.jpg
  184 |     │   ├── ptable18.jpg
  185 |     │   ├── ptable19.jpg
  186 |     │   ├── ptable2.jpg
  187 |     │   ├── ptable20.jpg
  188 |     │   ├── ptable3.jpg
  189 |     │   ├── ptable4.jpg
  190 |     │   ├── ptable5.jpg
  191 |     │   ├── ptable6.jpg
  192 |     │   ├── ptable7.jpg
  193 |     │   ├── ptable8.jpg
  194 |     │   ├── ptable9.jpg
  195 |     │   ├── rect2.png
  196 |     │   ├── rect3.png
  197 |     │   └── rectangle.png
  198 | ├── example_config.py
  199 | ├── models
  200 |     ├── __init__.py
  201 |     ├── __pycache__
  202 |     │   └── __init__.cpython-312.pyc
  203 |     ├── esports
  204 |     │   ├── __init__.py
  205 |     │   ├── __pycache__
  206 |     │   │   ├── __init__.cpython-312.pyc
  207 |     │   │   ├── scrims.cpython-312.pyc
  208 |     │   │   ├── slotm.cpython-312.pyc
  209 |     │   │   ├── ssverify.cpython-312.pyc
  210 |     │   │   ├── tagcheck.cpython-312.pyc
  211 |     │   │   └── tourney.cpython-312.pyc
  212 |     │   ├── ptable.py
  213 |     │   ├── reserve.py
  214 |     │   ├── scrims.py
  215 |     │   ├── slotm.py
  216 |     │   ├── ssverify.py
  217 |     │   ├── tagcheck.py
  218 |     │   └── tourney.py
  219 |     ├── helpers
  220 |     │   ├── __init__.py
  221 |     │   ├── __pycache__
  222 |     │   │   ├── __init__.cpython-312.pyc
  223 |     │   │   ├── cfields.cpython-312.pyc
  224 |     │   │   ├── functions.cpython-312.pyc
  225 |     │   │   └── validators.cpython-312.pyc
  226 |     │   ├── cfields.py
  227 |     │   ├── functions.py
  228 |     │   └── validators.py
  229 |     └── misc
  230 |     │   ├── AutoPurge.py
  231 |     │   ├── Autorole.py
  232 |     │   ├── Commands.py
  233 |     │   ├── Lockdown.py
  234 |     │   ├── Snipe.py
  235 |     │   ├── Tag.py
  236 |     │   ├── Timer.py
  237 |     │   ├── User.py
  238 |     │   ├── Votes.py
  239 |     │   ├── __init__.py
  240 |     │   ├── __pycache__
  241 |     │       ├── AutoPurge.cpython-312.pyc
  242 |     │       ├── Autorole.cpython-312.pyc
  243 |     │       ├── Commands.cpython-312.pyc
  244 |     │       ├── Lockdown.cpython-312.pyc
  245 |     │       ├── Snipe.cpython-312.pyc
  246 |     │       ├── Tag.cpython-312.pyc
  247 |     │       ├── Timer.cpython-312.pyc
  248 |     │       ├── User.cpython-312.pyc
  249 |     │       ├── Votes.cpython-312.pyc
  250 |     │       ├── __init__.cpython-312.pyc
  251 |     │       ├── alerts.cpython-312.pyc
  252 |     │       ├── block.cpython-312.pyc
  253 |     │       ├── guild.cpython-312.pyc
  254 |     │       └── premium.cpython-312.pyc
  255 |     │   ├── alerts.py
  256 |     │   ├── block.py
  257 |     │   ├── guild.py
  258 |     │   └── premium.py
  259 | ├── requirements.txt
  260 | ├── server
  261 |     ├── __init__.py
  262 |     ├── app
  263 |     │   ├── __init__.py
  264 |     │   └── payment.py
  265 |     └── templates
  266 |     │   ├── payu.html
  267 |     │   └── response.html
  268 | ├── sockets
  269 |     ├── __init__.py
  270 |     ├── app
  271 |     │   ├── __init__.py
  272 |     │   └── app.py
  273 |     ├── events
  274 |     │   ├── __init__.py
  275 |     │   ├── dashgate.py
  276 |     │   ├── guilds.py
  277 |     │   ├── premium.py
  278 |     │   ├── scrims.py
  279 |     │   ├── settings.py
  280 |     │   └── tourney.py
  281 |     └── schemas
  282 |     │   ├── __init__.py
  283 |     │   ├── _guild.py
  284 |     │   ├── _resp.py
  285 |     │   ├── _scrim.py
  286 |     │   └── _tourney.py
  287 | └── utils
  288 |     ├── __init__.py
  289 |     ├── __pycache__
  290 |         ├── __init__.cpython-312.pyc
  291 |         ├── buttons.cpython-312.pyc
  292 |         ├── converters.cpython-312.pyc
  293 |         ├── default.cpython-312.pyc
  294 |         ├── emote.cpython-312.pyc
  295 |         ├── exceptions.cpython-312.pyc
  296 |         ├── formats.cpython-312.pyc
  297 |         ├── inputs.cpython-312.pyc
  298 |         ├── paginator.cpython-312.pyc
  299 |         ├── regex.cpython-312.pyc
  300 |         └── time.cpython-312.pyc
  301 |     ├── buttons.py
  302 |     ├── checks.py
  303 |     ├── converters.py
  304 |     ├── default.py
  305 |     ├── emote.py
  306 |     ├── exceptions.py
  307 |     ├── formats.py
  308 |     ├── inputs.py
  309 |     ├── paginator.py
  310 |     ├── regex.py
  311 |     └── time.py
  312 | 
  313 | 
  314 | /LICENSE:
  315 | --------------------------------------------------------------------------------
  316 |  1 | MIT License
  317 |  2 | 
  318 |  3 | Copyright (c) 2025 ₦ł₵₭  ₣ɄⱤɎ
  319 |  4 | 
  320 |  5 | Permission is hereby granted, free of charge, to any person obtaining a copy
  321 |  6 | of this software and associated documentation files (the "Software"), to deal
  322 |  7 | in the Software without restriction, including without limitation the rights
  323 |  8 | to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  324 |  9 | copies of the Software, and to permit persons to whom the Software is
  325 | 10 | furnished to do so, subject to the following conditions:
  326 | 11 | 
  327 | 12 | The above copyright notice and this permission notice shall be included in all
  328 | 13 | copies or substantial portions of the Software.
  329 | 14 | 
  330 | 15 | THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  331 | 16 | IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  332 | 17 | FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  333 | 18 | AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  334 | 19 | LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  335 | 20 | OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  336 | 21 | SOFTWARE.
  337 | 22 | 
  338 | 
  339 | 
  340 | --------------------------------------------------------------------------------
  341 | /README.md:
  342 | --------------------------------------------------------------------------------
  343 | 1 | # Quotient-copy
  344 | 2 | its not my code the code is open source on Quotient is the ultimate open-source discord bot designed to empower E sports communities
  345 | 3 | 
  346 | 
  347 | 
  348 | --------------------------------------------------------------------------------
  349 | /__pycache__/config.cpython-312.pyc:
  350 | --------------------------------------------------------------------------------
  351 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/__pycache__/config.cpython-312.pyc
  352 | 
  353 | 
  354 | --------------------------------------------------------------------------------
  355 | /__pycache__/constants.cpython-312.pyc:
  356 | --------------------------------------------------------------------------------
  357 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/__pycache__/constants.cpython-312.pyc
  358 | 
  359 | 
  360 | --------------------------------------------------------------------------------
  361 | /aerich.ini:
  362 | --------------------------------------------------------------------------------
  363 | 1 | [aerich]
  364 | 2 | tortoise_orm = config.TORTOISE
  365 | 3 | location = ./migrations
  366 | 4 | 
  367 | 5 | 
  368 | 
  369 | 
  370 | --------------------------------------------------------------------------------
  371 | /bot.py:
  372 | --------------------------------------------------------------------------------
  373 | 1 | if __name__ == "__main__":
  374 | 2 |     from core import bot
  375 | 3 | 
  376 | 4 |     bot.run(bot.config.DISCORD_TOKEN)
  377 | 5 | 
  378 | 
  379 | 
  380 | --------------------------------------------------------------------------------
  381 | /cogs/esports/__init__.py:
  382 | --------------------------------------------------------------------------------
  383 |   1 | from __future__ import annotations
  384 |   2 | 
  385 |   3 | import typing
  386 |   4 | 
  387 |   5 | from cogs.esports.events.slots import SlotManagerEvents
  388 |   6 | from cogs.esports.views.scrims.main import ScrimsMain
  389 |   7 | from cogs.esports.views.tourney.main import TourneyManager
  390 |   8 | 
  391 |   9 | if typing.TYPE_CHECKING:
  392 |  10 |     from core import Quotient
  393 |  11 | 
  394 |  12 | import discord
  395 |  13 | from discord.ext import commands
  396 |  14 | 
  397 |  15 | from core import Cog, Context, QuotientView
  398 |  16 | from models import *
  399 |  17 | from utils import QuoRole, QuoTextChannel, checks
  400 |  18 | 
  401 |  19 | from .errors import SMError
  402 |  20 | from .events import ScrimEvents, Ssverification, TagEvents, TourneyEvents
  403 |  21 | from .helpers import delete_denied_message
  404 |  22 | from .slash import *
  405 |  23 | from .views import *
  406 |  24 | 
  407 |  25 | 
  408 |  26 | class ScrimManager(Cog, name="Esports"):
  409 |  27 |     def __init__(self, bot: Quotient):
  410 |  28 |         self.bot = bot
  411 |  29 | 
  412 |  30 |     # ************************************************************************************************
  413 |  31 |     @Cog.listener()
  414 |  32 |     async def on_message_delete(self, message: discord.Message):
  415 |  33 |         if not message.guild or message.author.bot:
  416 |  34 |             return
  417 |  35 | 
  418 |  36 |         if message.channel.id in self.bot.cache.scrim_channels:
  419 |  37 |             scrim = await Scrim.get_or_none(registration_channel_id=message.channel.id)
  420 |  38 |             if not scrim or not scrim.opened_at:  # either scrim doesn't exist or it is closed.
  421 |  39 |                 return
  422 |  40 | 
  423 |  41 |             if not message.id in (record.message_id for record in await scrim.assigned_slots.all()):
  424 |  42 |                 return
  425 |  43 | 
  426 |  44 |             slot = [
  427 |  45 |                 slot
  428 |  46 |                 for slot in await scrim.assigned_slots.all()
  429 |  47 |                 if slot.user_id == message.author.id and slot.message_id == message.id
  430 |  48 |             ]
  431 |  49 |             if not slot:  # means their registration was denied
  432 |  50 |                 return
  433 |  51 |             slot = slot[0]
  434 |  52 | 
  435 |  53 |             self.bot.dispatch("scrim_registration_delete", scrim, message, slot)
  436 |  54 | 
  437 |  55 |     # ************************************************************************************************
  438 |  56 | 
  439 |  57 |     @commands.command(aliases=("s", "sm"))
  440 |  58 |     @commands.bot_has_permissions(embed_links=True, add_reactions=True, manage_messages=True)
  441 |  59 |     @commands.bot_has_guild_permissions(manage_channels=True, manage_roles=True, manage_messages=True)
  442 |  60 |     @commands.cooldown(1, 15, type=commands.BucketType.guild)
  443 |  61 |     async def smanager(self, ctx: Context):
  444 |  62 |         """
  445 |  63 |         Contains commands related to Quotient's powerful scrims manager.
  446 |  64 |         """
  447 |  65 |         if not any((ctx.author.guild_permissions.manage_guild, Scrim.is_ignorable(ctx.author))):
  448 |  66 |             return await ctx.error(f"You need `scrims-mod` role or `Manage-Server` permissions to use this command.")
  449 |  67 | 
  450 |  68 |         v = ScrimsMain(ctx)
  451 |  69 |         v.message = await ctx.send(embed=await v.initial_embed(), view=v)
  452 |  70 | 
  453 |  71 |     # ************************************************************************************************
  454 |  72 |     # ************************************************************************************************
  455 |  73 | 
  456 |  74 |     @commands.command(aliases=("tm", "t"))
  457 |  75 |     @commands.bot_has_permissions(embed_links=True, add_reactions=True, manage_messages=True)
  458 |  76 |     @commands.bot_has_guild_permissions(
  459 |  77 |         manage_channels=True, manage_permissions=True, manage_roles=True, manage_messages=True
  460 |  78 |     )
  461 |  79 |     @commands.cooldown(1, 15, type=commands.BucketType.guild)
  462 |  80 |     async def tourney(self, ctx: Context):
  463 |  81 |         """Create & Manage tournaments with Quotient"""
  464 |  82 |         if not Tourney.is_ignorable(ctx.author) and not ctx.author.guild_permissions.manage_guild:
  465 |  83 |             return await ctx.error(
  466 |  84 |                 "You need either `Manage Server` permissions or `@tourney-mod` role to manage tournaments."
  467 |  85 |             )
  468 |  86 | 
  469 |  87 |         view = TourneyManager(ctx)
  470 |  88 |         view.add_item(QuotientView.tricky_invite_button())
  471 |  89 |         view.message = await ctx.send(embed=await view.initial_embed(), view=view)
  472 |  90 | 
  473 |  91 |     @commands.hybrid_command(
  474 |  92 |         aliases=("quickidp",),
  475 |  93 |         extras={"examples": ["idp 1234 pass Miramar", "idp 1234 pass Sanhok @role"]},
  476 |  94 |     )
  477 |  95 |     @commands.bot_has_permissions(embed_links=True, manage_messages=True)
  478 |  96 |     @checks.can_use_sm()
  479 |  97 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  480 |  98 |     async def idp(self, ctx: Context, room_id: str, password: str, map: str, role_to_ping: Optional[discord.Role] = None):
  481 |  99 |         """
  482 | 100 |         Share Id/pass with embed quickly.
  483 | 101 |         Message is automatically deleted after 30 minutes.
  484 | 102 |         """
  485 | 103 |         await ctx.message.delete(delay=0)
  486 | 104 |         room_id, password, map = truncate_string(room_id, 100), truncate_string(password, 100), truncate_string(map, 100)
  487 | 105 | 
  488 | 106 |         _e = discord.Embed(color=self.bot.color)
  489 | 107 |         _e.set_thumbnail(url=getattr(ctx.guild.icon, "url", self.bot.user.avatar.url))
  490 | 108 |         _e.set_author(name=ctx.author, icon_url=ctx.author.display_avatar.url)
  491 | 109 |         _e.add_field(name="Room ID", value=room_id)
  492 | 110 |         _e.add_field(name="Password", value=password)
  493 | 111 |         _e.add_field(name="Map", value=map)
  494 | 112 |         _e.set_footer(text=f"Auto-delete time")
  495 | 113 |         _e.timestamp = self.bot.current_time + timedelta(minutes=30)
  496 | 114 | 
  497 | 115 |         view = IdpView(room_id, password, map)
  498 | 116 |         msg = await ctx.send(
  499 | 117 |             content=role_to_ping.mention if role_to_ping else None,
  500 | 118 |             embed=_e,
  501 | 119 |             view=view,
  502 | 120 |             allowed_mentions=discord.AllowedMentions(roles=True),
  503 | 121 |         )
  504 | 122 |         await self.bot.wait_and_delete(msg, 30 * 60)
  505 | 123 | 
  506 | 124 |     @commands.group(aliases=("eztag",), invoke_without_command=True)
  507 | 125 |     async def easytag(self, ctx: Context):
  508 | 126 |         """Commands related to quotient's eztag"""
  509 | 127 |         await ctx.send_help(ctx.command)
  510 | 128 | 
  511 | 129 |     @easytag.command(name="set", extras={"examples": ["eztag set #channel"]})
  512 | 130 |     # @checks.has_done_setup()
  513 | 131 |     @commands.bot_has_guild_permissions(manage_roles=True)
  514 | 132 |     @commands.has_permissions(manage_guild=True)
  515 | 133 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  516 | 134 |     async def set_eztag(self, ctx: Context, *, channel: QuoTextChannel):
  517 | 135 |         """Set a channel as eztag channel."""
  518 | 136 |         count = await EasyTag.filter(guild_id=ctx.guild.id).count()
  519 | 137 |         guild = await Guild.get(guild_id=ctx.guild.id)
  520 | 138 | 
  521 | 139 |         if count == 1 and not guild.is_premium:
  522 | 140 |             return await ctx.error(
  523 | 141 |                 f"Upgrade your server to Quotient Premium to setup more than 1 EasyTag channel.\n[Click Me to Purchase]({self.bot.prime_link})"
  524 | 142 |             )
  525 | 143 | 
  526 | 144 |         if channel.id in self.bot.cache.eztagchannels:
  527 | 145 |             return await ctx.error(f"This channel is already a easy tag channel.")
  528 | 146 | 
  529 | 147 |         if (
  530 | 148 |             not channel.permissions_for(ctx.me).send_messages
  531 | 149 |             or not channel.permissions_for(ctx.me).embed_links
  532 | 150 |             or not channel.permissions_for(ctx.me).manage_messages
  533 | 151 |         ):
  534 | 152 |             return await ctx.error(
  535 | 153 |                 f"I need `send messages`, `embed links` and `manage messages` permission in {channel.mention}"
  536 | 154 |             )
  537 | 155 | 
  538 | 156 |         role = discord.utils.get(ctx.guild.roles, name="quotient-tag-ignore")
  539 | 157 |         if not role:
  540 | 158 |             role = await ctx.guild.create_role(
  541 | 159 |                 name="quotient-tag-ignore", color=self.bot.color, reason=f"Created by {ctx.author}"
  542 | 160 |             )
  543 | 161 | 
  544 | 162 |         await EasyTag.create(guild_id=ctx.guild.id, channel_id=channel.id)
  545 | 163 |         self.bot.cache.eztagchannels.add(channel.id)
  546 | 164 | 
  547 | 165 |         embed = self.bot.embed(ctx, title="Easy Tagging")
  548 | 166 |         embed.description = """
  549 | 167 |         Unable to mention teammates while registering for scrims or tournaments? Quotient is here for the rescue.
  550 | 168 | 
  551 | 169 |         Use `teammate's ID`, `@teammate_name` or `@teammate's_discord_tag` in your registration format. Quotient will convert that into an actual discord tag.        
  552 | 170 |         """
  553 | 171 |         embed.set_image(url="https://media.discordapp.net/attachments/775707108192157706/850788091236450344/eztags.gif")
  554 | 172 |         msg = await channel.send(embed=embed)
  555 | 173 |         await msg.pin()
  556 | 174 | 
  557 | 175 |         await ctx.success(
  558 | 176 |             f"Successfully added **{channel}** to easy tag channels.\n\nAdd {role.mention} to your roles to ignore your messages in **{channel}**"
  559 | 177 |         )
  560 | 178 | 
  561 | 179 |     @easytag.command(name="remove", extras={"examples": ["eztag remove #channel"]})
  562 | 180 |     # @checks.has_done_setup()
  563 | 181 |     @commands.has_permissions(manage_guild=True)
  564 | 182 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  565 | 183 |     async def remove_eztag(self, ctx: Context, *, channel: QuoTextChannel):
  566 | 184 |         """Remove a eztag channel"""
  567 | 185 |         if not channel.id in self.bot.cache.eztagchannels:
  568 | 186 |             return await ctx.error(f"This is not a EasyTag channel.")
  569 | 187 | 
  570 | 188 |         await EasyTag.filter(channel_id=channel.id).delete()
  571 | 189 |         self.bot.cache.eztagchannels.discard(channel.id)
  572 | 190 |         await ctx.success(f"Removed {channel} from EasyTag channels.")
  573 | 191 | 
  574 | 192 |     @easytag.command(name="config")
  575 | 193 |     # @checks.has_done_setup()
  576 | 194 |     @commands.has_permissions(manage_guild=True)
  577 | 195 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  578 | 196 |     async def config_eztag(self, ctx: Context):
  579 | 197 |         """Get a list of all your easytag channels."""
  580 | 198 |         records = await EasyTag.filter(guild_id=ctx.guild.id)
  581 | 199 |         if not records:
  582 | 200 |             return await ctx.error(
  583 | 201 |                 f"You haven't set any easytag channel yet.\n\nUse `{ctx.prefix}eztag set #{ctx.channel}`"
  584 | 202 |             )
  585 | 203 | 
  586 | 204 |         eztags = []
  587 | 205 |         for idx, record in enumerate(records, start=1):
  588 | 206 |             channel = getattr(record.channel, "mention", record.channel_id)
  589 | 207 |             eztags.append(
  590 | 208 |                 f"`{idx:02}.` {channel} (Delete After: {record.delete_after if record.delete_after else 'Not Set'})"
  591 | 209 |             )
  592 | 210 | 
  593 | 211 |         embed = self.bot.embed(ctx, title="EasyTag config", description="\n".join(eztags))
  594 | 212 |         await ctx.send(embed=embed)
  595 | 213 | 
  596 | 214 |     @easytag.command(name="autodelete", extras={"examples": ["eztag autodelete #channel"]})
  597 | 215 |     #    @checks.has_done_setup()
  598 | 216 |     @commands.has_permissions(manage_guild=True)
  599 | 217 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  600 | 218 |     async def delete_eztag(self, ctx: Context, channel: QuoTextChannel):
  601 | 219 |         """Enable/Disable autodelete for eztag."""
  602 | 220 |         record = await EasyTag.get_or_none(channel_id=channel.id)
  603 | 221 |         if not record:
  604 | 222 |             return await ctx.error(f"This is not a EasyTag Channel.")
  605 | 223 | 
  606 | 224 |         await EasyTag.filter(channel_id=channel.id).update(delete_after=not record.delete_after)
  607 | 225 |         await ctx.success(
  608 | 226 |             f"Delete After for **{channel}** turned {'ON' if not record.delete_after else 'OFF'}!\n\nDelete After automatically deletes the format message after some time."
  609 | 227 |         )
  610 | 228 | 
  611 | 229 |     # ************************************************************************************************
  612 | 230 |     # ************************************************************************************************
  613 | 231 |     # ************************************************************************************************
  614 | 232 |     # ************************************************************************************************
  615 | 233 |     # ************************************************************************************************
  616 | 234 |     # ************************************************************************************************
  617 | 235 |     # ************************************************************************************************
  618 | 236 | 
  619 | 237 |     @commands.group(invoke_without_command=True, aliases=("tc",))
  620 | 238 |     async def tagcheck(self, ctx: Context):
  621 | 239 |         """
  622 | 240 |         Setup tagcheck channels for scrims/tournaments.
  623 | 241 |         """
  624 | 242 |         await ctx.send_help(ctx.command)
  625 | 243 | 
  626 | 244 |     @tagcheck.command(name="set", extras={"examples": ["tc set #channel 4", "tagcheck set #channel 2"]})
  627 | 245 |     @commands.has_permissions(manage_guild=True)
  628 | 246 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  629 | 247 |     # @checks.has_done_setup()
  630 | 248 |     async def tagcheck_set(self, ctx: Context, channel: discord.TextChannel, mentions: int = 4):
  631 | 249 |         """
  632 | 250 |         Set a channel for tagcheck.
  633 | 251 |         mentions defines required mentions, It's 4 by default.
  634 | 252 |         """
  635 | 253 |         count = await TagCheck.filter(guild_id=ctx.guild.id).count()
  636 | 254 |         guild = await Guild.get(guild_id=ctx.guild.id)
  637 | 255 | 
  638 | 256 |         if count == 1 and not guild.is_premium:
  639 | 257 |             return await ctx.error(
  640 | 258 |                 f"Upgrade your server to Quotient Premium to setup more than 1 Tagcheck channel.\n[Click Me to Purchase]({self.bot.prime_link})"
  641 | 259 |             )
  642 | 260 | 
  643 | 261 |         if channel.id in self.bot.cache.tagcheck:
  644 | 262 |             return await ctx.error(f"This channel is already a tagcheck channel.")
  645 | 263 | 
  646 | 264 |         if (
  647 | 265 |             not channel.permissions_for(ctx.me).send_messages
  648 | 266 |             or not channel.permissions_for(ctx.me).embed_links
  649 | 267 |             or not channel.permissions_for(ctx.me).manage_messages
  650 | 268 |         ):
  651 | 269 |             return await ctx.error(
  652 | 270 |                 f"I need `send_messages`, `embed_links` and `manage_messages` permission in {channel.mention}"
  653 | 271 |             )
  654 | 272 | 
  655 | 273 |         role = discord.utils.get(ctx.guild.roles, name="quotient-tag-ignore")
  656 | 274 |         if not role:
  657 | 275 |             role = await ctx.guild.create_role(
  658 | 276 |                 name="quotient-tag-ignore", color=self.bot.color, reason=f"Created by {ctx.author}"
  659 | 277 |             )
  660 | 278 | 
  661 | 279 |         await TagCheck.create(guild_id=ctx.guild.id, channel_id=channel.id, required_mentions=mentions)
  662 | 280 |         self.bot.cache.tagcheck.add(channel.id)
  663 | 281 | 
  664 | 282 |         await ctx.success(
  665 | 283 |             f"Successfully added **{channel}** to tagcheck channels.\n\nAdd {role.mention} to your roles to ignore your messages in **{channel}**"
  666 | 284 |         )
  667 | 285 | 
  668 | 286 |     @tagcheck.command(name="config")
  669 | 287 |     # @checks.has_done_setup()
  670 | 288 |     @commands.has_permissions(manage_guild=True)
  671 | 289 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  672 | 290 |     async def tagcheck_config(self, ctx: Context):
  673 | 291 |         """
  674 | 292 |         Get tagcheck config.
  675 | 293 |         """
  676 | 294 |         records = await TagCheck.filter(guild_id=ctx.guild.id)
  677 | 295 |         if not records:
  678 | 296 |             return await ctx.error(
  679 | 297 |                 f"You haven't set any tagcheck channel yet.\n\nUse `{ctx.prefix}tagcheck set #{ctx.channel}`"
  680 | 298 |             )
  681 | 299 | 
  682 | 300 |         tags = []
  683 | 301 |         for idx, record in enumerate(records, start=1):
  684 | 302 |             channel = getattr(record.channel, "mention", record.channel_id)
  685 | 303 |             tags.append(
  686 | 304 |                 f"`{idx:02}.` {channel} (Mentions: {record.required_mentions},Auto-delete: {record.delete_after if record.delete_after else 'Not Set'})"
  687 | 305 |             )
  688 | 306 | 
  689 | 307 |         embed = self.bot.embed(ctx, title="TagCheck config", description="\n".join(tags))
  690 | 308 |         await ctx.send(embed=embed)
  691 | 309 | 
  692 | 310 |     @tagcheck.command(name="remove", extras={"examples": ["tagcheck remove #channel"]})
  693 | 311 |     @commands.has_permissions(manage_guild=True)
  694 | 312 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  695 | 313 |     async def tagcheck_remove(self, ctx: Context, *, channel: QuoTextChannel):
  696 | 314 |         """Remove a channel from tagcheck"""
  697 | 315 |         if not channel.id in self.bot.cache.tagcheck:
  698 | 316 |             return await ctx.error(f"This is not a TagCheck channel.")
  699 | 317 | 
  700 | 318 |         await TagCheck.filter(channel_id=channel.id).delete()
  701 | 319 |         self.bot.cache.tagcheck.discard(channel.id)
  702 | 320 |         await ctx.success(f"Removed {channel} from TagCheck channels.")
  703 | 321 | 
  704 | 322 |     @tagcheck.command(name="autodelete", extras={"examples": ["tagcheck autodelete #channel"]})
  705 | 323 |     @commands.has_permissions(manage_guild=True)
  706 | 324 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  707 | 325 |     async def tagcheck_autodelete(self, ctx: Context, *, channel: QuoTextChannel):
  708 | 326 |         """Enable/Disable autodelete wrong tagchecks."""
  709 | 327 |         record = await TagCheck.get_or_none(channel_id=channel.id)
  710 | 328 |         if not record:
  711 | 329 |             return await ctx.error(f"This is not a TagCheck Channel.")
  712 | 330 | 
  713 | 331 |         await TagCheck.filter(channel_id=channel.id).update(delete_after=not record.delete_after)
  714 | 332 |         await ctx.success(
  715 | 333 |             f"Autodelete for **{channel}** turned {'ON' if not record.delete_after else 'OFF'}!\nThis automatically deletes the wrong format message after some time."
  716 | 334 |         )
  717 | 335 | 
  718 | 336 |     # ************************************************************************************************
  719 | 337 |     # ************************************************************************************************
  720 | 338 |     # ************************************************************************************************
  721 | 339 |     # ************************************************************************************************
  722 | 340 |     # ************************************************************************************************
  723 | 341 |     # ************************************************************************************************
  724 | 342 |     # ************************************************************************************************
  725 | 343 | 
  726 | 344 |     @commands.command(aliases=("slotm",))
  727 | 345 |     @checks.can_use_sm()
  728 | 346 |     @commands.bot_has_guild_permissions(embed_links=True, manage_messages=True, manage_channels=True)
  729 | 347 |     # # @checks.has_done_setup()
  730 | 348 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  731 | 349 |     async def slotmanager(self, ctx: Context):
  732 | 350 |         """
  733 | 351 |         SlotManager helps people to setup scrims-slots cancel and claim manager.
  734 | 352 |         Users can easily claim and cancel their slots anytime without bothering mods.
  735 | 353 |         """
  736 | 354 |         _view = ScrimsSlotManagerSetup(ctx)
  737 | 355 |         _e = await _view.initial_message(ctx.guild)
  738 | 356 |         _view.add_item(QuotientView.tricky_invite_button())
  739 | 357 |         _view.message = await ctx.send(embed=_e, view=_view, embed_perms=True)
  740 | 358 | 
  741 | 359 |     @commands.command(name="banlog", extras={"examples": ["banlog #channel"]})
  742 | 360 |     @checks.can_use_sm()
  743 | 361 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  744 | 362 |     async def _banlog(self, ctx: Context, *, channel: discord.TextChannel = None):
  745 | 363 |         """
  746 | 364 |         Set a channel for all scrims ban/unban logs
  747 | 365 |         """
  748 | 366 |         if not channel:
  749 | 367 |             record = await BanLog.get_or_none(guild_id=ctx.guild.id)
  750 | 368 |             if not record:
  751 | 369 |                 return await ctx.simple(
  752 | 370 |                     f"You haven't setup any esports ban log channel yet.\n"
  753 | 371 |                     f"Use `{ctx.prefix}banlog #{ctx.channel}` to do it."
  754 | 372 |                 )
  755 | 373 |             return await ctx.simple(
  756 | 374 |                 f"Currently {getattr(record.channel, 'mention', 'deleted-channel')} is serving as ban/unban log channel."
  757 | 375 |             )
  758 | 376 |         if not channel.permissions_for(ctx.me).embed_links:
  759 | 377 |             return await ctx.error(f"I need `embed_links` permission in {channel.mention} to send logs.")
  760 | 378 | 
  761 | 379 |         await BanLog.update_or_create(guild_id=ctx.guild.id, defaults={"channel_id": channel.id})
  762 | 380 |         await ctx.success(f"Successfully set {channel.mention} as esports ban/unban log channel.")
  763 | 381 | 
  764 | 382 |     @commands.group(invoke_without_command=True, aliases=("ss",))
  765 | 383 |     @checks.can_use_tm()
  766 | 384 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
  767 | 385 |     @commands.bot_has_permissions(manage_channels=True, add_reactions=True, embed_links=True, manage_roles=True)
  768 | 386 |     async def ssverify(self, ctx: Context):
  769 | 387 |         """
  770 | 388 |         Setup/Edit ssverification in your server
  771 | 389 |         """
  772 | 390 |         if not await ctx.is_premium_guild():
  773 | 391 |             if not ctx.guild.member_count > 100 and not ctx.guild.id == 779229001986080779:
  774 | 392 |                 return await ctx.error("Your server must have atleast 100 members to setup ssverification.")
  775 | 393 | 
  776 | 394 |         _view = SsmodMainView(ctx)
  777 | 395 |         _view.message = await ctx.send(embed=await _view.initial_message(), view=_view, embed_perms=True)
  778 | 396 | 
  779 | 397 | 
  780 | 398 | async def setup(bot: Quotient):
  781 | 399 |     await bot.add_cog(ScrimManager(bot))
  782 | 400 |     await bot.add_cog(SMError(bot))
  783 | 401 |     await bot.add_cog(ScrimEvents(bot))
  784 | 402 |     await bot.add_cog(TourneyEvents(bot))
  785 | 403 |     await bot.add_cog(TagEvents(bot))
  786 | 404 |     await bot.add_cog(Ssverification(bot))
  787 | 405 |     await bot.add_cog(SlotManagerEvents(bot))
  788 | 406 |     await bot.add_cog(SlashCog(bot))
  789 | 407 | 
  790 | 
  791 | 
  792 | --------------------------------------------------------------------------------
  793 | /cogs/esports/errors.py:
  794 | --------------------------------------------------------------------------------
  795 |   1 | from __future__ import annotations
  796 |   2 | 
  797 |   3 | import typing
  798 |   4 | 
  799 |   5 | if typing.TYPE_CHECKING:
  800 |   6 |     from core import Quotient
  801 |   7 | 
  802 |   8 | from contextlib import suppress
  803 |   9 | 
  804 |  10 | import discord
  805 |  11 | 
  806 |  12 | from constants import EsportsLog, EsportsRole, RegDeny
  807 |  13 | from core import Cog
  808 |  14 | from models import ArrayAppend, AssignedSlot, EasyTag, ReservedSlot, Scrim, TagCheck, Timer, Tourney
  809 |  15 | from utils import plural
  810 |  16 | 
  811 |  17 | from .helpers import delete_denied_message, scrim_work_role, tourney_work_role
  812 |  18 | 
  813 |  19 | 
  814 |  20 | class SMError(Cog):
  815 |  21 |     def __init__(self, bot: Quotient):
  816 |  22 |         self.bot = bot
  817 |  23 | 
  818 |  24 |     @staticmethod
  819 |  25 |     def red_embed(description: str):
  820 |  26 |         embed = discord.Embed(color=discord.Color.red(), description=description)
  821 |  27 |         return embed
  822 |  28 | 
  823 |  29 |     @Cog.listener()
  824 |  30 |     async def on_tourney_registration_deny(self, message: discord.Message, _type: RegDeny, tourney: Tourney, **kwargs):
  825 |  31 |         logschan = tourney.logschan
  826 |  32 |         if not logschan:
  827 |  33 |             return
  828 |  34 | 
  829 |  35 |         text = f"Registration of [{str(message.author)}]({message.jump_url}) has been denied in {message.channel.mention}\n**Reason:** "
  830 |  36 | 
  831 |  37 |         with suppress(discord.NotFound, discord.NotFound, AttributeError, discord.HTTPException):
  832 |  38 |             await message.add_reaction(tourney.cross_emoji)
  833 |  39 | 
  834 |  40 |             if _type == RegDeny.botmention:
  835 |  41 |                 await message.reply(
  836 |  42 |                     embed=self.red_embed("Don't mention Bots. Mention your real teammates."),
  837 |  43 |                     delete_after=5,
  838 |  44 |                 )
  839 |  45 |                 text += f"Mentioned Bots."
  840 |  46 | 
  841 |  47 |             elif _type == RegDeny.nomention:
  842 |  48 |                 await message.reply(
  843 |  49 |                     embed=self.red_embed(
  844 |  50 |                         f"{str(message.author)}, **`{plural(tourney.required_mentions):mention is |mentions are}`** required for successful registration."
  845 |  51 |                     ),
  846 |  52 |                     delete_after=5,
  847 |  53 |                 )
  848 |  54 | 
  849 |  55 |                 text += f"Insufficient Mentions (`{len(message.mentions)}/{tourney.required_mentions}`)"
  850 |  56 | 
  851 |  57 |             elif _type == RegDeny.banned:
  852 |  58 |                 await message.reply(
  853 |  59 |                     embed=self.red_embed(
  854 |  60 |                         f"{str(message.author)}, You are banned from the tournament. You cannot register."
  855 |  61 |                     ),
  856 |  62 |                     delete_after=5,
  857 |  63 |                 )
  858 |  64 |                 text += f"They are banned from tournament."
  859 |  65 | 
  860 |  66 |             elif _type == RegDeny.multiregister:
  861 |  67 |                 await message.reply(
  862 |  68 |                     embed=self.red_embed(f"{str(message.author)}, This server doesn't allow multiple registerations."),
  863 |  69 |                     delete_after=5,
  864 |  70 |                 )
  865 |  71 | 
  866 |  72 |                 text += f"They have already registered once.\n\nIf you wish to allow multiple registerations,\nuse: `tourney edit {tourney.id}`"
  867 |  73 | 
  868 |  74 |             elif _type == RegDeny.noteamname:
  869 |  75 |                 await message.reply(
  870 |  76 |                     embed=self.red_embed(f"{str(message.author)}, Team Name is required to register."),
  871 |  77 |                     delete_after=5,
  872 |  78 |                 )
  873 |  79 |                 text += f"Teamname compulsion is on and I couldn't find teamname in their registration\n\nIf you wish allow without teamname,\nUse: `tourney edit {tourney.id}`"
  874 |  80 | 
  875 |  81 |             elif _type == RegDeny.duplicate:
  876 |  82 |                 await message.reply(
  877 |  83 |                     embed=self.red_embed(f"{str(message.author)}, Someone already registered with the same team name."),
  878 |  84 |                     delete_after=5,
  879 |  85 |                 )
  880 |  86 |                 text += f"Duplicate teamname. Someone already registered with the same team name."
  881 |  87 | 
  882 |  88 |             elif _type == RegDeny.nolines:
  883 |  89 |                 await message.reply(
  884 |  90 |                     embed=self.red_embed(
  885 |  91 |                         f"{str(message.author)}, Your registration message is too short. It seems you missed some required information."
  886 |  92 |                     ),
  887 |  93 |                     delete_after=5,
  888 |  94 |                 )
  889 |  95 |                 text += f"Insufficient lines in their registration message."
  890 |  96 | 
  891 |  97 |             elif _type == RegDeny.faketag:
  892 |  98 |                 records = kwargs.get("records")
  893 |  99 |                 jump_url = records[0]["jump_url"]
  894 | 100 | 
  895 | 101 |                 await message.reply(
  896 | 102 |                     embed=self.red_embed(
  897 | 103 |                         f"{str(message.author)}, Someone already registered with the same mentions {jump_url}"
  898 | 104 |                         "\n\n`If you think this is a mistake contact moderators ASAP.`"
  899 | 105 |                     ),
  900 | 106 |                     delete_after=10,
  901 | 107 |                 )
  902 | 108 |                 text += f"Fake tag used. {jump_url}"
  903 | 109 | 
  904 | 110 |             if tourney.autodelete_rejected:
  905 | 111 |                 self.bot.loop.create_task(delete_denied_message(message))
  906 | 112 | 
  907 | 113 |             embed = discord.Embed(color=discord.Color.red(), description=text)
  908 | 114 |             with suppress(discord.Forbidden):
  909 | 115 |                 return await logschan.send(embed=embed)
  910 | 116 | 
  911 | 117 |     @Cog.listener()
  912 | 118 |     async def on_tourney_log(self, _type: EsportsLog, tourney: Tourney, **kwargs):
  913 | 119 |         """
  914 | 120 |         Same as on_scrim_log but for tourneys
  915 | 121 |         """
  916 | 122 |         logschan = tourney.logschan
  917 | 123 |         if not logschan:
  918 | 124 |             return
  919 | 125 | 
  920 | 126 |         registration_channel = tourney.registration_channel
  921 | 127 |         modrole = tourney.modrole
  922 | 128 | 
  923 | 129 |         open_role = tourney_work_role(tourney, EsportsRole.open)
  924 | 130 |         important = False
  925 | 131 | 
  926 | 132 |         embed = discord.Embed(color=0x00B1FF)
  927 | 133 |         if _type == EsportsLog.closed:
  928 | 134 |             permission_updated = kwargs.get("permission_updated")
  929 | 135 | 
  930 | 136 |             embed.description = (
  931 | 137 |                 f"Registration closed for {open_role} in {registration_channel.mention}(TourneyID: `{tourney.id}`)"
  932 | 138 |             )
  933 | 139 |             if not permission_updated:
  934 | 140 |                 important = True
  935 | 141 |                 embed.color = discord.Color.red()
  936 | 142 |                 embed.description += f"\nI couldn't close {registration_channel.mention}."
  937 | 143 | 
  938 | 144 |         elif _type == EsportsLog.success:
  939 | 145 |             message: discord.Message = kwargs.get("message")
  940 | 146 |             embed.color = discord.Color.green()
  941 | 147 |             embed.description = (
  942 | 148 |                 f"Registration of [{message.author}]({message.jump_url}) has been accepted in {message.channel.mention}"
  943 | 149 |             )
  944 | 150 | 
  945 | 151 |         with suppress(discord.Forbidden, AttributeError):
  946 | 152 |             await logschan.send(
  947 | 153 |                 content=modrole.mention if modrole is not None and important is True else None,
  948 | 154 |                 embed=embed,
  949 | 155 |                 allowed_mentions=discord.AllowedMentions(roles=True),
  950 | 156 |             )
  951 | 157 | 
  952 | 158 |     @Cog.listener()
  953 | 159 |     async def on_scrim_log(self, _type: EsportsLog, scrim: Scrim, **kwargs):
  954 | 160 |         """
  955 | 161 |         A listener that is dispatched everytime registration starts/ends or a registration is accepted.
  956 | 162 |         """
  957 | 163 |         logschan = scrim.logschan
  958 | 164 |         if not logschan:
  959 | 165 |             return
  960 | 166 | 
  961 | 167 |         registration_channel = scrim.registration_channel
  962 | 168 |         modrole = scrim.modrole
  963 | 169 | 
  964 | 170 |         open_role = scrim_work_role(scrim, EsportsRole.open)
  965 | 171 | 
  966 | 172 |         important = False
  967 | 173 | 
  968 | 174 |         embed = discord.Embed(color=0x00B1FF)
  969 | 175 |         with suppress(discord.NotFound, discord.Forbidden, AttributeError, discord.HTTPException):
  970 | 176 |             if _type == EsportsLog.open:
  971 | 177 |                 embed.description = (
  972 | 178 |                     f"Registration opened for {open_role} in {registration_channel.mention}(ScrimsID: `{scrim.id}`)"
  973 | 179 |                 )
  974 | 180 | 
  975 | 181 |             elif _type == EsportsLog.closed:
  976 | 182 |                 permission_updated = kwargs.get("permission_updated")
  977 | 183 |                 embed.description = f"Registration closed for {open_role} in {registration_channel.mention}(ScrimsID: `{scrim.id}`)\n\nUse `smanager slotlist edit {scrim.id}` to edit the slotlist."
  978 | 184 | 
  979 | 185 |                 await logschan.send(await scrim.get_text_slotlist())
  980 | 186 | 
  981 | 187 |                 if not permission_updated:
  982 | 188 |                     important = True
  983 | 189 |                     embed.color = discord.Color.red()
  984 | 190 |                     embed.description += f"\nI couldn't close {registration_channel.mention}."
  985 | 191 | 
  986 | 192 |             # elif _type == EsportsLog.success:
  987 | 193 | 
  988 | 194 |             #     message = kwargs.get("message")
  989 | 195 | 
  990 | 196 |             #     embed.color = discord.Color.green()
  991 | 197 |             #     embed.description = f"Registration of [{message.author}]({message.jump_url}) has been accepted in {message.channel.mention}"
  992 | 198 | 
  993 | 199 |             await logschan.send(
  994 | 200 |                 content=modrole.mention if modrole is not None and important is True else None,
  995 | 201 |                 embed=embed,
  996 | 202 |                 allowed_mentions=discord.AllowedMentions(roles=True),
  997 | 203 |             )
  998 | 204 | 
  999 | 205 |     # ==========================================================================================================================
 1000 | 206 |     # ==========================================================================================================================
 1001 | 207 | 
 1002 | 208 |     @Cog.listener()
 1003 | 209 |     async def on_scrim_registration_deny(self, message: discord.Message, _type: RegDeny, scrim: Scrim, **kwargs):
 1004 | 210 |         logschan = scrim.logschan
 1005 | 211 |         if logschan is None:
 1006 | 212 |             return
 1007 | 213 | 
 1008 | 214 |         text = f"Registration of [{str(message.author)}]({message.jump_url}) has been denied in {message.channel.mention}\n**Reason:** "
 1009 | 215 | 
 1010 | 216 |         with suppress(discord.NotFound, discord.Forbidden, AttributeError, discord.HTTPException):
 1011 | 217 |             await message.add_reaction(scrim.cross_emoji)
 1012 | 218 | 
 1013 | 219 |             if _type == RegDeny.botmention:
 1014 | 220 |                 await message.reply(
 1015 | 221 |                     embed=self.red_embed("Don't mention Bots. Mention your real teammates."),
 1016 | 222 |                     delete_after=5,
 1017 | 223 |                 )
 1018 | 224 |                 text += f"Mentioned Bots."
 1019 | 225 | 
 1020 | 226 |             elif _type == RegDeny.nomention:
 1021 | 227 |                 await message.reply(
 1022 | 228 |                     embed=self.red_embed(
 1023 | 229 |                         f"{str(message.author)}, **`{plural(scrim.required_mentions):mention is |mentions are}`** required for successful registration."
 1024 | 230 |                     ),
 1025 | 231 |                     delete_after=5,
 1026 | 232 |                 )
 1027 | 233 |                 text += f"Insufficient Mentions (`{len(message.mentions)}/{scrim.required_mentions}`)"
 1028 | 234 | 
 1029 | 235 |             elif _type == RegDeny.banned:
 1030 | 236 |                 await message.reply(
 1031 | 237 |                     embed=self.red_embed(f"{str(message.author)}, You are banned from the scrims. You cannot register."),
 1032 | 238 |                     delete_after=5,
 1033 | 239 |                 )
 1034 | 240 |                 text += f"They are banned from scrims."
 1035 | 241 | 
 1036 | 242 |             elif _type == RegDeny.multiregister:
 1037 | 243 |                 await message.reply(
 1038 | 244 |                     embed=self.red_embed(f"{str(message.author)}, This server doesn't allow multiple registerations."),
 1039 | 245 |                     delete_after=5,
 1040 | 246 |                 )
 1041 | 247 |                 text += f"They have already registered once.\n\nIf you wish to allow multiple registerations,\nuse: `smanager toggle {scrim.id} multiregister`"
 1042 | 248 | 
 1043 | 249 |             elif _type == RegDeny.noteamname:
 1044 | 250 |                 await message.reply(
 1045 | 251 |                     embed=self.red_embed(f"{str(message.author)}, Team Name is required to register."),
 1046 | 252 |                     delete_after=5,
 1047 | 253 |                 )
 1048 | 254 |                 text += f"Teamname compulsion is on and I couldn't find teamname in their registration\n\nIf you wish allow without teamname,\nUse: `smanager edit {scrim.id}`"
 1049 | 255 | 
 1050 | 256 |             elif _type == RegDeny.duplicate:
 1051 | 257 |                 await message.reply(
 1052 | 258 |                     embed=self.red_embed(
 1053 | 259 |                         f"{str(message.author)}, Someone has already registered with the same teamname."
 1054 | 260 |                     ),
 1055 | 261 |                     delete_after=5,
 1056 | 262 |                 )
 1057 | 263 |                 text += f"No duplicate team names is ON and someone has already registered with the same team name\nIf you wish to allow duplicate team names,\nUse: `smanager edit {scrim.id}`"
 1058 | 264 | 
 1059 | 265 |             elif _type == RegDeny.nolines:
 1060 | 266 |                 await message.reply(
 1061 | 267 |                     embed=self.red_embed(
 1062 | 268 |                         f"{str(message.author)}, Your registration message is too short. It seems you missed some required information."
 1063 | 269 |                     ),
 1064 | 270 |                     delete_after=5,
 1065 | 271 |                 )
 1066 | 272 |                 text += f"Insufficient lines in their registration message."
 1067 | 273 | 
 1068 | 274 |             elif _type == RegDeny.faketag:
 1069 | 275 |                 records = kwargs.get("records")
 1070 | 276 |                 jump_url = records[0]["jump_url"]
 1071 | 277 | 
 1072 | 278 |                 await message.reply(
 1073 | 279 |                     embed=self.red_embed(
 1074 | 280 |                         f"{str(message.author)}, Someone already registered with the same mentions {jump_url}"
 1075 | 281 |                         "\n\n`If you think this is a mistake contact moderators ASAP.`"
 1076 | 282 |                     ),
 1077 | 283 |                     delete_after=10,
 1078 | 284 |                 )
 1079 | 285 |                 text += f"Fake tag used. {jump_url}"
 1080 | 286 | 
 1081 | 287 |             # elif _type == RegDeny.bannedteammate:
 1082 | 288 |             #     await message.reply(
 1083 | 289 |             #         embed = self.red_embed(
 1084 | 290 |             #             f"{str(message.author)}, Your registration cannot be accepted because one your teammates is banned from scrims."
 1085 | 291 |             #     ),
 1086 | 292 |             #     delete_after = 5,
 1087 | 293 |             #     )
 1088 | 294 |             #     text += f"One of their teammate is banned from scrims."
 1089 | 295 | 
 1090 | 296 |             if scrim.autodelete_rejects:
 1091 | 297 |                 self.bot.loop.create_task(delete_denied_message(message))
 1092 | 298 | 
 1093 | 299 |             embed = discord.Embed(color=discord.Color.red(), description=text)
 1094 | 300 |             return await logschan.send(embed=embed)
 1095 | 301 | 
 1096 | 302 |     # ==========================================================================================================================
 1097 | 303 |     # ==========================================================================================================================
 1098 | 304 | 
 1099 | 305 |     @Cog.listener()
 1100 | 306 |     async def on_scrim_reserve_timer_complete(self, timer: Timer):
 1101 | 307 |         scrim_id = timer.kwargs["scrim_id"]
 1102 | 308 |         team_name = timer.kwargs["team_name"]
 1103 | 309 |         user_id = timer.kwargs["user_id"]
 1104 | 310 | 
 1105 | 311 |         scrim = await Scrim.get_or_none(pk=scrim_id)
 1106 | 312 |         if scrim is None:
 1107 | 313 |             return
 1108 | 314 | 
 1109 | 315 |         guild = scrim.guild
 1110 | 316 |         if not guild:
 1111 | 317 |             return
 1112 | 318 | 
 1113 | 319 |         if not user_id in await scrim.reserved_user_ids():
 1114 | 320 |             return
 1115 | 321 | 
 1116 | 322 |         team = await scrim.reserved_slots.filter(user_id=user_id).first()
 1117 | 323 | 
 1118 | 324 |         if team.expires != timer.expires:
 1119 | 325 |             return
 1120 | 326 | 
 1121 | 327 |         await ReservedSlot.filter(id=team.id).delete()
 1122 | 328 | 
 1123 | 329 |         logschan = scrim.logschan
 1124 | 330 |         if logschan is not None and logschan.permissions_for(guild.me).send_messages:
 1125 | 331 |             user = self.bot.get_user(user_id)
 1126 | 332 |             embed = discord.Embed(
 1127 | 333 |                 color=discord.Color.green(),
 1128 | 334 |                 description=f"Reservation period of **{team_name.title()}** ({user}) is now over.\nSlot will not be reserved for them in Scrim (`{scrim_id}`).",
 1129 | 335 |             )
 1130 | 336 | 
 1131 | 337 |             await logschan.send(embed=embed)
 1132 | 338 | 
 1133 | 339 |     @Cog.listener()
 1134 | 340 |     async def on_scrim_cmd_log(self, **kwargs):
 1135 | 341 |         ...
 1136 | 342 | 
 1137 | 343 |     @Cog.listener()
 1138 | 344 |     async def on_guild_channel_delete(self, channel: discord.TextChannel):
 1139 | 345 |         # will delete scrim/tournament if its registration channel.
 1140 | 346 |         self.bot.cache.eztagchannels.discard(channel.id)
 1141 | 347 |         self.bot.cache.tagcheck.discard(channel.id)
 1142 | 348 |         self.bot.cache.scrim_channels.discard(channel.id)
 1143 | 349 |         self.bot.cache.tourney_channels.discard(channel.id)
 1144 | 350 | 
 1145 | 351 |         await Scrim.filter(registration_channel_id=channel.id).delete()
 1146 | 352 |         await Tourney.filter(registration_channel_id=channel.id).delete()
 1147 | 353 |         await TagCheck.filter(channel_id=channel.id).delete()
 1148 | 354 |         await EasyTag.filter(channel_id=channel.id).delete()
 1149 | 355 | 
 1150 | 356 |     @Cog.listener()
 1151 | 357 |     async def on_scrim_registration_delete(self, scrim: Scrim, message: discord.Message, slot):
 1152 | 358 |         assert message.guild is not None
 1153 | 359 | 
 1154 | 360 |         self.bot.loop.create_task(message.author.remove_roles(scrim.role))
 1155 | 361 |         await AssignedSlot.filter(id=slot.id).delete()
 1156 | 362 |         await Scrim.filter(id=scrim.id).update(available_slots=ArrayAppend("available_slots", slot.num))
 1157 | 363 |         if scrim.logschan is not None:
 1158 | 364 |             embed = discord.Embed(color=discord.Color.red())
 1159 | 365 |             embed.description = f"Slot of {message.author.mention} was deleted from Scrim: {scrim.id}, because their registration was deleted from {message.channel.mention}"
 1160 | 366 |             await scrim.logschan.send(embed=embed)
 1161 | 367 | 
 1162 | 
 1163 | 
 1164 | --------------------------------------------------------------------------------
 1165 | /cogs/esports/events/__init__.py:
 1166 | --------------------------------------------------------------------------------
 1167 | 1 | from .scrims import ScrimEvents
 1168 | 2 | from .slots import SlotManagerEvents
 1169 | 3 | from .ssverify import Ssverification
 1170 | 4 | from .tags import TagEvents
 1171 | 5 | from .tourneys import TourneyEvents
 1172 | 6 | 
 1173 | 
 1174 | 
 1175 | --------------------------------------------------------------------------------
 1176 | /cogs/esports/events/scrims.py:
 1177 | --------------------------------------------------------------------------------
 1178 |   1 | from __future__ import annotations
 1179 |   2 | 
 1180 |   3 | import typing
 1181 |   4 | 
 1182 |   5 | if typing.TYPE_CHECKING:
 1183 |   6 |     from core import Quotient
 1184 |   7 | 
 1185 |   8 | import asyncio
 1186 |   9 | from datetime import datetime, timedelta
 1187 |  10 | from unicodedata import normalize
 1188 |  11 | 
 1189 |  12 | import discord
 1190 |  13 | 
 1191 |  14 | import utils
 1192 |  15 | from constants import IST, AutocleanType, Day
 1193 |  16 | from core import Cog
 1194 |  17 | from models import ArrayRemove, AssignedSlot, BanLog, BannedTeam, Scrim, Timer
 1195 |  18 | 
 1196 |  19 | from ..helpers import (
 1197 |  20 |     before_registrations,
 1198 |  21 |     cannot_take_registration,
 1199 |  22 |     check_scrim_requirements,
 1200 |  23 |     should_open_scrim,
 1201 |  24 | )
 1202 |  25 | 
 1203 |  26 | 
 1204 |  27 | class ScrimEvents(Cog):
 1205 |  28 |     def __init__(self, bot: Quotient):
 1206 |  29 |         self.bot = bot
 1207 |  30 | 
 1208 |  31 |         self.__scrim_lock = asyncio.Lock()
 1209 |  32 |         self.__autoclean_lock = asyncio.Lock()
 1210 |  33 | 
 1211 |  34 |     @Cog.listener("on_message")
 1212 |  35 |     async def on_scrim_registration(self, message: discord.Message):
 1213 |  36 |         if not message.guild or message.author.bot:
 1214 |  37 |             return
 1215 |  38 | 
 1216 |  39 |         channel_id = message.channel.id
 1217 |  40 | 
 1218 |  41 |         if channel_id not in self.bot.cache.scrim_channels:
 1219 |  42 |             return
 1220 |  43 | 
 1221 |  44 |         scrim = await Scrim.get_or_none(
 1222 |  45 |             registration_channel_id=channel_id,
 1223 |  46 |         )
 1224 |  47 | 
 1225 |  48 |         if scrim is None:  # Scrim is possibly deleted
 1226 |  49 |             return self.bot.cache.scrim_channels.discard(channel_id)
 1227 |  50 | 
 1228 |  51 |         scrim_role = scrim.role
 1229 |  52 | 
 1230 |  53 |         if scrim.opened_at is None or scrim_role is None:
 1231 |  54 |             return
 1232 |  55 | 
 1233 |  56 |         if Scrim.is_ignorable(message.author):
 1234 |  57 |             return
 1235 |  58 | 
 1236 |  59 |         if not before_registrations(message, scrim_role):
 1237 |  60 |             return await cannot_take_registration(message, scrim)
 1238 |  61 | 
 1239 |  62 |         message.content = normalize("NFKC", message.content.lower())
 1240 |  63 | 
 1241 |  64 |         if not await check_scrim_requirements(self.bot, message, scrim):
 1242 |  65 |             return
 1243 |  66 | 
 1244 |  67 |         async with self.__scrim_lock:
 1245 |  68 |             ctx = await self.bot.get_context(message)
 1246 |  69 | 
 1247 |  70 |             teamname, drop_location = utils.find_team(message), utils.find_drop_location(message)
 1248 |  71 | 
 1249 |  72 |             scrim = await Scrim.get_or_none(pk=scrim.id)
 1250 |  73 | 
 1251 |  74 |             if not scrim or scrim.closed:  # Scrim is deleted or closed.
 1252 |  75 |                 return
 1253 |  76 | 
 1254 |  77 |             try:
 1255 |  78 |                 slot_num = scrim.available_slots[0]
 1256 |  79 |             except IndexError:
 1257 |  80 |                 return
 1258 |  81 | 
 1259 |  82 |             _team = {message.author.id}
 1260 |  83 |             for _ in message.mentions:
 1261 |  84 |                 if not _.bot:
 1262 |  85 |                     _team.add(_.id)
 1263 |  86 | 
 1264 |  87 |             slot = await AssignedSlot.create(
 1265 |  88 |                 user_id=ctx.author.id,
 1266 |  89 |                 team_name=utils.truncate_string(teamname, 30),
 1267 |  90 |                 # drop_location=utils.truncate_string(drop_location, 30),
 1268 |  91 |                 num=slot_num,
 1269 |  92 |                 jump_url=message.jump_url,
 1270 |  93 |                 message_id=message.id,
 1271 |  94 |                 members=_team,
 1272 |  95 |             )
 1273 |  96 | 
 1274 |  97 |             await scrim.assigned_slots.add(slot)
 1275 |  98 | 
 1276 |  99 |             await Scrim.filter(pk=scrim.id).update(available_slots=ArrayRemove("available_slots", slot_num))
 1277 | 100 |             self.bot.loop.create_task(scrim.add_tick(message))
 1278 | 101 | 
 1279 | 102 |             if len(scrim.available_slots) == 1:
 1280 | 103 |                 try:
 1281 | 104 |                     await scrim.close_registration()
 1282 | 105 |                 except Exception as e:
 1283 | 106 |                     print(f"scrim close error: {e}")
 1284 | 107 | 
 1285 | 108 |     # ==========================================================================================================
 1286 | 109 |     # ==========================================================================================================
 1287 | 110 | 
 1288 | 111 |     @Cog.listener()
 1289 | 112 |     async def on_scrim_open_timer_complete(self, timer: Timer):
 1290 | 113 |         """This listener opens the scrim registration at time."""
 1291 | 114 | 
 1292 | 115 |         scrim_id = timer.kwargs["scrim_id"]
 1293 | 116 |         scrim = await Scrim.get_or_none(pk=scrim_id)
 1294 | 117 | 
 1295 | 118 |         if not scrim:  # we don't want to do anything if the scrim is deleted
 1296 | 119 |             return
 1297 | 120 | 
 1298 | 121 |         if scrim.open_time != timer.expires:  # If time is not same return :)
 1299 | 122 |             return
 1300 | 123 | 
 1301 | 124 |         await Scrim.filter(pk=scrim.id).update(
 1302 | 125 |             open_time=scrim.open_time + timedelta(hours=24),
 1303 | 126 |         )
 1304 | 127 | 
 1305 | 128 |         await self.bot.reminders.create_timer(
 1306 | 129 |             scrim.open_time + timedelta(hours=24),
 1307 | 130 |             "scrim_open",
 1308 | 131 |             scrim_id=scrim.id,
 1309 | 132 |         )  # we don't want to risk this
 1310 | 133 | 
 1311 | 134 |         if scrim.toggle is not True or not Day(utils.day_today()) in scrim.open_days:
 1312 | 135 |             return
 1313 | 136 | 
 1314 | 137 |         if scrim.opened_at and scrim.opened_at.strftime("%d-%b-%Y %I:%M %p") == datetime.now(tz=IST).strftime("%d-%b-%Y %I:%M %p"):
 1315 | 138 |             return  # means we are having multiple timers for a single scrim :c shit
 1316 | 139 | 
 1317 | 140 |         guild = scrim.guild
 1318 | 141 | 
 1319 | 142 |         if not guild:
 1320 | 143 |             return
 1321 | 144 | 
 1322 | 145 |         if not await should_open_scrim(scrim):
 1323 | 146 |             return
 1324 | 147 | 
 1325 | 148 |         if not guild.chunked:
 1326 | 149 |             self.bot.loop.create_task(guild.chunk())
 1327 | 150 | 
 1328 | 151 |         await scrim.start_registration()
 1329 | 152 | 
 1330 | 153 |     @Cog.listener()
 1331 | 154 |     async def on_autoclean_timer_complete(self, timer: Timer):
 1332 | 155 |         scrim_id = timer.kwargs["scrim_id"]
 1333 | 156 | 
 1334 | 157 |         scrim = await Scrim.get_or_none(pk=scrim_id)
 1335 | 158 | 
 1336 | 159 |         if not scrim:  # deleted probably
 1337 | 160 |             return
 1338 | 161 | 
 1339 | 162 |         if timer.expires != scrim.autoclean_time:
 1340 | 163 |             return
 1341 | 164 | 
 1342 | 165 |         next_autoclean_time = scrim.autoclean_time + timedelta(hours=24)
 1343 | 166 | 
 1344 | 167 |         await Scrim.filter(pk=scrim.id).update(autoclean_time=next_autoclean_time)
 1345 | 168 |         await self.bot.reminders.create_timer(next_autoclean_time, "autoclean", scrim_id=scrim.id)
 1346 | 169 | 
 1347 | 170 |         if not scrim.toggle:  # scrim is disabled
 1348 | 171 |             return
 1349 | 172 | 
 1350 | 173 |         if scrim.closed_at and scrim.closed_at < self.bot.current_time - timedelta(hours=48):
 1351 | 174 |             return
 1352 | 175 | 
 1353 | 176 |         guild = scrim.guild
 1354 | 177 |         if not guild:
 1355 | 178 |             return
 1356 | 179 | 
 1357 | 180 |         if not guild.chunked:
 1358 | 181 |             self.bot.loop.create_task(guild.chunk())
 1359 | 182 | 
 1360 | 183 |         async with self.__autoclean_lock:
 1361 | 184 |             if AutocleanType.channel in scrim.autoclean:
 1362 | 185 |                 self.bot.loop.create_task(self.__purge_channel(scrim.registration_channel))
 1363 | 186 |                 await asyncio.sleep(2)
 1364 | 187 | 
 1365 | 188 |             if AutocleanType.role in scrim.autoclean:
 1366 | 189 |                 slots = await scrim.assigned_slots.filter(user_id__isnull=False)
 1367 | 190 | 
 1368 | 191 |                 users = {slot.user_id for slot in slots}
 1369 | 192 |                 if scrim_role := scrim.role:
 1370 | 193 |                     for m in scrim_role.members:
 1371 | 194 |                         users.add(m.id)
 1372 | 195 | 
 1373 | 196 |                 reserved_slots = await scrim.reserved_slots.filter(user_id__isnull=False)
 1374 | 197 |                 for slot in reserved_slots:
 1375 | 198 |                     users.discard(slot.user_id)
 1376 | 199 | 
 1377 | 200 |                 async for member in self.bot.resolve_member_ids(guild, users):
 1378 | 201 |                     try:
 1379 | 202 |                         await member.remove_roles(discord.Object(scrim.role_id), reason="autoclean")
 1380 | 203 |                         await asyncio.sleep(0.2)
 1381 | 204 |                     except discord.HTTPException:
 1382 | 205 |                         continue
 1383 | 206 | 
 1384 | 207 |             await asyncio.sleep(7)
 1385 | 208 | 
 1386 | 209 |     async def __purge_channel(self, channel: discord.TextChannel = None):
 1387 | 210 |         if not channel:
 1388 | 211 |             return
 1389 | 212 |         try:
 1390 | 213 |             await channel.purge(limit=100, check=lambda x: not x.pinned, reason="autoclean")
 1391 | 214 |         except discord.HTTPException:
 1392 | 215 |             pass
 1393 | 216 | 
 1394 | 217 |     @Cog.listener()
 1395 | 218 |     async def on_scrim_ban_timer_complete(self, timer: Timer):
 1396 | 219 |         scrims = timer.kwargs["scrims"]
 1397 | 220 |         user_id = timer.kwargs["user_id"]
 1398 | 221 | 
 1399 | 222 |         reason = timer.kwargs["reason"]
 1400 | 223 | 
 1401 | 224 |         new_reason = ("[Auto-Unban] because ban time's up.") + f"\nBanned for: {reason}" if reason else ""
 1402 | 225 | 
 1403 | 226 |         scrims = await Scrim.filter(pk__in=scrims)
 1404 | 227 |         if not scrims:
 1405 | 228 |             return
 1406 | 229 | 
 1407 | 230 |         guild = scrims[0].guild
 1408 | 231 |         if not guild:
 1409 | 232 |             return
 1410 | 233 | 
 1411 | 234 |         count = 0
 1412 | 235 |         for scrim in scrims:
 1413 | 236 |             bans = await scrim.banned_teams.filter(user_id=user_id)
 1414 | 237 |             c = await BannedTeam.filter(pk__in=[_.pk for _ in bans]).delete()
 1415 | 238 |             count += c
 1416 | 239 | 
 1417 | 240 |         if not count:
 1418 | 241 |             return
 1419 | 242 | 
 1420 | 243 |         if banlog := await BanLog.get_or_none(guild_id=guild.id):
 1421 | 244 |             await banlog.log_unban(user_id, guild.me, scrims, new_reason)
 1422 | 245 | 
 1423 | 
 1424 | 
 1425 | --------------------------------------------------------------------------------
 1426 | /cogs/esports/events/slots.py:
 1427 | --------------------------------------------------------------------------------
 1428 |  1 | from __future__ import annotations
 1429 |  2 | 
 1430 |  3 | import typing
 1431 |  4 | 
 1432 |  5 | if typing.TYPE_CHECKING:
 1433 |  6 |     from core import Quotient
 1434 |  7 | 
 1435 |  8 | import discord
 1436 |  9 | 
 1437 | 10 | from core import Cog
 1438 | 11 | from models import Scrim, ScrimsSlotManager, Timer
 1439 | 12 | 
 1440 | 13 | 
 1441 | 14 | class SlotManagerEvents(Cog):
 1442 | 15 |     def __init__(self, bot: Quotient):
 1443 | 16 |         self.bot = bot
 1444 | 17 | 
 1445 | 18 |     @Cog.listener()
 1446 | 19 |     async def on_scrim_match_timer_complete(self, timer: Timer):
 1447 | 20 |         scrim_id = timer.kwargs["scrim_id"]
 1448 | 21 | 
 1449 | 22 |         scrim = await Scrim.get_or_none(pk=scrim_id)
 1450 | 23 |         if not scrim:
 1451 | 24 |             return
 1452 | 25 | 
 1453 | 26 |         if not scrim.match_time == timer.expires:
 1454 | 27 |             return
 1455 | 28 | 
 1456 | 29 |         record = await ScrimsSlotManager.get_or_none(guild_id=scrim.guild_id, scrim_ids__contains=scrim.id)
 1457 | 30 |         if record:
 1458 | 31 |             await record.refresh_public_message()
 1459 | 32 | 
 1460 | 33 |     @Cog.listener()
 1461 | 34 |     async def on_guild_channel_delete(self, channel: discord.TextChannel):
 1462 | 35 |         record = await ScrimsSlotManager.get_or_none(main_channel_id=channel.id)
 1463 | 36 |         if not record:
 1464 | 37 |             return
 1465 | 38 |         await record.full_delete()
 1466 | 39 | 
 1467 | 40 |     @Cog.listener()
 1468 | 41 |     async def on_raw_message_delete(self, payload: discord.RawMessageDeleteEvent):
 1469 | 42 |         if not payload.guild_id:
 1470 | 43 |             return
 1471 | 44 | 
 1472 | 45 |         record = await ScrimsSlotManager.get_or_none(message_id=payload.message_id)
 1473 | 46 |         if not record:
 1474 | 47 |             return
 1475 | 48 | 
 1476 | 49 |         await record.full_delete()
 1477 | 50 | 
 1478 | 
 1479 | 
 1480 | --------------------------------------------------------------------------------
 1481 | /cogs/esports/events/ssverify.py:
 1482 | --------------------------------------------------------------------------------
 1483 |   1 | from __future__ import annotations
 1484 |   2 | 
 1485 |   3 | import asyncio
 1486 |   4 | from typing import TYPE_CHECKING, List
 1487 |   5 | 
 1488 |   6 | import aiohttp
 1489 |   7 | import discord
 1490 |   8 | 
 1491 |   9 | from constants import SSType
 1492 |  10 | 
 1493 |  11 | if TYPE_CHECKING:
 1494 |  12 |     from core import Quotient
 1495 |  13 | 
 1496 |  14 | from collections import defaultdict
 1497 |  15 | from contextlib import suppress
 1498 |  16 | 
 1499 |  17 | import humanize
 1500 |  18 | 
 1501 |  19 | from core import Cog, Context, QuotientRatelimiter
 1502 |  20 | from models import ImageResponse, SSVerify
 1503 |  21 | from utils import emote, plural
 1504 |  22 | 
 1505 |  23 | 
 1506 |  24 | class MemberLimits(defaultdict):
 1507 |  25 |     def __missing__(self, key):
 1508 |  26 |         r = self[key] = QuotientRatelimiter(1, 7)
 1509 |  27 |         return r
 1510 |  28 | 
 1511 |  29 | 
 1512 |  30 | class GuildLimits(defaultdict):
 1513 |  31 |     def __missing__(self, key):
 1514 |  32 |         r = self[key] = QuotientRatelimiter(10, 60)
 1515 |  33 |         return r
 1516 |  34 | 
 1517 |  35 | 
 1518 |  36 | class Ssverification(Cog):
 1519 |  37 |     def __init__(self, bot: Quotient):
 1520 |  38 |         self.bot = bot
 1521 |  39 | 
 1522 |  40 |         self.request_url = self.bot.config.FASTAPI_URL + "/ocr"
 1523 |  41 |         self.headers = {
 1524 |  42 |             "authorization": self.bot.config.FASTAPI_KEY,
 1525 |  43 |             "Content-Type": "application/json",
 1526 |  44 |         }
 1527 |  45 | 
 1528 |  46 |         self.__mratelimiter = MemberLimits(QuotientRatelimiter)  # ss/15s by member
 1529 |  47 |         self.__gratelimiter = GuildLimits(QuotientRatelimiter)  # ss/minute by guild
 1530 |  48 |         self.__verify_lock = asyncio.Lock()
 1531 |  49 | 
 1532 |  50 |     async def __check_ratelimit(self, message: discord.Message):
 1533 |  51 |         if retry := self.__mratelimiter[message.author].is_ratelimited(message.author):
 1534 |  52 |             await message.reply(
 1535 |  53 |                 embed=discord.Embed(
 1536 |  54 |                     color=discord.Color.red(),
 1537 |  55 |                     description=f"**You are too fast. Kindly resend after `{retry:.2f}` seconds.**",
 1538 |  56 |                 )
 1539 |  57 |             )
 1540 |  58 |             return False
 1541 |  59 | 
 1542 |  60 |         elif retry := self.__gratelimiter[message.guild].is_ratelimited(message.guild):
 1543 |  61 |             await message.reply(
 1544 |  62 |                 embed=discord.Embed(
 1545 |  63 |                     color=discord.Color.red(),
 1546 |  64 |                     description=f"**Many users are submitting screenshots from this server at this time. Kindly retry after `{retry:.2f}` seconds.**",
 1547 |  65 |                 )
 1548 |  66 |             )
 1549 |  67 |             return False
 1550 |  68 |         return True
 1551 |  69 | 
 1552 |  70 |     @Cog.listener()
 1553 |  71 |     async def on_message(self, message: discord.Message):
 1554 |  72 |         if not all(
 1555 |  73 |             (
 1556 |  74 |                 message.guild,
 1557 |  75 |                 not message.author.bot,
 1558 |  76 |                 message.channel.id in self.bot.cache.ssverify_channels,
 1559 |  77 |             )
 1560 |  78 |         ):
 1561 |  79 |             return
 1562 |  80 | 
 1563 |  81 |         record = await SSVerify.get_or_none(channel_id=message.channel.id)
 1564 |  82 |         if not record:
 1565 |  83 |             return self.bot.cache.ssverify_channels.discard(message.channel.id)
 1566 |  84 |         #
 1567 |  85 |         if "tourney-mod" in (role.name.lower() for role in message.author.roles):  # type: ignore # line guarded #70-76
 1568 |  86 |             return
 1569 |  87 | 
 1570 |  88 |         ctx: Context = await self.bot.get_context(message)
 1571 |  89 | 
 1572 |  90 |         _e = discord.Embed(color=discord.Color.red())
 1573 |  91 | 
 1574 |  92 |         with suppress(discord.HTTPException):
 1575 |  93 |             if await record.is_user_verified(message.author.id):
 1576 |  94 |                 _e.description = "**Your screenshots are already verified, kindly move onto next step.**"
 1577 |  95 |                 return await ctx.reply(embed=_e)
 1578 |  96 | 
 1579 |  97 |             if not (attachments := self.__valid_attachments(message)):
 1580 |  98 |                 _e.description = "**Kindly send screenshots in `png/jpg/jpeg` format only.**"
 1581 |  99 |                 return await ctx.reply(embed=_e)
 1582 | 100 | 
 1583 | 101 |             if not await self.__check_ratelimit(message):
 1584 | 102 |                 return
 1585 | 103 | 
 1586 | 104 |             if len(attachments) > record.required_ss:
 1587 | 105 |                 _e.description = (
 1588 | 106 |                     f"**You only have to send `{record.required_ss}` screenshots but you sent `{len(attachments)}`**"
 1589 | 107 |                 )
 1590 | 108 |                 return await ctx.reply(embed=_e)
 1591 | 109 | 
 1592 | 110 |             _e.color = discord.Color.yellow()  # type: ignore
 1593 | 111 |             _e.description = f"Processing your {plural(attachments):screenshot|screenshots}... {emote.loading}"
 1594 | 112 |             m: discord.Message = await message.reply(embed=_e)
 1595 | 113 | 
 1596 | 114 |             _data = [{"url": _.proxy_url} for _ in attachments]
 1597 | 115 | 
 1598 | 116 |             start_at = self.bot.current_time
 1599 | 117 | 
 1600 | 118 |             async with self.__verify_lock:
 1601 | 119 |                 async with self.bot.session.post(self.request_url, json=_data, headers=self.headers) as resp:
 1602 | 120 |                     complete_at = self.bot.current_time
 1603 | 121 | 
 1604 | 122 |                     try:
 1605 | 123 |                         _ocr = await resp.json()
 1606 | 124 |                     except aiohttp.ContentTypeError:
 1607 | 125 |                         _e.color, _e.description = (  # type: ignore
 1608 | 126 |                             discord.Color.red(),
 1609 | 127 |                             "**Failed to process your screenshots. Try again later.**",
 1610 | 128 |                         )
 1611 | 129 |                         return await message.reply(embed=_e)
 1612 | 130 | 
 1613 | 131 |             embed = await self.__verify_screenshots(ctx, record, [ImageResponse(**_) for _ in _ocr])
 1614 | 132 |             embed.set_footer(text=f"Time taken: {humanize.precisedelta(complete_at-start_at)}")
 1615 | 133 |             embed.set_author(
 1616 | 134 |                 name=f"Submitted {await record.data.filter(author_id=ctx.author.id).count()}/{record.required_ss}",
 1617 | 135 |                 icon_url=getattr(ctx.author.display_avatar, "url", None),
 1618 | 136 |             )
 1619 | 137 | 
 1620 | 138 |             with suppress(discord.HTTPException):
 1621 | 139 |                 await m.delete()
 1622 | 140 | 
 1623 | 141 |             await message.reply(embed=embed)
 1624 | 142 | 
 1625 | 143 |             if await record.is_user_verified(ctx.author.id):
 1626 | 144 |                 await message.author.add_roles(discord.Object(id=record.role_id))  # type: ignore # line guarded #70-76
 1627 | 145 | 
 1628 | 146 |                 if record.success_message:
 1629 | 147 |                     _e.title = f"Screenshot Verification Complete"
 1630 | 148 |                     _e.url, _e.description = message.jump_url, record.success_message
 1631 | 149 | 
 1632 | 150 |                     return await message.reply(embed=_e)
 1633 | 151 | 
 1634 | 152 |                 _e.description = f"{ctx.author.mention} Your screenshots are verified, Move to next step."
 1635 | 153 |                 await message.reply(embed=_e)
 1636 | 154 | 
 1637 | 155 |     async def __verify_screenshots(self, ctx: Context, record: SSVerify, _ocr: List[ImageResponse]) -> discord.Embed:
 1638 | 156 |         _e = discord.Embed(color=self.bot.color, description="")
 1639 | 157 | 
 1640 | 158 |         for _ in _ocr:
 1641 | 159 |             if not record.allow_same:
 1642 | 160 |                 b, t = await record._match_for_duplicate(_.dhash, _.phash, ctx.author.id)
 1643 | 161 |                 if b:
 1644 | 162 |                     _e.description += t
 1645 | 163 |                     continue
 1646 | 164 | 
 1647 | 165 |             if record.ss_type == SSType.anyss:
 1648 | 166 |                 _e.description += f"{record.emoji(True)} | Successfully Verified.\n"  # type: ignore
 1649 | 167 |                 await record._add_to_data(ctx, _)
 1650 | 168 | 
 1651 | 169 |             elif record.ss_type == SSType.yt:
 1652 | 170 |                 _e.description += await record.verify_yt(ctx, _)
 1653 | 171 | 
 1654 | 172 |             elif record.ss_type == SSType.insta:
 1655 | 173 |                 _e.description += await record.verify_insta(ctx, _)
 1656 | 174 | 
 1657 | 175 |             elif record.ss_type == SSType.loco:
 1658 | 176 |                 _e.description += await record.verify_loco(ctx, _)
 1659 | 177 | 
 1660 | 178 |             elif record.ss_type == SSType.rooter:
 1661 | 179 |                 _e.description += await record.verify_rooter(ctx, _)
 1662 | 180 | 
 1663 | 181 |             elif record.ss_type == SSType.custom:
 1664 | 182 |                 _e.description += await record.verify_custom(ctx, _)
 1665 | 183 | 
 1666 | 184 |         return _e
 1667 | 185 | 
 1668 | 186 |     def __valid_attachments(self, message: discord.Message):
 1669 | 187 |         return [_ for _ in message.attachments if _.content_type in ("image/png", "image/jpeg", "image/jpg")]
 1670 | 188 | 
 1671 | 189 |     @Cog.listener()
 1672 | 190 |     async def on_guild_channel_delete(self, channel: discord.TextChannel):
 1673 | 191 |         if channel.id in self.bot.cache.ssverify_channels:
 1674 | 192 |             record = await SSVerify.get_or_none(channel_id=channel.id)
 1675 | 193 |             if record:
 1676 | 194 |                 await record.full_delete()
 1677 | 195 | 
 1678 | 196 |     @Cog.listener()
 1679 | 197 |     async def on_guild_role_delete(self, role: discord.Role):
 1680 | 198 |         records = await SSVerify.filter(role_id=role.id)
 1681 | 199 |         if records:
 1682 | 200 |             for record in records:
 1683 | 201 |                 await record.full_delete()
 1684 | 202 | 
 1685 | 
 1686 | 
 1687 | --------------------------------------------------------------------------------
 1688 | /cogs/esports/events/tags.py:
 1689 | --------------------------------------------------------------------------------
 1690 |   1 | from __future__ import annotations
 1691 |   2 | 
 1692 |   3 | import typing
 1693 |   4 | 
 1694 |   5 | if typing.TYPE_CHECKING:
 1695 |   6 |     from core import Quotient
 1696 |   7 | 
 1697 |   8 | import re
 1698 |   9 | from contextlib import suppress
 1699 |  10 | 
 1700 |  11 | import discord
 1701 |  12 | 
 1702 |  13 | import utils
 1703 |  14 | from core import Cog
 1704 |  15 | from models import EasyTag, TagCheck
 1705 |  16 | 
 1706 |  17 | from ..helpers import EasyMemberConverter, delete_denied_message
 1707 |  18 | 
 1708 |  19 | 
 1709 |  20 | class TagEvents(Cog):
 1710 |  21 |     def __init__(self, bot: Quotient):
 1711 |  22 |         self.bot = bot
 1712 |  23 | 
 1713 |  24 |     @Cog.listener(name="on_message")
 1714 |  25 |     async def on_tagcheck_msg(self, message: discord.Message):
 1715 |  26 |         if not message.guild or message.author.bot:
 1716 |  27 |             return
 1717 |  28 | 
 1718 |  29 |         channel_id = message.channel.id
 1719 |  30 | 
 1720 |  31 |         if not channel_id in self.bot.cache.tagcheck:
 1721 |  32 |             return
 1722 |  33 | 
 1723 |  34 |         tagcheck = await TagCheck.get_or_none(channel_id=channel_id)
 1724 |  35 | 
 1725 |  36 |         if not tagcheck:
 1726 |  37 |             return self.bot.cache.tagcheck.discard(channel_id)
 1727 |  38 | 
 1728 |  39 |         ignore_role = tagcheck.ignorerole
 1729 |  40 | 
 1730 |  41 |         if ignore_role is not None and ignore_role in message.author.roles:  # type: ignore # line guarded #25
 1731 |  42 |             return
 1732 |  43 | 
 1733 |  44 |         with suppress(discord.HTTPException, AttributeError):
 1734 |  45 |             ctx = await self.bot.get_context(message)
 1735 |  46 | 
 1736 |  47 |             _react = True
 1737 |  48 |             if tagcheck.required_mentions and not all(map(lambda m: not m.bot, message.mentions)):
 1738 |  49 |                 _react = False
 1739 |  50 |                 await message.reply("Kindly mention your real teammate.", delete_after=5)
 1740 |  51 | 
 1741 |  52 |             if not len(message.mentions) >= tagcheck.required_mentions:
 1742 |  53 |                 _react = False
 1743 |  54 |                 await message.reply(
 1744 |  55 |                     f"You need to mention `{utils.plural(tagcheck.required_mentions):teammate|teammates}`.",
 1745 |  56 |                     delete_after=5,
 1746 |  57 |                 )
 1747 |  58 | 
 1748 |  59 |             team_name = utils.find_team(message)
 1749 |  60 |             await message.add_reaction(("❌", "✅")[_react])
 1750 |  61 | 
 1751 |  62 |             if _react:
 1752 |  63 |                 embed = self.bot.embed(ctx)
 1753 |  64 |                 embed.description = f"Team Name: {team_name}\nPlayer(s): {(', '.join(m.mention for m in message.mentions)) if message.mentions else message.author.mention}"
 1754 |  65 |                 await message.reply(embed=embed)
 1755 |  66 | 
 1756 |  67 |             if tagcheck.delete_after and not _react:
 1757 |  68 |                 self.bot.loop.create_task(delete_denied_message(message, 15))
 1758 |  69 | 
 1759 |  70 |     # ==========================================================================================================
 1760 |  71 |     # ==========================================================================================================
 1761 |  72 | 
 1762 |  73 |     @Cog.listener(name="on_message")
 1763 |  74 |     async def on_eztag_msg(self, message: discord.Message):
 1764 |  75 |         if not message.guild or message.author.bot:
 1765 |  76 |             return
 1766 |  77 | 
 1767 |  78 |         if not message.channel.id in self.bot.cache.eztagchannels:
 1768 |  79 |             return
 1769 |  80 | 
 1770 |  81 |         channel_id = message.channel.id
 1771 |  82 |         eztag = await EasyTag.get_or_none(channel_id=channel_id)
 1772 |  83 | 
 1773 |  84 |         if not eztag:
 1774 |  85 |             return self.bot.cache.eztagchannels.discard(channel_id)
 1775 |  86 | 
 1776 |  87 |         ignore_role = eztag.ignorerole
 1777 |  88 | 
 1778 |  89 |         if ignore_role is not None and ignore_role in message.author.roles:  # type: ignore # line guarded #74
 1779 |  90 |             return
 1780 |  91 | 
 1781 |  92 |         with suppress(discord.HTTPException, AttributeError):
 1782 |  93 |             ctx = await self.bot.get_context(message)
 1783 |  94 | 
 1784 |  95 |             tags = set(re.findall(r"\b\d{18}\b|\b@\w+", message.content, re.IGNORECASE))
 1785 |  96 | 
 1786 |  97 |             if not tags:
 1787 |  98 |                 await message.add_reaction("❌")
 1788 |  99 |                 return await ctx.reply(
 1789 | 100 |                     "I couldn't find any discord tag in this form.\nYou can write your teammate's id , @their_name or @their_full_discord_tag",
 1790 | 101 |                     delete_after=10,
 1791 | 102 |                 )
 1792 | 103 | 
 1793 | 104 |             members = []
 1794 | 105 |             for m in tags:
 1795 | 106 |                 members.append(await EasyMemberConverter().convert(ctx, m))
 1796 | 107 | 
 1797 | 108 |             mentions = ", ".join(members)
 1798 | 109 | 
 1799 | 110 |             msg = await ctx.reply(f"```{message.clean_content}\nDiscord Tags: {mentions}```")
 1800 | 111 | 
 1801 | 112 |             if eztag.delete_after:
 1802 | 113 |                 self.bot.loop.create_task(delete_denied_message(message, 60))
 1803 | 114 |                 self.bot.loop.create_task(delete_denied_message(msg, 60))
 1804 | 115 | 
 1805 | 116 |     @Cog.listener(name="on_guild_channel_delete")
 1806 | 117 |     async def on_channel_delete(self, channel: discord.abc.GuildChannel) -> None:
 1807 | 118 |         if not isinstance(channel, discord.TextChannel):
 1808 | 119 |             return
 1809 | 120 | 
 1810 | 121 |         channel_id = channel.id
 1811 | 122 | 
 1812 | 123 |         # Delete EasyTag record
 1813 | 124 |         if channel_id in self.bot.cache.eztagchannels:
 1814 | 125 |             await EasyTag.filter(channel_id=channel_id).delete()
 1815 | 126 |             self.bot.cache.eztagchannels.remove(channel_id)
 1816 | 127 | 
 1817 | 128 |         # Delete TagCheck record
 1818 | 129 |         if channel_id in self.bot.cache.tagcheck:
 1819 | 130 |             await TagCheck.filter(channel_id=channel_id).delete()
 1820 | 131 |             self.bot.cache.tagcheck.remove(channel_id)
 1821 | 132 | 
 1822 | 
 1823 | 
 1824 | --------------------------------------------------------------------------------
 1825 | /cogs/esports/events/tourneys.py:
 1826 | --------------------------------------------------------------------------------
 1827 |   1 | from __future__ import annotations
 1828 |   2 | 
 1829 |   3 | import typing
 1830 |   4 | from contextlib import suppress
 1831 |   5 | 
 1832 |   6 | from cogs.esports.helpers.tourney import get_tourney_from_channel
 1833 |   7 | 
 1834 |   8 | if typing.TYPE_CHECKING:
 1835 |   9 |     from core import Quotient
 1836 |  10 | 
 1837 |  11 | import asyncio
 1838 |  12 | from unicodedata import normalize
 1839 |  13 | 
 1840 |  14 | import discord
 1841 |  15 | from tortoise.exceptions import DoesNotExist
 1842 |  16 | 
 1843 |  17 | import utils
 1844 |  18 | from constants import EsportsLog, RegDeny
 1845 |  19 | from core import Cog
 1846 |  20 | from models import MediaPartner, PartnerSlot, TGroupList, TMSlot, Tourney
 1847 |  21 | from utils import truncate_string
 1848 |  22 | 
 1849 |  23 | from ..helpers import (
 1850 |  24 |     before_registrations,
 1851 |  25 |     cannot_take_registration,
 1852 |  26 |     check_tourney_requirements,
 1853 |  27 |     get_tourney_slots,
 1854 |  28 |     update_confirmed_message,
 1855 |  29 | )
 1856 |  30 | 
 1857 |  31 | 
 1858 |  32 | class TourneyEvents(Cog):
 1859 |  33 |     def __init__(self, bot: Quotient):
 1860 |  34 |         self.bot = bot
 1861 |  35 |         self.__tourney_lock = asyncio.Lock()
 1862 |  36 | 
 1863 |  37 |     async def __process_tourney_message(
 1864 |  38 |         self, message: discord.Message, tourney: Tourney, *, check_duplicate=True, mp=False
 1865 |  39 |     ):
 1866 |  40 |         """
 1867 |  41 |         Processes a message that is a tourney message.
 1868 |  42 | 
 1869 |  43 |         :param check_duplicate: In case we want a message to be processed without these checks.
 1870 |  44 |         """
 1871 |  45 | 
 1872 |  46 |         teamname = utils.find_team(message)
 1873 |  47 | 
 1874 |  48 |         try:
 1875 |  49 |             await tourney.refresh_from_db()  # Refetch Tourney to check get its updated instance
 1876 |  50 |         except DoesNotExist:
 1877 |  51 |             return
 1878 |  52 |         if not tourney or tourney.closed:  # Tourney is deleted or not opened.
 1879 |  53 |             return
 1880 |  54 | 
 1881 |  55 |         if tourney.no_duplicate_name and check_duplicate:
 1882 |  56 |             if await tourney.assigned_slots.filter(team_name=teamname).exists():
 1883 |  57 |                 return self.bot.dispatch("tourney_registration_deny", message, RegDeny.duplicate, tourney)
 1884 |  58 | 
 1885 |  59 |         if not tourney.multiregister and message.author.id in get_tourney_slots(await tourney.assigned_slots.all()):
 1886 |  60 |             return self.bot.dispatch("tourney_registration_deny", message, RegDeny.multiregister, tourney)
 1887 |  61 | 
 1888 |  62 |         ctx = await self.bot.get_context(message)
 1889 |  63 | 
 1890 |  64 |         if mp:
 1891 |  65 |             partner = await MediaPartner.get(pk=ctx.channel.id)
 1892 |  66 | 
 1893 |  67 |             media_slot = await PartnerSlot.create(
 1894 |  68 |                 user_id=ctx.author.id,
 1895 |  69 |                 message_id=ctx.message.id,
 1896 |  70 |                 jump_url=ctx.message.jump_url,
 1897 |  71 |                 members=[m.id for m in message.mentions],
 1898 |  72 |             )
 1899 |  73 |             await partner.slots.add(media_slot)
 1900 |  74 | 
 1901 |  75 |         assigned_slots = await tourney.assigned_slots.order_by("-num").first()
 1902 |  76 | 
 1903 |  77 |         numb = 0 if assigned_slots is None else assigned_slots.num
 1904 |  78 | 
 1905 |  79 |         slot = TMSlot(
 1906 |  80 |             leader_id=ctx.author.id,
 1907 |  81 |             team_name=truncate_string(teamname, 30),
 1908 |  82 |             num=numb + 1,
 1909 |  83 |             members=[m.id for m in message.mentions],
 1910 |  84 |             jump_url=message.jump_url,
 1911 |  85 |             message_id=message.id,
 1912 |  86 |         )
 1913 |  87 | 
 1914 |  88 |         await tourney.add_assigned_slot(slot, ctx.message)
 1915 |  89 | 
 1916 |  90 |         self.bot.loop.create_task(tourney.finalize_slot(ctx, slot))
 1917 |  91 | 
 1918 |  92 |         self.bot.dispatch(
 1919 |  93 |             "tourney_log",
 1920 |  94 |             EsportsLog.success,
 1921 |  95 |             tourney,
 1922 |  96 |             message=ctx.message,
 1923 |  97 |         )
 1924 |  98 | 
 1925 |  99 |         if tourney.total_slots <= await tourney.assigned_slots.all().count():
 1926 | 100 |             await tourney.end_process()
 1927 | 101 | 
 1928 | 102 |     @Cog.listener("on_message")
 1929 | 103 |     async def on_tourney_registration(self, message: discord.Message):
 1930 | 104 |         if not message.guild or message.author.bot:
 1931 | 105 |             return
 1932 | 106 | 
 1933 | 107 |         channel_id = message.channel.id
 1934 | 108 | 
 1935 | 109 |         if channel_id not in self.bot.cache.tourney_channels:
 1936 | 110 |             return
 1937 | 111 | 
 1938 | 112 |         tourney = await Tourney.get_or_none(registration_channel_id=channel_id)
 1939 | 113 | 
 1940 | 114 |         if tourney is None:
 1941 | 115 |             return self.bot.cache.tourney_channels.discard(channel_id)
 1942 | 116 | 
 1943 | 117 |         if tourney.started_at is None:
 1944 | 118 |             return
 1945 | 119 | 
 1946 | 120 |         if tourney.is_ignorable(message.author):
 1947 | 121 |             return
 1948 | 122 | 
 1949 | 123 |         if not before_registrations(message, tourney.role):
 1950 | 124 |             return await cannot_take_registration(message, tourney)
 1951 | 125 | 
 1952 | 126 |         message.content = normalize("NFKC", message.content.lower())
 1953 | 127 | 
 1954 | 128 |         if not await check_tourney_requirements(self.bot, message, tourney):
 1955 | 129 |             return
 1956 | 130 | 
 1957 | 131 |         async with self.__tourney_lock:
 1958 | 132 |             await self.__process_tourney_message(message, tourney)
 1959 | 133 | 
 1960 | 134 |     @Cog.listener()
 1961 | 135 |     async def on_raw_reaction_add(self, payload: discord.RawReactionActionEvent):
 1962 | 136 |         if not all((payload.guild_id, payload.member, not payload.member.bot)):
 1963 | 137 |             return
 1964 | 138 | 
 1965 | 139 |         if not payload.channel_id in self.bot.cache.tourney_channels:
 1966 | 140 |             return
 1967 | 141 | 
 1968 | 142 |         tourney = await Tourney.get_or_none(registration_channel_id=payload.channel_id)
 1969 | 143 | 
 1970 | 144 |         if not tourney:
 1971 | 145 |             return self.bot.cache.tourney_channels.discard(payload.channel_id)
 1972 | 146 | 
 1973 | 147 |         if not str(payload.emoji) in tourney.emojis.values():
 1974 | 148 |             return
 1975 | 149 | 
 1976 | 150 |         if not tourney.is_ignorable(payload.member):
 1977 | 151 |             return
 1978 | 152 | 
 1979 | 153 |         slot = await TMSlot.get_or_none(message_id=payload.message_id)
 1980 | 154 | 
 1981 | 155 |         e = str(payload.emoji)
 1982 | 156 | 
 1983 | 157 |         message = None
 1984 | 158 |         with suppress(discord.HTTPException, AttributeError):
 1985 | 159 |             channel = self.bot.get_channel(payload.channel_id)
 1986 | 160 |             message = await self.bot.get_or_fetch_message(channel, payload.message_id)
 1987 | 161 | 
 1988 | 162 |         if not message:
 1989 | 163 |             return
 1990 | 164 | 
 1991 | 165 |         member = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, payload.user_id)
 1992 | 166 | 
 1993 | 167 |         # if not slot and e == tourney.cross_emoji:
 1994 | 168 |         #     return  # no need to do anything kyuki already registered nai hai user
 1995 | 169 | 
 1996 | 170 |         if not slot and e == tourney.check_emoji:
 1997 | 171 |             if tourney.total_slots <= await tourney.assigned_slots.all().count():
 1998 | 172 |                 return await channel.send(f"{getattr(member, 'mention','')}, Slots are already full.", delete_after=6)
 1999 | 173 | 
 2000 | 174 |             # TODO:send log here
 2001 | 175 |             return await self.__process_tourney_message(message, tourney, check_duplicate=False)
 2002 | 176 | 
 2003 | 177 |         if str(payload.emoji) == tourney.check_emoji:
 2004 | 178 |             return
 2005 | 179 | 
 2006 | 180 |         if str(payload.emoji) == tourney.cross_emoji:
 2007 | 181 |             return await ...  # cancel kardo slot user ka
 2008 | 182 | 
 2009 | 183 |     @Cog.listener(name="on_message")
 2010 | 184 |     async def on_media_partner_message(self, message: discord.Message):
 2011 | 185 |         if not all(
 2012 | 186 |             (
 2013 | 187 |                 message.guild,
 2014 | 188 |                 not message.author.bot,
 2015 | 189 |                 message.channel.id in self.bot.cache.media_partner_channels,
 2016 | 190 |             )
 2017 | 191 |         ):
 2018 | 192 |             return
 2019 | 193 | 
 2020 | 194 |         media_partner = await MediaPartner.get_or_none(pk=message.channel.id)
 2021 | 195 | 
 2022 | 196 |         if not media_partner:
 2023 | 197 |             return self.bot.cache.media_partner_channels.discard(message.channel.id)
 2024 | 198 | 
 2025 | 199 |         tourney = await get_tourney_from_channel(message.guild.id, message.channel.id)  # type: ignore # line guarded
 2026 | 200 | 
 2027 | 201 |         if not tourney:
 2028 | 202 |             return self.bot.cache.media_partner_channels.discard(message.channel.id)
 2029 | 203 | 
 2030 | 204 |         if tourney.started_at is None:
 2031 | 205 |             return
 2032 | 206 | 
 2033 | 207 |         if tourney.is_ignorable(message.author):
 2034 | 208 |             return
 2035 | 209 | 
 2036 | 210 |         partner_tourney = await Tourney.get_or_none(pk=media_partner.tourney_id)
 2037 | 211 |         if not partner_tourney:
 2038 | 212 |             _e = discord.Embed(
 2039 | 213 |                 color=discord.Color.red(),
 2040 | 214 |                 description=(
 2041 | 215 |                     f"{message.author.mention}, you can't register because partner tournament was deleted,\n"
 2042 | 216 |                     f"Kindly register directly through {tourney.registration_channel.mention}."
 2043 | 217 |                 ),
 2044 | 218 |             )
 2045 | 219 |             await message.add_reaction(tourney.cross_emoji)
 2046 | 220 |             return await message.reply(embed=_e, delete_after=7)
 2047 | 221 | 
 2048 | 222 |         if not message.author.id in get_tourney_slots(await partner_tourney.assigned_slots.all()):
 2049 | 223 |             await message.add_reaction(tourney.cross_emoji)
 2050 | 224 | 
 2051 | 225 |             _e = discord.Embed(
 2052 | 226 |                 color=discord.Color.red(),
 2053 | 227 |                 description=(
 2054 | 228 |                     f"{message.author.mention}, you can't register through here because you didn't register in our "
 2055 | 229 |                     f"Media-Partner tourney running in {partner_tourney.guild}\n\n"
 2056 | 230 |                     f"Kindly register through {tourney.registration_channel.mention}."
 2057 | 231 |                 ),
 2058 | 232 |             )
 2059 | 233 |             return await message.reply(embed=_e, delete_after=7)
 2060 | 234 | 
 2061 | 235 |         message.content = normalize("NFKC", message.content.lower())
 2062 | 236 | 
 2063 | 237 |         if not await check_tourney_requirements(self.bot, message, tourney):
 2064 | 238 |             return
 2065 | 239 | 
 2066 | 240 |         async with self.__tourney_lock:
 2067 | 241 |             await self.__process_tourney_message(message, tourney, mp=True)
 2068 | 242 | 
 2069 | 243 |     @Cog.listener()
 2070 | 244 |     async def on_raw_message_delete(self, payload: discord.RawMessageDeleteEvent):
 2071 | 245 |         message_id = payload.message_id
 2072 | 246 |         _del = await Tourney.filter(slotm_message_id=message_id).update(slotm_message_id=None, slotm_channel_id=None)
 2073 | 247 | 
 2074 | 248 |         tourney = None
 2075 | 249 |         if not _del:
 2076 | 250 |             if payload.channel_id in self.bot.cache.media_partner_channels:
 2077 | 251 |                 media_partner = await MediaPartner.get_or_none(pk=payload.channel_id)
 2078 | 252 |                 if media_partner:
 2079 | 253 |                     tourney = await get_tourney_from_channel(payload.guild_id, payload.channel_id)
 2080 | 254 |             elif payload.channel_id in self.bot.cache.tourney_channels:
 2081 | 255 |                 tourney = await Tourney.get_or_none(registration_channel_id=payload.channel_id)
 2082 | 256 | 
 2083 | 257 |         if tourney:
 2084 | 258 |             slot = await tourney.assigned_slots.filter(message_id=payload.message_id).first()
 2085 | 259 |             if slot:
 2086 | 260 |                 if slot.confirm_jump_url:
 2087 | 261 |                     self.bot.loop.create_task(update_confirmed_message(tourney, slot.confirm_jump_url))
 2088 | 262 | 
 2089 | 263 |                 if await tourney.assigned_slots.filter(leader_id=slot.leader_id).count() == 1:
 2090 | 264 |                     m = tourney.guild.get_member(slot.leader_id)
 2091 | 265 |                     if m:
 2092 | 266 |                         self.bot.loop.create_task(m.remove_roles(tourney.role))
 2093 | 267 | 
 2094 | 268 |                 await TMSlot.filter(pk=slot.pk).delete()
 2095 | 269 | 
 2096 | 270 |         await TGroupList.filter(message_id=message_id).delete()
 2097 | 271 | 
 2098 | 272 |     @Cog.listener()
 2099 | 273 |     async def on_guild_channel_delete(self, channel: discord.TextChannel):
 2100 | 274 |         await Tourney.filter(slotm_channel_id=channel.id).update(slotm_channel_id=None, slotm_message_id=None)
 2101 | 275 |         await MediaPartner.filter(channel_id=channel.id).delete()
 2102 | 276 | 
 2103 | 277 |     @Cog.listener()
 2104 | 278 |     async def on_member_update(self, before: discord.Member, after: discord.Member):
 2105 | 279 |         if before.roles != after.roles:
 2106 | 280 |             tourney = await Tourney.filter(guild_id=before.guild.id).first()
 2107 | 281 |             if not tourney:
 2108 | 282 |                 return
 2109 | 283 | 
 2110 | 284 |             msg = None
 2111 | 285 |             if role := tourney.modrole:
 2112 | 286 |                 if role in after.roles and not role in before.roles:
 2113 | 287 |                     msg = (
 2114 | 288 |                         f"Congratulations {before.mention} on becoming a {role.mention},\n\n"
 2115 | 289 |                         "Here's a list of perks you get with the new responsibilities:\n"
 2116 | 290 |                         "• You can now use all `qtourney` commands.\n"
 2117 | 291 |                         "• You can now edit, manage or even delete any tourney.\n"
 2118 | 292 |                         "• **Your messages are now ignored in all the registration channels.**\n\n"
 2119 | 293 |                         "Good luck!"
 2120 | 294 |                     )
 2121 | 295 | 
 2122 | 296 |                 elif role in before.roles and not role in after.roles:
 2123 | 297 |                     msg = (
 2124 | 298 |                         f"{before.mention} is no longer a {role.mention},\n"
 2125 | 299 |                         "All the special perks they enjoyed, are now revoked."
 2126 | 300 |                     )
 2127 | 301 | 
 2128 | 302 |                 if msg:
 2129 | 303 |                     with suppress(discord.HTTPException, AttributeError):
 2130 | 304 |                         await tourney.logschan.send(msg)
 2131 | 305 | 
 2132 | 306 |     @Cog.listener()
 2133 | 307 |     async def on_guild_channel_update(self, before: discord.TextChannel, after: discord.TextChannel):
 2134 | 308 |         if before.name == after.name or not before.name == "quotient-tourney-logs":
 2135 | 309 |             return
 2136 | 310 | 
 2137 | 311 |         if after.permissions_for(after.guild.me).manage_channels:
 2138 | 312 |             return await after.edit(
 2139 | 313 |                 name="quotient-tourney-logs",
 2140 | 314 |                 reason="tourney logging won't work if you rename this.",
 2141 | 315 |             )
 2142 | 316 | 
 2143 | 317 |         _e = discord.Embed(
 2144 | 318 |             color=discord.Color.red(),
 2145 | 319 |             description=(
 2146 | 320 |                 "Someone renamed this channel kindly rename it back to `quotient-tourney-logs`, "
 2147 | 321 |                 "**Quotient Tourneys won't work without it.**"
 2148 | 322 |             ),
 2149 | 323 |         )
 2150 | 324 |         await after.send(
 2151 | 325 |             embed=_e, content=getattr(after.guild.owner, "mention")
 2152 | 326 |         )  # there is very less chances of getting attribute error on `owner.mention`
 2153 | 327 | 
 2154 | 328 |     @Cog.listener()
 2155 | 329 |     async def on_guild_role_update(self, before: discord.Role, after: discord.Role):
 2156 | 330 |         if before.name == after.name or not before.name == "tourney-mod":
 2157 | 331 |             return
 2158 | 332 | 
 2159 | 333 |         if after.guild.me.guild_permissions.manage_roles:
 2160 | 334 |             return await after.edit(name="tourney-mod", reason="tourney mod role won't work if you rename this.")
 2161 | 335 | 
 2162 | 336 |         _e = discord.Embed(
 2163 | 337 |             color=discord.Color.red(),
 2164 | 338 |             description=(
 2165 | 339 |                 f"Someone renamed Quotient's tourney-mod role to {after.mention}, kindly rename it back to `tourney-mod`."
 2166 | 340 |                 "**Quotient Tourneys need the name of this role to be `tourney-mod`**"
 2167 | 341 |             ),
 2168 | 342 |         )
 2169 | 343 | 
 2170 | 344 |         c = discord.utils.get(after.guild.text_channels, name="quotient-tourney-logs")
 2171 | 345 |         if c:
 2172 | 346 |             await c.send(
 2173 | 347 |                 embed=_e, content=getattr(after.guild.owner, "mention")
 2174 | 348 |             )  # there is very less chances of getting attribute error on `owner.mention`
 2175 | 349 | 
 2176 | 
 2177 | 
 2178 | --------------------------------------------------------------------------------
 2179 | /cogs/esports/helpers/__init__.py:
 2180 | --------------------------------------------------------------------------------
 2181 | 1 | from .converters import *
 2182 | 2 | from .tourney import *
 2183 | 3 | from .utils import *
 2184 | 4 | 
 2185 | 
 2186 | 
 2187 | --------------------------------------------------------------------------------
 2188 | /cogs/esports/helpers/converters.py:
 2189 | --------------------------------------------------------------------------------
 2190 |  1 | from discord.ext import commands
 2191 |  2 | from discord.ext.commands import Converter
 2192 |  3 | 
 2193 |  4 | from models import *
 2194 |  5 | from utils import QuoMember
 2195 |  6 | 
 2196 |  7 | 
 2197 |  8 | class EasyMemberConverter(Converter):
 2198 |  9 |     async def convert(self, ctx, argument: str):
 2199 | 10 |         try:
 2200 | 11 |             member = await QuoMember().convert(ctx, argument)
 2201 | 12 |             return getattr(member, "mention")
 2202 | 13 |         except commands.MemberNotFound:
 2203 | 14 |             return "Invalid Member!"
 2204 | 15 | 
 2205 | 
 2206 | 
 2207 | --------------------------------------------------------------------------------
 2208 | /cogs/esports/helpers/image.py:
 2209 | --------------------------------------------------------------------------------
 2210 |   1 | # from models import PointsInfo, PointsTable
 2211 |   2 | # from ast import literal_eval
 2212 |   3 | # from collections import Counter
 2213 |   4 | # from PIL import Image, ImageFilter, ImageFont, ImageDraw
 2214 |   5 | # from pathlib import Path
 2215 |   6 | # from utils import split_list
 2216 |   7 | # import asyncio, io
 2217 |   8 | # import random
 2218 |   9 | # import discord
 2219 |  10 | 
 2220 |  11 | 
 2221 |  12 | # def add_watermark(image, footer):
 2222 |  13 | #     width, height = image.size
 2223 |  14 | #     draw = ImageDraw.Draw(image)
 2224 |  15 | 
 2225 |  16 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "Ubuntu-Regular.ttf"), 25)
 2226 |  17 | #     textwidth, textheight = draw.textsize(footer, font)
 2227 |  18 | 
 2228 |  19 | #     margin = 20
 2229 |  20 | #     x = width - textwidth - margin
 2230 |  21 | #     y = height - textheight - margin
 2231 |  22 | 
 2232 |  23 | #     draw.text((x, y), footer, font=font)
 2233 |  24 | 
 2234 |  25 | 
 2235 |  26 | # def add_title(image, title, second_title=None):
 2236 |  27 | 
 2237 |  28 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "robo-bold.ttf"), 90)
 2238 |  29 | 
 2239 |  30 | #     d1 = ImageDraw.Draw(image)
 2240 |  31 | 
 2241 |  32 | #     w, h = d1.textsize(title.upper(), font)
 2242 |  33 | 
 2243 |  34 | #     left = (image.width - w) / 2
 2244 |  35 | #     top = 50
 2245 |  36 | #     d1.text((left, top), title.upper(), font=font)
 2246 |  37 | 
 2247 |  38 | #     if second_title:
 2248 |  39 | #         w, h = d1.textsize(second_title.upper(), font)
 2249 |  40 | #         left = (image.width - w) / 2
 2250 |  41 | #         d1.text((left, 150), second_title.upper(), font=font)
 2251 |  42 | 
 2252 |  43 | 
 2253 |  44 | # def title_rect():
 2254 |  45 | #     image = Image.open(str(Path.cwd() / "src" / "data" / "img" / "rectangle.png"))
 2255 |  46 | #     image = image.convert("RGBA")
 2256 |  47 | 
 2257 |  48 | #     image = image.resize((round(image.size[0] / 2.8), round(image.size[1] / 2.8)))
 2258 |  49 | 
 2259 |  50 | #     draw = ImageDraw.Draw(image)
 2260 |  51 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "robo-italic.ttf"), 30)
 2261 |  52 | 
 2262 |  53 | #     top = 8
 2263 |  54 | #     fill = (0, 0, 0)
 2264 |  55 | 
 2265 |  56 | #     draw.text((18, top), "Rank", fill, font=font)
 2266 |  57 | #     draw.text((250, top), "Team Name", fill, font=font)
 2267 |  58 | #     draw.text((610, top), "Place Pt", fill, font=font)
 2268 |  59 | #     draw.text((770, top), "Kills Pt", fill, font=font)
 2269 |  60 | 
 2270 |  61 | #     draw.text((905, top), "Total Pt", fill, font=font)
 2271 |  62 | 
 2272 |  63 | #     draw.text((1046, top), "InGame", fill, font=font)
 2273 |  64 | #     return image
 2274 |  65 | 
 2275 |  66 | 
 2276 |  67 | # def rect_list(data):
 2277 |  68 | 
 2278 |  69 | #     fill = (0, 0, 0)
 2279 |  70 | #     _list = []
 2280 |  71 | 
 2281 |  72 | #     top = 10
 2282 |  73 | #     left = 35
 2283 |  74 | 
 2284 |  75 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "robo-bold.ttf"), 30)
 2285 |  76 | 
 2286 |  77 | #     for idx, item in enumerate(data.items(), start=1):
 2287 |  78 | 
 2288 |  79 | #         image = Image.open(str(Path.cwd() / "src" / "data" / "img" / "rectangle.png"))
 2289 |  80 | #         image = image.convert("RGBA")
 2290 |  81 | 
 2291 |  82 | #         image = image.resize((round(image.size[0] / 2.8), round(image.size[1] / 2.8)))
 2292 |  83 | 
 2293 |  84 | #         draw = ImageDraw.Draw(image)
 2294 |  85 | 
 2295 |  86 | #         team = item[0]
 2296 |  87 | #         win, place, kill, total = item[1]
 2297 |  88 | 
 2298 |  89 | #         draw.text((left, top), f"#{idx:02}", fill, font=font)
 2299 |  90 | #         draw.text((left + 150, top), f"Team {team.title()}", fill, font=font)
 2300 |  91 | #         draw.text((left + 610, top), f"{place:02}", fill, font=font)
 2301 |  92 | #         draw.text((left + 760, top), f"{kill:02}", fill, font=font)
 2302 |  93 | #         draw.text((left + 897, top), f"{total:02}", fill, font=font)
 2303 |  94 | #         draw.text((left + 1025, top), f"{'Win' if win else 'Lost'}", fill, font=font)
 2304 |  95 | 
 2305 |  96 | #         _list.append(image)
 2306 |  97 | 
 2307 |  98 | #     return _list
 2308 |  99 | 
 2309 | 100 | 
 2310 | 101 | # async def ptable_files(points: PointsInfo, data: PointsTable):
 2311 | 102 | 
 2312 | 103 | #     table = literal_eval(data.points_table)
 2313 | 104 | 
 2314 | 105 | #     def wrapper():
 2315 | 106 | 
 2316 | 107 | #         _list = rect_list(table)
 2317 | 108 | 
 2318 | 109 | #         images = []
 2319 | 110 | 
 2320 | 111 | #         number = random.choice(range(1, 15))
 2321 | 112 | #         for group in split_list(_list, 10):
 2322 | 113 | #             image = Image.open(str(Path.cwd() / "src" / "data" / "img" / f"ptable{number}.jpg"))
 2323 | 114 | #             # image = Image.open(str(Path.cwd() / "src" / "data" / "back" / f"9.jpg"))
 2324 | 115 | #             image = image.resize((1250, 938))
 2325 | 116 | #             image = image.filter(ImageFilter.GaussianBlur(4))
 2326 | 117 | #             top = 320
 2327 | 118 | 
 2328 | 119 | #             title_rec = title_rect()
 2329 | 120 | #             image.paste(title_rec, (40, 260), title_rec)
 2330 | 121 | 
 2331 | 122 | #             for rect in group:
 2332 | 123 | #                 image.paste(rect, (40, top), rect)
 2333 | 124 | #                 top += 50
 2334 | 125 | 
 2335 | 126 | #             add_watermark(image, points.footer)
 2336 | 127 | #             add_title(image, points.title, points.secondary_title)
 2337 | 128 | 
 2338 | 129 | #             img_bytes = io.BytesIO()
 2339 | 130 | #             image.save(img_bytes, "PNG")
 2340 | 131 | #             img_bytes.seek(0)
 2341 | 132 | #             images.append(discord.File(img_bytes, "points_table.png"))
 2342 | 133 | 
 2343 | 134 | #         return images
 2344 | 135 | 
 2345 | 136 | #     return await asyncio.get_event_loop().run_in_executor(None, wrapper)
 2346 | 137 | 
 2347 | 138 | 
 2348 | 139 | # def add_first_lb_rect(image):
 2349 | 140 | #     rect = Image.open(str(Path.cwd() / "src" / "data" / "img" / f"rect2.png"))
 2350 | 141 | #     rect = rect.convert("RGBA")
 2351 | 142 | #     rect = rect.resize((round(rect.size[0] / 1.5), round(rect.size[1] / 1.4)))
 2352 | 143 | 
 2353 | 144 | #     draw = ImageDraw.Draw(rect)
 2354 | 145 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "robo-italic.ttf"), 16)
 2355 | 146 | 
 2356 | 147 | #     top = 71
 2357 | 148 | #     fill = (0, 0, 0)
 2358 | 149 | 
 2359 | 150 | #     draw.text((16, top), "RANK", fill, font=font)
 2360 | 151 | #     draw.text((220, top), "TEAM NAME", fill, font=font)
 2361 | 152 | #     draw.text((492, top), "MATCHES", fill, font=font)
 2362 | 153 | #     draw.text((612, top), "PLACE POINTS", fill, font=font)
 2363 | 154 | #     draw.text((744, top), "KILL POINTS", fill, font=font)
 2364 | 155 | 
 2365 | 156 | #     draw.text((870, top), "TOTAL POINTS", fill, font=font)
 2366 | 157 | 
 2367 | 158 | #     draw.text((1024, top), "WINS", fill, font=font)
 2368 | 159 | 
 2369 | 160 | #     image.paste(rect, (46, 220), rect)
 2370 | 161 | 
 2371 | 162 | 
 2372 | 163 | # def lb_rects(_dict, matches) -> list:
 2373 | 164 | 
 2374 | 165 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "robo-bold.ttf"), 25)
 2375 | 166 | #     top, left = 68, 16
 2376 | 167 | 
 2377 | 168 | #     _list = []
 2378 | 169 | #     for idx, team in enumerate(_dict.items(), start=1):
 2379 | 170 | #         image = Image.open(str(Path.cwd() / "src" / "data" / "img" / "rect3.png"))
 2380 | 171 | #         image = image.convert("RGBA")
 2381 | 172 | 
 2382 | 173 | #         image = image.resize((round(image.size[0] / 1.5), round(image.size[1] / 1.4)))
 2383 | 174 | 
 2384 | 175 | #         draw = ImageDraw.Draw(image)
 2385 | 176 | 
 2386 | 177 | #         team_name = team[0]
 2387 | 178 | #         win, place, kill, total = team[1]
 2388 | 179 | 
 2389 | 180 | #         draw.text((left, top), f"#{idx:02}", (255, 255, 255), font=font)
 2390 | 181 | #         draw.text((left + 125, top), f"Team {team_name.title()}", (0, 0, 0), font=font)
 2391 | 182 | #         draw.text((left + 503, top), f"{matches.get(team_name):02}", (0, 0, 0), font=font)
 2392 | 183 | #         draw.text((left + 624, top), f"{place:02}", (0, 0, 0), font=font)
 2393 | 184 | #         draw.text((left + 760, top), f"{kill:02}", (0, 0, 0), font=font)
 2394 | 185 | #         draw.text((left + 897, top), f"{total:02}", (0, 0, 0), font=font)
 2395 | 186 | #         draw.text((left + 1025, top), f"x {win}", (0, 0, 0), font=font)
 2396 | 187 | 
 2397 | 188 | #         _list.append(image)
 2398 | 189 | 
 2399 | 190 | #     return _list
 2400 | 191 | 
 2401 | 192 | 
 2402 | 193 | # async def lb_files(points: PointsInfo, records):
 2403 | 194 | #     d1 = literal_eval(records[0].points_table)
 2404 | 195 | 
 2405 | 196 | #     ds = [literal_eval(record.points_table) for record in records]
 2406 | 197 | 
 2407 | 198 | #     _dict = {}
 2408 | 199 | #     for dict_item in ds:
 2409 | 200 | #         for key, value in dict_item.items():
 2410 | 201 | #             if key in _dict:
 2411 | 202 | #                 val = [a + b for a, b in zip(_dict[key], value)]
 2412 | 203 | #                 _dict[key] = val
 2413 | 204 | #             else:
 2414 | 205 | #                 _dict[key] = value
 2415 | 206 | #     _dict.update(dict(sorted(_dict.items(), reverse=True, key=lambda x: x[1][3])))
 2416 | 207 | 
 2417 | 208 | #     matches = Counter([j for i in ds for j in i.keys()])
 2418 | 209 | 
 2419 | 210 | #     def _wrapper():
 2420 | 211 | #         _list = lb_rects(_dict, matches)
 2421 | 212 | 
 2422 | 213 | #         images = []
 2423 | 214 | #         number = random.choice(range(1, 21))
 2424 | 215 | #         for group in split_list(_list, 10):
 2425 | 216 | #             image = Image.open(str(Path.cwd() / "src" / "data" / "img" / f"ptable{number}.jpg"))
 2426 | 217 | #             image = image.resize((1250, 938))
 2427 | 218 | #             image = image.filter(ImageFilter.GaussianBlur(1))
 2428 | 219 | #             top = 300
 2429 | 220 | 
 2430 | 221 | #             for rect in group:
 2431 | 222 | #                 image.paste(rect, (46, top), rect)
 2432 | 223 | #                 top += 50
 2433 | 224 | 
 2434 | 225 | #             add_first_lb_rect(image)
 2435 | 226 | #             add_watermark(image, points.footer)
 2436 | 227 | #             add_title(image, points.title, points.secondary_title)
 2437 | 228 | #             img_bytes = io.BytesIO()
 2438 | 229 | #             image.save(img_bytes, "PNG")
 2439 | 230 | #             img_bytes.seek(0)
 2440 | 231 | #             images.append(discord.File(img_bytes, "leaderboard.png"))
 2441 | 232 | 
 2442 | 233 | #         return images
 2443 | 234 | 
 2444 | 235 | #     return await asyncio.get_event_loop().run_in_executor(None, _wrapper)
 2445 | 236 | 
 2446 | 
 2447 | 
 2448 | --------------------------------------------------------------------------------
 2449 | /cogs/esports/helpers/tourney.py:
 2450 | --------------------------------------------------------------------------------
 2451 |   1 | from __future__ import annotations
 2452 |   2 | 
 2453 |   3 | import re
 2454 |   4 | from contextlib import suppress
 2455 |   5 | from typing import Iterable, List, Optional
 2456 |   6 | 
 2457 |   7 | import discord
 2458 |   8 | 
 2459 |   9 | from constants import EsportsRole, RegDeny
 2460 |  10 | from models import TMSlot, Tourney
 2461 |  11 | 
 2462 |  12 | 
 2463 |  13 | def get_tourney_slots(slots: List[TMSlot]) -> Iterable[int]:
 2464 |  14 |     for slot in slots:
 2465 |  15 |         yield slot.leader_id
 2466 |  16 | 
 2467 |  17 | 
 2468 |  18 | def tourney_work_role(tourney: Tourney, _type: EsportsRole):
 2469 |  19 |     if _type == EsportsRole.ping:
 2470 |  20 |         role = tourney.ping_role
 2471 |  21 | 
 2472 |  22 |     elif _type == EsportsRole.open:
 2473 |  23 |         role = tourney.open_role
 2474 |  24 | 
 2475 |  25 |     if not role:
 2476 |  26 |         return None
 2477 |  27 | 
 2478 |  28 |     if role == tourney.guild.default_role:
 2479 |  29 |         return "@everyone"
 2480 |  30 | 
 2481 |  31 |     return getattr(role, "mention", "role-deleted")
 2482 |  32 | 
 2483 |  33 | 
 2484 |  34 | def before_registrations(message: discord.Message, role: discord.Role) -> bool:
 2485 |  35 |     assert message.guild is not None
 2486 |  36 | 
 2487 |  37 |     me = message.guild.me
 2488 |  38 |     channel = message.channel
 2489 |  39 | 
 2490 |  40 |     if not role:
 2491 |  41 |         return False
 2492 |  42 | 
 2493 |  43 |     if not all(
 2494 |  44 |         (
 2495 |  45 |             me.guild_permissions.manage_roles,
 2496 |  46 |             role < message.guild.me.top_role,
 2497 |  47 |             channel.permissions_for(me).add_reactions,  # type: ignore
 2498 |  48 |             channel.permissions_for(me).use_external_emojis,  # type: ignore
 2499 |  49 |         )
 2500 |  50 |     ):
 2501 |  51 |         return False
 2502 |  52 |     return True
 2503 |  53 | 
 2504 |  54 | 
 2505 |  55 | async def check_tourney_requirements(bot, message: discord.Message, tourney: Tourney) -> bool:
 2506 |  56 |     _bool = True
 2507 |  57 | 
 2508 |  58 |     if tourney.teamname_compulsion:
 2509 |  59 |         teamname = re.search(r"team.*", message.content)
 2510 |  60 |         if not teamname or not teamname.group().strip():
 2511 |  61 |             _bool = False
 2512 |  62 |             bot.dispatch("tourney_registration_deny", message, RegDeny.noteamname, tourney)
 2513 |  63 | 
 2514 |  64 |     if tourney.required_mentions and not all(map(lambda m: not m.bot, message.mentions)):
 2515 |  65 |         _bool = False
 2516 |  66 |         bot.dispatch("tourney_registration_deny", message, RegDeny.botmention, tourney)
 2517 |  67 | 
 2518 |  68 |     elif not len(message.mentions) >= tourney.required_mentions:
 2519 |  69 |         _bool = False
 2520 |  70 |         bot.dispatch("tourney_registration_deny", message, RegDeny.nomention, tourney)
 2521 |  71 | 
 2522 |  72 |     elif message.author.id in tourney.banned_users:
 2523 |  73 |         _bool = False
 2524 |  74 |         bot.dispatch("tourney_registration_deny", message, RegDeny.banned, tourney)
 2525 |  75 | 
 2526 |  76 |     elif len(message.content.splitlines()) < tourney.required_lines:
 2527 |  77 |         _bool = False
 2528 |  78 |         bot.dispatch("tourney_registration_deny", message, RegDeny.nolines, tourney)
 2529 |  79 | 
 2530 |  80 |     elif not tourney.allow_duplicate_tags:
 2531 |  81 |         records = await tourney.check_fake_tags(message)
 2532 |  82 |         if records:
 2533 |  83 |             _bool = False
 2534 |  84 |             bot.dispatch("tourney_registration_deny", message, RegDeny.faketag, tourney, records=records)
 2535 |  85 | 
 2536 |  86 |     return _bool
 2537 |  87 | 
 2538 |  88 | 
 2539 |  89 | async def t_ask_embed(ctx, value, description: str):
 2540 |  90 |     embed = discord.Embed(
 2541 |  91 |         color=ctx.bot.color,
 2542 |  92 |         title=f"🛠️ Tournament Manager ({value}/5)",
 2543 |  93 |         description=description,
 2544 |  94 |     )
 2545 |  95 |     embed.set_footer(text=f'Reply with "cancel" to stop the process.')
 2546 |  96 |     await ctx.send(embed=embed, embed_perms=True)
 2547 |  97 | 
 2548 |  98 | 
 2549 |  99 | async def update_confirmed_message(tourney: Tourney, link: str):
 2550 | 100 |     _ids = [int(i) for i in link.split("/")[5:]]
 2551 | 101 | 
 2552 | 102 |     message = None
 2553 | 103 | 
 2554 | 104 |     with suppress(discord.HTTPException, IndexError):
 2555 | 105 |         message = await tourney.guild.get_channel(_ids[0]).fetch_message(_ids[1])
 2556 | 106 | 
 2557 | 107 |         if message:
 2558 | 108 |             e = message.embeds[0]
 2559 | 109 | 
 2560 | 110 |             e.description = "~~" + e.description.strip() + "~~"
 2561 | 111 |             e.title = "Cancelled Slot"
 2562 | 112 |             e.color = discord.Color.red()
 2563 | 113 | 
 2564 | 114 |             await message.edit(embed=e)
 2565 | 115 | 
 2566 | 116 | 
 2567 | 117 | async def get_tourney_from_channel(guild_id: int, channel_id: int) -> Optional[Tourney]:
 2568 | 118 |     tourneys = await Tourney.filter(guild_id=guild_id)
 2569 | 119 | 
 2570 | 120 |     for tourney in tourneys:
 2571 | 121 |         if await tourney.media_partners.filter(pk=channel_id).exists():
 2572 | 122 |             return tourney
 2573 | 123 | 
 2574 | 124 |     return None
 2575 | 125 | 
 2576 | 
 2577 | 
 2578 | --------------------------------------------------------------------------------
 2579 | /cogs/esports/helpers/utils.py:
 2580 | --------------------------------------------------------------------------------
 2581 |   1 | import asyncio
 2582 |   2 | import re
 2583 |   3 | from contextlib import suppress
 2584 |   4 | from typing import Union
 2585 |   5 | 
 2586 |   6 | import discord
 2587 |   7 | 
 2588 |   8 | import constants
 2589 |   9 | from models import Scrim, Tourney
 2590 |  10 | from utils import find_team
 2591 |  11 | 
 2592 |  12 | 
 2593 |  13 | def get_slots(slots):
 2594 |  14 |     for slot in slots:
 2595 |  15 |         yield slot.user_id
 2596 |  16 | 
 2597 |  17 | 
 2598 |  18 | async def already_reserved(scrim: Scrim):
 2599 |  19 |     return [i.num for i in await scrim.reserved_slots.all()]
 2600 |  20 | 
 2601 |  21 | 
 2602 |  22 | async def available_to_reserve(scrim: Scrim):
 2603 |  23 |     reserved = await already_reserved(scrim)
 2604 |  24 |     return sorted([i for i in scrim.available_to_reserve if i not in reserved])
 2605 |  25 | 
 2606 |  26 | 
 2607 |  27 | async def cannot_take_registration(message: discord.Message, obj: Union[Scrim, Tourney]):
 2608 |  28 |     assert message.guild is not None
 2609 |  29 | 
 2610 |  30 |     logschan = obj.logschan
 2611 |  31 | 
 2612 |  32 |     with suppress(AttributeError, discord.Forbidden):
 2613 |  33 |         embed = discord.Embed(
 2614 |  34 |             color=discord.Color.red(),
 2615 |  35 |             description=f"**Registration couldn't be accepted in {message.channel.mention}**",
 2616 |  36 |         )
 2617 |  37 |         embed.description += (  # type: ignore # line guarded above
 2618 |  38 |             "\nPossible reasons are:\n"
 2619 |  39 |             "> Success Role of tourney has been deleted.\n"
 2620 |  40 |             "> I don't have add reaction permission in the channel\n"
 2621 |  41 |             "> I don't have manage_roles permission in the server\n"
 2622 |  42 |             f"> My top role({message.guild.me.top_role.mention}) is below {obj.role.mention}\n"
 2623 |  43 |             "> I don't have use external emojis permission in the channel."
 2624 |  44 |         )
 2625 |  45 | 
 2626 |  46 |         await logschan.send(
 2627 |  47 |             content=getattr(obj.modrole, "mention", None),
 2628 |  48 |             embed=embed,
 2629 |  49 |             allowed_mentions=discord.AllowedMentions(roles=True),
 2630 |  50 |         )
 2631 |  51 | 
 2632 |  52 | 
 2633 |  53 | async def toggle_channel(channel, role, _bool=True) -> bool:
 2634 |  54 |     overwrite = channel.overwrites_for(role)
 2635 |  55 |     overwrite.update(send_messages=_bool)
 2636 |  56 |     try:
 2637 |  57 |         await channel.set_permissions(
 2638 |  58 |             role,
 2639 |  59 |             overwrite=overwrite,
 2640 |  60 |             reason=("Registration is over!", "Open for Registrations!")[_bool],  # False=0, True=1
 2641 |  61 |         )
 2642 |  62 | 
 2643 |  63 |         return True
 2644 |  64 | 
 2645 |  65 |     except:
 2646 |  66 |         return False
 2647 |  67 | 
 2648 |  68 | 
 2649 |  69 | async def wait_and_purge(channel, *, limit=100, wait_for=15, check=lambda m: True):
 2650 |  70 |     await asyncio.sleep(wait_for)
 2651 |  71 | 
 2652 |  72 |     with suppress(discord.HTTPException):
 2653 |  73 |         await channel.purge(limit=limit, check=check)
 2654 |  74 | 
 2655 |  75 | 
 2656 |  76 | async def delete_denied_message(message: discord.Message, seconds=10):
 2657 |  77 |     with suppress(AttributeError, discord.HTTPException, discord.NotFound, discord.Forbidden):
 2658 |  78 |         await asyncio.sleep(seconds)
 2659 |  79 |         await message.delete()
 2660 |  80 | 
 2661 |  81 | 
 2662 |  82 | async def check_scrim_requirements(bot, message: discord.Message, scrim: Scrim) -> bool:
 2663 |  83 |     _bool = True
 2664 |  84 | 
 2665 |  85 |     if scrim.teamname_compulsion:
 2666 |  86 |         teamname = re.search(r"team.*", message.content)
 2667 |  87 |         if not teamname or not teamname.group().strip():
 2668 |  88 |             _bool = False
 2669 |  89 |             bot.dispatch("scrim_registration_deny", message, constants.RegDeny.noteamname, scrim)
 2670 |  90 | 
 2671 |  91 |     if scrim.required_mentions and not all(map(lambda m: not m.bot, message.mentions)):
 2672 |  92 |         _bool = False
 2673 |  93 |         bot.dispatch("scrim_registration_deny", message, constants.RegDeny.botmention, scrim)
 2674 |  94 | 
 2675 |  95 |     elif not len(message.mentions) >= scrim.required_mentions:
 2676 |  96 |         _bool = False
 2677 |  97 |         bot.dispatch("scrim_registration_deny", message, constants.RegDeny.nomention, scrim)
 2678 |  98 | 
 2679 |  99 |     elif message.author.id in await scrim.banned_user_ids():
 2680 | 100 |         _bool = False
 2681 | 101 |         bot.dispatch("scrim_registration_deny", message, constants.RegDeny.banned, scrim)
 2682 | 102 | 
 2683 | 103 |     elif len(message.content.splitlines()) < scrim.required_lines:
 2684 | 104 |         _bool = False
 2685 | 105 |         bot.dispatch("scrim_registration_deny", message, constants.RegDeny.nolines, scrim)
 2686 | 106 | 
 2687 | 107 |     # elif any(x in banned for x in (i.id for i in message.mentions)):
 2688 | 108 |     #     _bool = False
 2689 | 109 |     #     bot.dispatch("scrim_registration_deny", message, constants.RegDeny.bannedteammate, scrim)
 2690 | 110 | 
 2691 | 111 |     elif not scrim.multiregister and message.author.id in get_slots(await scrim.assigned_slots.all()):
 2692 | 112 |         _bool = False
 2693 | 113 |         bot.dispatch("scrim_registration_deny", message, constants.RegDeny.multiregister, scrim)
 2694 | 114 | 
 2695 | 115 |     elif scrim.no_duplicate_name:
 2696 | 116 |         teamname = find_team(message)
 2697 | 117 |         async for slot in scrim.assigned_slots.all():
 2698 | 118 |             if slot.team_name == teamname:
 2699 | 119 |                 _bool = False
 2700 | 120 |                 bot.dispatch("scrim_registration_deny", message, constants.RegDeny.duplicate, scrim)
 2701 | 121 |                 break
 2702 | 122 |             else:
 2703 | 123 |                 continue
 2704 | 124 | 
 2705 | 125 |     elif not scrim.allow_duplicate_tags:
 2706 | 126 |         records = await scrim.check_fake_tags(message)
 2707 | 127 |         if records:
 2708 | 128 |             _bool = False
 2709 | 129 |             bot.dispatch("tourney_registration_deny", message, constants.RegDeny.faketag, scrim, records=records)
 2710 | 130 | 
 2711 | 131 |     return _bool
 2712 | 132 | 
 2713 | 133 | 
 2714 | 134 | async def should_open_scrim(scrim: Scrim):
 2715 | 135 |     guild = scrim.guild
 2716 | 136 |     registration_channel = scrim.registration_channel
 2717 | 137 |     role = scrim.role
 2718 | 138 |     _bool = True
 2719 | 139 | 
 2720 | 140 |     text = f"Registration of Scrim: `{scrim.id}` couldn't be opened due to the following reason:\n\n"
 2721 | 141 | 
 2722 | 142 |     if not registration_channel:
 2723 | 143 |         _bool = False
 2724 | 144 |         text += "I couldn't find registration channel. Maybe its deleted or hidden from me."
 2725 | 145 | 
 2726 | 146 |     elif not registration_channel.permissions_for(guild.me).manage_channels:
 2727 | 147 |         _bool = False
 2728 | 148 |         text += "I do not have `manage_channels` permission in {0}".format(registration_channel.mention)
 2729 | 149 | 
 2730 | 150 |     elif role is None:
 2731 | 151 |         _bool = False
 2732 | 152 |         text += "I couldn't find success registration role."
 2733 | 153 | 
 2734 | 154 |     elif not guild.me.guild_permissions.manage_roles or role >= guild.me.top_role:
 2735 | 155 |         _bool = False
 2736 | 156 |         text += "I don't have permissions to `manage roles` in this server or {0} is above my top role ({1}).".format(
 2737 | 157 |             role.mention, guild.me.top_role.mention
 2738 | 158 |         )
 2739 | 159 | 
 2740 | 160 |     elif scrim.open_role_id and not scrim.open_role:
 2741 | 161 |         _bool = False
 2742 | 162 |         text += "You have setup an open role earlier and I couldn't find it."
 2743 | 163 | 
 2744 | 164 |     if not _bool:
 2745 | 165 |         logschan = scrim.logschan
 2746 | 166 |         if logschan:
 2747 | 167 |             embed = discord.Embed(color=discord.Color.red())
 2748 | 168 |             embed.description = text
 2749 | 169 |             with suppress(discord.Forbidden, discord.NotFound):
 2750 | 170 |                 await logschan.send(
 2751 | 171 |                     content=getattr(scrim.modrole, "mention", None),
 2752 | 172 |                     embed=embed,
 2753 | 173 |                     allowed_mentions=discord.AllowedMentions(roles=True),
 2754 | 174 |                 )
 2755 | 175 | 
 2756 | 176 |     return _bool
 2757 | 177 | 
 2758 | 178 | 
 2759 | 179 | def scrim_work_role(scrim: Scrim, _type: constants.EsportsRole):
 2760 | 180 |     if _type == constants.EsportsRole.ping:
 2761 | 181 |         role = scrim.ping_role
 2762 | 182 | 
 2763 | 183 |     elif _type == constants.EsportsRole.open:
 2764 | 184 |         role = scrim.open_role
 2765 | 185 | 
 2766 | 186 |     if not role:
 2767 | 187 |         return None
 2768 | 188 | 
 2769 | 189 |     if role == scrim.guild.default_role:
 2770 | 190 |         return "@everyone"
 2771 | 191 |     return getattr(role, "mention", "Role deleted!")
 2772 | 192 | 
 2773 | 
 2774 | 
 2775 | --------------------------------------------------------------------------------
 2776 | /cogs/esports/menus.py:
 2777 | --------------------------------------------------------------------------------
 2778 |   1 | from __future__ import annotations
 2779 |   2 | 
 2780 |   3 | import string
 2781 |   4 | 
 2782 |   5 | import aiohttp
 2783 |   6 | from discord.ext import menus
 2784 |   7 | from discord.ext.menus import Button
 2785 |   8 | 
 2786 |   9 | import config
 2787 |  10 | import constants
 2788 |  11 | from models import Scrim
 2789 |  12 | from models.helpers import *  # noqa: F401, F403
 2790 |  13 | from utils import *  # noqa: F401, F403
 2791 |  14 | 
 2792 |  15 | from .errors import ScrimError
 2793 |  16 | from .helpers import delete_denied_message, scrim_work_role
 2794 |  17 | 
 2795 |  18 | # class PointsConfigEditor(menus.Menu):
 2796 |  19 | #     def __init__(self, points: PointsInfo):
 2797 |  20 | #         super().__init__(
 2798 |  21 | #             timeout=60,
 2799 |  22 | #             delete_message_after=False,
 2800 |  23 | #             clear_reactions_after=True,
 2801 |  24 | #         )
 2802 |  25 | 
 2803 |  26 | #         self.points = points
 2804 |  27 | #         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
 2805 |  28 | 
 2806 |  29 | #     def inital_embed(self):
 2807 |  30 | #         points = self.points
 2808 |  31 | #         embed = discord.Embed(color=self.bot.color, title=f"Ptable Setup Editor: {points.id}")
 2809 |  32 | 
 2810 |  33 | #         fields = {
 2811 |  34 | #             "Title": points.title,
 2812 |  35 | #             "Secondary Title": points.secondary_title,
 2813 |  36 | #             "Watermark": points.footer,
 2814 |  37 | #             "Channel": getattr(points.channel, "mention", "`Not Found!`"),
 2815 |  38 | #             "Per kill point": points.kill_points,
 2816 |  39 | #             "Default Position Points": "Click me for preview",
 2817 |  40 | #         }
 2818 |  41 | 
 2819 |  42 | #         for idx, (name, value) in enumerate(fields.items()):
 2820 |  43 | #             embed.add_field(
 2821 |  44 | #                 name=f"{regional_indicator(string.ascii_uppercase[idx])} {name}:",
 2822 |  45 | #                 value=value,
 2823 |  46 | #                 inline=False,
 2824 |  47 | #             )
 2825 |  48 | 
 2826 |  49 | #         embed.set_thumbnail(url=self.bot.user.display_avatar.url)
 2827 |  50 | #         return embed
 2828 |  51 | 
 2829 |  52 | #     async def send_initial_message(self, ctx, channel):
 2830 |  53 | #         return await channel.send(embed=self.inital_embed())
 2831 |  54 | 
 2832 |  55 | #     async def refresh(self):
 2833 |  56 | #         self.points = await PointsInfo.get(id=self.points.id)
 2834 |  57 | #         await self.message.edit(embed=self.inital_embed())
 2835 |  58 | 
 2836 |  59 | #     @menus.button(regional_indicator("A"))
 2837 |  60 | #     async def on_a(self, payload):
 2838 |  61 | #         msg = await self.ctx.simple(
 2839 |  62 | #             f"What do you want the title of points table to be?\n\n`Please enter a title under 22 characters.`"
 2840 |  63 | #         )
 2841 |  64 | 
 2842 |  65 | #         title = await inputs.string_input(self.ctx, self.check, delete_after=True)
 2843 |  66 | #         await inputs.safe_delete(msg)
 2844 |  67 | 
 2845 |  68 | #         if len(title) > 22:
 2846 |  69 | #             return await self.ctx.error("Character length of title cannot exceed 22 characters.", delete_after=3)
 2847 |  70 | 
 2848 |  71 | #         await PointsInfo.filter(id=self.points.id).update(title=title)
 2849 |  72 | #         await self.refresh()
 2850 |  73 | 
 2851 |  74 | #     @menus.button(regional_indicator("B"))
 2852 |  75 | #     async def on_b(self, payload):
 2853 |  76 | #         msg = await self.ctx.simple(
 2854 |  77 | #             "What do you want to secondary title to be? This will be shown under the main title.\n\n`Please keep this under 22 characters.`"
 2855 |  78 | #         )
 2856 |  79 | 
 2857 |  80 | #         title = await inputs.string_input(self.ctx, self.check, delete_after=True)
 2858 |  81 | #         await inputs.safe_delete(msg)
 2859 |  82 | 
 2860 |  83 | #         if len(title) > 22:
 2861 |  84 | #             return await self.ctx.error(
 2862 |  85 | #                 "Character length of secondary title cannot exceed 22 characters.", delete_after=3
 2863 |  86 | #             )
 2864 |  87 | 
 2865 |  88 | #         await PointsInfo.filter(id=self.points.id).update(secondary_title=title)
 2866 |  89 | #         await self.refresh()
 2867 |  90 | 
 2868 |  91 | #     @menus.button(regional_indicator("C"))
 2869 |  92 | #     async def on_c(self, payload):
 2870 |  93 | #         if not await self.ctx.is_premium_guild():
 2871 |  94 | #             return await self.ctx.error(
 2872 |  95 | #                 "This feature is available to premium servers only.\n\nYou can upgrade your server with Quotient Premium to use this.\n\n`Kindly use qperks cmd to know more.`",
 2873 |  96 | #                 delete_after=4,
 2874 |  97 | #             )
 2875 |  98 | 
 2876 |  99 | #         msg = await self.ctx.simple("What do you want the footer text to be?\n\n`Please keep it under 50 characters.`")
 2877 | 100 | #         title = await inputs.string_input(self.ctx, self.check, delete_after=True)
 2878 | 101 | #         await inputs.safe_delete(msg)
 2879 | 102 | 
 2880 | 103 | #         if len(title) > 50:
 2881 | 104 | #             return await self.ctx.error("Character length of footer cannot exceed 50 characters.", delete_after=3)
 2882 | 105 | 
 2883 | 106 | #         await PointsInfo.filter(id=self.points.id).update(footer=title)
 2884 | 107 | #         await self.refresh()
 2885 | 108 | 
 2886 | 109 | #     @menus.button(regional_indicator("D"))
 2887 | 110 | #     async def on_d(self, payload):
 2888 | 111 | #         msg = await self.ctx.simple(
 2889 | 112 | #             f"Which channel should I use to send points tables?\n\n`Either mention the channel or write its name`"
 2890 | 113 | #         )
 2891 | 114 | 
 2892 | 115 | #         channel = await inputs.channel_input(self.ctx, self.check, delete_after=True)
 2893 | 116 | #         await inputs.safe_delete(msg)
 2894 | 117 | 
 2895 | 118 | #         perms = channel.permissions_for(self.ctx.me)
 2896 | 119 | #         if not all((perms.send_messages, perms.embed_links)):
 2897 | 120 | #             return await self.ctx.error(
 2898 | 121 | #                 f"kindly make sure I have `send_messages` and `embed_links` permissions in {channel.mention}",
 2899 | 122 | #                 delete_after=3,
 2900 | 123 | #             )
 2901 | 124 | 
 2902 | 125 | #         await PointsInfo.filter(id=self.points.id).update(channel_id=channel.id)
 2903 | 126 | #         await self.refresh()
 2904 | 127 | 
 2905 | 128 | #     @menus.button(regional_indicator("E"))
 2906 | 129 | #     async def on_e(self, payload):
 2907 | 130 | #         msg = await self.ctx.simple(
 2908 | 131 | #             f"How many points do you want me to give per kill?\n\n`Enter a number between 1 and 10.`"
 2909 | 132 | #         )
 2910 | 133 | #         kill_point = await inputs.integer_input(self.ctx, self.check, delete_after=True, limits=(0, 10))
 2911 | 134 | #         await inputs.safe_delete(msg)
 2912 | 135 | #         await PointsInfo.filter(id=self.points.id).update(kill_points=kill_point)
 2913 | 136 | #         await self.refresh()
 2914 | 137 | 
 2915 | 138 | #     @menus.button(regional_indicator("F"))
 2916 | 139 | #     async def on_f(self, payload):
 2917 | 140 | #         return await self.ctx.error(
 2918 | 141 | #             f"This feature is currently under development, it will be available soon", delete_after=3
 2919 | 142 | #         )
 2920 | 143 | 
 2921 | 144 | #     @menus.button("\N{BLACK SQUARE FOR STOP}")
 2922 | 145 | #     async def on_stop(self, payload):
 2923 | 146 | #         self.stop()
 2924 | 147 | 
 2925 | 148 | 
 2926 | 149 | # class PointsMenu(menus.Menu):
 2927 | 150 | #     def __init__(self, points: PointsInfo, msg: discord.Message):
 2928 | 151 | #         super().__init__(
 2929 | 152 | #             timeout=60,
 2930 | 153 | #             delete_message_after=False,
 2931 | 154 | #             clear_reactions_after=True,
 2932 | 155 | #         )
 2933 | 156 | #         self.msg = msg
 2934 | 157 | #         self.points = points
 2935 | 158 | #         self._dict = {}
 2936 | 159 | #         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
 2937 | 160 | 
 2938 | 161 | #     def table_embed(self):
 2939 | 162 | #         table = PrettyTable()
 2940 | 163 | #         table.field_names = ["S.No", "Team Name", "Posi Pt", "Kills", "Total"]
 2941 | 164 | #         for idx, teams in enumerate(self._dict.items(), start=1):
 2942 | 165 | #             team = teams[0]
 2943 | 166 | #             _list = teams[1]
 2944 | 167 | #             win, posi, kill, total = _list
 2945 | 168 | #             table.add_row([idx, textwrap.fill(team, width=12), posi, kill, total])
 2946 | 169 | 
 2947 | 170 | #         embed = discord.Embed(color=self.bot.color, title=self.points.title)
 2948 | 171 | #         embed.description = f"```ml\n{table.get_string()}```"
 2949 | 172 | #         return embed
 2950 | 173 | 
 2951 | 174 | #     def initial_embed(self):
 2952 | 175 | #         embed = discord.Embed(color=self.bot.color)
 2953 | 176 | #         embed.description = "▶️ | Start or Edit points table\n" "❌ | Do not save & abort\n" "✅ | Save and Create Image"
 2954 | 177 | #         return embed
 2955 | 178 | 
 2956 | 179 | #     async def send_initial_message(self, ctx, channel):
 2957 | 180 | #         await self.msg.edit(embed=self.table_embed())
 2958 | 181 | #         return await channel.send(embed=self.initial_embed())
 2959 | 182 | 
 2960 | 183 | #     async def pointsembed(self, description: str):
 2961 | 184 | #         embed = discord.Embed(color=self.bot.color, title=f"📊 Points Table Menu")
 2962 | 185 | #         embed.description = description
 2963 | 186 | #         return await self.ctx.send(embed=embed, embed_perms=True)
 2964 | 187 | 
 2965 | 188 | #     async def refresh(self):
 2966 | 189 | #         try:
 2967 | 190 | #             await self.msg.edit(embed=self.table_embed())
 2968 | 191 | #         except Exception as e:
 2969 | 192 | #             await self.ctx.send(e)
 2970 | 193 | 
 2971 | 194 | #     @menus.button("▶️")
 2972 | 195 | #     async def on_start(self, payload):
 2973 | 196 | #         msg = await self.pointsembed(
 2974 | 197 | #             "Enter team names with their kill points.\n"
 2975 | 198 | #             "Format:\n`<Team Name> = <Kills>`\nKindly don't use special characters in team names.\n"
 2976 | 199 | #             "Separate them with comma (`,`)\n"
 2977 | 200 | #             "Example:\n"
 2978 | 201 | #             "```Team Quotient = 20,\nTeam Butterfly = 14,\nTeam Kite = 5,\nTeam 4Pandas = 8```\n"
 2979 | 202 | #             "Write these according to their position in match.\n"
 2980 | 203 | #             "You have 10 minutes to answer this."
 2981 | 204 | #         )
 2982 | 205 | #         teams = await inputs.string_input(self.ctx, self.check, delete_after=True, timeout=600)
 2983 | 206 | #         await inputs.safe_delete(msg)
 2984 | 207 | 
 2985 | 208 | #         result = {}
 2986 | 209 | #         try:
 2987 | 210 | 
 2988 | 211 | #             for idx, line in enumerate(teams.replace("\n", "").split(","), start=1):
 2989 | 212 | #                 line_values = [value.strip() for value in line.split("=")]
 2990 | 213 | 
 2991 | 214 | #                 teamname = " ".join(
 2992 | 215 | #                     normalize("NFKC", line_values[0]).lower().replace("team", "").replace("name", "").split()
 2993 | 216 | #                 )
 2994 | 217 | #                 # teamname = (
 2995 | 218 | #                 #     re.sub(r"<@*#*!*&*\d+>|team|name|[^\w\s]", "", normalize("NFKC", line_values[0].lower()))
 2996 | 219 | #                 # ).split()[0]
 2997 | 220 | 
 2998 | 221 | #                 posi = self.points.posi_points.get(str(idx), 0)
 2999 | 222 | #                 kills = int(line_values[1]) * self.points.kill_points
 3000 | 223 | 
 3001 | 224 | #                 if kills > 99:
 3002 | 225 | #                     return await self.ctx.error(
 3003 | 226 | #                         f"Kills value (`{kills}`) too large at **{str(line_values[0])}**", delete_after=4
 3004 | 227 | #                     )
 3005 | 228 | 
 3006 | 229 | #                 if not teamname:
 3007 | 230 | #                     return await self.ctx.error(f"I couldn't determine team name.", delete_after=4)
 3008 | 231 | 
 3009 | 232 | #                 if len(teamname) > 22:
 3010 | 233 | #                     return await self.ctx.error(f"Team name too large at **{teamname}**", delete_after=4)
 3011 | 234 | 
 3012 | 235 | #                 result[teamname] = [1 if idx == 1 else 0, posi, kills, posi + kills]
 3013 | 236 | 
 3014 | 237 | #         except Exception as e:
 3015 | 238 | #             return await self.ctx.error(f"Oops , you entered wrong format", delete_after=3)
 3016 | 239 | 
 3017 | 240 | #         if len(result) > 25:
 3018 | 241 | #             return await self.ctx.error(f"You cannot enter more than 25 teams :c", delete_after=4)
 3019 | 242 | 
 3020 | 243 | #         _dict = dict(sorted(result.items(), key=lambda x: x[1][3], reverse=True))
 3021 | 244 | #         self._dict.update(_dict)
 3022 | 245 | #         await self.refresh()
 3023 | 246 | 
 3024 | 247 | #     @menus.button("❌")
 3025 | 248 | #     async def on_cross(self, payload):
 3026 | 249 | #         self.stop()
 3027 | 250 | 
 3028 | 251 | #     @menus.button("✅")
 3029 | 252 | #     async def on_check(self, payload):
 3030 | 253 | #         table = await PointsTable.create(
 3031 | 254 | #             points_table=str(self._dict),
 3032 | 255 | #             created_by=self.ctx.author.id,
 3033 | 256 | #             created_at=(datetime.now(constants.IST).replace(hour=0, minute=0, second=0, microsecond=0)),
 3034 | 257 | #         )
 3035 | 258 | #         await self.points.data.add(table)
 3036 | 259 | #         await self.ctx.success(
 3037 | 260 | #             f"Successfully created points table.\n\nYou can use `pt match show {self.points.id}` to get it in image format.\nOr you can send the image to a channel with `pt match send {self.points.id}`"
 3038 | 261 | #         )
 3039 | 262 | #         self.stop()
 3040 | 263 | 
 3041 | 264 | 
 3042 | 265 | class IDPMenu(menus.Menu):
 3043 | 266 |     def __init__(self, send_channel: QuoTextChannel, role: QuoRole):
 3044 | 267 |         super().__init__(timeout=60, delete_message_after=False, clear_reactions_after=True)
 3045 | 268 |         self.embed = None
 3046 | 269 |         self._id = "Not Set!"
 3047 | 270 |         self._pass = "Not Set!"
 3048 | 271 |         self.msg = None
 3049 | 272 |         self.send_channel = send_channel
 3050 | 273 |         self.ping_role = role
 3051 | 274 |         self.delete_in = 30
 3052 | 275 |         self.id_pass_content = False
 3053 | 276 |         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
 3054 | 277 | 
 3055 | 278 |     def idp_embed(self):
 3056 | 279 |         embed = self.ctx.bot.embed(self.ctx, title="New Custom Room. JOIN NOW!")
 3057 | 280 |         embed.set_thumbnail(url=self.ctx.guild.icon.url)
 3058 | 281 |         embed.add_field(name="Room ID", value=self._id)
 3059 | 282 |         embed.add_field(name="Password", value=self._pass)
 3060 | 283 |         embed.add_field(name="Map", value="Not Set")
 3061 | 284 |         embed.add_field(name="Match Starts at", value="Not Set")
 3062 | 285 | 
 3063 | 286 |         embed.set_footer(
 3064 | 287 |             text=f"Shared by: {self.ctx.author} • Auto delete in {plural(self.delete_in):minute|minutes}.",
 3065 | 288 |             icon_url=self.ctx.author.display_avatar.url,
 3066 | 289 |         )
 3067 | 290 |         return embed
 3068 | 291 | 
 3069 | 292 |     @staticmethod
 3070 | 293 |     def inital_embed():
 3071 | 294 |         embed = discord.Embed(color=config.COLOR, title="ID-PASS Menu")
 3072 | 295 |         embed.description = (
 3073 | 296 |             "🇹 | Set Title\n"
 3074 | 297 |             "🆔 | Set Room ID\n"
 3075 | 298 |             "🇵 | Set Room Password\n"
 3076 | 299 |             "🗺️ | Set Room Map\n"
 3077 | 300 |             "🕰️ | Set Start Time\n"
 3078 | 301 |             "🖼️ | Set thumbnail image\n"
 3079 | 302 |             "❔ | ID/Pass as Content\n"
 3080 | 303 |             "⏰ | Autodelete after\n"
 3081 | 304 |         )
 3082 | 305 |         return embed
 3083 | 306 | 
 3084 | 307 |     async def refresh(self):
 3085 | 308 |         try:
 3086 | 309 |             content = self.ping_role.mention if self.ping_role else ""
 3087 | 310 |             if self.id_pass_content:
 3088 | 311 |                 content += f"\nID: {self._id} | Password: {self._pass}"
 3089 | 312 |             await self.msg.edit(
 3090 | 313 |                 content=content,
 3091 | 314 |                 embed=self.embed,
 3092 | 315 |                 allowed_mentions=discord.AllowedMentions(everyone=False, roles=False),
 3093 | 316 |             )
 3094 | 317 |         except:
 3095 | 318 |             self.stop()
 3096 | 319 | 
 3097 | 320 |     async def cembed(self, description):
 3098 | 321 |         return await self.ctx.send(
 3099 | 322 |             embed=discord.Embed(
 3100 | 323 |                 color=discord.Color(config.COLOR),
 3101 | 324 |                 title=f"🛠️ ID/Pass Formatter",
 3102 | 325 |                 description=description,
 3103 | 326 |             )
 3104 | 327 |         )
 3105 | 328 | 
 3106 | 329 |     async def send_initial_message(self, ctx, channel):
 3107 | 330 |         self.embed = self.idp_embed()
 3108 | 331 |         self.msg = await channel.send(embed=self.idp_embed())
 3109 | 332 |         return await channel.send(embed=self.inital_embed())
 3110 | 333 | 
 3111 | 334 |     @menus.button(regional_indicator("T"))
 3112 | 335 |     async def set_title(self, payload):
 3113 | 336 |         msg = await self.cembed(f"What do you want the title to be?\n\nTitle cannot exceed 256 characters.")
 3114 | 337 | 
 3115 | 338 |         title = await inputs.string_input(self.ctx, self.check, delete_after=True)
 3116 | 339 |         if len(title) > 256:
 3117 | 340 |             return await self.ctx.error(f"Title cannot exceed 256 characters.", delete_after=3)
 3118 | 341 | 
 3119 | 342 |         await inputs.safe_delete(msg)
 3120 | 343 |         if title.lower() == "none":
 3121 | 344 |             self.embed.title = None
 3122 | 345 |         else:
 3123 | 346 |             self.embed.title = title
 3124 | 347 |         await self.refresh()
 3125 | 348 | 
 3126 | 349 |     @menus.button("🆔")
 3127 | 350 |     async def set_id(self, payload):
 3128 | 351 |         msg = await self.cembed(f"What is the ID of custom room?")
 3129 | 352 | 
 3130 | 353 |         _id = await inputs.string_input(self.ctx, self.check, delete_after=True)
 3131 | 354 | 
 3132 | 355 |         await inputs.safe_delete(msg)
 3133 | 356 |         self.embed.set_field_at(0, name="Room ID", value=_id)
 3134 | 357 |         self._id = _id
 3135 | 358 |         await self.refresh()
 3136 | 359 | 
 3137 | 360 |     @menus.button("🇵")
 3138 | 361 |     async def set_pass(self, payload):
 3139 | 362 |         msg = await self.cembed(f"What is the password for room?")
 3140 | 363 | 
 3141 | 364 |         _pass = await inputs.string_input(self.ctx, self.check, delete_after=True)
 3142 | 365 | 
 3143 | 366 |         await inputs.safe_delete(msg)
 3144 | 367 |         self.embed.set_field_at(1, name="Password", value=_pass)
 3145 | 368 |         self._pass = _pass
 3146 | 369 |         await self.refresh()
 3147 | 370 | 
 3148 | 371 |     @menus.button("🗺️")
 3149 | 372 |     async def set_map(self, payload):
 3150 | 373 |         msg = await self.cembed(f"What is the name of map?")
 3151 | 374 | 
 3152 | 375 |         _map = await inputs.string_input(self.ctx, self.check, delete_after=True)
 3153 | 376 | 
 3154 | 377 |         await inputs.safe_delete(msg)
 3155 | 378 |         self.embed.set_field_at(2, name="Maps", value=_map)
 3156 | 379 |         await self.refresh()
 3157 | 380 | 
 3158 | 381 |     @menus.button("🕰️")
 3159 | 382 |     async def set_starttime(self, payload):
 3160 | 383 |         msg = await self.cembed(f"What is the match start time?")
 3161 | 384 | 
 3162 | 385 |         start_time = await inputs.string_input(self.ctx, self.check, delete_after=True)
 3163 | 386 | 
 3164 | 387 |         await inputs.safe_delete(msg)
 3165 | 388 |         self.embed.set_field_at(3, name="Match Starts at", value=start_time)
 3166 | 389 |         await self.refresh()
 3167 | 390 | 
 3168 | 391 |     @menus.button("🖼️")
 3169 | 392 |     async def set_thumbnail(self, payload):
 3170 | 393 |         msg = await self.cembed(f"Enter the Image URL you want to set as thumbnail.")
 3171 | 394 |         image = await inputs.string_input(self.ctx, self.check, delete_after=True)
 3172 | 395 | 
 3173 | 396 |         await inputs.safe_delete(msg)
 3174 | 397 | 
 3175 | 398 |         if image.lower() == "none":
 3176 | 399 |             self.embed.set_thumbnail(url=None)
 3177 | 400 |         else:
 3178 | 401 |             try:
 3179 | 402 |                 image_formats = ("image/png", "image/jpeg", "image/jpg", "image/gif")
 3180 | 403 |                 res = await self.bot.session.get(image)
 3181 | 404 |                 if res.headers["content-type"] in image_formats:
 3182 | 405 |                     check = True
 3183 | 406 | 
 3184 | 407 |                 else:
 3185 | 408 |                     check = False
 3186 | 409 | 
 3187 | 410 |             except aiohttp.client_exceptions.InvalidURL:
 3188 | 411 |                 return await self.ctx.error(f"This is not a valid Image URL", delete_after=3)
 3189 | 412 | 
 3190 | 413 |             if not check:
 3191 | 414 |                 return await self.ctx.error(f"The URL didn't contain a valid Image format.", delete_after=3)
 3192 | 415 | 
 3193 | 416 |             self.embed.set_thumbnail(url=image)
 3194 | 417 |             await self.refresh()
 3195 | 418 | 
 3196 | 419 |     @menus.button("❔")
 3197 | 420 |     async def idp_content(self, payload):
 3198 | 421 |         self.id_pass_content = not self.id_pass_content
 3199 | 422 |         await self.refresh()
 3200 | 423 | 
 3201 | 424 |     @menus.button("⏰")
 3202 | 425 |     async def delete_time(self, payload):
 3203 | 426 |         msg = await self.cembed(
 3204 | 427 |             f"After how many minutes do you want me to delete the idp message?\nIt can be between 1-30"
 3205 | 428 |         )
 3206 | 429 |         delete_time = await inputs.integer_input(self.ctx, self.check, delete_after=True, limits=(None, None))
 3207 | 430 |         await inputs.safe_delete(msg)
 3208 | 431 |         self.delete_in = delete_time
 3209 | 432 |         self.embed.set_footer(
 3210 | 433 |             text=f"Shared by: {self.ctx.author} • Auto delete in {plural(self.delete_in):minute|minutes}",
 3211 | 434 |             icon_url=self.ctx.author.display_avatar.url,
 3212 | 435 |         )
 3213 | 436 |         await self.refresh()
 3214 | 437 | 
 3215 | 438 |     @menus.button("❌")
 3216 | 439 |     async def on_cancel(self, payload):
 3217 | 440 |         self.stop()
 3218 | 441 | 
 3219 | 442 |     @menus.button("✅")
 3220 | 443 |     async def on_confirm(self, payload):
 3221 | 444 |         content = self.ping_role.mention if self.ping_role else ""
 3222 | 445 |         if self.id_pass_content:
 3223 | 446 |             content += f"\nID: {self._id} | Password: {self._pass}"
 3224 | 447 | 
 3225 | 448 |         msg = await self.send_channel.send(
 3226 | 449 |             content=content,
 3227 | 450 |             embed=self.embed,
 3228 | 451 |             allowed_mentions=discord.AllowedMentions(everyone=True, roles=True),
 3229 | 452 |         )
 3230 | 453 | 
 3231 | 454 |         self.bot.loop.create_task(delete_denied_message(msg, self.delete_in * 60))
 3232 | 455 |         self.stop()
 3233 | 456 | 
 3234 | 457 | 
 3235 | 458 | class AutocleanMenu(menus.Menu):
 3236 | 459 |     def __init__(self, *, scrim: Scrim):
 3237 | 460 |         super().__init__(
 3238 | 461 |             timeout=60,
 3239 | 462 |             delete_message_after=False,
 3240 | 463 |             clear_reactions_after=True,
 3241 | 464 |         )
 3242 | 465 |         self.scrim = scrim
 3243 | 466 |         self.days = scrim.open_days
 3244 | 467 |         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
 3245 | 468 | 
 3246 | 469 |     def initial_embed(self):
 3247 | 470 |         scrim = self.scrim
 3248 | 471 |         autoclean_time = (scrim.autoclean_time).strftime("%I:%M %p") if scrim.autoclean_time else "Not Set!"
 3249 | 472 | 
 3250 | 473 |         embed = discord.Embed(color=config.COLOR)
 3251 | 474 |         embed.title = "Edit Autoclean: {0}".format(scrim.id)
 3252 | 475 |         description = "\n".join(
 3253 | 476 |             f"{idx:02}. {(_type.value.title()).ljust(15)} {('❌', '✅')[_type in scrim.autoclean]}"
 3254 | 477 |             for idx, _type in enumerate(constants.AutocleanType, start=1)
 3255 | 478 |         )
 3256 | 479 |         embed.description = f"```{description}```"
 3257 | 480 |         embed.description += f"```03. Clean At: {autoclean_time}```"
 3258 | 481 |         return embed
 3259 | 482 | 
 3260 | 483 |     async def send_initial_message(self, ctx, channel):
 3261 | 484 |         return await channel.send(embed=self.initial_embed())
 3262 | 485 | 
 3263 | 486 |     async def refresh(self):
 3264 | 487 |         self.scrim = await Scrim.get(pk=self.scrim.id)
 3265 | 488 |         await self.message.edit(embed=self.initial_embed())
 3266 | 489 | 
 3267 | 490 |     @menus.button(keycap_digit(1))
 3268 | 491 |     async def on_one(self, payload):
 3269 | 492 |         func = (ArrayAppend, ArrayRemove)[constants.AutocleanType.channel in self.scrim.autoclean]
 3270 | 493 |         await Scrim.filter(pk=self.scrim.id).update(autoclean=func("autoclean", constants.AutocleanType.channel))
 3271 | 494 |         await self.refresh()
 3272 | 495 | 
 3273 | 496 |     @menus.button(keycap_digit(2))
 3274 | 497 |     async def on_two(self, payload):
 3275 | 498 |         func = (ArrayAppend, ArrayRemove)[constants.AutocleanType.role in self.scrim.autoclean]
 3276 | 499 |         await Scrim.filter(pk=self.scrim.id).update(autoclean=func("autoclean", constants.AutocleanType.role))
 3277 | 500 |         await self.refresh()
 3278 | 501 | 
 3279 | 502 |     @menus.button(keycap_digit(3))
 3280 | 503 |     async def on_three(self, payload):
 3281 | 504 |         msg = await self.ctx.send(
 3282 | 505 |             "**At what time should I run cleaner?**"
 3283 | 506 |             "**Example: 14:00** - Registration will open at 2PM.\n\n"
 3284 | 507 |             "**Currently Quotient works according to Indian Standard Time (UTC+05:30)**"
 3285 | 508 |         )
 3286 | 509 | 
 3287 | 510 |         clean_time = await inputs.time_input(self.ctx, self.check, delete_after=True)
 3288 | 511 |         await inputs.safe_delete(msg)
 3289 | 512 | 
 3290 | 513 |         await self.bot.get_cog("Reminders").create_timer(
 3291 | 514 |             clean_time,
 3292 | 515 |             "autoclean",
 3293 | 516 |             scrim_id=self.scrim.id,
 3294 | 517 |         )
 3295 | 518 |         await Scrim.filter(pk=self.scrim.id).update(autoclean_time=clean_time)
 3296 | 519 |         await self.refresh()
 3297 | 520 | 
 3298 | 521 |     @menus.button("\N{BLACK SQUARE FOR STOP}")
 3299 | 522 |     async def on_stop(self, payload):
 3300 | 523 |         self.stop()
 3301 | 524 | 
 3302 | 525 | 
 3303 | 526 | class DaysMenu(menus.Menu):
 3304 | 527 |     def __init__(self, *, scrim: Scrim):
 3305 | 528 |         super().__init__(
 3306 | 529 |             timeout=60,
 3307 | 530 |             delete_message_after=False,
 3308 | 531 |             clear_reactions_after=True,
 3309 | 532 |         )
 3310 | 533 |         self.scrim = scrim
 3311 | 534 |         self.days = scrim.open_days
 3312 | 535 |         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
 3313 | 536 | 
 3314 | 537 |         # Adding buttons dynamically
 3315 | 538 |         for idx, day in enumerate(constants.Day, start=1):
 3316 | 539 | 
 3317 | 540 |             def action(day):
 3318 | 541 |                 async def wraps(self, payload):
 3319 | 542 |                     await self.update_scrim(day)
 3320 | 543 | 
 3321 | 544 |                 return wraps
 3322 | 545 | 
 3323 | 546 |             self.add_button(Button(keycap_digit(idx), action(day)))
 3324 | 547 | 
 3325 | 548 |     def initial_embed(self):
 3326 | 549 |         scrim = self.scrim
 3327 | 550 |         embed = discord.Embed(color=discord.Color(config.COLOR))
 3328 | 551 |         embed.title = "Edit Open Days: {0}".format(scrim.id)
 3329 | 552 |         description = "\n".join(
 3330 | 553 |             f"{idx:02}. {(day.value.title()).ljust(10)}   {('❌', '✅')[day in scrim.open_days]}"
 3331 | 554 |             for idx, day in enumerate(constants.Day, start=1)
 3332 | 555 |         )
 3333 | 556 |         embed.description = f"```{description}```"
 3334 | 557 |         return embed
 3335 | 558 | 
 3336 | 559 |     async def refresh(self):
 3337 | 560 |         self.scrim = await Scrim.get(pk=self.scrim.id)
 3338 | 561 |         await self.message.edit(embed=self.initial_embed())
 3339 | 562 | 
 3340 | 563 |     async def update_scrim(self, day):
 3341 | 564 |         # Lets do some magic
 3342 | 565 |         func = (ArrayAppend, ArrayRemove)[day in self.scrim.open_days]
 3343 | 566 |         await Scrim.filter(pk=self.scrim.id).update(open_days=func("open_days", day))
 3344 | 567 |         await self.refresh()
 3345 | 568 | 
 3346 | 569 |     async def send_initial_message(self, ctx, channel):
 3347 | 570 |         return await channel.send(embed=self.initial_embed())
 3348 | 571 | 
 3349 | 572 |     @menus.button("\N{BLACK SQUARE FOR STOP}\ufe0f")
 3350 | 573 |     async def on_stop(self, payload):
 3351 | 574 |         self.stop()
 3352 | 575 | 
 3353 | 576 | 
 3354 | 577 | class ConfigEditMenu(menus.Menu):
 3355 | 578 |     def __init__(self, *, scrim: Scrim):
 3356 | 579 |         super().__init__(
 3357 | 580 |             timeout=100,
 3358 | 581 |             delete_message_after=False,
 3359 | 582 |             clear_reactions_after=True,
 3360 | 583 |         )
 3361 | 584 |         self.scrim = scrim
 3362 | 585 |         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
 3363 | 586 | 
 3364 | 587 |     def initial_embed(self):
 3365 | 588 |         scrim = self.scrim
 3366 | 589 |         slotlist_channel = getattr(scrim.slotlist_channel, "mention", "`Channel Deleted!`")
 3367 | 590 |         registration_channel = getattr(scrim.registration_channel, "mention", "`Channel Deleted!`")
 3368 | 591 |         scrim_role = getattr(scrim.role, "mention", "`Role Deleted!`")
 3369 | 592 |         open_time = (scrim.open_time).strftime("%I:%M %p")
 3370 | 593 | 
 3371 | 594 |         ping_role = scrim_work_role(scrim, constants.EsportsRole.ping)
 3372 | 595 |         open_role = getattr(scrim.open_role, "mention", "`Role Deleted!`") if scrim.open_role_id else "@everyone"
 3373 | 596 | 
 3374 | 597 |         embed = discord.Embed(color=discord.Color(config.COLOR))
 3375 | 598 |         embed.title = f"Edit Scrims Configuration: {scrim.id}"
 3376 | 599 | 
 3377 | 600 |         fields = {
 3378 | 601 |             "Name": f"`{scrim.name}`",
 3379 | 602 |             "Registration Channel": registration_channel,
 3380 | 603 |             "Slotlist Channel": slotlist_channel,
 3381 | 604 |             "Role": scrim_role,
 3382 | 605 |             "Mentions": f"`{scrim.required_mentions:,}`",
 3383 | 606 |             "Slots": f"`{scrim.total_slots:,}`",
 3384 | 607 |             "Open Time": f"`{open_time}`",
 3385 | 608 |             "Auto-clean": "`qsm autoclean {0}`".format(scrim.id),
 3386 | 609 |             "Ping Role": ping_role,
 3387 | 610 |             "Open Role": open_role,
 3388 | 611 |             "Multi Register": ("`No!`", "`Yes!`")[scrim.multiregister],
 3389 | 612 |             "Slotlist Start from": scrim.start_from,
 3390 | 613 |             "Autodelete Rejected Registrations": ("`No!`", "`Yes!`")[scrim.autodelete_rejects],
 3391 | 614 |             "Team Name compulsion": ("`No!`", "`Yes!`")[scrim.teamname_compulsion],
 3392 | 615 |             "Duplicate Team Names": ("`Allowed!`", "`Not Allowed`")[scrim.no_duplicate_name],
 3393 | 616 |         }
 3394 | 617 | 
 3395 | 618 |         for idx, (name, value) in enumerate(fields.items()):
 3396 | 619 |             embed.add_field(
 3397 | 620 |                 name=f"{regional_indicator(string.ascii_uppercase[idx])} {name}:",
 3398 | 621 |                 value=value,
 3399 | 622 |             )
 3400 | 623 | 
 3401 | 624 |         embed.set_thumbnail(url=self.bot.user.display_avatar.url)
 3402 | 625 |         return embed
 3403 | 626 | 
 3404 | 627 |     async def cembed(self, description):
 3405 | 628 |         return await self.ctx.send(
 3406 | 629 |             embed=discord.Embed(
 3407 | 630 |                 color=discord.Color(config.COLOR),
 3408 | 631 |                 title=f"🛠️ Scrims Manager",
 3409 | 632 |                 description=description,
 3410 | 633 |             )
 3411 | 634 |         )
 3412 | 635 | 
 3413 | 636 |     async def send_initial_message(self, ctx, channel):
 3414 | 637 |         return await channel.send(embed=self.initial_embed())
 3415 | 638 | 
 3416 | 639 |     async def refresh(self):
 3417 | 640 |         self.scrim = await Scrim.get(pk=self.scrim.id)
 3418 | 641 |         await self.message.edit(embed=self.initial_embed())
 3419 | 642 | 
 3420 | 643 |     async def update_scrim(self, **kwargs):
 3421 | 644 |         await Scrim.filter(pk=self.scrim.id).update(**kwargs)
 3422 | 645 |         await self.refresh()
 3423 | 646 | 
 3424 | 647 |     @menus.button(regional_indicator("A"))
 3425 | 648 |     async def change_scrim_name(self, payload):
 3426 | 649 |         msg = await self.cembed("What is the new name you want to give to these scrims?")
 3427 | 650 |         name = await inputs.string_input(
 3428 | 651 |             self.ctx,
 3429 | 652 |             self.check,
 3430 | 653 |             delete_after=True,
 3431 | 654 |         )
 3432 | 655 |         if len(name) > 30:
 3433 | 656 |             raise ScrimError("Scrims Name cannot exceed 30 characters.")
 3434 | 657 |         elif len(name) < 5:
 3435 | 658 |             raise ScrimError("The length of new name is too short.")
 3436 | 659 | 
 3437 | 660 |         await inputs.safe_delete(msg)
 3438 | 661 |         await self.update_scrim(name=name)
 3439 | 662 | 
 3440 | 663 |     @menus.button(regional_indicator("B"))
 3441 | 664 |     async def change_registration_channel(self, payload):
 3442 | 665 |         msg = await self.cembed("Which is the new channel for registrations?")
 3443 | 666 |         channel = await inputs.channel_input(
 3444 | 667 |             self.ctx,
 3445 | 668 |             self.check,
 3446 | 669 |             delete_after=True,
 3447 | 670 |         )
 3448 | 671 |         await inputs.safe_delete(msg)
 3449 | 672 |         await self.update_scrim(registration_channel_id=channel.id)
 3450 | 673 | 
 3451 | 674 |     @menus.button(regional_indicator("C"))
 3452 | 675 |     async def change_slotlist_channel(self, payload):
 3453 | 676 |         msg = await self.cembed("Which is the new channel for slotlists?")
 3454 | 677 |         channel = await inputs.channel_input(
 3455 | 678 |             self.ctx,
 3456 | 679 |             self.check,
 3457 | 680 |             delete_after=True,
 3458 | 681 |         )
 3459 | 682 |         await inputs.safe_delete(msg)
 3460 | 683 |         await self.update_scrim(slotlist_channel_id=channel.id)
 3461 | 684 | 
 3462 | 685 |     @menus.button(regional_indicator("D"))
 3463 | 686 |     async def change_scrim_role(self, payload):
 3464 | 687 |         msg = await self.cembed("Which is the new role for correct registration?")
 3465 | 688 |         role = await inputs.role_input(
 3466 | 689 |             self.ctx,
 3467 | 690 |             self.check,
 3468 | 691 |             delete_after=True,
 3469 | 692 |         )
 3470 | 693 |         await inputs.safe_delete(msg)
 3471 | 694 |         await self.update_scrim(role_id=role.id)
 3472 | 695 | 
 3473 | 696 |     @menus.button(regional_indicator("E"))
 3474 | 697 |     async def change_required_mentions(self, payload):
 3475 | 698 |         msg = await self.cembed("How many mentions are required for successful registration?")
 3476 | 699 |         mentions = await inputs.integer_input(
 3477 | 700 |             self.ctx,
 3478 | 701 |             self.check,
 3479 | 702 |             delete_after=True,
 3480 | 703 |             limits=(0, 10),
 3481 | 704 |         )
 3482 | 705 |         await inputs.safe_delete(msg)
 3483 | 706 |         await self.update_scrim(required_mentions=mentions)
 3484 | 707 | 
 3485 | 708 |     @menus.button(regional_indicator("F"))
 3486 | 709 |     async def change_total_slots(self, payload):
 3487 | 710 |         msg = await self.cembed("How many total slots are there?")
 3488 | 711 |         slots = await inputs.integer_input(
 3489 | 712 |             self.ctx,
 3490 | 713 |             self.check,
 3491 | 714 |             delete_after=True,
 3492 | 715 |             limits=(1, 30),
 3493 | 716 |         )
 3494 | 717 |         await inputs.safe_delete(msg)
 3495 | 718 |         await self.update_scrim(total_slots=slots)
 3496 | 719 | 
 3497 | 720 |     @menus.button(regional_indicator("G"))
 3498 | 721 |     async def change_open_time(self, payload):
 3499 | 722 |         msg = await self.cembed(
 3500 | 723 |             "**At what time should I open registrations?**"
 3501 | 724 |             "**Example: 14:00** - Registration will open at 2PM.\n\n"
 3502 | 725 |             "**Currently Quotient works according to Indian Standard Time (UTC+05:30)**"
 3503 | 726 |         )
 3504 | 727 | 
 3505 | 728 |         open_time = await inputs.time_input(self.ctx, self.check, delete_after=True)
 3506 | 729 |         await inputs.safe_delete(msg)
 3507 | 730 | 
 3508 | 731 |         await self.bot.get_cog("Reminders").create_timer(
 3509 | 732 |             open_time,
 3510 | 733 |             "scrim_open",
 3511 | 734 |             scrim_id=self.scrim.id,
 3512 | 735 |         )
 3513 | 736 | 
 3514 | 737 |         await self.update_scrim(open_time=open_time)
 3515 | 738 | 
 3516 | 739 |     @menus.button(regional_indicator("H"))
 3517 | 740 |     async def change_cleanup(self, payload):
 3518 | 741 |         pass
 3519 | 742 | 
 3520 | 743 |     @menus.button(regional_indicator("I"))
 3521 | 744 |     async def change_ping_role(self, payload):
 3522 | 745 |         msg = await self.cembed("Which role should I ping when I open registrations?")
 3523 | 746 | 
 3524 | 747 |         role = await inputs.role_input(
 3525 | 748 |             self.ctx,
 3526 | 749 |             self.check,
 3527 | 750 |             delete_after=True,
 3528 | 751 |         )
 3529 | 752 |         await inputs.safe_delete(msg)
 3530 | 753 |         await self.update_scrim(ping_role_id=role.id)
 3531 | 754 | 
 3532 | 755 |     @menus.button(regional_indicator("J"))
 3533 | 756 |     async def change_open_role(self, payload):
 3534 | 757 |         msg = await self.cembed("For which role should I open registrations?")
 3535 | 758 | 
 3536 | 759 |         role = await inputs.role_input(
 3537 | 760 |             self.ctx,
 3538 | 761 |             self.check,
 3539 | 762 |             delete_after=True,
 3540 | 763 |         )
 3541 | 764 | 
 3542 | 765 |         await inputs.safe_delete(msg)
 3543 | 766 |         await self.update_scrim(open_role_id=role.id)
 3544 | 767 | 
 3545 | 768 |     @menus.button(regional_indicator("K"))
 3546 | 769 |     async def change_multiregister(self, payload):
 3547 | 770 |         await self.ctx.success(
 3548 | 771 |             f"Multiple registrations from a single user are now **{'Allowed' if not self.scrim.multiregister else 'Not Allowed'}!**",
 3549 | 772 |             delete_after=3,
 3550 | 773 |         )
 3551 | 774 |         await self.update_scrim(multiregister=not self.scrim.multiregister)
 3552 | 775 | 
 3553 | 776 |     @menus.button(regional_indicator("L"))
 3554 | 777 |     async def change_start_from(self, payload):
 3555 | 778 |         m = await self.ctx.send(
 3556 | 779 |             "From which slot do you want me to start slotlist?\n\nThis can be any number between 1 and 20."
 3557 | 780 |         )
 3558 | 781 |         start_from = await inputs.integer_input(
 3559 | 782 |             self.ctx,
 3560 | 783 |             self.check,
 3561 | 784 |             delete_after=True,
 3562 | 785 |             limits=(1, self.scrim.total_slots),
 3563 | 786 |         )
 3564 | 787 | 
 3565 | 788 |         await inputs.safe_delete(m)
 3566 | 789 |         await self.update_scrim(start_from=start_from)
 3567 | 790 | 
 3568 | 791 |     @menus.button(regional_indicator("M"))
 3569 | 792 |     async def auto_delete_rejects(self, payload):
 3570 | 793 |         await self.ctx.success(
 3571 | 794 |             f"Rejected registrations will **{'NOW' if not self.scrim.autodelete_rejects else 'NOT'}** be deleted.",
 3572 | 795 |             delete_after=2,
 3573 | 796 |         )
 3574 | 797 |         await self.update_scrim(autodelete_rejects=not self.scrim.autodelete_rejects)
 3575 | 798 | 
 3576 | 799 |     @menus.button(regional_indicator("N"))
 3577 | 800 |     async def teamname_compulsory(self, payload):
 3578 | 801 |         await self.ctx.success(
 3579 | 802 |             f"Team name in registrations is now **{'Necessary' if not self.scrim.teamname_compulsion else 'Not Necessary'}!**",
 3580 | 803 |             delete_after=2,
 3581 | 804 |         )
 3582 | 805 |         await self.update_scrim(teamname_compulsion=not self.scrim.teamname_compulsion)
 3583 | 806 | 
 3584 | 807 |     @menus.button(regional_indicator("O"))
 3585 | 808 |     async def _no_team_name(self, payload):
 3586 | 809 |         await self.ctx.success(
 3587 | 810 |             f"Duplicate team names are not **{'Allowed' if self.scrim.no_duplicate_name else 'Not Allowed'}!**",
 3588 | 811 |             delete_after=2,
 3589 | 812 |         )
 3590 | 813 |         await self.update_scrim(no_duplicate_name=not self.scrim.no_duplicate_name)
 3591 | 814 | 
 3592 | 815 |     @menus.button("\N{BLACK SQUARE FOR STOP}\ufe0f")
 3593 | 816 |     async def on_stop(self, payload):
 3594 | 817 |         self.stop()
 3595 | 818 | 
 3596 | 
 3597 | 
 3598 | --------------------------------------------------------------------------------
 3599 | /cogs/esports/slash/__init__.py:
 3600 | --------------------------------------------------------------------------------
 3601 |  1 | from __future__ import annotations
 3602 |  2 | 
 3603 |  3 | import typing as T
 3604 |  4 | 
 3605 |  5 | if T.TYPE_CHECKING:
 3606 |  6 |     from core import Quotient
 3607 |  7 | 
 3608 |  8 | from core import Cog
 3609 |  9 | 
 3610 | 10 | from .scrims import *
 3611 | 11 | 
 3612 | 12 | __all__ = ("SlashCog",)
 3613 | 13 | 
 3614 | 14 | 
 3615 | 15 | class SlashCog(Cog):
 3616 | 16 |     def __init__(self, bot: Quotient):
 3617 | 17 |         self.bot = bot
 3618 | 18 | 
 3619 | 19 |     async def cog_load(self) -> None:
 3620 | 20 |         await self.bot.add_cog(ScrimsSlash(self.bot))
 3621 | 21 | 
 3622 | 
 3623 | 
 3624 | --------------------------------------------------------------------------------
 3625 | /cogs/esports/slash/scrims.py:
 3626 | --------------------------------------------------------------------------------
 3627 |   1 | from __future__ import annotations
 3628 |   2 | 
 3629 |   3 | import typing as T
 3630 |   4 | 
 3631 |   5 | if T.TYPE_CHECKING:
 3632 |   6 |     from core import Quotient
 3633 |   7 | 
 3634 |   8 | from datetime import datetime, timedelta
 3635 |   9 | from random import randint
 3636 |  10 | 
 3637 |  11 | import dateparser
 3638 |  12 | import discord
 3639 |  13 | from discord import app_commands
 3640 |  14 | from discord.ext import commands
 3641 |  15 | 
 3642 |  16 | from core import Context
 3643 |  17 | from models import BanLog, Guild, ReservedSlot, Scrim
 3644 |  18 | from utils import Prompt, discord_timestamp, emote, plural, split_list
 3645 |  19 | 
 3646 |  20 | __all__ = ("ScrimsSlash",)
 3647 |  21 | 
 3648 |  22 | 
 3649 |  23 | class ScrimsSelector(discord.ui.Select):
 3650 |  24 |     def __init__(self, placeholder: str, scrims: list[Scrim], multi: bool):
 3651 |  25 |         _options = []
 3652 |  26 |         for scrim in scrims:
 3653 |  27 |             _options.append(
 3654 |  28 |                 discord.SelectOption(
 3655 |  29 |                     label=getattr(scrim.registration_channel, "name", "deleted-channel"),  # type: ignore
 3656 |  30 |                     value=scrim.id,
 3657 |  31 |                     description=f"{scrim.name} (ScrimID: {scrim.id})",
 3658 |  32 |                     emoji=emote.TextChannel,
 3659 |  33 |                 )
 3660 |  34 |             )
 3661 |  35 | 
 3662 |  36 |         super().__init__(placeholder=placeholder, options=_options, max_values=len(_options) if multi else 1)
 3663 |  37 | 
 3664 |  38 |     async def callback(self, interaction: discord.Interaction):
 3665 |  39 |         await interaction.response.defer()
 3666 |  40 | 
 3667 |  41 |         for option in self.options:
 3668 |  42 |             self.view.selected_scrims.discard(option.value)
 3669 |  43 | 
 3670 |  44 |         for val in self.values:
 3671 |  45 |             self.view.selected_scrims.add(val)
 3672 |  46 | 
 3673 |  47 | 
 3674 |  48 | class ScrimsSelector(discord.ui.Select):
 3675 |  49 |     def __init__(self, placeholder: str, scrims: list[Scrim], multi: bool):
 3676 |  50 |         _options = []
 3677 |  51 |         for scrim in scrims:
 3678 |  52 |             _options.append(
 3679 |  53 |                 discord.SelectOption(
 3680 |  54 |                     label=getattr(scrim.registration_channel, "name", "deleted-channel"),  # type: ignore
 3681 |  55 |                     value=scrim.id,
 3682 |  56 |                     description=f"{scrim.name} (ScrimID: {scrim.id})",
 3683 |  57 |                     emoji=emote.TextChannel,
 3684 |  58 |                 )
 3685 |  59 |             )
 3686 |  60 | 
 3687 |  61 |         super().__init__(placeholder=placeholder, options=_options, max_values=len(_options) if multi else 1)
 3688 |  62 | 
 3689 |  63 |     async def callback(self, interaction: discord.Interaction):
 3690 |  64 |         await interaction.response.defer()
 3691 |  65 | 
 3692 |  66 |         for option in self.options:
 3693 |  67 |             self.view.selected_scrims.discard(option.value)
 3694 |  68 | 
 3695 |  69 |         for val in self.values:
 3696 |  70 |             self.view.selected_scrims.add(val)
 3697 |  71 | 
 3698 |  72 | 
 3699 |  73 | class ConfirmButton(discord.ui.Button):
 3700 |  74 |     def __init__(self):
 3701 |  75 |         super().__init__(style=discord.ButtonStyle.green, label="Confirm")
 3702 |  76 | 
 3703 |  77 |     async def callback(self, interaction: discord.Interaction):
 3704 |  78 |         await interaction.response.defer()
 3705 |  79 |         self.view.proceed = True
 3706 |  80 | 
 3707 |  81 |         for child in self.view.children:
 3708 |  82 |             child.disabled = True
 3709 |  83 | 
 3710 |  84 |         await interaction.edit_original_response(view=self.view)
 3711 |  85 |         self.view.stop()
 3712 |  86 | 
 3713 |  87 | 
 3714 |  88 | class CancelButton(discord.ui.Button):
 3715 |  89 |     def __init__(self):
 3716 |  90 |         super().__init__(style=discord.ButtonStyle.red, label="Cancel")
 3717 |  91 | 
 3718 |  92 |     async def callback(self, interaction: discord.Interaction):
 3719 |  93 |         await interaction.response.defer()
 3720 |  94 | 
 3721 |  95 |         for child in self.view.children:
 3722 |  96 |             child.disabled = True
 3723 |  97 | 
 3724 |  98 |         await interaction.edit_original_response(view=self.view)
 3725 |  99 | 
 3726 | 100 |         self.view.stop()
 3727 | 101 | 
 3728 | 102 | 
 3729 | 103 | class ConfirmButton(discord.ui.Button):
 3730 | 104 |     def __init__(self):
 3731 | 105 |         super().__init__(style=discord.ButtonStyle.green, label="Confirm")
 3732 | 106 | 
 3733 | 107 |     async def callback(self, interaction: discord.Interaction):
 3734 | 108 |         await interaction.response.defer()
 3735 | 109 |         self.view.proceed = True
 3736 | 110 | 
 3737 | 111 |         for child in self.view.children:
 3738 | 112 |             child.disabled = True
 3739 | 113 | 
 3740 | 114 |         await interaction.edit_original_response(view=self.view)
 3741 | 115 |         self.view.stop()
 3742 | 116 | 
 3743 | 117 | 
 3744 | 118 | class CancelButton(discord.ui.Button):
 3745 | 119 |     def __init__(self):
 3746 | 120 |         super().__init__(style=discord.ButtonStyle.red, label="Cancel")
 3747 | 121 | 
 3748 | 122 |     async def callback(self, interaction: discord.Interaction):
 3749 | 123 |         await interaction.response.defer()
 3750 | 124 | 
 3751 | 125 |         for child in self.view.children:
 3752 | 126 |             child.disabled = True
 3753 | 127 | 
 3754 | 128 |         await interaction.edit_original_response(view=self.view)
 3755 | 129 | 
 3756 | 130 |         self.view.stop()
 3757 | 131 | 
 3758 | 132 | 
 3759 | 133 | class ScrimsSlash(commands.GroupCog, name="scrims"):
 3760 | 134 |     def __init__(self, bot: Quotient):
 3761 | 135 |         self.bot = bot
 3762 | 136 | 
 3763 | 137 |         super().__init__()
 3764 | 138 | 
 3765 | 139 |     async def can_use_command(self, interaction: discord.Interaction) -> bool:
 3766 | 140 |         if not any(
 3767 | 141 |             (interaction.user.guild_permissions.manage_guild, Scrim.is_ignorable(interaction.user))  # type: ignore # line guarded #25
 3768 | 142 |         ):
 3769 | 143 |             await interaction.response.send_message(
 3770 | 144 |                 embed=discord.Embed(
 3771 | 145 |                     color=discord.Color.red(),
 3772 | 146 |                     description=f"You need `scrims-mod` role or `Manage-Server` permissions to use this command.",
 3773 | 147 |                 )
 3774 | 148 |             )
 3775 | 149 |             return False
 3776 | 150 | 
 3777 | 151 |         return True
 3778 | 152 | 
 3779 | 153 |     def channel_perms(self, channel: discord.TextChannel) -> bool:
 3780 | 154 |         perms = channel.permissions_for(channel.guild.me)
 3781 | 155 |         return all((perms.manage_channels, perms.manage_permissions))
 3782 | 156 | 
 3783 | 157 |     def role_perms(self, role: discord.Role) -> bool:
 3784 | 158 |         perms = role.permissions
 3785 | 159 |         return any(
 3786 | 160 |             (
 3787 | 161 |                 perms.manage_guild,
 3788 | 162 |                 perms.administrator,
 3789 | 163 |                 perms.manage_channels,
 3790 | 164 |                 perms.manage_roles,
 3791 | 165 |                 perms.kick_members,
 3792 | 166 |                 perms.ban_members,
 3793 | 167 |             )
 3794 | 168 |         )
 3795 | 169 | 
 3796 | 170 |     async def show_scrims_selector(
 3797 | 171 |         self,
 3798 | 172 |         interaction: discord.Interaction,
 3799 | 173 |         scrims: list[Scrim],
 3800 | 174 |         multi: bool = False,
 3801 | 175 |         ephemeral: bool = True,
 3802 | 176 |         placeholder: str = "Select scrim(s) to proceed.",
 3803 | 177 |     ):
 3804 | 178 |         if len(scrims) == 1:
 3805 | 179 |             return scrims
 3806 | 180 | 
 3807 | 181 |         view = discord.ui.View(timeout=100)
 3808 | 182 |         view.selected_scrims = set()
 3809 | 183 |         view.proceed: bool = False
 3810 | 184 | 
 3811 | 185 |         if len(scrims) <= 25:
 3812 | 186 |             view.add_item(ScrimsSelector(placeholder, scrims, multi=multi))
 3813 | 187 | 
 3814 | 188 |         else:
 3815 | 189 |             for scrims_chunk in split_list(scrims, 25):
 3816 | 190 |                 view.add_item(ScrimsSelector(placeholder, scrims_chunk, multi=multi))
 3817 | 191 | 
 3818 | 192 |         view.add_item(ConfirmButton())
 3819 | 193 |         view.add_item(CancelButton())
 3820 | 194 | 
 3821 | 195 |         await interaction.followup.send("Select scrim(s) & press `Confirm`!", view=view, ephemeral=ephemeral)
 3822 | 196 |         await view.wait()
 3823 | 197 | 
 3824 | 198 |         if not view.proceed:
 3825 | 199 |             return
 3826 | 200 | 
 3827 | 201 |         return await Scrim.filter(id__in=view.selected_scrims).order_by("id")
 3828 | 202 | 
 3829 | 203 |     async def reserve_slot(self, scrim: Scrim, num: int, team_name: str, user_id: int = None, expires: datetime = None):
 3830 | 204 |         to_del = await scrim.reserved_slots.filter(num=num).first()
 3831 | 205 |         if to_del:
 3832 | 206 |             await ReservedSlot.filter(pk=to_del.id).delete()
 3833 | 207 | 
 3834 | 208 |         slot = await ReservedSlot.create(num=num, user_id=user_id, team_name=team_name, expires=expires)
 3835 | 209 |         await scrim.reserved_slots.add(slot)
 3836 | 210 |         if expires and user_id:
 3837 | 211 |             await scrim.bot.reminders.create_timer(
 3838 | 212 |                 expires, "scrim_reserve", scrim_id=scrim.id, user_id=user_id, team_name=team_name, num=num
 3839 | 213 |             )
 3840 | 214 | 
 3841 | 215 |     async def parse_datetime(self, interaction: discord.Interaction, time: str) -> datetime:
 3842 | 216 |         try:
 3843 | 217 |             parsed = dateparser.parse(
 3844 | 218 |                 time,
 3845 | 219 |                 settings={
 3846 | 220 |                     #  "RELATIVE_BASE": datetime.now(tz=IST),
 3847 | 221 |                     "TIMEZONE": "Asia/Kolkata",
 3848 | 222 |                     "RETURN_AS_TIMEZONE_AWARE": True,
 3849 | 223 |                 },
 3850 | 224 |             )
 3851 | 225 | 
 3852 | 226 |             while self.bot.current_time > parsed:
 3853 | 227 |                 parsed = parsed + timedelta(hours=24)
 3854 | 228 | 
 3855 | 229 |             return parsed
 3856 | 230 | 
 3857 | 231 |         except TypeError:
 3858 | 232 |             await interaction.followup.send(
 3859 | 233 |                 embed=discord.Embed(
 3860 | 234 |                     color=discord.Color.red(), description=f"Invalid time format. Please try again."
 3861 | 235 |                 ).set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/958291942062587934/timex.gif")
 3862 | 236 |             )
 3863 | 237 | 
 3864 | 238 |     @app_commands.command()
 3865 | 239 |     @app_commands.describe(
 3866 | 240 |         registration_channel="The channel where users will register for scrims.",
 3867 | 241 |         slotlist_channel="The channel where slotlist will be posted.",
 3868 | 242 |         success_role="The role that will be given to users who successfully register for scrims.",
 3869 | 243 |         required_mentions="The number of mentions required to register for scrims.",
 3870 | 244 |         total_slots="The total number of slots available for scrims.",
 3871 | 245 |         open_time="The time when registration will be opened.",
 3872 | 246 |     )
 3873 | 247 |     async def create(
 3874 | 248 |         self,
 3875 | 249 |         interaction: discord.Interaction,
 3876 | 250 |         registration_channel: discord.TextChannel,
 3877 | 251 |         slotlist_channel: discord.TextChannel,
 3878 | 252 |         success_role: discord.Role,
 3879 | 253 |         required_mentions: app_commands.Range[int, None, 5],
 3880 | 254 |         total_slots: app_commands.Range[int, 1, 30],
 3881 | 255 |         open_time: str,
 3882 | 256 |     ):
 3883 | 257 |         """Create a scrim."""
 3884 | 258 |         if not await self.can_use_command(interaction):
 3885 | 259 |             return
 3886 | 260 | 
 3887 | 261 |         await interaction.response.defer(thinking=True, ephemeral=False)
 3888 | 262 | 
 3889 | 263 |         if not await Guild.filter(pk=interaction.guild_id, is_premium=True).exists():
 3890 | 264 |             if await Scrim.filter(guild_id=interaction.guild_id).count() >= 3:
 3891 | 265 |                 return await interaction.followup.send(
 3892 | 266 |                     embed=discord.Embed(
 3893 | 267 |                         color=discord.Color.red(),
 3894 | 268 |                         description=(
 3895 | 269 |                             "You can only create 3 scrims in a server without premium.\n\n"
 3896 | 270 |                             "### Use `qpro` command to activate Quotient Pro."
 3897 | 271 |                         ),
 3898 | 272 |                     )
 3899 | 273 |                 )
 3900 | 274 | 
 3901 | 275 |         if not self.channel_perms(registration_channel):
 3902 | 276 |             return await interaction.followup.send(
 3903 | 277 |                 f"{emote.xmark} | I don't have permissions to manage {registration_channel.mention}.",
 3904 | 278 |                 ephemeral=True,
 3905 | 279 |             )
 3906 | 280 | 
 3907 | 281 |         if not self.channel_perms(slotlist_channel):
 3908 | 282 |             return await interaction.followup.send(
 3909 | 283 |                 f"{emote.xmark} | I don't have permissions to manage {slotlist_channel.mention}.",
 3910 | 284 |                 ephemeral=True,
 3911 | 285 |             )
 3912 | 286 | 
 3913 | 287 |         if await Scrim.filter(registration_channel_id=registration_channel.id).exists():
 3914 | 288 |             return await interaction.followup.send(
 3915 | 289 |                 f"{emote.xmark} | A scrim already exists in {registration_channel.mention}.",
 3916 | 290 |                 ephemeral=True,
 3917 | 291 |             )
 3918 | 292 | 
 3919 | 293 |         if not interaction.guild.me.guild_permissions.manage_roles:
 3920 | 294 |             return await interaction.followup.send(
 3921 | 295 |                 f"{emote.xmark} | I don't have permissions to manage roles.",
 3922 | 296 |                 ephemeral=True,
 3923 | 297 |             )
 3924 | 298 | 
 3925 | 299 |         if success_role.managed:
 3926 | 300 |             return await interaction.followup.send(
 3927 | 301 |                 f"{emote.xmark} | I can't give a managed role to users.",
 3928 | 302 |                 ephemeral=True,
 3929 | 303 |             )
 3930 | 304 | 
 3931 | 305 |         if success_role >= interaction.guild.me.top_role:
 3932 | 306 |             return await interaction.followup.send(
 3933 | 307 |                 f"{emote.xmark} | I can't set a success role ({success_role.mention}) higher than my top role ({interaction.guild.me.top_role.mention}).",
 3934 | 308 |                 ephemeral=True,
 3935 | 309 |             )
 3936 | 310 | 
 3937 | 311 |         if success_role >= interaction.user.top_role:
 3938 | 312 |             return await interaction.followup.send(
 3939 | 313 |                 f"{emote.xmark} | You can't set a success role ({success_role.mention}) higher than your top role ({interaction.user.top_role.mention}).",
 3940 | 314 |                 ephemeral=True,
 3941 | 315 |             )
 3942 | 316 | 
 3943 | 317 |         if self.role_perms(success_role):
 3944 | 318 |             return await interaction.followup.send(
 3945 | 319 |                 f"{emote.xmark} | {success_role.mention} has dangerous permissions.",
 3946 | 320 |                 ephemeral=True,
 3947 | 321 |             )
 3948 | 322 | 
 3949 | 323 |         parsed = await self.parse_datetime(interaction, open_time)
 3950 | 324 |         if not parsed:
 3951 | 325 |             return
 3952 | 326 | 
 3953 | 327 |         autoclean_time = self.bot.current_time.replace(
 3954 | 328 |             hour=randint(3, 6), minute=randint(1, 60), second=0, microsecond=0
 3955 | 329 |         ) + timedelta(days=1)
 3956 | 330 | 
 3957 | 331 |         scrim = Scrim(
 3958 | 332 |             registration_channel_id=registration_channel.id,
 3959 | 333 |             slotlist_channel_id=slotlist_channel.id,
 3960 | 334 |             role_id=success_role.id,
 3961 | 335 |             required_mentions=required_mentions,
 3962 | 336 |             total_slots=total_slots,
 3963 | 337 |             open_time=parsed,
 3964 | 338 |             host_id=interaction.user.id,
 3965 | 339 |             autoclean_time=autoclean_time,
 3966 | 340 |             guild_id=interaction.guild.id,
 3967 | 341 |         )
 3968 | 342 |         try:
 3969 | 343 |             await scrim.setup_logs()
 3970 | 344 |         except Exception as e:
 3971 | 345 |             return await interaction.followup.send(
 3972 | 346 |                 f"### {emote.xmark} An error occured! \n{e}",
 3973 | 347 |                 ephemeral=True,
 3974 | 348 |             )
 3975 | 349 |         await scrim.save()
 3976 | 350 |         await self.bot.reminders.create_timer(scrim.open_time, "scrim_open", scrim_id=scrim.id)
 3977 | 351 |         await self.bot.reminders.create_timer(scrim.autoclean_time, "autoclean", scrim_id=scrim.id)
 3978 | 352 | 
 3979 | 353 |         e = discord.Embed(
 3980 | 354 |             color=discord.Color.green(),
 3981 | 355 |             url=self.bot.config.SERVER_LINK,
 3982 | 356 |             title="Scrim created successfully!",
 3983 | 357 |             description=(
 3984 | 358 |                 f"**Registration Channel:** {registration_channel.mention}\n"
 3985 | 359 |                 f"**Slotlist Channel:** {slotlist_channel.mention}\n"
 3986 | 360 |                 f"**Success Role:** {success_role.mention}\n"
 3987 | 361 |                 f"**Required Mentions:** `{required_mentions}`\n"
 3988 | 362 |                 f"**Total Slots:** `{total_slots}`\n"
 3989 | 363 |                 f"**Open Time:** {discord_timestamp(parsed,'f')}\n"
 3990 | 364 |                 f"**Autoclean Time:** {discord_timestamp(autoclean_time,'f')}\n"
 3991 | 365 |                 f"**Host:** {interaction.user.mention}\n"
 3992 | 366 |             ),
 3993 | 367 |         )
 3994 | 368 |         e.set_footer(text="Get more info, using `s` command.")
 3995 | 369 | 
 3996 | 370 |         await interaction.followup.send(embed=e)
 3997 | 371 | 
 3998 | 372 |     @app_commands.command()
 3999 | 373 |     @app_commands.describe(
 4000 | 374 |         registration_channel="The channel where the scrim is hosted.",
 4001 | 375 |         slot="The slot you want to reserve. (1 to 30)",
 4002 | 376 |         team_name="The name of team.",
 4003 | 377 |         user="(Optional) The user you want to reserve the slot for.",
 4004 | 378 |         expire_time="(Optional) The time when the reservation will expire.",
 4005 | 379 |     )
 4006 | 380 |     async def reserve(
 4007 | 381 |         self,
 4008 | 382 |         interaction: discord.Interaction,
 4009 | 383 |         registration_channel: discord.TextChannel,
 4010 | 384 |         slot: app_commands.Range[int, 1, 30],
 4011 | 385 |         team_name: str,
 4012 | 386 |         user: discord.User = None,
 4013 | 387 |         expire_time: str = None,
 4014 | 388 |     ):
 4015 | 389 |         """Reserve slot in any scrim."""
 4016 | 390 |         await interaction.response.defer(thinking=True, ephemeral=True)
 4017 | 391 | 
 4018 | 392 |         scrim = await Scrim.get_or_none(registration_channel_id=registration_channel.id)
 4019 | 393 |         if not scrim:
 4020 | 394 |             return await interaction.followup.send(
 4021 | 395 |                 embed=discord.Embed(
 4022 | 396 |                     color=discord.Color.red(), description=f"No Scrim found in {registration_channel.mention}."
 4023 | 397 |                 )
 4024 | 398 |             )
 4025 | 399 | 
 4026 | 400 |         expiry = None
 4027 | 401 |         if expire_time:
 4028 | 402 |             expiry = await self.parse_datetime(interaction, expire_time)
 4029 | 403 |             if not expiry:
 4030 | 404 |                 return
 4031 | 405 | 
 4032 | 406 |         await self.reserve_slot(
 4033 | 407 |             scrim=scrim,
 4034 | 408 |             num=slot,
 4035 | 409 |             team_name=team_name,
 4036 | 410 |             user_id=getattr(user, "id", None),
 4037 | 411 |             expires=expiry,
 4038 | 412 |         )
 4039 | 413 |         await interaction.followup.send(
 4040 | 414 |             embed=discord.Embed(
 4041 | 415 |                 color=discord.Color.green(),
 4042 | 416 |                 description=(
 4043 | 417 |                     f"`Slot {slot}` has been reserved for `{team_name}` in {scrim}. "
 4044 | 418 |                     f"[Time: {'`Lifetime`' if not expiry else discord_timestamp(expiry)}] "
 4045 | 419 |                 ),
 4046 | 420 |             )
 4047 | 421 |         )
 4048 | 422 | 
 4049 | 423 |         other_scrims = await Scrim.filter(
 4050 | 424 |             registration_channel_id__not=registration_channel.id, guild_id=interaction.guild_id
 4051 | 425 |         )
 4052 | 426 | 
 4053 | 427 |         if not other_scrims:
 4054 | 428 |             return
 4055 | 429 | 
 4056 | 430 |         prompt = Prompt(interaction.user.id)
 4057 | 431 |         m = await interaction.followup.send("`Do you want to reserve this slot in other scrims as well?`", view=prompt)
 4058 | 432 |         await prompt.wait()
 4059 | 433 | 
 4060 | 434 |         await m.delete(delay=0)
 4061 | 435 |         if not prompt.value:
 4062 | 436 |             return
 4063 | 437 | 
 4064 | 438 |         scrims = await self.show_scrims_selector(
 4065 | 439 |             interaction, other_scrims, multi=True, placeholder="Select the scrim you want to reserve slot in."
 4066 | 440 |         )
 4067 | 441 |         if not scrims:
 4068 | 442 |             return
 4069 | 443 | 
 4070 | 444 |         for scrim in scrims:
 4071 | 445 |             await self.reserve_slot(
 4072 | 446 |                 scrim=scrim,
 4073 | 447 |                 num=slot,
 4074 | 448 |                 team_name=team_name,
 4075 | 449 |                 user_id=getattr(user, "id", None),
 4076 | 450 |                 expires=expiry,
 4077 | 451 |             )
 4078 | 452 |         await interaction.followup.send(
 4079 | 453 |             embed=discord.Embed(
 4080 | 454 |                 color=discord.Color.green(), description=f"`Slot {slot}` reserved successfully for all selected scrims."
 4081 | 455 |             )
 4082 | 456 |         )
 4083 | 457 | 
 4084 | 458 |     @app_commands.command()
 4085 | 459 |     @app_commands.describe(user="The user you want to unban from scrims.", reason="The reason for unbanning the user.")
 4086 | 460 |     async def unban(self, interaction: discord.Interaction, user: discord.User, reason: str = None):
 4087 | 461 |         """Unban any user from scrims."""
 4088 | 462 |         if not await self.can_use_command(interaction):
 4089 | 463 |             return
 4090 | 464 |         reason = reason or "No reason given."
 4091 | 465 | 
 4092 | 466 |         # fetching scrims where given user is banned
 4093 | 467 |         query = """
 4094 | 468 |             (SELECT *
 4095 | 469 | 		        FROM
 4096 | 470 | 			    (SELECT SCRIMS.ID AS SCRIM_ID,
 4097 | 471 | 					*
 4098 | 472 | 				FROM PUBLIC."sm.scrims" AS SCRIMS
 4099 | 473 | 				FULL OUTER JOIN
 4100 | 474 | 					(SELECT ID AS BANNED_SLOT_ID,
 4101 | 475 | 							*
 4102 | 476 | 						FROM PUBLIC."sm.scrims_sm.banned_teams" AS BANNED_SLOT
 4103 | 477 | 						INNER JOIN PUBLIC."sm.banned_teams" AS SLOTS ON SLOTS.ID = BANNED_SLOT.BANNEDTEAM_ID) AS BANNED_SLOT ON SCRIMS.ID = BANNED_SLOT."sm.scrims_id"
 4104 | 478 | 				WHERE (SCRIMS.GUILD_ID = $1 
 4105 | 479 | 										AND BANNED_SLOT."sm.scrims_id" IS NOT NULL)) AS SM
 4106 | 480 | 		    WHERE USER_ID = $2)        
 4107 | 481 |             """
 4108 | 482 | 
 4109 | 483 |         records: T.List[T.Any] = await self.bot.db.fetch(query, interaction.guild_id, user.id)
 4110 | 484 |         if not records:
 4111 | 485 |             return await interaction.response.send_message(f"{user.mention} is not banned from any scrim in this server.")
 4112 | 486 | 
 4113 | 487 |         await interaction.response.defer(thinking=True, ephemeral=True)
 4114 | 488 | 
 4115 | 489 |         scrims: T.List[Scrim] = []
 4116 | 490 |         for record in records:
 4117 | 491 |             scrim_id = record["scrim_id"]
 4118 | 492 |             record = dict(record)
 4119 | 493 |             record.pop("id")
 4120 | 494 | 
 4121 | 495 |             scrims.append(Scrim(id=scrim_id, **record))
 4122 | 496 | 
 4123 | 497 |         scrims = await Scrim.show_selector(await Context.from_interaction(interaction), scrims)
 4124 | 498 |         if not scrims:
 4125 | 499 |             return
 4126 | 500 | 
 4127 | 501 |         scrims = [scrims] if isinstance(scrims, Scrim) else scrims
 4128 | 502 | 
 4129 | 503 |         for scrim in scrims:
 4130 | 504 |             scrim = await Scrim.get_or_none(pk=scrim.id)
 4131 | 505 |             if scrim:
 4132 | 506 |                 r = await scrim.banned_teams.filter(user_id=user.id).first()
 4133 | 507 |                 if r:
 4134 | 508 |                     await r.delete()
 4135 | 509 | 
 4136 | 510 |         await interaction.followup.send(
 4137 | 511 |             f"{emote.check} | {user.mention} has been unbanned from `{plural(scrims):scrim|scrims}`.",
 4138 | 512 |             ephemeral=True,
 4139 | 513 |         )
 4140 | 514 | 
 4141 | 515 |         banlog = await BanLog.get_or_none(guild_id=interaction.guild_id)
 4142 | 516 |         if banlog:
 4143 | 517 |             await banlog.log_unban(user.id, interaction.user, scrims, f"```{reason}```")
 4144 | 518 | 
 4145 | 519 |     @app_commands.command()
 4146 | 520 |     @app_commands.describe(user="The user whose slots you want to see.")
 4147 | 521 |     async def slotinfo(self, interaction: discord.Interaction, user: discord.Member):
 4148 | 522 |         """Get info about all the slots a user has."""
 4149 | 523 | 
 4150 | 524 |         if not await self.can_use_command(interaction):
 4151 | 525 |             return
 4152 | 526 | 
 4153 | 527 |         await interaction.response.defer(thinking=True)
 4154 | 528 | 
 4155 | 529 |         # I hope one day these ORMs will be able to do this
 4156 | 530 |         query = """
 4157 | 531 |         
 4158 | 532 |         	(SELECT *
 4159 | 533 | 		FROM
 4160 | 534 | 			(SELECT SCRIMS.ID AS SCRIM_ID,
 4161 | 535 | 					*
 4162 | 536 | 				FROM PUBLIC."sm.scrims" AS SCRIMS
 4163 | 537 | 				FULL OUTER JOIN
 4164 | 538 | 					(SELECT ID AS ASSIGNED_SLOT_ID,
 4165 | 539 | 							*
 4166 | 540 | 						FROM PUBLIC."sm.scrims_sm.assigned_slots" AS ASSIGNED_SLOT
 4167 | 541 | 						INNER JOIN PUBLIC."sm.assigned_slots" AS SLOTS ON SLOTS.ID = ASSIGNED_SLOT.ASSIGNEDSLOT_ID) AS ASSIGNED_SLOT ON SCRIMS.ID = ASSIGNED_SLOT."sm.scrims_id"
 4168 | 542 | 				WHERE (SCRIMS.GUILD_ID = $1
 4169 | 543 | 											AND ASSIGNED_SLOT."sm.scrims_id" IS NOT NULL)) AS SM
 4170 | 544 | 		WHERE USER_ID = $2)
 4171 | 545 | 
 4172 | 546 |         
 4173 | 547 |         """
 4174 | 548 | 
 4175 | 549 |         records: T.List[T.Any] = await self.bot.db.fetch(query, interaction.guild_id, user.id)
 4176 | 550 |         if not records:
 4177 | 551 |             embed = discord.Embed(
 4178 | 552 |                 color=discord.Color.red(),
 4179 | 553 |                 description=f"{user.mention} doesn't have any slot in any scrim of this server.",
 4180 | 554 |             )
 4181 | 555 |             return await interaction.followup.send(embed=embed)
 4182 | 556 | 
 4183 | 557 |         embed = discord.Embed(color=self.bot.color)
 4184 | 558 |         embed.set_author(name=f"{user}'s slots", icon_url=user.display_avatar.url)
 4185 | 559 |         embed.description = ""
 4186 | 560 |         for idx, record in enumerate(records, start=1):
 4187 | 561 |             embed.description += (
 4188 | 562 |                 f"`[{idx:02}] ` [**{record['team_name']}**]({record['jump_url']}) - <#{record['registration_channel_id']}>\n"
 4189 | 563 |                 "Team: {0}\n\n".format(", ".join([f"<@{member}>" for member in record["members"]]))
 4190 | 564 |             )
 4191 | 565 | 
 4192 | 566 |         embed.set_footer(text=f"Requested by {interaction.user}", icon_url=interaction.user.display_avatar.url)
 4193 | 567 |         await interaction.followup.send(embed=embed)
 4194 | 568 | 
 4195 | 569 |     @app_commands.command()
 4196 | 570 |     @app_commands.describe(registration_channel="Scrims registration channel.")
 4197 | 571 |     async def slotlist(self, interaction: discord.Interaction, registration_channel: discord.TextChannel):
 4198 | 572 |         """Post scrims slotlist to current channel."""
 4199 | 573 | 
 4200 | 574 |         if not await self.can_use_command(interaction):
 4201 | 575 |             return
 4202 | 576 | 
 4203 | 577 |         scrim = await Scrim.get_or_none(registration_channel_id=registration_channel.id, guild_id=interaction.guild_id)
 4204 | 578 |         if not scrim:
 4205 | 579 |             return await interaction.response.send_message(
 4206 | 580 |                 f"No scrim found in {registration_channel.mention}.", ephemeral=True
 4207 | 581 |             )
 4208 | 582 | 
 4209 | 583 |         if not await scrim.teams_registered.count():
 4210 | 584 |             return await interaction.response.send_message(f"{scrim} has no registrations.")
 4211 | 585 | 
 4212 | 586 |         embed, schannel = await scrim.create_slotlist()
 4213 | 587 |         await interaction.response.send_message(embed=embed)
 4214 | 588 | 
 4215 | 
 4216 | 
 4217 | --------------------------------------------------------------------------------
 4218 | /cogs/esports/views/__init__.py:
 4219 | --------------------------------------------------------------------------------
 4220 | 1 | from .base import *
 4221 | 2 | from .groupm import *
 4222 | 3 | from .idp import *
 4223 | 4 | from .slotm import *
 4224 | 5 | from .smslotlist import *
 4225 | 6 | from .ssmod import *
 4226 | 7 | from .tourney import *
 4227 | 8 | 
 4228 | 
 4229 | 
 4230 | --------------------------------------------------------------------------------
 4231 | /cogs/esports/views/base.py:
 4232 | --------------------------------------------------------------------------------
 4233 |  1 | from __future__ import annotations
 4234 |  2 | 
 4235 |  3 | import typing
 4236 |  4 | 
 4237 |  5 | if typing.TYPE_CHECKING:
 4238 |  6 |     from core import Quotient
 4239 |  7 | 
 4240 |  8 | from contextlib import suppress
 4241 |  9 | 
 4242 | 10 | import discord
 4243 | 11 | 
 4244 | 12 | from core import Context
 4245 | 13 | 
 4246 | 14 | 
 4247 | 15 | class EsportsBaseView(discord.ui.View):
 4248 | 16 |     message: discord.Message
 4249 | 17 |     custom_id: str
 4250 | 18 | 
 4251 | 19 |     def __init__(self, ctx: Context, **kwargs):
 4252 | 20 |         super().__init__(timeout=kwargs.get("timeout", 60))
 4253 | 21 | 
 4254 | 22 |         self.ctx = ctx
 4255 | 23 |         self.title = kwargs.get("title", "")
 4256 | 24 |         self.bot: Quotient = ctx.bot
 4257 | 25 |         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
 4258 | 26 | 
 4259 | 27 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
 4260 | 28 |         if interaction.user.id != self.ctx.author.id:
 4261 | 29 |             await interaction.response.send_message(
 4262 | 30 |                 "Sorry, you can't use this interaction as it is not started by you.", ephemeral=True
 4263 | 31 |             )
 4264 | 32 |             return False
 4265 | 33 |         return True
 4266 | 34 | 
 4267 | 35 |     async def on_timeout(self) -> None:
 4268 | 36 |         if hasattr(self, "message"):
 4269 | 37 |             for b in self.children:
 4270 | 38 |                 if isinstance(b, discord.ui.Button) and not b.style == discord.ButtonStyle.link:
 4271 | 39 |                     b.style, b.disabled = discord.ButtonStyle.grey, True
 4272 | 40 | 
 4273 | 41 |             with suppress(discord.HTTPException):
 4274 | 42 |                 await self.message.edit(view=self)
 4275 | 43 | 
 4276 | 44 |     async def on_error(self, interaction: discord.Interaction, error: Exception, item) -> None:
 4277 | 45 |         print("Esports view error:", error)
 4278 | 46 |         self.ctx.bot.dispatch("command_error", self.ctx, error)
 4279 | 47 | 
 4280 | 48 |     async def ask_embed(self, desc: str, *, image=None):
 4281 | 49 |         embed = discord.Embed(color=self.bot.color, description=desc, title=self.title)
 4282 | 50 |         if image:
 4283 | 51 |             embed.set_image(url=image)
 4284 | 52 |         embed.set_footer(text=f"Reply with 'cancel' to stop this process.")
 4285 | 53 | 
 4286 | 54 |         return await self.ctx.send(embed=embed, embed_perms=True)
 4287 | 55 | 
 4288 | 56 |     async def error_embed(self, desc: str, *, footer: str = None, delete_after=3):
 4289 | 57 |         embed = discord.Embed(color=discord.Color.red(), title="Whoopsi-Doopsi", description=desc)
 4290 | 58 |         if footer:
 4291 | 59 |             embed.set_footer(text=footer)
 4292 | 60 |         await self.ctx.send(embed=embed, delete_after=delete_after, embed_perms=True)
 4293 | 61 | 
 4294 | 62 |     def red_embed(self, description: str) -> discord.Embed:
 4295 | 63 |         return discord.Embed(color=discord.Color.red(), title=self.title, description=description)
 4296 | 64 | 
 4297 | 
 4298 | 
 4299 | --------------------------------------------------------------------------------
 4300 | /cogs/esports/views/groupm/__init__.py:
 4301 | --------------------------------------------------------------------------------
 4302 | 1 | from ._refresh import *
 4303 | 2 | from .main import *
 4304 | 3 | 
 4305 | 
 4306 | 
 4307 | --------------------------------------------------------------------------------
 4308 | /cogs/esports/views/groupm/_paginator.py:
 4309 | --------------------------------------------------------------------------------
 4310 |   1 | from __future__ import annotations
 4311 |   2 | 
 4312 |   3 | import typing as T
 4313 |   4 | from contextlib import suppress
 4314 |   5 | 
 4315 |   6 | import discord
 4316 |   7 | 
 4317 |   8 | from core import Context
 4318 |   9 | from models.esports.tourney import TGroupList, TMSlot, Tourney
 4319 |  10 | from utils import emote, inputs
 4320 |  11 | 
 4321 |  12 | from ..base import EsportsBaseView
 4322 |  13 | from ._refresh import GroupRefresh
 4323 |  14 | 
 4324 |  15 | 
 4325 |  16 | class GroupPages(EsportsBaseView):
 4326 |  17 |     def __init__(self, ctx: Context, tourney: Tourney, *, ping_all: bool = True, category=None):
 4327 |  18 |         super().__init__(ctx)
 4328 |  19 | 
 4329 |  20 |         self.ping_all = ping_all
 4330 |  21 |         self.tourney = tourney
 4331 |  22 | 
 4332 |  23 |         self.records: T.List[T.List["TMSlot"]] = None
 4333 |  24 |         self.record: T.List[TMSlot] = None
 4334 |  25 | 
 4335 |  26 |         self.category: discord.CategoryChannel = category
 4336 |  27 |         self.send_to = None
 4337 |  28 | 
 4338 |  29 |     async def rendor(self, msg: discord.Message):
 4339 |  30 |         self.records = await self.tourney._get_groups()
 4340 |  31 |         self.record = self.records[0]
 4341 |  32 | 
 4342 |  33 |         self.message = await msg.edit(embed=self.initial_embed, view=self)
 4343 |  34 | 
 4344 |  35 |     async def refresh_view(self):
 4345 |  36 |         _e = self.initial_embed
 4346 |  37 |         try:
 4347 |  38 |             self.message = await self.message.edit(embed=_e, view=self)
 4348 |  39 |         except discord.HTTPException:
 4349 |  40 |             await self.on_timeout()
 4350 |  41 | 
 4351 |  42 |     @property
 4352 |  43 |     def send_channel(self):
 4353 |  44 |         index = self.records.index(self.record) + 1
 4354 |  45 |         if self.category:
 4355 |  46 |             with suppress(StopIteration):
 4356 |  47 |                 return next(c for c in self.category.text_channels if str(index) in c.name)
 4357 |  48 | 
 4358 |  49 |     @property
 4359 |  50 |     def initial_embed(self):
 4360 |  51 |         current_page = self.records.index(self.record) + 1
 4361 |  52 |         _e = discord.Embed(color=0x00FFB3, title=f"{self.tourney.name} - Group {current_page}")
 4362 |  53 |         _e.set_thumbnail(url=getattr(self.ctx.guild.icon, "url", None))
 4363 |  54 | 
 4364 |  55 |         _e.description = (
 4365 |  56 |             "```\n"
 4366 |  57 |             + "".join(
 4367 |  58 |                 [
 4368 |  59 |                     f"Slot {idx:02}  ->  {slot.team_name}\n"
 4369 |  60 |                     for idx, slot in enumerate(self.record, self.tourney.slotlist_start)
 4370 |  61 |                 ]
 4371 |  62 |             )
 4372 |  63 |             + "```"
 4373 |  64 |         )
 4374 |  65 | 
 4375 |  66 |         if s_t := self.send_to:
 4376 |  67 |             _e.add_field(name="Send to", value=getattr(s_t, "mention", "`Not-Set`"))
 4377 |  68 | 
 4378 |  69 |         else:
 4379 |  70 |             _e.add_field(name="Send to", value=getattr(self.send_channel, "mention", "`Not-Set`"))
 4380 |  71 | 
 4381 |  72 |         _e.add_field(name="Ping @everyone", value=("`No`", "`Yes`")[self.ping_all])
 4382 |  73 |         _e.set_footer(text="Page {}/{}".format(current_page, len(self.records)))
 4383 |  74 |         return _e
 4384 |  75 | 
 4385 |  76 |     @discord.ui.button(emoji="<:left:878668491660623872>")
 4386 |  77 |     async def prev_button(self, interaction: discord.Interaction, button: discord.Button):
 4387 |  78 |         await interaction.response.defer()
 4388 |  79 | 
 4389 |  80 |         index = self.records.index(self.record)
 4390 |  81 |         if index == 0:
 4391 |  82 |             self.record = self.records[-1]
 4392 |  83 |         else:
 4393 |  84 |             self.record = self.records[index - 1]
 4394 |  85 | 
 4395 |  86 |         await self.refresh_view()
 4396 |  87 | 
 4397 |  88 |     @discord.ui.button(label="Skip to...")
 4398 |  89 |     async def skip_to(self, interaction: discord.Interaction, button: discord.Button):
 4399 |  90 |         await interaction.response.defer()
 4400 |  91 |         m = await self.ctx.simple("What page do you want to go to? (Enter page number)")
 4401 |  92 |         p = await inputs.integer_input(self.ctx, delete_after=True, timeout=30)
 4402 |  93 |         await self.ctx.safe_delete(m)
 4403 |  94 | 
 4404 |  95 |         if p > len(self.records) + 1 or p <= 0:
 4405 |  96 |             return await self.ctx.error("Invalid page number.", 4)
 4406 |  97 | 
 4407 |  98 |         if self.record == self.records[p - 1]:
 4408 |  99 |             return await self.ctx.error("We are already on that page, ya dumb dumb.", 4)
 4409 | 100 | 
 4410 | 101 |         self.record = self.records[p - 1]
 4411 | 102 |         await self.refresh_view()
 4412 | 103 | 
 4413 | 104 |     @discord.ui.button(emoji="<:right:878668370331983913>")
 4414 | 105 |     async def next_button(self, interaction: discord.Interaction, button: discord.Button):
 4415 | 106 |         await interaction.response.defer()
 4416 | 107 | 
 4417 | 108 |         index = self.records.index(self.record)
 4418 | 109 |         if index == len(self.records) - 1:
 4419 | 110 |             self.record = self.records[0]
 4420 | 111 |         else:
 4421 | 112 |             self.record = self.records[index + 1]
 4422 | 113 | 
 4423 | 114 |         await self.refresh_view()
 4424 | 115 | 
 4425 | 116 |     @discord.ui.button(label="Give Roles")
 4426 | 117 |     async def give_roles(self, interaction: discord.Interaction, button: discord.ui.Button):
 4427 | 118 |         await interaction.response.defer()
 4428 | 119 | 
 4429 | 120 |         m = await self.ctx.simple(
 4430 | 121 |             f"Mention the role you want to give to Group {self.records.index(self.record) + 1} members."
 4431 | 122 |         )
 4432 | 123 |         role = await inputs.role_input(self.ctx, delete_after=True)
 4433 | 124 |         await self.ctx.safe_delete(m)
 4434 | 125 | 
 4435 | 126 |         m = await self.ctx.simple(f"Ok, Please wait... {emote.loading}")
 4436 | 127 | 
 4437 | 128 |         for slot in self.record:
 4438 | 129 |             member = await self.bot.get_or_fetch_member(self.ctx.guild, slot.leader_id)
 4439 | 130 |             if member and not role in member.roles:
 4440 | 131 |                 try:
 4441 | 132 |                     await member.add_roles(role)
 4442 | 133 |                 except Exception as e:
 4443 | 134 |                     await self.ctx.error(e)
 4444 | 135 | 
 4445 | 136 |         try:
 4446 | 137 |             await m.edit(
 4447 | 138 |                 embed=discord.Embed(
 4448 | 139 |                     color=self.ctx.bot.color,
 4449 | 140 |                     description=f"Done! Given {role.mention} to group {self.records.index(self.record) + 1}.",
 4450 | 141 |                 ),
 4451 | 142 |                 delete_after=6,
 4452 | 143 |             )
 4453 | 144 |         except discord.HTTPException:
 4454 | 145 |             await self.ctx.simple(
 4455 | 146 |                 f"Done, Given {role.mention} to group {self.records.index(self.record) + 1}.", delete_after=6
 4456 | 147 |             )
 4457 | 148 | 
 4458 | 149 |     @discord.ui.button(label="Send to", row=2, style=discord.ButtonStyle.blurple)
 4459 | 150 |     async def send_channl(self, interaction: discord.Interaction, button: discord.Button):
 4460 | 151 |         await interaction.response.defer()
 4461 | 152 | 
 4462 | 153 |         m = await self.ctx.simple("Mention the channel where you want to send this grouplist.")
 4463 | 154 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
 4464 | 155 |         await self.ctx.safe_delete(m)
 4465 | 156 | 
 4466 | 157 |         self.send_to = channel
 4467 | 158 |         self.category = channel.category
 4468 | 159 | 
 4469 | 160 |         await self.refresh_view()
 4470 | 161 | 
 4471 | 162 |     @discord.ui.button(label="Send", style=discord.ButtonStyle.green, row=2)
 4472 | 163 |     async def send_now(self, interaction: discord.Interaction, button: discord.Button):
 4473 | 164 |         await interaction.response.defer()
 4474 | 165 | 
 4475 | 166 |         c = self.send_to if self.send_to else self.send_channel
 4476 | 167 |         if not c:
 4477 | 168 |             return await self.ctx.error("You need to set a channel first.", 3)
 4478 | 169 | 
 4479 | 170 |         embed = self.initial_embed
 4480 | 171 | 
 4481 | 172 |         embed.set_thumbnail(url=None)
 4482 | 173 |         embed.clear_fields()
 4483 | 174 |         embed.set_footer(text=self.ctx.guild.name, icon_url=getattr(self.ctx.guild.icon, "url", None))
 4484 | 175 |         try:
 4485 | 176 |             m = await c.send(
 4486 | 177 |                 "@everyone" if self.ping_all else "",
 4487 | 178 |                 embed=embed,
 4488 | 179 |                 view=GroupRefresh(),
 4489 | 180 |                 allowed_mentions=discord.AllowedMentions(everyone=True),
 4490 | 181 |             )
 4491 | 182 | 
 4492 | 183 |             # I am 100% sure there is a better way to do this but as long as this works, i am good.
 4493 | 184 | 
 4494 | 185 |             await TGroupList.filter(tourney_id=self.tourney.id, group_number=self.records.index(self.record) + 1).delete()
 4495 | 186 | 
 4496 | 187 |             await TGroupList.create(
 4497 | 188 |                 message_id=m.id,
 4498 | 189 |                 channel_id=c.id,
 4499 | 190 |                 tourney_id=self.tourney.id,
 4500 | 191 |                 group_number=self.records.index(self.record) + 1,
 4501 | 192 |             )
 4502 | 193 |         except Exception as e:
 4503 | 194 |             await self.ctx.error(e)
 4504 | 195 | 
 4505 | 196 |         await self.ctx.success("GroupList published.", 3)
 4506 | 197 |         await self.refresh_view()
 4507 | 198 |         self.send_to = None
 4508 | 199 | 
 4509 | 
 4510 | 
 4511 | --------------------------------------------------------------------------------
 4512 | /cogs/esports/views/groupm/_refresh.py:
 4513 | --------------------------------------------------------------------------------
 4514 |   1 | from __future__ import annotations
 4515 |   2 | 
 4516 |   3 | import typing as T
 4517 |   4 | 
 4518 |   5 | import discord
 4519 |   6 | 
 4520 |   7 | from models import TGroupList, TMSlot, Tourney
 4521 |   8 | from utils import emote
 4522 |   9 | 
 4523 |  10 | from ..tourney._select import TourneySlotSelec
 4524 |  11 | 
 4525 |  12 | __all__ = ("GroupRefresh",)
 4526 |  13 | 
 4527 |  14 | 
 4528 |  15 | class GroupRefresh(discord.ui.View):
 4529 |  16 |     def __init__(self):
 4530 |  17 |         super().__init__(timeout=None)
 4531 |  18 | 
 4532 |  19 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
 4533 |  20 |         if not Tourney.is_ignorable(interaction.user) and not interaction.user.guild_permissions.manage_guild:
 4534 |  21 |             await interaction.response.send_message(
 4535 |  22 |                 "You need either `manage-server` permissions or `@tourney-mod` role to refresh grouplist.", ephemeral=True
 4536 |  23 |             )
 4537 |  24 |             return False
 4538 |  25 | 
 4539 |  26 |         return True
 4540 |  27 | 
 4541 |  28 |     @discord.ui.button(
 4542 |  29 |         custom_id="t_groups_refresh",
 4543 |  30 |         emoji="<:refresh:953888517619064833>",
 4544 |  31 |         label="Refresh",
 4545 |  32 |         style=discord.ButtonStyle.green,
 4546 |  33 |     )
 4547 |  34 |     async def refresh_group(self, interaction: discord.Interaction, button: discord.Button):
 4548 |  35 |         await interaction.response.defer()
 4549 |  36 | 
 4550 |  37 |         _checks = await self.__do_checks(interaction, True)
 4551 |  38 | 
 4552 |  39 |         try:
 4553 |  40 |             record, tourney, group = _checks
 4554 |  41 |         except:
 4555 |  42 |             return
 4556 |  43 | 
 4557 |  44 |         await TGroupList.filter(pk=record.pk).update(refresh_at=record.bot.current_time)
 4558 |  45 | 
 4559 |  46 |         _e = discord.Embed(color=0x00FFB3, title=f"{tourney.name} - Group {record.group_number}")
 4560 |  47 |         # _e.set_thumbnail(url=getattr(tourney.guild.icon, "url", None))
 4561 |  48 | 
 4562 |  49 |         _e.description = (
 4563 |  50 |             "```\n"
 4564 |  51 |             + "".join(
 4565 |  52 |                 [f"Slot {idx:02}  ->  {slot.team_name}\n" for idx, slot in enumerate(group, tourney.slotlist_start)]
 4566 |  53 |             )
 4567 |  54 |             + "```"
 4568 |  55 |         )
 4569 |  56 |         _e.set_footer(text=tourney.guild.name, icon_url=getattr(tourney.guild.icon, "url", None))
 4570 |  57 | 
 4571 |  58 |         await interaction.edit_original_response(embed=_e, view=self)
 4572 |  59 |         await interaction.followup.send("Grouplist message was refreshed successfully.", ephemeral=True)
 4573 |  60 | 
 4574 |  61 |     @discord.ui.button(custom_id="gl_info_b", emoji=emote.info, label="Info")
 4575 |  62 |     async def slots_info(self, interaction: discord.Interaction, button: discord.Button):
 4576 |  63 |         await interaction.response.defer()
 4577 |  64 | 
 4578 |  65 |         _checks = await self.__do_checks(interaction)
 4579 |  66 |         if not len(_checks) == 3:
 4580 |  67 |             return
 4581 |  68 | 
 4582 |  69 |         record, tourney, group = _checks
 4583 |  70 | 
 4584 |  71 |         for _ in group:
 4585 |  72 |             setattr(_, "tourney", tourney)
 4586 |  73 | 
 4587 |  74 |         v = discord.ui.View()
 4588 |  75 |         v.add_item(TourneySlotSelec(group, "Select the slot to see the team info."))
 4589 |  76 | 
 4590 |  77 |         await interaction.followup.send("", view=v, ephemeral=True)
 4591 |  78 |         await v.wait()
 4592 |  79 |         if hasattr(v, "custom_id"):
 4593 |  80 |             for _ in v.custom_id:
 4594 |  81 |                 slot_id, tourney_id = _.split(":")
 4595 |  82 |                 _slot = await TMSlot.get(pk=slot_id)
 4596 |  83 | 
 4597 |  84 |                 member = await tourney.bot.get_or_fetch_member(tourney.guild, _slot.leader_id)
 4598 |  85 |                 _e = discord.Embed(color=0x00FFB3, title=f"Slot {group.index(_slot)+1}, Group {record.group_number}")
 4599 |  86 |                 _e.description = (
 4600 |  87 |                     f"> Team Name: `{_slot.team_name}`\n"
 4601 |  88 |                     f"> Team Leader: `{member}`\n"
 4602 |  89 |                     f"> Registration Message: [Click here]({_slot.jump_url})\n"
 4603 |  90 |                     f"> Confirm Message: [Click here]({_slot.confirm_jump_url})"
 4604 |  91 |                 )
 4605 |  92 | 
 4606 |  93 |                 await interaction.followup.send(embed=_e, ephemeral=True)
 4607 |  94 | 
 4608 |  95 |     async def __do_checks(self, interaction: discord.Interaction, refresh_too=False):
 4609 |  96 |         record = await TGroupList.get_or_none(pk=interaction.message.id)
 4610 |  97 |         tourney = None
 4611 |  98 |         if record:
 4612 |  99 |             tourney = await Tourney.get_or_none(pk=record.tourney_id)
 4613 | 100 | 
 4614 | 101 |         if not record or not tourney:
 4615 | 102 |             self.children[0].disabled = True
 4616 | 103 |             return await interaction.edit_original_response(view=self)
 4617 | 104 | 
 4618 | 105 |         if refresh_too:
 4619 | 106 |             if (record.bot.current_time - record.refresh_at).total_seconds() < 120:
 4620 | 107 |                 return await interaction.followup.send("You can only refresh every 2 minutes.", ephemeral=True)
 4621 | 108 | 
 4622 | 109 |         group = await tourney.get_group(record.group_number)
 4623 | 110 |         if not group:
 4624 | 111 |             await interaction.delete_original_response()
 4625 | 112 |             return await interaction.followup.send("Group not found.", ephemeral=True)
 4626 | 113 | 
 4627 | 114 |         return record, tourney, group
 4628 | 115 | 
 4629 | 
 4630 | 
 4631 | --------------------------------------------------------------------------------
 4632 | /cogs/esports/views/groupm/main.py:
 4633 | --------------------------------------------------------------------------------
 4634 |   1 | from __future__ import annotations
 4635 |   2 | 
 4636 |   3 | import typing as T
 4637 |   4 | from contextlib import suppress
 4638 |   5 | 
 4639 |   6 | import discord
 4640 |   7 | 
 4641 |   8 | from core import Context
 4642 |   9 | from models import Tourney
 4643 |  10 | from utils import inputs, keycap_digit
 4644 |  11 | 
 4645 |  12 | from ..base import EsportsBaseView
 4646 |  13 | from ..tourney._buttons import DiscardButton
 4647 |  14 | from ._paginator import GroupPages
 4648 |  15 | 
 4649 |  16 | __all__ = ("TourneyGroupManager",)
 4650 |  17 | 
 4651 |  18 | 
 4652 |  19 | class TourneyGroupManager(EsportsBaseView):
 4653 |  20 |     def __init__(self, ctx: Context, tourney: Tourney, **kwargs):
 4654 |  21 |         super().__init__(ctx, **kwargs)
 4655 |  22 | 
 4656 |  23 |         self.tourney = tourney
 4657 |  24 |         self.category = None
 4658 |  25 | 
 4659 |  26 |         self.ping_all = False
 4660 |  27 | 
 4661 |  28 |         self.start_from = tourney.slotlist_start
 4662 |  29 | 
 4663 |  30 |     @property
 4664 |  31 |     def initial_embed(self):
 4665 |  32 |         _e = discord.Embed(
 4666 |  33 |             color=self.ctx.bot.color, title="Tourney Group Management", url=self.tourney.bot.config.SERVER_LINK
 4667 |  34 |         )
 4668 |  35 |         _e.description = (
 4669 |  36 |             f"Use `create channels & roles` to setup tourney groups.\n"
 4670 |  37 |             "Use `Group List` to post group/slotlist in channels."
 4671 |  38 |         )
 4672 |  39 |         _e.add_field(name=f"{keycap_digit(1)} Slotlist Start from", value=f"`Slot {self.start_from}`")
 4673 |  40 |         _e.add_field(name=f"{keycap_digit(2)} Ping @everyone", value=("`No`", "`Yes`")[self.ping_all])
 4674 |  41 |         return _e
 4675 |  42 | 
 4676 |  43 |     async def __refresh_msg(self):
 4677 |  44 |         with suppress(discord.HTTPException):
 4678 |  45 |             self.message = await self.message.edit(embed=self.initial_embed)
 4679 |  46 | 
 4680 |  47 |     @discord.ui.button(emoji=keycap_digit(1))
 4681 |  48 |     async def change_slotlist_start(self, interaction: discord.Interaction, button: discord.Button):
 4682 |  49 |         await interaction.response.defer()
 4683 |  50 | 
 4684 |  51 |         m = await self.ctx.simple("Enter the slot number to start group/slotlist. (Max `20`)")
 4685 |  52 |         self.start_from = await inputs.integer_input(self.ctx, limits=(1, 20), delete_after=True)
 4686 |  53 |         await self.ctx.safe_delete(m)
 4687 |  54 | 
 4688 |  55 |         await self.tourney.make_changes(slotlist_start=self.start_from)
 4689 |  56 |         await self.tourney.refresh_from_db()
 4690 |  57 | 
 4691 |  58 |         await self.__refresh_msg()
 4692 |  59 | 
 4693 |  60 |     @discord.ui.button(emoji=keycap_digit(2))
 4694 |  61 |     async def toggle_ping_all(self, interaction: discord.Interaction, button: discord.Button):
 4695 |  62 |         await interaction.response.defer()
 4696 |  63 |         self.ping_all = not self.ping_all
 4697 |  64 |         await self.__refresh_msg()
 4698 |  65 | 
 4699 |  66 |     @discord.ui.button(label="Create Channels & Roles")
 4700 |  67 |     async def create_roles_channels(self, interaction: discord.Interaction, button: discord.Button):
 4701 |  68 |         await interaction.response.defer()
 4702 |  69 |         if len(self.ctx.guild.channels) >= 490:
 4703 |  70 |             return await self.ctx.error("Too many channels in server. Please delete some first.", 4)
 4704 |  71 | 
 4705 |  72 |         _e = discord.Embed(color=0x00FFB3)
 4706 |  73 |         _e.description = (
 4707 |  74 |             "**Enter the format for group roles & channels creation.**\n"
 4708 |  75 |             "*`{0}` will be replaced by the number of group or roles*\n\nExamples:"
 4709 |  76 |         )
 4710 |  77 |         _e.set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/953163516481777684/unknown.png")
 4711 |  78 | 
 4712 |  79 |         m = await interaction.followup.send(embed=_e)
 4713 |  80 |         _format = await inputs.string_input(self.ctx, timeout=60, delete_after=True)
 4714 |  81 | 
 4715 |  82 |         await self.ctx.safe_delete(m)
 4716 |  83 |         if len(_format) > 35:
 4717 |  84 |             return await self.ctx.error("Name too long. Max 35 characters.", 4)
 4718 |  85 | 
 4719 |  86 |         if not "{0}" in _format:
 4720 |  87 |             return await self.ctx.error("No `{0}` found in input.", 4)
 4721 |  88 | 
 4722 |  89 |         p = await self.ctx.prompt(
 4723 |  90 |             f"Group Roles/channels will look like this: `{_format.replace('{0}','1')}`,`{_format.replace('{0}','2')}`",
 4724 |  91 |             title="Is this correct?",
 4725 |  92 |         )
 4726 |  93 | 
 4727 |  94 |         if not p:
 4728 |  95 |             return await self.ctx.error("Cancelled.", 4)
 4729 |  96 |         _e.description = (
 4730 |  97 |             "Enter the range of group numbers to create channels & setup roles.\n"
 4731 |  98 |             "For example:\n"
 4732 |  99 |             "`1-5` will create channels for group 1 to 5 and setup roles."
 4733 | 100 |         )
 4734 | 101 |         _e.set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/955013587049525278/unknown.png")
 4735 | 102 |         m = await interaction.followup.send(embed=_e)
 4736 | 103 |         _range = await inputs.string_input(self.ctx, delete_after=True)
 4737 | 104 |         await self.ctx.safe_delete(m)
 4738 | 105 |         _range = _range.strip().split("-")
 4739 | 106 |         if not len(_range) == 2:
 4740 | 107 |             return await self.ctx.error("Invalid format provided.", 4)
 4741 | 108 |         try:
 4742 | 109 |             x, y = tuple(map(int, _range))
 4743 | 110 |         except ValueError:
 4744 | 111 |             return await self.ctx.error("Invalid format provided.", 4)
 4745 | 112 | 
 4746 | 113 |         if x == y:
 4747 | 114 |             return await self.ctx.error("Invalid range provided.", 4)
 4748 | 115 | 
 4749 | 116 |         cat_name = _format.replace("{0}", "") + f" {x}-{y}"
 4750 | 117 | 
 4751 | 118 |         overwrites = {
 4752 | 119 |             self.ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),
 4753 | 120 |         }
 4754 | 121 |         if mod := self.tourney.modrole:
 4755 | 122 |             overwrites[mod] = discord.PermissionOverwrite(
 4756 | 123 |                 read_messages=True,
 4757 | 124 |                 send_messages=True,
 4758 | 125 |                 read_message_history=True,
 4759 | 126 |                 manage_channels=True,
 4760 | 127 |                 mention_everyone=True,
 4761 | 128 |             )
 4762 | 129 | 
 4763 | 130 |         await self.ctx.simple(f"Please wait ...", 5)
 4764 | 131 |         category = await self.ctx.guild.create_category(
 4765 | 132 |             name=cat_name, overwrites=overwrites, reason="for group management by {0}".format(self.ctx.author)
 4766 | 133 |         )
 4767 | 134 |         self.category = category
 4768 | 135 |         for i in range(x, y + 1):
 4769 | 136 |             role = await self.__get_or_create_role(_format.replace("{0}", str(i)))
 4770 | 137 |             if not isinstance(role, discord.Role):
 4771 | 138 |                 return await self.ctx.error(role, 10)
 4772 | 139 | 
 4773 | 140 |             _n = {
 4774 | 141 |                 role: discord.PermissionOverwrite(read_messages=True, send_messages=False, read_message_history=True),
 4775 | 142 |                 **overwrites,
 4776 | 143 |             }
 4777 | 144 |             try:
 4778 | 145 |                 await self.category.create_text_channel(_format.replace("{0}", str(i)), overwrites=_n)
 4779 | 146 |             except Exception as e:
 4780 | 147 |                 return await self.ctx.error(e)
 4781 | 148 | 
 4782 | 149 |         await self.ctx.simple("Group channels and roles creation successfuly", 5)
 4783 | 150 | 
 4784 | 151 |     @discord.ui.button(label="Group List", style=discord.ButtonStyle.green)
 4785 | 152 |     async def send_grouplist(self, interaction: discord.Interaction, button: discord.Button):
 4786 | 153 |         await interaction.response.defer()
 4787 | 154 | 
 4788 | 155 |         if not self.tourney.group_size:
 4789 | 156 |             return await self.ctx.error(
 4790 | 157 |                 "**Group size/Teams Per Group is not set.**\n\n"
 4791 | 158 |                 "Please press `Go Back` and click on Edit Settings to set Group Size.",
 4792 | 159 |                 6,
 4793 | 160 |             )
 4794 | 161 | 
 4795 | 162 |         if not await self.tourney.assigned_slots.all():
 4796 | 163 |             return await self.ctx.error("Noboby registered yet.", 4)
 4797 | 164 | 
 4798 | 165 |         self.stop()
 4799 | 166 |         _v = GroupPages(self.ctx, self.tourney, ping_all=self.ping_all, category=self.category)
 4800 | 167 |         _v.add_item(DiscardButton(self.ctx, "Main Menu", 2))
 4801 | 168 |         await _v.rendor(self.message)
 4802 | 169 | 
 4803 | 170 |     async def __get_or_create_role(self, name: str) -> T.Union[discord.Role, str]:
 4804 | 171 |         role = discord.utils.get(self.ctx.guild.roles, name=name)
 4805 | 172 |         if role:
 4806 | 173 |             return role
 4807 | 174 | 
 4808 | 175 |         try:
 4809 | 176 |             role = await self.ctx.guild.create_role(
 4810 | 177 |                 name=name, reason="created for group management by {0}".format(self.ctx.author)
 4811 | 178 |             )
 4812 | 179 |         except Exception as e:
 4813 | 180 |             return e
 4814 | 181 | 
 4815 | 182 |         else:
 4816 | 183 |             return role
 4817 | 184 | 
 4818 | 
 4819 | 
 4820 | --------------------------------------------------------------------------------
 4821 | /cogs/esports/views/idp/__init__.py:
 4822 | --------------------------------------------------------------------------------
 4823 |  1 | from __future__ import annotations
 4824 |  2 | 
 4825 |  3 | import discord
 4826 |  4 | 
 4827 |  5 | __all__ = ("IdpView",)
 4828 |  6 | 
 4829 |  7 | 
 4830 |  8 | class IdpView(discord.ui.View):
 4831 |  9 |     def __init__(self, room_id: str, password: str, map: str):
 4832 | 10 |         self.room_id = room_id
 4833 | 11 |         self.password = password
 4834 | 12 |         self.map = map
 4835 | 13 |         super().__init__(timeout=None)
 4836 | 14 | 
 4837 | 15 |     @discord.ui.button(label="Get in Copy Format", style=discord.ButtonStyle.green)
 4838 | 16 |     async def copy_format(self, interaction: discord.Interaction, button: discord.Button):
 4839 | 17 |         await interaction.response.send_message(
 4840 | 18 |             "ID: {}\nPassword: {}\nMap: {}".format(self.room_id, self.password, self.map), ephemeral=True
 4841 | 19 |         )
 4842 | 20 | 
 4843 | 
 4844 | 
 4845 | --------------------------------------------------------------------------------
 4846 | /cogs/esports/views/paginator/__init__.py:
 4847 | --------------------------------------------------------------------------------
 4848 |  1 | from __future__ import annotations
 4849 |  2 | 
 4850 |  3 | import discord
 4851 |  4 | 
 4852 |  5 | from utils import integer_input
 4853 |  6 | 
 4854 |  7 | from ...views.base import Context, EsportsBaseView
 4855 |  8 | 
 4856 |  9 | 
 4857 | 10 | class NextButton(discord.ui.Button):
 4858 | 11 |     view: "EsportsBaseView"
 4859 | 12 | 
 4860 | 13 |     def __init__(self):
 4861 | 14 |         super().__init__(emoji="<:double_right:878668437193359392>")
 4862 | 15 | 
 4863 | 16 |     async def callback(self, interaction: discord.Interaction):
 4864 | 17 |         await interaction.response.defer()
 4865 | 18 | 
 4866 | 19 |         self.view.current_page += 1
 4867 | 20 |         await self.view.refresh_view()
 4868 | 21 | 
 4869 | 22 | 
 4870 | 23 | class PrevButton(discord.ui.Button):
 4871 | 24 |     view: "EsportsBaseView"
 4872 | 25 | 
 4873 | 26 |     def __init__(self):
 4874 | 27 |         super().__init__(emoji="<:double_left:878668594530099220>")
 4875 | 28 | 
 4876 | 29 |     async def callback(self, interaction: discord.Interaction):
 4877 | 30 |         await interaction.response.defer()
 4878 | 31 | 
 4879 | 32 |         self.view.current_page -= 1
 4880 | 33 |         await self.view.refresh_view()
 4881 | 34 | 
 4882 | 35 | 
 4883 | 36 | class SkipToButton(discord.ui.Button):
 4884 | 37 |     view: "EsportsBaseView"
 4885 | 38 | 
 4886 | 39 |     def __init__(self, ctx: Context):
 4887 | 40 |         super().__init__(label="Skip to page ...")
 4888 | 41 |         self.ctx = ctx
 4889 | 42 | 
 4890 | 43 |     async def callback(self, interaction: discord.Interaction):
 4891 | 44 |         await interaction.response.defer()
 4892 | 45 | 
 4893 | 46 |         m = await self.ctx.simple(
 4894 | 47 |             "Please enter the page number you want to skip to. (`1` to `{}`)".format(len(self.view.records))
 4895 | 48 |         )
 4896 | 49 |         _page = await integer_input(self.ctx, timeout=30, delete_after=True, limits=(1, len(self.view.records)))
 4897 | 50 |         await self.ctx.safe_delete(m)
 4898 | 51 | 
 4899 | 52 |         self.view.current_page = _page
 4900 | 53 | 
 4901 | 54 |         await self.view.refresh_view()
 4902 | 55 | 
 4903 | 56 | 
 4904 | 57 | class StopButton(discord.ui.Button):
 4905 | 58 |     view: "EsportsBaseView"
 4906 | 59 | 
 4907 | 60 |     def __init__(self):
 4908 | 61 |         super().__init__(emoji="⏹️")
 4909 | 62 | 
 4910 | 63 |     async def callback(self, interaction: discord.Interaction):
 4911 | 64 |         await self.view.on_timeout()
 4912 | 65 | 
 4913 | 
 4914 | 
 4915 | --------------------------------------------------------------------------------
 4916 | /cogs/esports/views/points/__init__.py:
 4917 | --------------------------------------------------------------------------------
 4918 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/cogs/esports/views/points/__init__.py
 4919 | 
 4920 | 
 4921 | --------------------------------------------------------------------------------
 4922 | /cogs/esports/views/points/conts.py:
 4923 | --------------------------------------------------------------------------------
 4924 |  1 | from uuid import UUID, uuid4
 4925 |  2 | 
 4926 |  3 | from pydantic import BaseModel, Field
 4927 |  4 | 
 4928 |  5 | 
 4929 |  6 | class Team(BaseModel):
 4930 |  7 |     id: str = Field(default_factory=uuid4)
 4931 |  8 |     name: str
 4932 |  9 |     matches: str
 4933 | 10 |     kills: int
 4934 | 11 |     placepts: int
 4935 | 12 |     totalpts: int
 4936 | 13 | 
 4937 | 
 4938 | 
 4939 | --------------------------------------------------------------------------------
 4940 | /cogs/esports/views/points/main.py:
 4941 | --------------------------------------------------------------------------------
 4942 |   1 | from __future__ import annotations
 4943 |   2 | 
 4944 |   3 | import typing as T
 4945 |   4 | from contextlib import suppress
 4946 |   5 | 
 4947 |   6 | import discord
 4948 |   7 | 
 4949 |   8 | from core import Context, QuotientView
 4950 |   9 | from utils import emote
 4951 |  10 | 
 4952 |  11 | from .conts import Team
 4953 |  12 | 
 4954 |  13 | 
 4955 |  14 | class PointsTable(QuotientView):
 4956 |  15 |     def __init__(self, ctx: Context):
 4957 |  16 |         super().__init__(ctx, timeout=100)
 4958 |  17 | 
 4959 |  18 |         self.teams: T.List[Team] = []
 4960 |  19 |         self.header: str = None
 4961 |  20 | 
 4962 |  21 |         self.footer: str = None
 4963 |  22 | 
 4964 |  23 |     @property
 4965 |  24 |     def initial_msg(self):
 4966 |  25 |         _e = discord.Embed(color=self.bot.color, title="Points Table Maker")
 4967 |  26 |         _e.description = "S.No. " + "Team Name".ljust(22) + "Place Pts".ljust(5) + "Kills".ljust(5) + "Total\n" "```\n"
 4968 |  27 |         for idx, team in enumerate(self.teams, 1):
 4969 |  28 |             _e.description += (
 4970 |  29 |                 f"{idx:02}. {team.name.ljust(22)} {str(team.placepts).ljust(5)} {str(team.kills).ljust(5)}"
 4971 |  30 |                 f"{str(team.totalpts)}\n"
 4972 |  31 |             )
 4973 |  32 | 
 4974 |  33 |         _e.description += "```"
 4975 |  34 |         _e.set_footer(text=f"Header: {self.header or 'Not Set'}\nFooter: {self.footer or 'Not Set'}")
 4976 |  35 |         return _e
 4977 |  36 | 
 4978 |  37 |     async def refresh_view(self):
 4979 |  38 |         self.message = await self.message.edit(embed=self.initial_msg, view=self)
 4980 |  39 | 
 4981 |  40 |     @discord.ui.button(label="Title & Footer")
 4982 |  41 |     async def set_title(self, inter: discord.Interaction, btn: discord.Button):
 4983 |  42 |         modal = ...
 4984 |  43 |         await inter.response.send_modal()
 4985 |  44 |         await modal.wait()
 4986 |  45 | 
 4987 |  46 |         self.header = modal.header.value
 4988 |  47 |         self.footer = modal.footer.value
 4989 |  48 | 
 4990 |  49 |         await self.refresh_view()
 4991 |  50 | 
 4992 |  51 |     @discord.ui.button(label="Add Team")
 4993 |  52 |     async def add_team(self, inter: discord.Interaction, btn: discord.Button):
 4994 |  53 |         modal = TeamInput()
 4995 |  54 |         await inter.response.send_modal(modal)
 4996 |  55 |         await modal.wait()
 4997 |  56 | 
 4998 |  57 |         kills, placepts = None, None
 4999 |  58 | 
 5000 |  59 |         with suppress(ValueError):
 5001 |  60 |             kills = int(modal.kills.value)
 5002 |  61 |             placepts = int(modal.placepts.value)
 5003 |  62 | 
 5004 |  63 |         if not all((kills, placepts)):
 5005 |  64 |             return await self.ctx.error("Invalid input", 5)
 5006 |  65 | 
 5007 |  66 |         self.teams.append(
 5008 |  67 |             Team(
 5009 |  68 |                 name=modal.team_name.value,
 5010 |  69 |                 matches=modal.matches.value,
 5011 |  70 |                 kills=kills,
 5012 |  71 |                 placepts=placepts,
 5013 |  72 |                 totalpts=kills + placepts,
 5014 |  73 |             )
 5015 |  74 |         )
 5016 |  75 |         await self.refresh_view()
 5017 |  76 | 
 5018 |  77 |     @discord.ui.button(label="Remove Team")
 5019 |  78 |     async def remove_team(self, inter: discord.Interaction, btn: discord.Button):
 5020 |  79 |         await inter.response.defer()
 5021 |  80 |         if not self.teams:
 5022 |  81 |             return await self.ctx.error("No teams to remove.", 5)
 5023 |  82 | 
 5024 |  83 |         v = QuotientView(self.ctx)
 5025 |  84 |         v.add_item(TeamSelector(self.teams))
 5026 |  85 |         v.message = await inter.followup.send("", view=v, ephemeral=True)
 5027 |  86 |         await v.wait()
 5028 |  87 | 
 5029 |  88 |         for _ in self.teams:
 5030 |  89 |             if str(_.id) in v.custom_id:
 5031 |  90 |                 self.teams.remove(_)
 5032 |  91 | 
 5033 |  92 |         await self.refresh_view()
 5034 |  93 | 
 5035 |  94 |     @discord.ui.button(label="Create Image")
 5036 |  95 |     async def create_image(self, inter: discord.Interaction, btn: discord.Button):
 5037 |  96 |         await inter.response.send_message(self.teams)
 5038 |  97 | 
 5039 |  98 | 
 5040 |  99 | class HeaderInput(discord.ui.Modal, title="Set Title & Footer"):
 5041 | 100 |     header = discord.ui.TextInput(
 5042 | 101 |         label="Header (optional)",
 5043 | 102 |         max_length=100,
 5044 | 103 |         placeholder="Enter a title for the table",
 5045 | 104 |     )
 5046 | 105 |     footer = discord.ui.TextInput(
 5047 | 106 |         label="Footer (optional)",
 5048 | 107 |         max_length=100,
 5049 | 108 |         placeholder="Enter a footer for the table",
 5050 | 109 |     )
 5051 | 110 | 
 5052 | 111 |     async def on_submit(self, interaction: discord.Interaction) -> None:
 5053 | 112 |         await interaction.response.defer()
 5054 | 113 | 
 5055 | 114 | 
 5056 | 115 | class TeamInput(discord.ui.Modal, title="Add New Team"):
 5057 | 116 |     team_name = discord.ui.TextInput(
 5058 | 117 |         label="Team Name",
 5059 | 118 |         placeholder="Enter team name",
 5060 | 119 |         max_length=20,
 5061 | 120 |         min_length=4,
 5062 | 121 |         required=True,
 5063 | 122 |         style=discord.TextStyle.short,
 5064 | 123 |     )
 5065 | 124 | 
 5066 | 125 |     matches = discord.ui.TextInput(
 5067 | 126 |         label="No. of Matches",
 5068 | 127 |         placeholder="Enter no. of matches",
 5069 | 128 |         max_length=2,
 5070 | 129 |         min_length=1,
 5071 | 130 |         required=True,
 5072 | 131 |         default=1,
 5073 | 132 |     )
 5074 | 133 | 
 5075 | 134 |     kills = discord.ui.TextInput(
 5076 | 135 |         label="No. of Kills",
 5077 | 136 |         placeholder="Enter no. of kills",
 5078 | 137 |         max_length=2,
 5079 | 138 |         min_length=1,
 5080 | 139 |         required=True,
 5081 | 140 |     )
 5082 | 141 | 
 5083 | 142 |     placepts = discord.ui.TextInput(
 5084 | 143 |         label="Place Points",
 5085 | 144 |         placeholder="Enter placement points",
 5086 | 145 |         max_length=2,
 5087 | 146 |         min_length=1,
 5088 | 147 |         required=True,
 5089 | 148 |     )
 5090 | 149 | 
 5091 | 150 |     async def on_submit(self, interaction: discord.Interaction) -> None:
 5092 | 151 |         await interaction.response.defer()
 5093 | 152 | 
 5094 | 153 | 
 5095 | 154 | class TeamSelector(discord.ui.Select):
 5096 | 155 |     view: QuotientView
 5097 | 156 | 
 5098 | 157 |     def __init__(self, teams: T.List[Team]):
 5099 | 158 |         _options = []
 5100 | 159 |         for _ in teams:
 5101 | 160 |             _options.append(discord.SelectOption(label=_.name, value=str(_.id), emoji=emote.TextChannel))
 5102 | 161 | 
 5103 | 162 |         super().__init__(placeholder="Select the teams you want to remove...", max_values=len(teams), options=_options)
 5104 | 163 | 
 5105 | 164 |     async def callback(self, interaction: discord.Interaction):
 5106 | 165 |         await interaction.response.defer()
 5107 | 166 |         self.view.custom_id = self.values
 5108 | 167 |         self.view.stop()
 5109 | 168 | 
 5110 | 
 5111 | 
 5112 | --------------------------------------------------------------------------------
 5113 | /cogs/esports/views/scrims/__init__.py:
 5114 | --------------------------------------------------------------------------------
 5115 | 1 | from ._edit import *
 5116 | 2 | from .main import *
 5117 | 3 | from .selector import *
 5118 | 4 | 
 5119 | 
 5120 | 
 5121 | --------------------------------------------------------------------------------
 5122 | /cogs/esports/views/scrims/_ac.py:
 5123 | --------------------------------------------------------------------------------
 5124 |   1 | from __future__ import annotations
 5125 |   2 | 
 5126 |   3 | import typing as T
 5127 |   4 | 
 5128 |   5 | import discord
 5129 |   6 | 
 5130 |   7 | from constants import AutocleanType
 5131 |   8 | from core import Context
 5132 |   9 | from models import ArrayAppend, ArrayRemove, Scrim, Timer
 5133 |  10 | from utils import keycap_digit as kd
 5134 |  11 | from utils import time_input
 5135 |  12 | 
 5136 |  13 | from ._base import ScrimsButton, ScrimsView
 5137 |  14 | from ._pages import *
 5138 |  15 | 
 5139 |  16 | __all__ = ("AutocleanView",)
 5140 |  17 | 
 5141 |  18 | 
 5142 |  19 | class AutocleanView(ScrimsView):
 5143 |  20 |     def __init__(self, ctx: Context, scrim: Scrim):
 5144 |  21 |         super().__init__(ctx)
 5145 |  22 |         self.ctx = ctx
 5146 |  23 |         self.record = scrim
 5147 |  24 | 
 5148 |  25 |     @property
 5149 |  26 |     async def initial_embed(self) -> discord.Embed:
 5150 |  27 |         autoclean_time = (self.record.autoclean_time).strftime("%I:%M %p") if self.record.autoclean_time else "Not Set!"
 5151 |  28 | 
 5152 |  29 |         _e = discord.Embed(color=self.ctx.bot.color, description=f"**Scrim Autoclean - {self.record}**\n")
 5153 |  30 |         _d = "\n".join(
 5154 |  31 |             f"{idx:02}. {(_type.value.title()).ljust(15)} {('❌', '✅')[_type in self.record.autoclean]}"
 5155 |  32 |             for idx, _type in enumerate(AutocleanType, start=1)
 5156 |  33 |         )
 5157 |  34 | 
 5158 |  35 |         _e.description += f"```{_d}```\n"
 5159 |  36 |         _e.description += f"```03. Clean At: {autoclean_time}```"
 5160 |  37 |         _e.set_footer(text=f"Page - {' / '.join(await self.record.scrim_posi())}")
 5161 |  38 | 
 5162 |  39 |         return _e
 5163 |  40 | 
 5164 |  41 |     async def refresh_view(self):
 5165 |  42 |         await self.record.refresh_from_db()
 5166 |  43 | 
 5167 |  44 |         await self._add_buttons()
 5168 |  45 |         try:
 5169 |  46 |             self.message = await self.message.edit(embed=await self.initial_embed)
 5170 |  47 |         except discord.HTTPException:
 5171 |  48 |             await self.on_timeout()
 5172 |  49 | 
 5173 |  50 |     async def _add_buttons(self):
 5174 |  51 |         self.clear_items()
 5175 |  52 | 
 5176 |  53 |         self.add_item(OnOne())
 5177 |  54 |         self.add_item(OnTwo())
 5178 |  55 |         self.add_item(OnThree())
 5179 |  56 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
 5180 |  57 |             self.add_item(Prev(self.ctx, 2))
 5181 |  58 |             self.add_item(SkipTo(self.ctx, 2))
 5182 |  59 |             self.add_item(Next(self.ctx, 2))
 5183 |  60 | 
 5184 |  61 |         self.add_item(Back())
 5185 |  62 | 
 5186 |  63 | 
 5187 |  64 | class OnOne(ScrimsButton):
 5188 |  65 |     def __init__(self):
 5189 |  66 |         super().__init__(emoji=kd(1))
 5190 |  67 | 
 5191 |  68 |     async def callback(self, interaction: discord.Interaction):
 5192 |  69 |         await interaction.response.defer()
 5193 |  70 |         func = (ArrayAppend, ArrayRemove)[AutocleanType.channel in self.view.record.autoclean]
 5194 |  71 |         await Scrim.filter(pk=self.view.record.id).update(autoclean=func("autoclean", AutocleanType.channel))
 5195 |  72 |         await self.view.refresh_view()
 5196 |  73 | 
 5197 |  74 |         await self.view.ctx.success(
 5198 |  75 |             f"Registration channel will {('not be','be')[AutocleanType.channel in self.view.record.autoclean]} autocleaned.",
 5199 |  76 |             4,
 5200 |  77 |         )
 5201 |  78 | 
 5202 |  79 | 
 5203 |  80 | class OnTwo(ScrimsButton):
 5204 |  81 |     def __init__(self):
 5205 |  82 |         super().__init__(emoji=kd(2))
 5206 |  83 | 
 5207 |  84 |     async def callback(self, interaction: discord.Interaction):
 5208 |  85 |         await interaction.response.defer()
 5209 |  86 | 
 5210 |  87 |         func = (ArrayAppend, ArrayRemove)[AutocleanType.role in self.view.record.autoclean]
 5211 |  88 |         await Scrim.filter(pk=self.view.record.id).update(autoclean=func("autoclean", AutocleanType.role))
 5212 |  89 |         await self.view.refresh_view()
 5213 |  90 | 
 5214 |  91 |         await self.view.ctx.success(
 5215 |  92 |             f"Scrim role will {('not be','be')[AutocleanType.role in self.view.record.autoclean]} removed from everyone.",
 5216 |  93 |             4,
 5217 |  94 |         )
 5218 |  95 | 
 5219 |  96 | 
 5220 |  97 | class OnThree(ScrimsButton):
 5221 |  98 |     def __init__(self):
 5222 |  99 |         super().__init__(emoji=kd(3))
 5223 | 100 | 
 5224 | 101 |     async def callback(self, interaction: discord.Interaction):
 5225 | 102 |         await interaction.response.defer()
 5226 | 103 |         m = await self.view.ctx.simple(
 5227 | 104 |             "At what time do you want me to run autoclean?\n\nTime examples:",
 5228 | 105 |             image="https://cdn.discordapp.com/attachments/851846932593770496/958291942062587934/timex.gif",
 5229 | 106 |             footer="Time is according to Indian Standard Time (UTC+05:30)",
 5230 | 107 |         )
 5231 | 108 |         t = await time_input(self.view.ctx, delete_after=True)
 5232 | 109 |         await self.view.ctx.safe_delete(m)
 5233 | 110 |         self.view.record.autoclean_time = t
 5234 | 111 | 
 5235 | 112 |         await Timer.filter(extra={"args": [], "kwargs": {"scrim_id": self.view.record.id}}, event="autoclean").delete()
 5236 | 113 | 
 5237 | 114 |         await self.view.bot.reminders.create_timer(t, "autoclean", scrim_id=self.view.record.id)
 5238 | 115 | 
 5239 | 116 |         await self.view.record.make_changes(autoclean_time=t)
 5240 | 117 |         await self.view.refresh_view()
 5241 | 118 | 
 5242 | 119 | 
 5243 | 120 | class Back(ScrimsButton):
 5244 | 121 |     def __init__(self):
 5245 | 122 |         super().__init__(label="Back", style=discord.ButtonStyle.red, row=2)
 5246 | 123 | 
 5247 | 124 |     async def callback(self, interaction: discord.Interaction):
 5248 | 125 |         await interaction.response.defer()
 5249 | 126 |         self.view.stop()
 5250 | 127 | 
 5251 | 128 |         from ._edit import ScrimsEditor
 5252 | 129 | 
 5253 | 130 |         v = ScrimsEditor(self.view.ctx, self.view.record)
 5254 | 131 |         await v._add_buttons()
 5255 | 132 |         v.message = await self.view.message.edit(embed=await v.initial_message, view=v)
 5256 | 133 | 
 5257 | 
 5258 | 
 5259 | --------------------------------------------------------------------------------
 5260 | /cogs/esports/views/scrims/_ban.py:
 5261 | --------------------------------------------------------------------------------
 5262 |   1 | from __future__ import annotations
 5263 |   2 | 
 5264 |   3 | import asyncio
 5265 |   4 | import typing as T
 5266 |   5 | from contextlib import suppress
 5267 |   6 | from datetime import timedelta
 5268 |   7 | 
 5269 |   8 | import dateparser
 5270 |   9 | import discord
 5271 |  10 | 
 5272 |  11 | from core import Context, QuotientView
 5273 |  12 | from models import BanLog, BannedTeam, Scrim
 5274 |  13 | from utils import discord_timestamp, emote, get_chunks, plural, truncate_string
 5275 |  14 | 
 5276 |  15 | from ._base import ScrimsButton, ScrimsView
 5277 |  16 | from ._btns import Discard
 5278 |  17 | from ._pages import *
 5279 |  18 | 
 5280 |  19 | __all__ = ("ScrimBanManager",)
 5281 |  20 | 
 5282 |  21 | 
 5283 |  22 | class ScrimBanManager(ScrimsView):
 5284 |  23 |     def __init__(self, ctx: Context, scrim: Scrim):
 5285 |  24 |         super().__init__(ctx)
 5286 |  25 | 
 5287 |  26 |         self.ctx = ctx
 5288 |  27 |         self.record = scrim
 5289 |  28 | 
 5290 |  29 |     @property
 5291 |  30 |     async def initial_message(self):
 5292 |  31 |         banned = [_ async for _ in self.record.banned_teams.all()]
 5293 |  32 | 
 5294 |  33 |         _e = discord.Embed(color=self.bot.color)
 5295 |  34 |         _e.description = f"**Ban / Unban users from {self.record}**\n\n__Banned:__\n"
 5296 |  35 | 
 5297 |  36 |         t = ""
 5298 |  37 |         for idx, _ in enumerate(banned, 1):
 5299 |  38 |             t += (
 5300 |  39 |                 f"`{idx:02}.` {getattr(self.bot.get_user(_.user_id),'mention','`unknown-user`')} "
 5301 |  40 |                 f"`[{_.user_id}]` - {discord_timestamp(_.expires) if _.expires else 'Lifetime'}\n"
 5302 |  41 |             )
 5303 |  42 | 
 5304 |  43 |         if t != "":
 5305 |  44 |             _e.description += truncate_string(t, 3900)
 5306 |  45 |         else:
 5307 |  46 |             _e.description += "```\nNo Banned user\n```"
 5308 |  47 | 
 5309 |  48 |         _e.set_author(name=f"Page - {' / '.join(await self.record.scrim_posi())}", icon_url=self.bot.user.avatar.url)
 5310 |  49 | 
 5311 |  50 |         return _e
 5312 |  51 | 
 5313 |  52 |     async def refresh_view(self):
 5314 |  53 |         await self._add_buttons()
 5315 |  54 |         try:
 5316 |  55 |             self.message = await self.message.edit(embed=await self.initial_message, view=self)
 5317 |  56 |         except discord.HTTPException:
 5318 |  57 |             await self.on_timeout()
 5319 |  58 | 
 5320 |  59 |     async def _add_buttons(self):
 5321 |  60 |         self.clear_items()
 5322 |  61 | 
 5323 |  62 |         self.add_item(Ban())
 5324 |  63 |         self.add_item(UnBan())
 5325 |  64 |         self.add_item(UnbanAll())
 5326 |  65 | 
 5327 |  66 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
 5328 |  67 |             self.add_item(Prev(self.ctx, 2))
 5329 |  68 |             self.add_item(SkipTo(self.ctx, 2))
 5330 |  69 |             self.add_item(Next(self.ctx, 2))
 5331 |  70 | 
 5332 |  71 |         self.add_item(Discard(self.ctx, "Main Menu", 2))
 5333 |  72 | 
 5334 |  73 | 
 5335 |  74 | class Ban(ScrimsButton):
 5336 |  75 |     def __init__(self):
 5337 |  76 |         super().__init__(label="Ban Users", style=discord.ButtonStyle.red)
 5338 |  77 | 
 5339 |  78 |     async def callback(self, interaction: discord.Interaction):
 5340 |  79 |         modal = MainInput()
 5341 |  80 |         await interaction.response.send_modal(modal)
 5342 |  81 |         await modal.wait()
 5343 |  82 | 
 5344 |  83 |         m = await self.view.ctx.simple("Please mention the users to ban from this scrim.")
 5345 |  84 |         try:
 5346 |  85 |             msg: discord.Message = await self.view.bot.wait_for(
 5347 |  86 |                 "message",
 5348 |  87 |                 check=lambda x: x.author.id == interaction.user.id and x.channel.id == interaction.channel_id,
 5349 |  88 |                 timeout=60.0,
 5350 |  89 |             )
 5351 |  90 |         except asyncio.TimeoutError:
 5352 |  91 |             await self.view.ctx.safe_delete(m)
 5353 |  92 |             return await self.view.ctx.error("Time out, Please try again later.", 5)
 5354 |  93 | 
 5355 |  94 |         await self.view.ctx.safe_delete(m)
 5356 |  95 |         await self.view.ctx.safe_delete(msg)
 5357 |  96 | 
 5358 |  97 |         if not (user_ids := msg.raw_mentions):
 5359 |  98 |             return await self.view.ctx.error("You didn't mention any user to ban.", 5)
 5360 |  99 | 
 5361 | 100 |         expires = None
 5362 | 101 |         if modal.m_time.value:
 5363 | 102 |             with suppress(TypeError):
 5364 | 103 |                 expires = dateparser.parse(
 5365 | 104 |                     "in " + modal.m_time.value,
 5366 | 105 |                     settings={
 5367 | 106 |                         "RELATIVE_BASE": self.view.ctx.bot.current_time,
 5368 | 107 |                         "TIMEZONE": "Asia/Kolkata",
 5369 | 108 |                         "RETURN_AS_TIMEZONE_AWARE": True,
 5370 | 109 |                     },
 5371 | 110 |                 )
 5372 | 111 | 
 5373 | 112 |                 while self.view.bot.current_time > expires:
 5374 | 113 |                     expires = expires + timedelta(hours=24)
 5375 | 114 | 
 5376 | 115 |         count = 0
 5377 | 116 |         for user_id in user_ids:
 5378 | 117 |             if await self.view.record.banned_teams.filter(user_id=user_id).exists():
 5379 | 118 |                 continue
 5380 | 119 | 
 5381 | 120 |             b = await BannedTeam.create(user_id=user_id, expires=expires, reason=modal.m_reason.value)
 5382 | 121 |             await self.view.record.banned_teams.add(b)
 5383 | 122 | 
 5384 | 123 |             if banlog := await BanLog.get_or_none(guild_id=interaction.guild_id):
 5385 | 124 |                 await banlog.log_ban(user_id, interaction.user, [self.view.record], modal.m_reason.value, expires)
 5386 | 125 | 
 5387 | 126 |             if expires:
 5388 | 127 |                 await self.view.bot.reminders.create_timer(
 5389 | 128 |                     expires,
 5390 | 129 |                     "scrim_ban",
 5391 | 130 |                     scrims=[self.view.record.id],
 5392 | 131 |                     user_id=user_id,
 5393 | 132 |                     mod=interaction.user.id,
 5394 | 133 |                     reason=modal.m_reason.value,
 5395 | 134 |                 )
 5396 | 135 |             count += 1
 5397 | 136 | 
 5398 | 137 |         await self.view.ctx.success(f"Successfuly banned `{plural(count):user|users}` from {self.view.record}.", 6)
 5399 | 138 |         return await self.view.refresh_view()
 5400 | 139 | 
 5401 | 140 | 
 5402 | 141 | class UnBan(ScrimsButton):
 5403 | 142 |     def __init__(self):
 5404 | 143 |         super().__init__(label="Unban Users", style=discord.ButtonStyle.green)
 5405 | 144 | 
 5406 | 145 |     async def callback(self, interaction: discord.Interaction):
 5407 | 146 |         await interaction.response.defer()
 5408 | 147 | 
 5409 | 148 |         if not (banned_teams := await self.view.record.banned_teams.order_by("id")):
 5410 | 149 |             return await self.view.ctx.error("No banned user found.", 5)
 5411 | 150 | 
 5412 | 151 |         v = QuotientView(self.view.ctx)
 5413 | 152 |         for chunk in get_chunks(banned_teams, 25):
 5414 | 153 |             v.add_item(BanSelector(self.view.ctx, chunk))
 5415 | 154 |         v.message = await interaction.followup.send("", view=v, ephemeral=True)
 5416 | 155 |         await v.wait()
 5417 | 156 |         if v.custom_id:
 5418 | 157 |             banlog = await BanLog.get_or_none(guild_id=interaction.guild_id)
 5419 | 158 | 
 5420 | 159 |             for b in v.custom_id:
 5421 | 160 |                 slot = await BannedTeam.get_or_none(pk=b)
 5422 | 161 |                 if not slot:
 5423 | 162 |                     continue
 5424 | 163 | 
 5425 | 164 |                 await slot.delete()
 5426 | 165 | 
 5427 | 166 |                 if banlog:
 5428 | 167 |                     await banlog.log_unban(
 5429 | 168 |                         slot.user_id, self.view.ctx.author, [self.view.record], "```No reason given```"
 5430 | 169 |                     )
 5431 | 170 | 
 5432 | 171 |         await self.view.ctx.success(f"Successfully unbanned `{plural(v.custom_id):user|users}`.", 6)
 5433 | 172 |         return await self.view.refresh_view()
 5434 | 173 | 
 5435 | 174 | 
 5436 | 175 | class UnbanAll(ScrimsButton):
 5437 | 176 |     def __init__(self):
 5438 | 177 |         super().__init__(label="Unban All", style=discord.ButtonStyle.blurple)
 5439 | 178 | 
 5440 | 179 |     async def callback(self, interaction: discord.Interaction):
 5441 | 180 |         await interaction.response.defer()
 5442 | 181 | 
 5443 | 182 |         scrims = await Scrim.show_selector(self.view.ctx, multi=True)
 5444 | 183 | 
 5445 | 184 |         scrims = [scrims] if not isinstance(scrims, list) else scrims
 5446 | 185 | 
 5447 | 186 |         prompt = await self.view.ctx.prompt(f"Every banned user will be unbanned from `{plural(scrims):scrim|scrims}`")
 5448 | 187 |         if not prompt:
 5449 | 188 |             return await self.view.ctx.error("OK! Aborting.", 4)
 5450 | 189 | 
 5451 | 190 |         count = 0
 5452 | 191 |         for scrim in scrims:
 5453 | 192 |             bans = await scrim.banned_teams.all()
 5454 | 193 |             await BannedTeam.filter(pk__in=(_.pk for _ in bans)).delete()
 5455 | 194 |             count += len(bans)
 5456 | 195 | 
 5457 | 196 |         await self.view.ctx.success(f"Unbanned `{plural(count):user|users}` from `{plural(len(scrims)):scrim|scrims}`", 5)
 5458 | 197 |         return await self.view.refresh_view()
 5459 | 198 | 
 5460 | 199 | 
 5461 | 200 | class MainInput(discord.ui.Modal, title="Ban Time & Reason"):
 5462 | 201 |     m_time = discord.ui.TextInput(
 5463 | 202 |         label="Ban Duration (Optional)",
 5464 | 203 |         placeholder="Eg: 7 days, 1d, 24h, Friday at 6pm, etc.",
 5465 | 204 |         max_length=256,
 5466 | 205 |         required=False,
 5467 | 206 |         style=discord.TextStyle.short,
 5468 | 207 |     )
 5469 | 208 | 
 5470 | 209 |     m_reason = discord.ui.TextInput(
 5471 | 210 |         label="Reason for Ban (Optional)",
 5472 | 211 |         placeholder="khelne nahi aaye harami :)",
 5473 | 212 |         max_length=256,
 5474 | 213 |         required=False,
 5475 | 214 |         style=discord.TextStyle.short,
 5476 | 215 |     )
 5477 | 216 | 
 5478 | 217 |     async def on_submit(self, interaction: discord.Interaction) -> None:
 5479 | 218 |         await interaction.response.defer()
 5480 | 219 | 
 5481 | 220 | 
 5482 | 221 | class BanSelector(discord.ui.Select):
 5483 | 222 |     view: QuotientView
 5484 | 223 | 
 5485 | 224 |     def __init__(self, ctx: Context, teams: T.List[BannedTeam]):
 5486 | 225 |         _options = []
 5487 | 226 | 
 5488 | 227 |         for _ in teams:
 5489 | 228 |             _options.append(
 5490 | 229 |                 discord.SelectOption(
 5491 | 230 |                     label=f"{getattr(ctx.bot.get_user(_.user_id),'name','unknown-user')} [{_.user_id}]",
 5492 | 231 |                     description=f"Expires: {_.expires.strftime('%d %b %Y %H:%M') if _.expires else 'Never'}",
 5493 | 232 |                     emoji=emote.TextChannel,
 5494 | 233 |                     value=_.id,
 5495 | 234 |                 )
 5496 | 235 |             )
 5497 | 236 | 
 5498 | 237 |         super().__init__(placeholder="Select the players to Unban...", options=_options, max_values=len(_options))
 5499 | 238 | 
 5500 | 239 |     async def callback(self, interaction: discord.Interaction):
 5501 | 240 |         await interaction.response.defer()
 5502 | 241 |         self.view.custom_id = self.values
 5503 | 242 |         self.view.stop()
 5504 | 243 | 
 5505 | 
 5506 | 
 5507 | --------------------------------------------------------------------------------
 5508 | /cogs/esports/views/scrims/_base.py:
 5509 | --------------------------------------------------------------------------------
 5510 |  1 | from __future__ import annotations
 5511 |  2 | 
 5512 |  3 | import discord
 5513 |  4 | 
 5514 |  5 | from models import Scrim
 5515 |  6 | 
 5516 |  7 | from ...views.base import EsportsBaseView
 5517 |  8 | 
 5518 |  9 | __all__ = ("ScrimsView", "ScrimsButton")
 5519 | 10 | 
 5520 | 11 | 
 5521 | 12 | class ScrimsView(EsportsBaseView):
 5522 | 13 |     record: Scrim
 5523 | 14 |     # scrim:Scrim
 5524 | 15 | 
 5525 | 16 |     def __init__(self, ctx, **kwargs):
 5526 | 17 |         super().__init__(ctx, **kwargs)
 5527 | 18 | 
 5528 | 19 |     async def on_error(self, interaction: discord.Interaction, error: Exception, item) -> None:
 5529 | 20 |         print("Scrims View Error:", error)
 5530 | 21 |         self.ctx.bot.dispatch("command_error", self.ctx, error)
 5531 | 22 | 
 5532 | 23 | 
 5533 | 24 | class ScrimsButton(discord.ui.Button):
 5534 | 25 |     view: ScrimsView
 5535 | 26 | 
 5536 | 27 |     def __init__(self, **kwargs):
 5537 | 28 |         super().__init__(**kwargs)
 5538 | 29 | 
 5539 | 
 5540 | 
 5541 | --------------------------------------------------------------------------------
 5542 | /cogs/esports/views/scrims/_btns.py:
 5543 | --------------------------------------------------------------------------------
 5544 |   1 | from __future__ import annotations
 5545 |   2 | 
 5546 |   3 | from datetime import timedelta
 5547 |   4 | 
 5548 |   5 | import discord
 5549 |   6 | from discord import Interaction
 5550 |   7 | 
 5551 |   8 | from core import Context
 5552 |   9 | from models import Scrim
 5553 |  10 | from utils import discord_timestamp as dt
 5554 |  11 | from utils import emote, inputs
 5555 |  12 | from utils import regional_indicator as ri
 5556 |  13 | from utils import truncate_string
 5557 |  14 | 
 5558 |  15 | from ._base import ScrimsButton
 5559 |  16 | 
 5560 |  17 | 
 5561 |  18 | class SetName(ScrimsButton):
 5562 |  19 |     def __init__(self, ctx: Context, letter: str):
 5563 |  20 |         super().__init__(emoji=ri(letter))
 5564 |  21 |         self.ctx = ctx
 5565 |  22 | 
 5566 |  23 |     async def callback(self, interaction: Interaction):
 5567 |  24 |         await interaction.response.defer()
 5568 |  25 |         m = await self.ctx.simple("Enter the new name of this scrim. (`Max 30 characters`)")
 5569 |  26 |         name = await inputs.string_input(self.ctx, delete_after=True)
 5570 |  27 |         await self.ctx.safe_delete(m)
 5571 |  28 |         self.view.record.name = truncate_string(name, 30)
 5572 |  29 | 
 5573 |  30 |         await self.view.refresh_view()
 5574 |  31 | 
 5575 |  32 | 
 5576 |  33 | class RegChannel(ScrimsButton):
 5577 |  34 |     def __init__(self, ctx: Context, letter: str):
 5578 |  35 |         super().__init__(emoji=ri(letter))
 5579 |  36 |         self.ctx = ctx
 5580 |  37 | 
 5581 |  38 |     async def callback(self, interaction: Interaction):
 5582 |  39 |         await interaction.response.defer()
 5583 |  40 |         m = await self.ctx.simple("Mention the channel where you want to take registrations.")
 5584 |  41 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
 5585 |  42 |         await self.ctx.safe_delete(m)
 5586 |  43 | 
 5587 |  44 |         if await Scrim.filter(registration_channel_id=channel.id).exists():
 5588 |  45 |             return await self.ctx.error("That channel is already in use for another scrim.", 5)
 5589 |  46 | 
 5590 |  47 |         self.view.record.registration_channel_id = channel.id
 5591 |  48 | 
 5592 |  49 |         if not self.view.record.slotlist_channel_id:
 5593 |  50 |             self.view.record.slotlist_channel_id = channel.id
 5594 |  51 | 
 5595 |  52 |         await self.view.refresh_view()
 5596 |  53 | 
 5597 |  54 | 
 5598 |  55 | class SlotChannel(ScrimsButton):
 5599 |  56 |     def __init__(self, ctx: Context, letter: str):
 5600 |  57 |         super().__init__(emoji=ri(letter))
 5601 |  58 |         self.ctx = ctx
 5602 |  59 | 
 5603 |  60 |     async def callback(self, interaction: Interaction):
 5604 |  61 |         await interaction.response.defer()
 5605 |  62 | 
 5606 |  63 |         m = await self.ctx.simple("Mention the channel where you want me to post slotlist after registrations.")
 5607 |  64 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
 5608 |  65 |         await self.ctx.safe_delete(m)
 5609 |  66 | 
 5610 |  67 |         self.view.record.slotlist_channel_id = channel.id
 5611 |  68 | 
 5612 |  69 |         await self.view.refresh_view()
 5613 |  70 | 
 5614 |  71 | 
 5615 |  72 | class SetRole(ScrimsButton):
 5616 |  73 |     def __init__(self, ctx: Context, letter: str):
 5617 |  74 |         super().__init__(emoji=ri(letter))
 5618 |  75 |         self.ctx = ctx
 5619 |  76 | 
 5620 |  77 |     async def callback(self, interaction: Interaction):
 5621 |  78 |         await interaction.response.defer()
 5622 |  79 |         m = await self.ctx.simple("Mention the role you want to give for correct registration.")
 5623 |  80 |         role = await inputs.role_input(self.ctx, delete_after=True)
 5624 |  81 |         await self.ctx.safe_delete(m)
 5625 |  82 | 
 5626 |  83 |         self.view.record.role_id = role.id
 5627 |  84 | 
 5628 |  85 |         await self.view.refresh_view()
 5629 |  86 | 
 5630 |  87 | 
 5631 |  88 | class SetMentions(ScrimsButton):
 5632 |  89 |     def __init__(self, ctx: Context, letter: str):
 5633 |  90 |         super().__init__(emoji=ri(letter))
 5634 |  91 |         self.ctx = ctx
 5635 |  92 | 
 5636 |  93 |     async def callback(self, interaction: Interaction):
 5637 |  94 |         await interaction.response.defer()
 5638 |  95 |         m = await self.ctx.simple("How many mentions are required for registration? (Max `10`)")
 5639 |  96 |         self.view.record.required_mentions = await inputs.integer_input(self.ctx, delete_after=True, limits=(0, 10))
 5640 |  97 |         await self.ctx.safe_delete(m)
 5641 |  98 | 
 5642 |  99 |         await self.view.refresh_view()
 5643 | 100 | 
 5644 | 101 | 
 5645 | 102 | class MinLines(ScrimsButton):
 5646 | 103 |     def __init__(self, ctx: Context, letter: str):
 5647 | 104 |         super().__init__(emoji=ri(letter))
 5648 | 105 |         self.ctx = ctx
 5649 | 106 | 
 5650 | 107 |     async def callback(self, interaction: Interaction):
 5651 | 108 |         await interaction.response.defer()
 5652 | 109 |         if not await self.ctx.is_premium_guild():
 5653 | 110 |             return await self.ctx.error(
 5654 | 111 |                 "**Quotient Premium is required to use this feature.**\n\n`Use qpro command to activate Premium.`", 5
 5655 | 112 |             )
 5656 | 113 | 
 5657 | 114 |         m = await self.ctx.simple("How many lines in registration message are required for registration? (Max `100`)")
 5658 | 115 |         self.view.record.required_lines = await inputs.integer_input(self.ctx, delete_after=True, limits=(0, 10))
 5659 | 116 |         await self.ctx.safe_delete(m)
 5660 | 117 | 
 5661 | 118 |         await self.view.refresh_view()
 5662 | 119 | 
 5663 | 120 | 
 5664 | 121 | class DuplicateTags(ScrimsButton):
 5665 | 122 |     def __init__(self, ctx: Context, letter: str):
 5666 | 123 |         super().__init__(emoji=ri(letter))
 5667 | 124 | 
 5668 | 125 |         self.ctx = ctx
 5669 | 126 | 
 5670 | 127 |     async def callback(self, interaction: discord.Interaction):
 5671 | 128 |         await interaction.response.defer()
 5672 | 129 | 
 5673 | 130 |         if not await self.ctx.is_premium_guild():
 5674 | 131 |             return await self.ctx.error(
 5675 | 132 |                 "[Quotient Premium](https://quotientbot.xyz/premium) is required to use this feature.", 4
 5676 | 133 |             )
 5677 | 134 | 
 5678 | 135 |         self.view.record.allow_duplicate_tags = not self.view.record.allow_duplicate_tags
 5679 | 136 |         await self.ctx.success(
 5680 | 137 |             f"Registrations with fake / duplicate mentions are now **{'allowed' if self.view.record.allow_duplicate_tags else 'not allowed'}**.",
 5681 | 138 |             3,
 5682 | 139 |         )
 5683 | 140 |         await self.view.refresh_view()
 5684 | 141 |         await self.view.record.confirm_all_scrims(self.ctx, allow_duplicate_tags=self.view.record.allow_duplicate_tags)
 5685 | 142 | 
 5686 | 143 | 
 5687 | 144 | class TotalSlots(ScrimsButton):
 5688 | 145 |     def __init__(self, ctx: Context, letter: str):
 5689 | 146 |         super().__init__(emoji=ri(letter))
 5690 | 147 |         self.ctx = ctx
 5691 | 148 | 
 5692 | 149 |     async def callback(self, interaction: Interaction):
 5693 | 150 |         await interaction.response.defer()
 5694 | 151 | 
 5695 | 152 |         m = await self.ctx.simple("How many total slots are there? (Max `30`)")
 5696 | 153 |         self.view.record.total_slots = await inputs.integer_input(self.ctx, delete_after=True, limits=(1, 30))
 5697 | 154 |         await self.ctx.safe_delete(m)
 5698 | 155 | 
 5699 | 156 |         await self.view.refresh_view()
 5700 | 157 | 
 5701 | 158 | 
 5702 | 159 | class OpenTime(ScrimsButton):
 5703 | 160 |     def __init__(self, ctx: Context, letter: str):
 5704 | 161 |         super().__init__(emoji=ri(letter))
 5705 | 162 |         self.ctx = ctx
 5706 | 163 | 
 5707 | 164 |     async def callback(self, interaction: Interaction):
 5708 | 165 |         await interaction.response.defer()
 5709 | 166 |         m = await self.ctx.simple(
 5710 | 167 |             "At what time do you want me to open registrations daily?\n\nTime examples:",
 5711 | 168 |             image="https://cdn.discordapp.com/attachments/851846932593770496/958291942062587934/timex.gif",
 5712 | 169 |             footer="Time is according to Indian Standard Time (UTC+05:30)",
 5713 | 170 |         )
 5714 | 171 |         self.view.record.open_time = await inputs.time_input(self.ctx, delete_after=True)
 5715 | 172 |         await self.ctx.safe_delete(m)
 5716 | 173 | 
 5717 | 174 |         await self.view.refresh_view()
 5718 | 175 | 
 5719 | 176 | 
 5720 | 177 | class SetEmojis(ScrimsButton):
 5721 | 178 |     def __init__(self, ctx: Context, letter: str):
 5722 | 179 |         super().__init__(emoji=ri(letter))
 5723 | 180 |         self.ctx = ctx
 5724 | 181 | 
 5725 | 182 |     async def callback(self, interaction: Interaction):
 5726 | 183 |         await interaction.response.defer()
 5727 | 184 |         if not await self.ctx.is_premium_guild():
 5728 | 185 |             return await self.ctx.error(
 5729 | 186 |                 "[Quotient Premium](https://quotientbot.xyz/premium) is required to use this feature.", 4
 5730 | 187 |             )
 5731 | 188 | 
 5732 | 189 |         e = discord.Embed(color=self.ctx.bot.color, title="Edit scrims emojis")
 5733 | 190 | 
 5734 | 191 |         e.description = (
 5735 | 192 |             "Which emojis do you want to use for tick and cross in scrims registrations?\n\n"
 5736 | 193 |             "`Please enter two emojis and separate them with a comma`"
 5737 | 194 |         )
 5738 | 195 | 
 5739 | 196 |         e.set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/888097255607906354/unknown.png")
 5740 | 197 |         e.set_footer(text="The first emoji must be the emoji for tick mark.")
 5741 | 198 | 
 5742 | 199 |         m = await interaction.followup.send(embed=e)
 5743 | 200 |         emojis = await inputs.string_input(self.ctx, delete_after=True)
 5744 | 201 | 
 5745 | 202 |         await self.ctx.safe_delete(m)
 5746 | 203 | 
 5747 | 204 |         emojis = emojis.strip().split(",")
 5748 | 205 |         if not len(emojis) == 2:
 5749 | 206 |             return await interaction.followup.send("You didn't enter the correct format.", ephemeral=True)
 5750 | 207 | 
 5751 | 208 |         check, cross = emojis
 5752 | 209 | 
 5753 | 210 |         for emoji in emojis:
 5754 | 211 |             try:
 5755 | 212 |                 await self.view.message.add_reaction(emoji.strip())
 5756 | 213 |                 await self.view.message.clear_reactions()
 5757 | 214 |             except discord.HTTPException:
 5758 | 215 |                 return await interaction.followup.send("One of the emojis you entered is invalid.", ephemeral=True)
 5759 | 216 | 
 5760 | 217 |         self.view.record.emojis = {"tick": check.strip(), "cross": cross.strip()}
 5761 | 218 |         await self.view.refresh_view()
 5762 | 219 |         await self.view.record.confirm_all_scrims(self.ctx, emojis=self.view.record.emojis)
 5763 | 220 | 
 5764 | 221 | 
 5765 | 222 | class SetAutoclean(ScrimsButton):
 5766 | 223 |     def __init__(self, ctx: Context, letter: str):
 5767 | 224 |         super().__init__(emoji=ri(letter))
 5768 | 225 |         self.ctx = ctx
 5769 | 226 | 
 5770 | 227 |     async def callback(self, interaction: Interaction):
 5771 | 228 |         await interaction.response.defer()
 5772 | 229 | 
 5773 | 230 |         from ._ac import AutocleanView
 5774 | 231 | 
 5775 | 232 |         self.view.stop()
 5776 | 233 | 
 5777 | 234 |         view = AutocleanView(self.ctx, self.view.record)
 5778 | 235 |         await view._add_buttons()
 5779 | 236 |         view.message = await self.view.message.edit(embed=await view.initial_embed, view=view)
 5780 | 237 | 
 5781 | 238 | 
 5782 | 239 | class PingRole(ScrimsButton):
 5783 | 240 |     def __init__(self, ctx: Context, letter: str):
 5784 | 241 |         super().__init__(emoji=ri(letter))
 5785 | 242 |         self.ctx = ctx
 5786 | 243 | 
 5787 | 244 |     async def callback(self, interaction: Interaction):
 5788 | 245 |         await interaction.response.defer()
 5789 | 246 |         if self.view.record.ping_role_id:
 5790 | 247 |             self.view.record.ping_role_id = None
 5791 | 248 |             await self.view.refresh_view()
 5792 | 249 |             return await self.ctx.success("Removed ping-role, click again to set.", 5)
 5793 | 250 | 
 5794 | 251 |         m = await self.ctx.simple("Mention the role you want to ping when registration starts.")
 5795 | 252 |         role = await inputs.role_input(self.ctx, delete_after=True)
 5796 | 253 |         await self.ctx.safe_delete(m)
 5797 | 254 |         self.view.record.ping_role_id = role.id
 5798 | 255 |         await self.view.refresh_view()
 5799 | 256 | 
 5800 | 257 | 
 5801 | 258 | class OpenRole(ScrimsButton):
 5802 | 259 |     def __init__(self, ctx: Context, letter: str):
 5803 | 260 |         super().__init__(emoji=ri(letter))
 5804 | 261 |         self.ctx = ctx
 5805 | 262 | 
 5806 | 263 |     async def callback(self, interaction: Interaction):
 5807 | 264 |         await interaction.response.defer()
 5808 | 265 |         m = await self.ctx.simple("Mention the role you want to open registration for.")
 5809 | 266 |         role = await inputs.role_input(self.ctx, delete_after=True)
 5810 | 267 |         await self.ctx.safe_delete(m)
 5811 | 268 |         self.view.record.open_role_id = role.id
 5812 | 269 |         await self.view.refresh_view()
 5813 | 270 | 
 5814 | 271 | 
 5815 | 272 | class OpenDays(ScrimsButton):
 5816 | 273 |     def __init__(self, ctx: Context, letter: str):
 5817 | 274 |         super().__init__(emoji=ri(letter))
 5818 | 275 |         self.ctx = ctx
 5819 | 276 | 
 5820 | 277 |     async def callback(self, interaction: Interaction):
 5821 | 278 |         from ._days import WeekDays
 5822 | 279 | 
 5823 | 280 |         await interaction.response.defer()
 5824 | 281 |         v = discord.ui.View(timeout=60.0)
 5825 | 282 |         v.add_item(WeekDays())
 5826 | 283 | 
 5827 | 284 |         await interaction.followup.send("Please select the days to open registrations:", view=v, ephemeral=True)
 5828 | 285 |         await v.wait()
 5829 | 286 |         if c := getattr(v, "custom_id", None):
 5830 | 287 |             self.view.record.open_days = c
 5831 | 288 |             await self.view.refresh_view()
 5832 | 289 | 
 5833 | 290 | 
 5834 | 291 | class MultiReg(ScrimsButton):
 5835 | 292 |     def __init__(self, ctx: Context, letter: str):
 5836 | 293 |         super().__init__(emoji=ri(letter))
 5837 | 294 |         self.ctx = ctx
 5838 | 295 | 
 5839 | 296 |     async def callback(self, interaction: Interaction):
 5840 | 297 |         await interaction.response.defer()
 5841 | 298 | 
 5842 | 299 |         self.view.record.multiregister = not self.view.record.multiregister
 5843 | 300 |         await self.ctx.success(
 5844 | 301 |             f"Now users **{'can' if self.view.record.multiregister else 'can not'}** register more than once.", 3
 5845 | 302 |         )
 5846 | 303 |         await self.view.refresh_view()
 5847 | 304 | 
 5848 | 305 |         await self.view.record.confirm_all_scrims(self.ctx, multiregister=self.view.record.multiregister)
 5849 | 306 | 
 5850 | 307 | 
 5851 | 308 | class TeamCompulsion(ScrimsButton):
 5852 | 309 |     def __init__(self, ctx: Context, letter: str):
 5853 | 310 |         super().__init__(emoji=ri(letter))
 5854 | 311 |         self.ctx = ctx
 5855 | 312 | 
 5856 | 313 |     async def callback(self, interaction: Interaction):
 5857 | 314 |         await interaction.response.defer()
 5858 | 315 |         self.view.record.teamname_compulsion = not self.view.record.teamname_compulsion
 5859 | 316 |         await self.ctx.success(
 5860 | 317 |             f"Now Team Name **{'is' if self.view.record.teamname_compulsion else 'is not'}** required to register.", 3
 5861 | 318 |         )
 5862 | 319 |         await self.view.refresh_view()
 5863 | 320 |         await self.view.record.confirm_all_scrims(self.ctx, teamname_compulsion=self.view.record.teamname_compulsion)
 5864 | 321 | 
 5865 | 322 | 
 5866 | 323 | class DuplicateTeam(ScrimsButton):
 5867 | 324 |     def __init__(self, ctx: Context, letter: str):
 5868 | 325 |         super().__init__(emoji=ri(letter))
 5869 | 326 |         self.ctx = ctx
 5870 | 327 | 
 5871 | 328 |     async def callback(self, interaction: Interaction):
 5872 | 329 |         await interaction.response.defer()
 5873 | 330 | 
 5874 | 331 |         self.view.record.no_duplicate_name = not self.view.record.no_duplicate_name
 5875 | 332 |         await self.ctx.success(
 5876 | 333 |             f"Duplicate team names are now **{'not allowed' if self.view.record.no_duplicate_name else 'allowed'}**.", 3
 5877 | 334 |         )
 5878 | 335 |         await self.view.refresh_view()
 5879 | 336 | 
 5880 | 337 |         await self.view.record.confirm_all_scrims(self.ctx, no_duplicate_name=self.view.record.no_duplicate_name)
 5881 | 338 | 
 5882 | 339 | 
 5883 | 340 | class DeleteReject(ScrimsButton):
 5884 | 341 |     def __init__(self, ctx: Context, letter: str):
 5885 | 342 |         super().__init__(emoji=ri(letter))
 5886 | 343 |         self.ctx = ctx
 5887 | 344 | 
 5888 | 345 |     async def callback(self, interaction: Interaction):
 5889 | 346 |         await interaction.response.defer()
 5890 | 347 |         self.view.record.autodelete_rejects = not self.view.record.autodelete_rejects
 5891 | 348 |         await self.ctx.success(
 5892 | 349 |             f"Rejected registrations will **{'be' if self.view.record.autodelete_rejects else 'not be'}** deleted automatically.",
 5893 | 350 |             3,
 5894 | 351 |         )
 5895 | 352 |         await self.view.refresh_view()
 5896 | 353 |         await self.view.record.confirm_all_scrims(self.ctx, autodelete_rejects=self.view.record.autodelete_rejects)
 5897 | 354 | 
 5898 | 355 | 
 5899 | 356 | class DeleteLate(ScrimsButton):
 5900 | 357 |     def __init__(self, ctx: Context, letter: str):
 5901 | 358 |         super().__init__(emoji=ri(letter))
 5902 | 359 |         self.ctx = ctx
 5903 | 360 | 
 5904 | 361 |     async def callback(self, interaction: Interaction):
 5905 | 362 |         await interaction.response.defer()
 5906 | 363 | 
 5907 | 364 |         self.view.record.autodelete_extras = not self.view.record.autodelete_extras
 5908 | 365 |         await self.ctx.success(
 5909 | 366 |             f"Late/Extra registration messages will **{'be' if self.view.record.autodelete_extras else 'not be'}** deleted automatically.",
 5910 | 367 |             3,
 5911 | 368 |         )
 5912 | 369 |         await self.view.refresh_view()
 5913 | 370 |         await self.view.record.confirm_all_scrims(self.ctx, autodelete_extras=self.view.record.autodelete_extras)
 5914 | 371 | 
 5915 | 372 | 
 5916 | 373 | class SlotlistStart(ScrimsButton):
 5917 | 374 |     def __init__(self, ctx: Context, letter: str):
 5918 | 375 |         super().__init__(emoji=ri(letter))
 5919 | 376 |         self.ctx = ctx
 5920 | 377 | 
 5921 | 378 |     async def callback(self, interaction: Interaction):
 5922 | 379 |         await interaction.response.defer()
 5923 | 380 | 
 5924 | 381 |         m = await self.ctx.success(
 5925 | 382 |             f"From which slot number do you want to start the slotlist? (Enter a number between 1 and {self.view.record.total_slots})"
 5926 | 383 |         )
 5927 | 384 |         self.view.record.start_from = await inputs.integer_input(
 5928 | 385 |             self.ctx, delete_after=True, limits=(1, self.view.record.total_slots)
 5929 | 386 |         )
 5930 | 387 | 
 5931 | 388 |         await self.ctx.safe_delete(m)
 5932 | 389 |         await self.view.refresh_view()
 5933 | 390 |         await self.view.record.confirm_all_scrims(self.ctx, start_from=self.view.record.start_from)
 5934 | 391 | 
 5935 | 392 | 
 5936 | 393 | class Discard(ScrimsButton):
 5937 | 394 |     def __init__(self, ctx: Context, label="Back", row: int = None):
 5938 | 395 |         super().__init__(style=discord.ButtonStyle.red, label=label, row=row)
 5939 | 396 |         self.ctx = ctx
 5940 | 397 | 
 5941 | 398 |     async def callback(self, interaction: Interaction):
 5942 | 399 |         await interaction.response.defer()
 5943 | 400 | 
 5944 | 401 |         from .main import ScrimsMain as SM
 5945 | 402 | 
 5946 | 403 |         self.view.stop()
 5947 | 404 |         v = SM(self.ctx)
 5948 | 405 |         v.message = await self.view.message.edit(embed=await v.initial_embed(), view=v)
 5949 | 406 | 
 5950 | 407 | 
 5951 | 408 | class DeleteScrim(ScrimsButton):
 5952 | 409 |     def __init__(self, ctx: Context):
 5953 | 410 |         super().__init__(emoji=emote.trash, label="Delete")
 5954 | 411 |         self.ctx = ctx
 5955 | 412 | 
 5956 | 413 |     async def callback(self, interaction: Interaction):
 5957 | 414 |         await interaction.response.defer()
 5958 | 415 | 
 5959 | 416 |         prompt = await self.ctx.prompt(
 5960 | 417 |             f"{self.view.record} will be permanently deleted. This action is irreversible.",
 5961 | 418 |             title="Are you sure you want to continue?",
 5962 | 419 |         )
 5963 | 420 |         if not prompt:
 5964 | 421 |             return await self.ctx.simple("OK! Not deleting.", 4)
 5965 | 422 | 
 5966 | 423 |         await self.view.record.full_delete()
 5967 | 424 |         await self.ctx.success(f"{self.view.record} has been deleted.", 4)
 5968 | 425 | 
 5969 | 426 |         from .main import ScrimsMain as SM
 5970 | 427 | 
 5971 | 428 |         self.view.stop()
 5972 | 429 |         v = SM(self.ctx)
 5973 | 430 |         v.message = await self.view.message.edit(embed=await v.initial_embed(), view=v)
 5974 | 431 | 
 5975 | 432 | 
 5976 | 433 | class SaveScrim(ScrimsButton):
 5977 | 434 |     def __init__(self, ctx: Context):
 5978 | 435 |         super().__init__(style=discord.ButtonStyle.green, label="Save Scrim", disabled=True)
 5979 | 436 |         self.ctx = ctx
 5980 | 437 | 
 5981 | 438 |     async def callback(self, interaction: Interaction):
 5982 | 439 |         await interaction.response.defer()
 5983 | 440 | 
 5984 | 441 |         self.ctx.bot.loop.create_task(self.view.record.setup_logs())
 5985 | 442 | 
 5986 | 443 |         self.view.record.autoclean_time = self.ctx.bot.current_time.replace(
 5987 | 444 |             hour=4, minute=0, second=0, microsecond=0
 5988 | 445 |         ) + timedelta(days=1)
 5989 | 446 | 
 5990 | 447 |         await self.view.record.save()
 5991 | 448 | 
 5992 | 449 |         await self.ctx.bot.reminders.create_timer(self.view.record.open_time, "scrim_open", scrim_id=self.view.record.id)
 5993 | 450 | 
 5994 | 451 |         await self.ctx.bot.reminders.create_timer(
 5995 | 452 |             self.view.record.autoclean_time, "autoclean", scrim_id=self.view.record.id
 5996 | 453 |         )
 5997 | 454 | 
 5998 | 455 |         self.view.stop()
 5999 | 456 |         await self.ctx.success(f"Scrim was successfully created. (Registration: {dt(self.view.record.open_time)})", 6)
 6000 | 457 | 
 6001 | 458 |         from .main import ScrimsMain
 6002 | 459 | 
 6003 | 460 |         view = ScrimsMain(self.ctx)
 6004 | 461 |         view.message = await self.view.message.edit(embed=await view.initial_embed(), view=view)
 6005 | 462 | 
 6006 | 463 | 
 6007 | 464 | #!add option to add this scrim to cancel claim
 6008 | 465 | 
 6009 | 
 6010 | 
 6011 | --------------------------------------------------------------------------------
 6012 | /cogs/esports/views/scrims/_cdn.py:
 6013 | --------------------------------------------------------------------------------
 6014 |   1 | from __future__ import annotations
 6015 |   2 | 
 6016 |   3 | import typing as T
 6017 |   4 | 
 6018 |   5 | import discord
 6019 |   6 | from pydantic import BaseModel
 6020 |   7 | 
 6021 |   8 | import config
 6022 |   9 | from core import Context
 6023 |  10 | from core.embeds import EmbedBuilder
 6024 |  11 | from models import Scrim
 6025 |  12 | from utils import integer_input
 6026 |  13 | from utils import keycap_digit as kd
 6027 |  14 | 
 6028 |  15 | from ._base import ScrimsView
 6029 |  16 | 
 6030 |  17 | __all__ = ("ScrimsCDN",)
 6031 |  18 | 
 6032 |  19 | 
 6033 |  20 | class CDN(BaseModel):
 6034 |  21 |     status: bool = False
 6035 |  22 |     countdown: int = 5
 6036 |  23 |     msg: dict = ...
 6037 |  24 | 
 6038 |  25 | 
 6039 |  26 | class ScrimsCDN(ScrimsView):
 6040 |  27 |     def __init__(self, ctx: Context, scrim: Scrim):
 6041 |  28 |         super().__init__(ctx, timeout=60.0)
 6042 |  29 | 
 6043 |  30 |         self.scrim = scrim
 6044 |  31 | 
 6045 |  32 |     @property
 6046 |  33 |     def initial_embed(self):
 6047 |  34 |         _e = discord.Embed(
 6048 |  35 |             color=self.bot.color,
 6049 |  36 |         )
 6050 |  37 |         _e.description = "**Registration open countdown editor -** {0}".format(self.scrim)
 6051 |  38 | 
 6052 |  39 |         fields = {
 6053 |  40 |             "ON / OFF": ("`OFF`", "`ON`")[self.scrim.cdn["status"]],
 6054 |  41 |             "Countdown": f"`{self.scrim.cdn['countdown']}s`",
 6055 |  42 |             "Message": "`Click to view or edit`",
 6056 |  43 |         }
 6057 |  44 | 
 6058 |  45 |         for idx, (name, value) in enumerate(fields.items(), 1):
 6059 |  46 |             _e.add_field(
 6060 |  47 |                 name=f"{kd(idx)} {name}:",
 6061 |  48 |                 value=value,
 6062 |  49 |                 inline=False,
 6063 |  50 |             )
 6064 |  51 | 
 6065 |  52 |         return _e
 6066 |  53 | 
 6067 |  54 |     async def refresh_view(self, **kwargs):
 6068 |  55 |         await self.scrim.make_changes(**kwargs)
 6069 |  56 |         self.message = await self.message.edit(embed=self.initial_embed, view=self)
 6070 |  57 | 
 6071 |  58 |     @discord.ui.button(emoji=kd(1))
 6072 |  59 |     async def change_status(self, inter: discord.Interaction, btn: discord.Button):
 6073 |  60 |         await inter.response.defer()
 6074 |  61 | 
 6075 |  62 |         self.scrim.cdn["status"] = not self.scrim.cdn["status"]
 6076 |  63 |         await self.refresh_view(cdn=self.scrim.cdn)
 6077 |  64 | 
 6078 |  65 |     @discord.ui.button(emoji=kd(2))
 6079 |  66 |     async def set_time(self, inter: discord.Interaction, btn: discord.Button):
 6080 |  67 |         await inter.response.defer()
 6081 |  68 | 
 6082 |  69 |         _m = await self.ctx.simple("How many seconds should the countdown be? (Min: `3` Max: `10`)")
 6083 |  70 |         self.scrim.cdn["countdown"] = await integer_input(self.ctx, limits=(5, 15), delete_after=True)
 6084 |  71 |         await self.ctx.safe_delete(_m)
 6085 |  72 |         await self.refresh_view(cdn=self.scrim.cdn)
 6086 |  73 | 
 6087 |  74 |     @discord.ui.button(emoji=kd(3))
 6088 |  75 |     async def set_msg(self, inter: discord.Interaction, btn: discord.Button):
 6089 |  76 |         await inter.response.defer()
 6090 |  77 |         await self.scrim.refresh_from_db()
 6091 |  78 | 
 6092 |  79 |         from ._design import BackBtn, MsgType, SaveMessageBtn, ScrimDesign, SetDefault
 6093 |  80 | 
 6094 |  81 |         if len(self.scrim.cdn["msg"]) <= 1:
 6095 |  82 |             _e = ScrimDesign.default_countdown_msg()
 6096 |  83 | 
 6097 |  84 |         else:
 6098 |  85 |             _e = discord.Embed.from_dict(self.scrim.cdn["msg"])
 6099 |  86 | 
 6100 |  87 |         self.stop()
 6101 |  88 | 
 6102 |  89 |         embed = discord.Embed(color=self.bot.color, title="Click Me if you need Help", url=self.bot.config.SERVER_LINK)
 6103 |  90 |         embed.description = (
 6104 |  91 |             f"\n*You are editing registration close message for {self.scrim}*\n\n"
 6105 |  92 |             "**__Keywords you can use in design:__**\n"
 6106 |  93 |             "`<<t>>` - Seconds left in opening reg (counter).\n"
 6107 |  94 |         )
 6108 |  95 |         await self.message.edit(embed=embed, content="", view=None)
 6109 |  96 | 
 6110 |  97 |         _v = EmbedBuilder(
 6111 |  98 |             self.ctx,
 6112 |  99 |             items=[
 6113 | 100 |                 SaveMessageBtn(self.ctx, self.scrim, MsgType.countdown, self.message),
 6114 | 101 |                 BackBtn(self.ctx, self.scrim, self.message),
 6115 | 102 |                 SetDefault(self.ctx, self.scrim, MsgType.countdown),
 6116 | 103 |             ],
 6117 | 104 |         )
 6118 | 105 | 
 6119 | 106 |         await _v.rendor(embed=_e)
 6120 | 107 | 
 6121 | 108 |     @discord.ui.button(style=discord.ButtonStyle.red, label="Back")
 6122 | 109 |     async def go_back(self, inter: discord.Interaction, btn: discord.Button):
 6123 | 110 |         await inter.response.defer()
 6124 | 111 | 
 6125 | 112 |         from ._design import ScrimDesign
 6126 | 113 | 
 6127 | 114 |         self.stop()
 6128 | 115 |         v = ScrimDesign(self.ctx, self.scrim)
 6129 | 116 |         v.message = await self.message.edit(embed=v.initial_embed, view=v)
 6130 | 117 | 
 6131 | 
 6132 | 
 6133 | --------------------------------------------------------------------------------
 6134 | /cogs/esports/views/scrims/_days.py:
 6135 | --------------------------------------------------------------------------------
 6136 |  1 | from __future__ import annotations
 6137 |  2 | 
 6138 |  3 | import discord
 6139 |  4 | 
 6140 |  5 | from constants import Day
 6141 |  6 | from utils import keycap_digit
 6142 |  7 | 
 6143 |  8 | __all__ = ("WeekDays",)
 6144 |  9 | 
 6145 | 10 | 
 6146 | 11 | class WeekDays(discord.ui.Select):
 6147 | 12 |     def __init__(self, placeholder="Select the weekdays for registrations", max=7):
 6148 | 13 |         _o = []
 6149 | 14 |         for idx, day in enumerate(Day, start=1):
 6150 | 15 |             _o.append(discord.SelectOption(label=day.name.title(), value=day.name, emoji=keycap_digit(idx)))
 6151 | 16 | 
 6152 | 17 |         super().__init__(placeholder=placeholder, max_values=max, options=_o)
 6153 | 18 | 
 6154 | 19 |     async def callback(self, interaction: discord.Interaction):
 6155 | 20 |         await interaction.response.defer()
 6156 | 21 |         self.view.stop()
 6157 | 22 | 
 6158 | 23 |         self.view.custom_id = [Day(_) for _ in self.values]
 6159 | 24 | 
 6160 | 
 6161 | 
 6162 | --------------------------------------------------------------------------------
 6163 | /cogs/esports/views/scrims/_design.py:
 6164 | --------------------------------------------------------------------------------
 6165 |   1 | from __future__ import annotations
 6166 |   2 | 
 6167 |   3 | import typing as T
 6168 |   4 | from enum import Enum
 6169 |   5 | 
 6170 |   6 | import discord
 6171 |   7 | 
 6172 |   8 | import config
 6173 |   9 | from core import Context
 6174 |  10 | from core.embeds import EmbedBuilder
 6175 |  11 | from models import Scrim
 6176 |  12 | from utils import regional_indicator as ri
 6177 |  13 | 
 6178 |  14 | from ._base import ScrimsButton, ScrimsView
 6179 |  15 | from ._btns import Discard
 6180 |  16 | from ._cdn import ScrimsCDN
 6181 |  17 | from ._formatter import show_slotlist_formatter
 6182 |  18 | from ._pages import *
 6183 |  19 | 
 6184 |  20 | 
 6185 |  21 | class MsgType(Enum):
 6186 |  22 |     open = "1"
 6187 |  23 |     close = "2"
 6188 |  24 |     countdown = "3"
 6189 |  25 | 
 6190 |  26 | 
 6191 |  27 | class ScrimDesign(ScrimsView):
 6192 |  28 |     def __init__(self, ctx: Context, scrim: Scrim):
 6193 |  29 |         super().__init__(ctx, timeout=60.0)
 6194 |  30 | 
 6195 |  31 |         self.record = scrim
 6196 |  32 |         self.ctx = ctx
 6197 |  33 | 
 6198 |  34 |     @staticmethod
 6199 |  35 |     def default_open_msg():
 6200 |  36 |         return discord.Embed(
 6201 |  37 |             color=config.COLOR,
 6202 |  38 |             title="Registration is now open!",
 6203 |  39 |             description=f"📣 **`<<mentions>>`** mentions required.\n"
 6204 |  40 |             f"📣 Total slots: **`<<slots>>`** [`<<reserved>>` slots reserved]",
 6205 |  41 |         )
 6206 |  42 | 
 6207 |  43 |     @staticmethod
 6208 |  44 |     def default_close_msg():
 6209 |  45 |         return discord.Embed(color=config.COLOR, description="**Registration is now Closed!**")
 6210 |  46 | 
 6211 |  47 |     @staticmethod
 6212 |  48 |     def default_countdown_msg():
 6213 |  49 |         return discord.Embed(color=config.COLOR, description="*Registration is starting in* **`<<t>>` seconds.**")
 6214 |  50 | 
 6215 |  51 |     @property
 6216 |  52 |     async def initial_embed(self):
 6217 |  53 |         _e = discord.Embed(color=0x00FFB3)
 6218 |  54 |         _e.description = (
 6219 |  55 |             f"[**Scrims - Design Settings - {self.record}**]({self.ctx.config.SERVER_LINK})\n"
 6220 |  56 |             "What do you want to design today?\n\n"
 6221 |  57 |             f"{ri('a')} - Registration Open Message\n"
 6222 |  58 |             f"{ri('b')} - Registration Close Message\n"
 6223 |  59 |             # f"{ri('c')} - Registration Open Countdown\n"
 6224 |  60 |             f"{ri('c')} - Slotlist Design\n"
 6225 |  61 |         )
 6226 |  62 |         _e.set_footer(text=f"Page - {' / '.join(await self.record.scrim_posi())}")
 6227 |  63 |         return _e
 6228 |  64 | 
 6229 |  65 |     async def _add_buttons(self):
 6230 |  66 |         self.clear_items()
 6231 |  67 | 
 6232 |  68 |         self.add_item(OpenMessage())
 6233 |  69 |         self.add_item(CloseMessage())
 6234 |  70 |         # self.add_item(CDNmsg())
 6235 |  71 |         self.add_item(SlotlistFormat())
 6236 |  72 | 
 6237 |  73 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
 6238 |  74 |             self.add_item(Prev(self.ctx, 2))
 6239 |  75 |             self.add_item(SkipTo(self.ctx, 2))
 6240 |  76 |             self.add_item(Next(self.ctx, 2))
 6241 |  77 | 
 6242 |  78 |         self.add_item(Discard(self.ctx, "Main Menu", 2))
 6243 |  79 | 
 6244 |  80 |     async def refresh_view(self):
 6245 |  81 |         await self._add_buttons()
 6246 |  82 |         try:
 6247 |  83 |             self.message = await self.message.edit(embed=await self.initial_embed, view=self)
 6248 |  84 |         except discord.HTTPException:
 6249 |  85 |             await self.on_timeout()
 6250 |  86 | 
 6251 |  87 | 
 6252 |  88 | class OpenMessage(ScrimsButton):
 6253 |  89 |     def __init__(self):
 6254 |  90 |         super().__init__(emoji=ri("a"))
 6255 |  91 | 
 6256 |  92 |     async def callback(self, interaction: discord.Interaction):
 6257 |  93 |         await interaction.response.defer()
 6258 |  94 | 
 6259 |  95 |         await self.view.record.refresh_from_db()
 6260 |  96 | 
 6261 |  97 |         if len(self.view.record.open_message) <= 1:
 6262 |  98 |             _e = ScrimDesign.default_open_msg()
 6263 |  99 | 
 6264 | 100 |         else:
 6265 | 101 |             _e = discord.Embed.from_dict(self.view.record.open_message)
 6266 | 102 | 
 6267 | 103 |         self.view.stop()
 6268 | 104 | 
 6269 | 105 |         embed = discord.Embed(color=self.view.bot.color, title="Click me to Get Help", url=config.SERVER_LINK)
 6270 | 106 |         embed.description = (
 6271 | 107 |             f"\n*You are editing registration open message for {self.view.record}*\n\n"
 6272 | 108 |             "**__Keywords you can use in design:__**\n"
 6273 | 109 |             "`<<mentions>>` - Number of mentions required\n"
 6274 | 110 |             "`<<slots>>` - Total slots in this scrim\n"
 6275 | 111 |             "`<<reserved>>` - Number of Reserved slots\n"
 6276 | 112 |             "`<<slotlist>>` - Slotlist Channel mention.\n"
 6277 | 113 |             "`<<mention_banned>>` -  Mention banned users.\n"
 6278 | 114 |             "`<<mention_reserved>>` - Mention reserved slot owners.\n"
 6279 | 115 |         )
 6280 | 116 |         await self.view.message.edit(embed=embed, content="", view=None)
 6281 | 117 | 
 6282 | 118 |         _v = EmbedBuilder(
 6283 | 119 |             self.view.ctx,
 6284 | 120 |             items=[
 6285 | 121 |                 SaveMessageBtn(self.view.ctx, self.view.record, MsgType.open, self.view.message),
 6286 | 122 |                 BackBtn(self.view.ctx, self.view.record, self.view.message),
 6287 | 123 |                 SetDefault(self.view.ctx, self.view.record, MsgType.open),
 6288 | 124 |             ],
 6289 | 125 |         )
 6290 | 126 | 
 6291 | 127 |         await _v.rendor(embed=_e)
 6292 | 128 | 
 6293 | 129 | 
 6294 | 130 | class CloseMessage(ScrimsButton):
 6295 | 131 |     def __init__(self):
 6296 | 132 |         super().__init__(emoji=ri("b"))
 6297 | 133 | 
 6298 | 134 |     async def callback(self, interaction: discord.Interaction):
 6299 | 135 |         await interaction.response.defer()
 6300 | 136 | 
 6301 | 137 |         await self.view.record.refresh_from_db()
 6302 | 138 | 
 6303 | 139 |         if len(self.view.record.close_message) <= 1:
 6304 | 140 |             _e = ScrimDesign.default_close_msg()
 6305 | 141 | 
 6306 | 142 |         else:
 6307 | 143 |             _e = discord.Embed.from_dict(self.view.record.close_message)
 6308 | 144 | 
 6309 | 145 |         self.view.stop()
 6310 | 146 |         embed = discord.Embed(
 6311 | 147 |             color=self.view.bot.color, title="Click Me if you need Help", url=self.view.bot.config.SERVER_LINK
 6312 | 148 |         )
 6313 | 149 |         embed.description = (
 6314 | 150 |             f"\n*You are editing registration close message for {self.view.record}*\n\n"
 6315 | 151 |             "**__Keywords you can use in design:__**\n"
 6316 | 152 |             "`<<slots>>` - Total slots in this scrim.\n"
 6317 | 153 |             "`<<filled>>` - Number of slots filled during registration.\n"
 6318 | 154 |             "`<<time_taken>>` - Time taken in registration.\n"
 6319 | 155 |             "`<<open_time>>` - Next day's registration time."
 6320 | 156 |         )
 6321 | 157 |         await self.view.message.edit(embed=embed, content="", view=None)
 6322 | 158 | 
 6323 | 159 |         _v = EmbedBuilder(
 6324 | 160 |             self.view.ctx,
 6325 | 161 |             items=[
 6326 | 162 |                 SaveMessageBtn(self.view.ctx, self.view.record, MsgType.close, self.view.message),
 6327 | 163 |                 BackBtn(self.view.ctx, self.view.record, self.view.message),
 6328 | 164 |                 SetDefault(self.view.ctx, self.view.record, MsgType.close),
 6329 | 165 |             ],
 6330 | 166 |         )
 6331 | 167 | 
 6332 | 168 |         await _v.rendor(embed=_e)
 6333 | 169 | 
 6334 | 170 | 
 6335 | 171 | class CDNmsg(ScrimsButton):
 6336 | 172 |     def __init__(self):
 6337 | 173 |         super().__init__(emoji=ri("c"))
 6338 | 174 | 
 6339 | 175 |     async def callback(self, interaction: discord.Interaction):
 6340 | 176 |         await interaction.response.defer()
 6341 | 177 | 
 6342 | 178 |         self.view.stop()
 6343 | 179 |         v = ScrimsCDN(self.view.ctx, self.view.record)
 6344 | 180 |         v.message = await self.view.message.edit(embed=v.initial_embed, view=v)
 6345 | 181 | 
 6346 | 182 | 
 6347 | 183 | class SlotlistFormat(ScrimsButton):
 6348 | 184 |     def __init__(self):
 6349 | 185 |         super().__init__(emoji=ri("c"))
 6350 | 186 | 
 6351 | 187 |     async def callback(self, interaction: discord.Interaction):
 6352 | 188 |         await interaction.response.defer()
 6353 | 189 |         self.view.stop()
 6354 | 190 |         await show_slotlist_formatter(self.view.ctx, self.view.record, self.view.message)
 6355 | 191 | 
 6356 | 192 | 
 6357 | 193 | class SaveMessageBtn(discord.ui.Button):
 6358 | 194 |     view: EmbedBuilder
 6359 | 195 | 
 6360 | 196 |     def __init__(self, ctx: Context, scrim: Scrim, _type: MsgType, msg: discord.Message = None):
 6361 | 197 |         super().__init__(style=discord.ButtonStyle.green, label="Save this design")
 6362 | 198 |         self.scrim = scrim
 6363 | 199 | 
 6364 | 200 |         self.ctx = ctx
 6365 | 201 |         self.msg = msg
 6366 | 202 |         self._type = _type
 6367 | 203 | 
 6368 | 204 |     async def callback(self, interaction: discord.Interaction):
 6369 | 205 |         await interaction.response.defer()
 6370 | 206 | 
 6371 | 207 |         await self.ctx.simple(f"Saving Changes...", 2)
 6372 | 208 | 
 6373 | 209 |         if self._type == MsgType.open:
 6374 | 210 |             await self.scrim.make_changes(open_message=self.view.formatted)
 6375 | 211 |             await self.scrim.confirm_all_scrims(self.ctx, open_message=self.view.formatted)
 6376 | 212 | 
 6377 | 213 |         elif self._type == MsgType.close:
 6378 | 214 |             await self.scrim.make_changes(close_message=self.view.formatted)
 6379 | 215 |             await self.scrim.confirm_all_scrims(self.ctx, close_message=self.view.formatted)
 6380 | 216 | 
 6381 | 217 |         elif self._type == MsgType.countdown:
 6382 | 218 |             self.scrim.cdn["msg"] = self.view.formatted
 6383 | 219 |             await self.scrim.make_changes(cdn=self.scrim.cdn)
 6384 | 220 |             await self.scrim.confirm_all_scrims(self.ctx, cdn=self.scrim.cdn)
 6385 | 221 | 
 6386 | 222 |         await self.ctx.success(f"Saved!", 2)
 6387 | 223 | 
 6388 | 224 |         self.view.stop()
 6389 | 225 | 
 6390 | 226 |         if self.msg:
 6391 | 227 |             await self.ctx.safe_delete(self.msg)
 6392 | 228 | 
 6393 | 229 |         v = ScrimDesign(self.ctx, self.scrim)
 6394 | 230 |         await v._add_buttons()
 6395 | 231 |         v.message = await self.view.message.edit(embed=await v.initial_embed, view=v)
 6396 | 232 | 
 6397 | 233 | 
 6398 | 234 | class BackBtn(discord.ui.Button):
 6399 | 235 |     view: EmbedBuilder
 6400 | 236 | 
 6401 | 237 |     def __init__(self, ctx: Context, scrim: Scrim, msg: discord.Message = None):
 6402 | 238 |         super().__init__(style=discord.ButtonStyle.red, label="Exit")
 6403 | 239 |         self.ctx = ctx
 6404 | 240 |         self.scrim = scrim
 6405 | 241 | 
 6406 | 242 |         self.msg = msg
 6407 | 243 | 
 6408 | 244 |     async def callback(self, interaction: discord.Interaction):
 6409 | 245 |         await interaction.response.defer()
 6410 | 246 |         prompt = await self.ctx.prompt("All unsaved changes will be lost forever. Do you still want to continue?")
 6411 | 247 |         if not prompt:
 6412 | 248 |             return await self.ctx.simple("OK. Not Exiting.", 4)
 6413 | 249 | 
 6414 | 250 |         self.view.stop()
 6415 | 251 | 
 6416 | 252 |         if self.msg:
 6417 | 253 |             await self.ctx.safe_delete(self.msg)
 6418 | 254 |         v = ScrimDesign(self.ctx, self.scrim)
 6419 | 255 |         await v._add_buttons()
 6420 | 256 |         v.message = await self.view.message.edit(embed=await v.initial_embed, view=v)
 6421 | 257 | 
 6422 | 258 | 
 6423 | 259 | class SetDefault(discord.ui.Button):
 6424 | 260 |     view: EmbedBuilder
 6425 | 261 | 
 6426 | 262 |     def __init__(self, ctx: Context, scrim: Scrim, _type: MsgType):
 6427 | 263 |         super().__init__(style=discord.ButtonStyle.blurple, label="Reset to default")
 6428 | 264 |         self._type = _type
 6429 | 265 |         self.scrim = scrim
 6430 | 266 |         self.ctx = ctx
 6431 | 267 | 
 6432 | 268 |     async def callback(self, interaction: discord.Interaction):
 6433 | 269 |         await interaction.response.defer()
 6434 | 270 |         prompt = await self.ctx.prompt("All changes will be lost. Do you still want to continue?")
 6435 | 271 |         if not prompt:
 6436 | 272 |             return await self.ctx.simple("OK, not reseting.", 3)
 6437 | 273 | 
 6438 | 274 |         if self._type == MsgType.open:
 6439 | 275 |             self.view.embed = ScrimDesign.default_open_msg()
 6440 | 276 | 
 6441 | 277 |         elif self._type == MsgType.close:
 6442 | 278 |             self.view.embed = ScrimDesign.default_close_msg()
 6443 | 279 | 
 6444 | 280 |         else:
 6445 | 281 |             self.view.embed = ScrimDesign.default_countdown_msg()
 6446 | 282 | 
 6447 | 283 |         self.view.content = ""
 6448 | 284 |         await self.view.refresh_view()
 6449 | 285 |         await self.ctx.success("Message set to default. Click `Save` to save this design.", 4)
 6450 | 286 | 
 6451 | 
 6452 | 
 6453 | --------------------------------------------------------------------------------
 6454 | /cogs/esports/views/scrims/_edit.py:
 6455 | --------------------------------------------------------------------------------
 6456 |   1 | from __future__ import annotations
 6457 |   2 | 
 6458 |   3 | import typing as T
 6459 |   4 | from string import ascii_uppercase
 6460 |   5 | 
 6461 |   6 | import discord
 6462 |   7 | 
 6463 |   8 | from core import Context
 6464 |   9 | from models import Scrim, Timer
 6465 |  10 | from utils import discord_timestamp as dt
 6466 |  11 | from utils import regional_indicator as ri
 6467 |  12 | 
 6468 |  13 | from ._base import ScrimsView
 6469 |  14 | from ._btns import *
 6470 |  15 | from ._pages import *
 6471 |  16 | 
 6472 |  17 | 
 6473 |  18 | class ScrimsEditor(ScrimsView):
 6474 |  19 |     def __init__(self, ctx: Context, scrim: Scrim):
 6475 |  20 |         super().__init__(ctx, timeout=60.0)
 6476 |  21 |         self.ctx = ctx
 6477 |  22 |         self.record = scrim
 6478 |  23 | 
 6479 |  24 |         self.page_info = ("x", "y")
 6480 |  25 | 
 6481 |  26 |     async def refresh_view(self):
 6482 |  27 |         _d = dict(self.record)
 6483 |  28 | 
 6484 |  29 |         del _d["id"]
 6485 |  30 |         del _d["autoclean"]
 6486 |  31 |         del _d["available_slots"]
 6487 |  32 |         del _d["open_days"]
 6488 |  33 | 
 6489 |  34 |         await Timer.filter(extra={"args": [], "kwargs": {"scrim_id": self.record.id}}, event="scrim_open").delete()
 6490 |  35 |         await self.bot.reminders.create_timer(_d["open_time"], "scrim_open", scrim_id=self.record.id)
 6491 |  36 | 
 6492 |  37 |         await self.bot.db.execute(
 6493 |  38 |             """UPDATE public."sm.scrims" SET open_days = $1 WHERE id = $2""",
 6494 |  39 |             [_.value for _ in self.record.open_days],
 6495 |  40 |             self.record.id,
 6496 |  41 |         )
 6497 |  42 | 
 6498 |  43 |         await self.record.make_changes(**_d)
 6499 |  44 | 
 6500 |  45 |         await self._add_buttons()
 6501 |  46 |         try:
 6502 |  47 |             self.message = await self.message.edit(embed=await self.initial_message, view=self)
 6503 |  48 |         except discord.HTTPException:
 6504 |  49 |             await self.on_timeout()
 6505 |  50 | 
 6506 |  51 |     @property
 6507 |  52 |     async def initial_message(self):
 6508 |  53 |         scrim = self.record
 6509 |  54 | 
 6510 |  55 |         _e = discord.Embed(color=0x00FFB3, url=self.ctx.config.SERVER_LINK)
 6511 |  56 |         _e.title = "Scrims Editor - Edit Settings"
 6512 |  57 | 
 6513 |  58 |         fields = {
 6514 |  59 |             "Name": "`{0}`".format(scrim.name),
 6515 |  60 |             "Registration Channel": getattr(scrim.registration_channel, "mention", "`channel-deleted`"),
 6516 |  61 |             "Slotlist Channel": getattr(scrim.slotlist_channel, "mention", "`deleted-channel`"),
 6517 |  62 |             "Success Role": getattr(scrim.role, "mention", "`role-deleted`"),
 6518 |  63 |             "Mentions": f"`{scrim.required_mentions}`",
 6519 |  64 |             "Slots": f"`{scrim.total_slots}`",
 6520 |  65 |             "Open Time": f"{dt(scrim.open_time,'t')} ({dt(scrim.open_time)})",
 6521 |  66 |             f"Reactions {self.bot.config.PRIME_EMOJI}": f"{scrim.check_emoji},{scrim.cross_emoji}",
 6522 |  67 |             "Ping Role": getattr(scrim.ping_role, "mention", "`Not-Set`"),
 6523 |  68 |             "Open Role": getattr(scrim.open_role, "mention", "`role-deleted`"),
 6524 |  69 |             "Multi-Register": ("`Not allowed!`", "`Allowed`")[scrim.multiregister],
 6525 |  70 |             "Team Compulsion": ("`No!`", "`Yes!`")[scrim.teamname_compulsion],
 6526 |  71 |             "Duplicate Team Name": ("`Allowed`", "`Not allowed!`")[scrim.no_duplicate_name],
 6527 |  72 |             "Autodelete Rejected": ("`No!`", "`Yes!`")[scrim.autodelete_rejects],
 6528 |  73 |             "Autodelete Late Messages": ("`No!`", "`Yes!`")[scrim.autodelete_extras],
 6529 |  74 |             "Slotlist Start from": "`{}`".format(scrim.start_from),
 6530 |  75 |             "Autoclean": f"{dt(scrim.autoclean_time,'t')} (`{', '.join(_.name.title() for _ in scrim.autoclean)}`)"
 6531 |  76 |             if scrim.autoclean_time
 6532 |  77 |             else "`Turned OFF`",
 6533 |  78 |             "Scrim Days": ", ".join(map(lambda x: "`{0}`".format(x.name.title()[:2]), self.record.open_days))
 6534 |  79 |             if self.record.open_days
 6535 |  80 |             else "`Not set`",
 6536 |  81 |             f"Required Lines {self.bot.config.PRIME_EMOJI}": ("`Not set`", "`{0}`".format(scrim.required_lines))[
 6537 |  82 |                 bool(scrim.required_lines)
 6538 |  83 |             ],
 6539 |  84 |             f"Duplicate / Fake Tags {self.bot.config.PRIME_EMOJI}": ("`Not allowed!`", "`Allowed`")[
 6540 |  85 |                 scrim.allow_duplicate_tags
 6541 |  86 |             ],
 6542 |  87 |         }
 6543 |  88 | 
 6544 |  89 |         for idx, (name, value) in enumerate(fields.items()):
 6545 |  90 |             _e.add_field(
 6546 |  91 |                 name=f"{ri(ascii_uppercase[idx])} {name}:",
 6547 |  92 |                 value=value,
 6548 |  93 |             )
 6549 |  94 |         _e.add_field(name="\u200b", value="\u200b")  # invisible field
 6550 |  95 |         _e.set_footer(text=f"Page - {' / '.join(await self.record.scrim_posi())}")
 6551 |  96 |         return _e
 6552 |  97 | 
 6553 |  98 |     async def _add_buttons(self):
 6554 |  99 |         self.clear_items()
 6555 | 100 | 
 6556 | 101 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
 6557 | 102 |             self.add_item(Prev(self.ctx))
 6558 | 103 |             self.add_item(SkipTo(self.ctx))
 6559 | 104 |             self.add_item(Next(self.ctx))
 6560 | 105 | 
 6561 | 106 |         self.add_item(SetName(self.ctx, "a"))
 6562 | 107 |         self.add_item(RegChannel(self.ctx, "b"))
 6563 | 108 |         self.add_item(SlotChannel(self.ctx, "c"))
 6564 | 109 |         self.add_item(SetRole(self.ctx, "d"))
 6565 | 110 |         self.add_item(SetMentions(self.ctx, "e"))
 6566 | 111 |         self.add_item(TotalSlots(self.ctx, "f"))
 6567 | 112 |         self.add_item(OpenTime(self.ctx, "g"))
 6568 | 113 |         self.add_item(SetEmojis(self.ctx, "h"))
 6569 | 114 |         self.add_item(PingRole(self.ctx, "i"))
 6570 | 115 |         self.add_item(OpenRole(self.ctx, "j"))
 6571 | 116 | 
 6572 | 117 |         self.add_item(MultiReg(self.ctx, "k"))
 6573 | 118 |         self.add_item(TeamCompulsion(self.ctx, "l"))
 6574 | 119 |         self.add_item(DuplicateTeam(self.ctx, "m"))
 6575 | 120 |         self.add_item(DeleteReject(self.ctx, "n"))
 6576 | 121 |         self.add_item(DeleteLate(self.ctx, "o"))
 6577 | 122 |         self.add_item(SlotlistStart(self.ctx, "p"))
 6578 | 123 |         self.add_item(SetAutoclean(self.ctx, "q"))
 6579 | 124 |         self.add_item(OpenDays(self.ctx, "r"))
 6580 | 125 |         self.add_item(MinLines(self.ctx, "s"))
 6581 | 126 |         self.add_item(DuplicateTags(self.ctx, "t"))
 6582 | 127 | 
 6583 | 128 |         self.add_item(DeleteScrim(self.ctx))
 6584 | 129 |         self.add_item(Discard(self.ctx, "Main Menu"))
 6585 | 130 | 
 6586 | 
 6587 | 
 6588 | --------------------------------------------------------------------------------
 6589 | /cogs/esports/views/scrims/_formatter.py:
 6590 | --------------------------------------------------------------------------------
 6591 |   1 | from __future__ import annotations
 6592 |   2 | 
 6593 |   3 | import discord
 6594 |   4 | 
 6595 |   5 | from core import Context
 6596 |   6 | from core.embeds import EmbedBuilder
 6597 |   7 | from models import Scrim
 6598 |   8 | 
 6599 |   9 | DEFAULT_MSG = Scrim.default_slotlist_format()
 6600 |  10 | 
 6601 |  11 | __all__ = ("show_slotlist_formatter",)
 6602 |  12 | 
 6603 |  13 | 
 6604 |  14 | async def show_slotlist_formatter(ctx: Context, scrim: Scrim, view_msg: discord.Message):
 6605 |  15 |     await scrim.refresh_from_db()
 6606 |  16 | 
 6607 |  17 |     embed = discord.Embed(color=ctx.bot.color, title="Click me to Get Help", url=ctx.config.SERVER_LINK)
 6608 |  18 |     embed.description = (
 6609 |  19 |         f"\n*You are editing slotlist design for {scrim}*\n\n"
 6610 |  20 |         "**__Keywords you can use in design:__**\n"
 6611 |  21 |         "`<<slots>>` - Slot number and team names (**Most Important**)\n"
 6612 |  22 |         "`<<name>>` -  Name of the scrim\n"
 6613 |  23 |         "`<<open_time>>` - Next day's registration open time.\n"
 6614 |  24 |         "`<<time_taken>>` - Time taken in registration.\n"
 6615 |  25 |     )
 6616 |  26 | 
 6617 |  27 |     await view_msg.edit(embed=embed, content="", view=None)
 6618 |  28 | 
 6619 |  29 |     if len(scrim.slotlist_format) <= 1:
 6620 |  30 |         embed = DEFAULT_MSG
 6621 |  31 |     else:
 6622 |  32 |         embed = discord.Embed.from_dict(scrim.slotlist_format)
 6623 |  33 | 
 6624 |  34 |     _v = EmbedBuilder(
 6625 |  35 |         ctx,
 6626 |  36 |         items=[
 6627 |  37 |             SaveBtn(ctx, scrim, view_msg),
 6628 |  38 |             BackBtn(ctx, scrim, view_msg),
 6629 |  39 |             SetDefault(ctx, scrim),
 6630 |  40 |         ],
 6631 |  41 |     )
 6632 |  42 | 
 6633 |  43 |     await _v.rendor(embed=embed)
 6634 |  44 | 
 6635 |  45 | 
 6636 |  46 | class SaveBtn(discord.ui.Button):
 6637 |  47 |     view: EmbedBuilder
 6638 |  48 | 
 6639 |  49 |     def __init__(self, ctx: Context, scrim: Scrim, msg: discord.Message = None):
 6640 |  50 |         super().__init__(style=discord.ButtonStyle.green, label="Save this design")
 6641 |  51 | 
 6642 |  52 |         self.ctx = ctx
 6643 |  53 |         self.scrim = scrim
 6644 |  54 |         self.msg = msg
 6645 |  55 | 
 6646 |  56 |     async def callback(self, interaction: discord.Interaction):
 6647 |  57 |         await interaction.response.defer()
 6648 |  58 | 
 6649 |  59 |         await self.ctx.simple(f"Saving Changes...", 2)
 6650 |  60 | 
 6651 |  61 |         await self.scrim.make_changes(slotlist_format=self.view.formatted)
 6652 |  62 |         await self.scrim.confirm_all_scrims(self.ctx, slotlist_format=self.view.formatted)
 6653 |  63 | 
 6654 |  64 |         await self.ctx.success(f"Saved your new design!", 2)
 6655 |  65 |         self.view.stop()
 6656 |  66 | 
 6657 |  67 |         if self.msg:
 6658 |  68 |             await self.ctx.safe_delete(self.msg)
 6659 |  69 | 
 6660 |  70 |         from .main import ScrimsMain
 6661 |  71 | 
 6662 |  72 |         v = ScrimsMain(self.ctx)
 6663 |  73 |         v.message = await self.view.message.edit(content="", embed=await v.initial_embed(), view=v)
 6664 |  74 | 
 6665 |  75 | 
 6666 |  76 | class BackBtn(discord.ui.Button):
 6667 |  77 |     view: EmbedBuilder
 6668 |  78 | 
 6669 |  79 |     def __init__(self, ctx: Context, scrim: Scrim, msg: discord.Message = None):
 6670 |  80 |         super().__init__(style=discord.ButtonStyle.red, label="Exit")
 6671 |  81 |         self.ctx = ctx
 6672 |  82 |         self.scrim = scrim
 6673 |  83 | 
 6674 |  84 |         self.msg = msg
 6675 |  85 | 
 6676 |  86 |     async def callback(self, interaction: discord.Interaction):
 6677 |  87 |         await interaction.response.defer()
 6678 |  88 |         prompt = await self.ctx.prompt("All unsaved changes will be lost forever. Do you still want to continue?")
 6679 |  89 |         if not prompt:
 6680 |  90 |             return await self.ctx.simple("OK. Not Exiting.", 4)
 6681 |  91 | 
 6682 |  92 |         self.view.stop()
 6683 |  93 | 
 6684 |  94 |         if self.msg:
 6685 |  95 |             await self.ctx.safe_delete(self.msg)
 6686 |  96 | 
 6687 |  97 |         from .main import ScrimsMain
 6688 |  98 | 
 6689 |  99 |         v = ScrimsMain(self.ctx)
 6690 | 100 |         v.message = await self.view.message.edit(content="", embed=await v.initial_embed(), view=v)
 6691 | 101 | 
 6692 | 102 | 
 6693 | 103 | class SetDefault(discord.ui.Button):
 6694 | 104 |     view: EmbedBuilder
 6695 | 105 | 
 6696 | 106 |     def __init__(self, ctx: Context, scrim: Scrim):
 6697 | 107 |         super().__init__(style=discord.ButtonStyle.blurple, label="Reset to default")
 6698 | 108 | 
 6699 | 109 |         self.scrim = scrim
 6700 | 110 |         self.ctx = ctx
 6701 | 111 | 
 6702 | 112 |     async def callback(self, interaction: discord.Interaction):
 6703 | 113 |         await interaction.response.defer()
 6704 | 114 |         prompt = await self.ctx.prompt("All changes will be lost. Do you still want to continue?")
 6705 | 115 |         if not prompt:
 6706 | 116 |             return await self.ctx.simple("OK, not reseting.", 3)
 6707 | 117 | 
 6708 | 118 |         self.view.embed = DEFAULT_MSG
 6709 | 119 | 
 6710 | 120 |         self.view.content = ""
 6711 | 121 |         await self.view.refresh_view()
 6712 | 122 |         await self.ctx.success("Slotlist design set to default. Click `Save` to save this design.", 4)
 6713 | 123 | 
 6714 | 
 6715 | 
 6716 | --------------------------------------------------------------------------------
 6717 | /cogs/esports/views/scrims/_pages.py:
 6718 | --------------------------------------------------------------------------------
 6719 |  1 | from __future__ import annotations
 6720 |  2 | 
 6721 |  3 | import discord
 6722 |  4 | 
 6723 |  5 | from core import Context
 6724 |  6 | from models import Scrim
 6725 |  7 | 
 6726 |  8 | from ._base import ScrimsButton
 6727 |  9 | 
 6728 | 10 | __all__ = "Next", "Prev", "SkipTo"
 6729 | 11 | 
 6730 | 12 | 
 6731 | 13 | class Next(ScrimsButton):
 6732 | 14 |     def __init__(self, ctx: Context, row: int = None):
 6733 | 15 |         super().__init__(emoji="<:double_right:878668437193359392>", row=row)
 6734 | 16 |         self.ctx = ctx
 6735 | 17 | 
 6736 | 18 |     async def callback(self, interaction: discord.Interaction):
 6737 | 19 |         await interaction.response.defer()
 6738 | 20 | 
 6739 | 21 |         _ids = [_.pk async for _ in Scrim.filter(guild_id=self.ctx.guild.id).order_by("open_time")]
 6740 | 22 |         current = _ids.index(self.view.record.pk)
 6741 | 23 | 
 6742 | 24 |         try:
 6743 | 25 |             next_id = _ids[current + 1]
 6744 | 26 |         except IndexError:
 6745 | 27 |             next_id = _ids[0]
 6746 | 28 | 
 6747 | 29 |         new_scrim = await Scrim.get(pk=next_id)
 6748 | 30 |         if not self.view.record == new_scrim:
 6749 | 31 |             self.view.record = new_scrim
 6750 | 32 |             await self.view.refresh_view()
 6751 | 33 | 
 6752 | 34 | 
 6753 | 35 | class Prev(ScrimsButton):
 6754 | 36 |     def __init__(self, ctx: Context, row: int = None):
 6755 | 37 |         super().__init__(emoji="<:double_left:878668594530099220>", row=row)
 6756 | 38 |         self.ctx = ctx
 6757 | 39 | 
 6758 | 40 |     async def callback(self, interaction: discord.Interaction):
 6759 | 41 |         await interaction.response.defer()
 6760 | 42 | 
 6761 | 43 |         _ids = [_.pk async for _ in Scrim.filter(guild_id=self.ctx.guild.id).order_by("open_time")]
 6762 | 44 |         current = _ids.index(self.view.record.pk)
 6763 | 45 | 
 6764 | 46 |         try:
 6765 | 47 |             next_id = _ids[current - 1]
 6766 | 48 |         except IndexError:
 6767 | 49 |             next_id = _ids[-1]
 6768 | 50 | 
 6769 | 51 |         new_scrim = await Scrim.get(pk=next_id)
 6770 | 52 |         if not self.view.record == new_scrim:
 6771 | 53 |             self.view.record = new_scrim
 6772 | 54 |             await self.view.refresh_view()
 6773 | 55 | 
 6774 | 56 | 
 6775 | 57 | class SkipTo(ScrimsButton):
 6776 | 58 |     def __init__(self, ctx: Context, row: int = None):
 6777 | 59 |         super().__init__(label="Skip to...", row=row)
 6778 | 60 |         self.ctx = ctx
 6779 | 61 | 
 6780 | 62 |     async def callback(self, interaction: discord.Interaction):
 6781 | 63 |         await interaction.response.defer()
 6782 | 64 | 
 6783 | 
 6784 | 
 6785 | --------------------------------------------------------------------------------
 6786 | /cogs/esports/views/scrims/_reserve.py:
 6787 | --------------------------------------------------------------------------------
 6788 |   1 | from __future__ import annotations
 6789 |   2 | 
 6790 |   3 | import typing as T
 6791 |   4 | 
 6792 |   5 | import discord
 6793 |   6 | 
 6794 |   7 | from core import Context
 6795 |   8 | from models import ReservedSlot, Scrim
 6796 |   9 | from utils import BetterFutureTime, QuoMember, emote, string_input, truncate_string
 6797 |  10 | 
 6798 |  11 | from ._base import ScrimsButton, ScrimsView
 6799 |  12 | from ._btns import Discard
 6800 |  13 | from ._pages import *
 6801 |  14 | 
 6802 |  15 | __all__ = ("ScrimsSlotReserve",)
 6803 |  16 | 
 6804 |  17 | 
 6805 |  18 | class ScrimsSlotReserve(ScrimsView):
 6806 |  19 |     def __init__(self, ctx: Context, scrim: Scrim):
 6807 |  20 |         super().__init__(ctx)
 6808 |  21 | 
 6809 |  22 |         self.ctx = ctx
 6810 |  23 |         self.record = scrim
 6811 |  24 | 
 6812 |  25 |     @property
 6813 |  26 |     async def initial_embed(self):
 6814 |  27 |         _e = discord.Embed(color=self.bot.color)
 6815 |  28 |         _e.description = f"**{self.record}  -  Reserved Slots**\n\n"
 6816 |  29 | 
 6817 |  30 |         reserved = await self.record.reserved_slots.order_by("num")
 6818 |  31 |         _l = []
 6819 |  32 |         for _ in range(self.record.start_from, self.record.total_slots + self.record.start_from):
 6820 |  33 |             team_name = next(
 6821 |  34 |                 (
 6822 |  35 |                     f"{i.team_name} [{'Lifetime' if not i.expires else i.expires.strftime('%b/%d')}]"
 6823 |  36 |                     for i in reserved
 6824 |  37 |                     if i.num == _
 6825 |  38 |                 ),
 6826 |  39 |                 "❌",
 6827 |  40 |             )
 6828 |  41 |             _l.append(f"Slot {_:02}  -->  " + team_name + "\n")
 6829 |  42 | 
 6830 |  43 |         _e.description += f"```{''.join(_l)}```"
 6831 |  44 | 
 6832 |  45 |         _e.set_footer(text=f"Page - {' / '.join(await self.record.scrim_posi())}")
 6833 |  46 |         return _e
 6834 |  47 | 
 6835 |  48 |     async def refresh_view(self):
 6836 |  49 |         await self.add_buttons()
 6837 |  50 |         try:
 6838 |  51 |             self.message = await self.message.edit(embed=await self.initial_embed, view=self)
 6839 |  52 |         except discord.HTTPException:
 6840 |  53 |             await self.on_timeout()
 6841 |  54 | 
 6842 |  55 |     async def add_buttons(self):
 6843 |  56 |         self.clear_items()
 6844 |  57 | 
 6845 |  58 |         self.add_item(NewReserve(self.ctx))
 6846 |  59 | 
 6847 |  60 |         self.add_item(RemoveReserve(self.ctx, not bool(await self.record.reserved_slots.all().count())))
 6848 |  61 | 
 6849 |  62 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
 6850 |  63 |             self.add_item(Prev(self.ctx, 2))
 6851 |  64 |             self.add_item(SkipTo(self.ctx, 2))
 6852 |  65 |             self.add_item(Next(self.ctx, 2))
 6853 |  66 | 
 6854 |  67 |         self.add_item(Discard(self.ctx, "Main Menu", 2))
 6855 |  68 | 
 6856 |  69 | 
 6857 |  70 | class NewReserve(ScrimsButton):
 6858 |  71 |     view: ScrimsSlotReserve
 6859 |  72 | 
 6860 |  73 |     def __init__(self, ctx: Context):
 6861 |  74 |         super().__init__(style=discord.ButtonStyle.green, label="Reserve Slot(s)")
 6862 |  75 | 
 6863 |  76 |         self.ctx = ctx
 6864 |  77 | 
 6865 |  78 |     async def callback(self, interaction: discord.Interaction):
 6866 |  79 |         await interaction.response.defer()
 6867 |  80 | 
 6868 |  81 |         m = await self.ctx.simple(
 6869 |  82 |             "Enter the slot details you want to reserve in the following format:\n"
 6870 |  83 |             "> `slot_number`,`team_name`, `team_owner`, `time to reserve`\n\n"
 6871 |  84 |             "Enter `none` in place of:\n"
 6872 |  85 |             "- `team owner` if you want the slot be a management slot.\n"
 6873 |  86 |             "- `time to reserve` if you want the reserve time to never expire.\n\n"
 6874 |  87 |             "\n*don't forget to separate everything with comma (`,`)*\n",
 6875 |  88 |             image="https://cdn.discordapp.com/attachments/851846932593770496/988408404341039134/reserve_help.gif",
 6876 |  89 |         )
 6877 |  90 | 
 6878 |  91 |         slots = await string_input(self.ctx, delete_after=True)
 6879 |  92 |         await self.ctx.safe_delete(m)
 6880 |  93 | 
 6881 |  94 |         if slots.strip().lower() == "cancel":
 6882 |  95 |             return await self.ctx.error("Alright, Aborting.", 4)
 6883 |  96 | 
 6884 |  97 |         slots = slots.split("\n")
 6885 |  98 |         for _ in slots:
 6886 |  99 |             _ = _.split(",")
 6887 | 100 | 
 6888 | 101 |             try:
 6889 | 102 |                 num, team_name, team_owner, time_to_reserve = _
 6890 | 103 |                 num = int(num.strip())
 6891 | 104 | 
 6892 | 105 |                 team_name = truncate_string(team_name.strip(), 25)
 6893 | 106 | 
 6894 | 107 |             except ValueError:
 6895 | 108 |                 return await self.ctx.error(
 6896 | 109 |                     "The details you entered were not according to the proper format. Please refer to example image.", 6
 6897 | 110 |                 )
 6898 | 111 | 
 6899 | 112 |             owner_id = None
 6900 | 113 |             if team_owner.strip().lower() != "none":
 6901 | 114 |                 owner = await QuoMember().convert(self.ctx, team_owner.strip())
 6902 | 115 |                 owner_id = owner.id
 6903 | 116 | 
 6904 | 117 |             expire = None
 6905 | 118 |             if time_to_reserve.strip().lower() != "none":
 6906 | 119 |                 expire = await BetterFutureTime().convert(self.ctx, time_to_reserve.strip())
 6907 | 120 | 
 6908 | 121 |             if num not in (_range := self.view.record.available_to_reserve):
 6909 | 122 |                 return await self.ctx.error(
 6910 | 123 |                     f"The slot-number you entered (`{num}`) cannot be reserved.\n"
 6911 | 124 |                     f"\nThe slot-number must be a number between `{_range.start}` and `{_range.stop}`",
 6912 | 125 |                     5,
 6913 | 126 |                 )
 6914 | 127 | 
 6915 | 128 |             to_del = await self.view.record.reserved_slots.filter(num=num).first()
 6916 | 129 |             if to_del:
 6917 | 130 |                 await ReservedSlot.filter(pk=to_del.id).delete()
 6918 | 131 | 
 6919 | 132 |             slot = await ReservedSlot.create(num=num, user_id=owner_id, team_name=team_name, expires=expire)
 6920 | 133 |             await self.view.record.reserved_slots.add(slot)
 6921 | 134 |             if expire and owner_id:
 6922 | 135 |                 await self.ctx.bot.reminders.create_timer(
 6923 | 136 |                     expire, "scrim_reserve", scrim_id=self.view.record.id, user_id=owner_id, team_name=team_name, num=num
 6924 | 137 |                 )
 6925 | 138 | 
 6926 | 139 |         await self.view.refresh_view()
 6927 | 140 | 
 6928 | 141 | 
 6929 | 142 | class RemoveReserve(ScrimsButton):
 6930 | 143 |     def __init__(self, ctx: Context, disabled: bool = True):
 6931 | 144 |         super().__init__(style=discord.ButtonStyle.red, label="Remove Reserved", disabled=disabled)
 6932 | 145 | 
 6933 | 146 |         self.ctx = ctx
 6934 | 147 | 
 6935 | 148 |     async def callback(self, interaction: discord.Interaction):
 6936 | 149 |         await interaction.response.defer()
 6937 | 150 | 
 6938 | 151 |         v = ScrimsView(self.ctx)
 6939 | 152 |         v.add_item(SlotSelect(await self.view.record.reserved_slots.all().order_by("num")))
 6940 | 153 | 
 6941 | 154 |         m = await self.ctx.send("Please select the slots to remove from reserved:", view=v)
 6942 | 155 |         await v.wait()
 6943 | 156 | 
 6944 | 157 |         if v.custom_id:
 6945 | 158 |             await ReservedSlot.filter(id__in=v.custom_id).delete()
 6946 | 159 |             await self.view.refresh_view()
 6947 | 160 | 
 6948 | 161 |         await self.ctx.safe_delete(m)
 6949 | 162 | 
 6950 | 163 | 
 6951 | 164 | class SlotSelect(discord.ui.Select):
 6952 | 165 |     view: ScrimsView
 6953 | 166 | 
 6954 | 167 |     def __init__(self, slots: T.List[ReservedSlot]):
 6955 | 168 |         _options = []
 6956 | 169 |         for _ in slots:
 6957 | 170 |             _options.append(
 6958 | 171 |                 discord.SelectOption(
 6959 | 172 |                     label=f"Slot {_.num}",
 6960 | 173 |                     description=f"Team: {_.team_name} ({_.leader or 'No leader'})",
 6961 | 174 |                     value=_.id.__str__(),
 6962 | 175 |                     emoji=emote.TextChannel,
 6963 | 176 |                 )
 6964 | 177 |             )
 6965 | 178 |         super().__init__(
 6966 | 179 |             max_values=len(slots), placeholder="Select the slot(s) you want to remove from reserved", options=_options
 6967 | 180 |         )
 6968 | 181 | 
 6969 | 182 |     async def callback(self, interaction: discord.Interaction):
 6970 | 183 |         await interaction.response.defer()
 6971 | 184 |         self.view.custom_id = self.values
 6972 | 185 |         self.view.stop()
 6973 | 186 | 
 6974 | 
 6975 | 
 6976 | --------------------------------------------------------------------------------
 6977 | /cogs/esports/views/scrims/_slotlist.py:
 6978 | --------------------------------------------------------------------------------
 6979 |  1 | from __future__ import annotations
 6980 |  2 | 
 6981 |  3 | from contextlib import suppress
 6982 |  4 | 
 6983 |  5 | import discord
 6984 |  6 | 
 6985 |  7 | from core import Context
 6986 |  8 | from models import Scrim
 6987 |  9 | from utils import emote, inputs
 6988 | 10 | 
 6989 | 11 | from ._base import ScrimsView
 6990 | 12 | from ._formatter import show_slotlist_formatter
 6991 | 13 | 
 6992 | 14 | __all__ = ("ManageSlotlist",)
 6993 | 15 | 
 6994 | 16 | 
 6995 | 17 | class ManageSlotlist(discord.ui.Select):
 6996 | 18 |     view: ScrimsView
 6997 | 19 | 
 6998 | 20 |     def __init__(self, ctx: Context, scrim: Scrim):
 6999 | 21 |         super().__init__(
 7000 | 22 |             placeholder="Select an option to manage slotlist.",
 7001 | 23 |             options=[
 7002 | 24 |                 discord.SelectOption(
 7003 | 25 |                     label="Repost Slotlist",
 7004 | 26 |                     emoji="🔁",
 7005 | 27 |                     description="Respost slotlist to a channel",
 7006 | 28 |                     value="repost",
 7007 | 29 |                 ),
 7008 | 30 |                 discord.SelectOption(
 7009 | 31 |                     label="Change Design",
 7010 | 32 |                     description="Design slotlist of any scrim.",
 7011 | 33 |                     emoji="⚙️",
 7012 | 34 |                     value="format",
 7013 | 35 |                 ),
 7014 | 36 |                 discord.SelectOption(
 7015 | 37 |                     label="Edit Slotlist",
 7016 | 38 |                     description="Edit slotlist (Remove/Add New teams).",
 7017 | 39 |                     emoji=emote.edit,
 7018 | 40 |                     value="edit",
 7019 | 41 |                 ),
 7020 | 42 |                 discord.SelectOption(
 7021 | 43 |                     label="Go Back",
 7022 | 44 |                     description="Move back to Main Menu",
 7023 | 45 |                     emoji=emote.exit,
 7024 | 46 |                     value="back",
 7025 | 47 |                 ),
 7026 | 48 |             ],
 7027 | 49 |         )
 7028 | 50 | 
 7029 | 51 |         self.ctx = ctx
 7030 | 52 |         self.record = scrim
 7031 | 53 | 
 7032 | 54 |     async def callback(self, interaction: discord.Interaction):
 7033 | 55 |         await interaction.response.defer()
 7034 | 56 | 
 7035 | 57 |         if (selected := self.values[0]) == "repost":
 7036 | 58 |             m = await self.ctx.simple("Mention the channel to send slotlist.")
 7037 | 59 |             channel = await inputs.channel_input(self.ctx, delete_after=True)
 7038 | 60 |             await self.ctx.safe_delete(m)
 7039 | 61 | 
 7040 | 62 |             if not await self.record.teams_registered.count():
 7041 | 63 |                 return await self.ctx.error("No registrations found in {0}.".format(self.record), 5)
 7042 | 64 | 
 7043 | 65 |             m = await self.record.send_slotlist(channel)
 7044 | 66 |             await self.ctx.success("Slotlist sent! [Click to Jump]({0})".format(m.jump_url), 5)
 7045 | 67 | 
 7046 | 68 |             from .main import ScrimsMain
 7047 | 69 | 
 7048 | 70 |             self.view.stop()
 7049 | 71 |             v = ScrimsMain(self.ctx)
 7050 | 72 |             v.message = await self.view.message.edit(content="", embed=await v.initial_embed(), view=v)
 7051 | 73 | 
 7052 | 74 |         elif selected == "format":
 7053 | 75 |             self.view.stop()
 7054 | 76 |             await show_slotlist_formatter(self.ctx, self.record, self.view.message)
 7055 | 77 | 
 7056 | 78 |         elif selected == "edit":
 7057 | 79 |             if self.record.slotlist_message_id == None:
 7058 | 80 |                 return await self.ctx.error("Slotlist not found. Please repost.", 5)
 7059 | 81 | 
 7060 | 82 |             msg = None
 7061 | 83 |             with suppress(discord.HTTPException):
 7062 | 84 |                 msg = await self.ctx.bot.get_or_fetch_message(
 7063 | 85 |                     self.record.slotlist_channel, self.record.slotlist_message_id
 7064 | 86 |                 )
 7065 | 87 |             if not msg:
 7066 | 88 |                 return await self.ctx.error("Slotlist Message not found. Repost first.", 5)
 7067 | 89 | 
 7068 | 90 |             return await self.ctx.success("Click `Edit` button under [slotlist message]({0}).".format(msg.jump_url), 6)
 7069 | 91 | 
 7070 | 92 |         elif selected == "back":
 7071 | 93 |             from .main import ScrimsMain
 7072 | 94 | 
 7073 | 95 |             self.view.stop()
 7074 | 96 |             v = ScrimsMain(self.ctx)
 7075 | 97 |             v.message = await self.view.message.edit(content="", embed=await v.initial_embed(), view=v)
 7076 | 98 | 
 7077 | 
 7078 | 
 7079 | --------------------------------------------------------------------------------
 7080 | /cogs/esports/views/scrims/_toggle.py:
 7081 | --------------------------------------------------------------------------------
 7082 |  1 | from __future__ import annotations
 7083 |  2 | 
 7084 |  3 | import discord
 7085 |  4 | 
 7086 |  5 | from core import Context
 7087 |  6 | from models import Scrim
 7088 |  7 | 
 7089 |  8 | from ._base import ScrimsButton, ScrimsView
 7090 |  9 | from ._btns import Discard
 7091 | 10 | from ._pages import *
 7092 | 11 | 
 7093 | 12 | __all__ = ("ScrimsToggle",)
 7094 | 13 | 
 7095 | 14 | 
 7096 | 15 | class ScrimsToggle(ScrimsView):
 7097 | 16 |     def __init__(self, ctx: Context, scrim: Scrim):
 7098 | 17 |         self.ctx = ctx
 7099 | 18 |         self.record = scrim
 7100 | 19 | 
 7101 | 20 |         super().__init__(ctx)
 7102 | 21 | 
 7103 | 22 |     @property
 7104 | 23 |     async def initial_message(self):
 7105 | 24 |         _e = discord.Embed(color=self.bot.color)
 7106 | 25 |         _e.description = "**Start / Stop scrim registration of {}**".format(self.record)
 7107 | 26 |         _e.set_author(name=f"Page - {' / '.join(await self.record.scrim_posi())}", icon_url=self.bot.user.avatar.url)
 7108 | 27 |         return _e
 7109 | 28 | 
 7110 | 29 |     async def refresh_view(self):
 7111 | 30 |         await self._add_buttons()
 7112 | 31 |         try:
 7113 | 32 |             self.message = await self.message.edit(embed=await self.initial_message, view=self)
 7114 | 33 |         except discord.HTTPException:
 7115 | 34 |             await self.on_timeout()
 7116 | 35 | 
 7117 | 36 |     async def _add_buttons(self):
 7118 | 37 |         self.clear_items()
 7119 | 38 | 
 7120 | 39 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
 7121 | 40 |             self.add_item(Prev(self.ctx))
 7122 | 41 |             self.add_item(SkipTo(self.ctx))
 7123 | 42 |             self.add_item(Next(self.ctx))
 7124 | 43 | 
 7125 | 44 |         self.add_item(StartReg())
 7126 | 45 |         self.add_item(StopReg())
 7127 | 46 |         self.add_item(Discard(self.ctx, "Main Menu", 2))
 7128 | 47 | 
 7129 | 48 | 
 7130 | 49 | class StartReg(ScrimsButton):
 7131 | 50 |     def __init__(self):
 7132 | 51 |         super().__init__(label="Start Reg", style=discord.ButtonStyle.green, row=2)
 7133 | 52 | 
 7134 | 53 |     async def callback(self, interaction: discord.Interaction):
 7135 | 54 |         await interaction.response.defer()
 7136 | 55 | 
 7137 | 56 |         if not self.view.record.closed_at and self.view.record.opened_at:
 7138 | 57 |             return await self.view.ctx.error("Registration is already open. To restart, pls stop registration first.", 4)
 7139 | 58 | 
 7140 | 59 |         try:
 7141 | 60 |             await self.view.record.start_registration()
 7142 | 61 |         except Exception as e:
 7143 | 62 |             return await self.view.ctx.error(e, 10)
 7144 | 63 | 
 7145 | 64 |         else:
 7146 | 65 |             await self.view.ctx.success(f"Registration opened {self.view.record}.", 5)
 7147 | 66 |             await self.view.record.refresh_from_db()
 7148 | 67 | 
 7149 | 68 | 
 7150 | 69 | class StopReg(ScrimsButton):
 7151 | 70 |     def __init__(self):
 7152 | 71 |         super().__init__(label="Stop Reg", style=discord.ButtonStyle.red, row=2)
 7153 | 72 | 
 7154 | 73 |     async def callback(self, interaction: discord.Interaction):
 7155 | 74 |         await interaction.response.defer()
 7156 | 75 | 
 7157 | 76 |         if not self.view.record.opened_at:
 7158 | 77 |             return await self.view.ctx.error("Registration is already closed.", 5)
 7159 | 78 | 
 7160 | 79 |         try:
 7161 | 80 |             await self.view.record.close_registration()
 7162 | 81 |         except Exception as e:
 7163 | 82 |             return await self.view.ctx.error(e, 10)
 7164 | 83 | 
 7165 | 84 |         else:
 7166 | 85 |             await self.view.record.refresh_from_db()
 7167 | 86 |             await self.view.ctx.success(f"Registration closed {self.view.record}.", 5)
 7168 | 87 | 
 7169 | 
 7170 | 
 7171 | --------------------------------------------------------------------------------
 7172 | /cogs/esports/views/scrims/_wiz.py:
 7173 | --------------------------------------------------------------------------------
 7174 |  1 | from __future__ import annotations
 7175 |  2 | 
 7176 |  3 | import typing as T
 7177 |  4 | from string import ascii_uppercase
 7178 |  5 | 
 7179 |  6 | import discord
 7180 |  7 | 
 7181 |  8 | from core import Context
 7182 |  9 | from models import Scrim
 7183 | 10 | from utils import discord_timestamp as dt
 7184 | 11 | 
 7185 | 12 | from ._base import ScrimsView
 7186 | 13 | from ._btns import *
 7187 | 14 | 
 7188 | 15 | __all__ = ("ScrimSetup",)
 7189 | 16 | 
 7190 | 17 | 
 7191 | 18 | class ScrimSetup(ScrimsView):
 7192 | 19 |     def __init__(self, ctx: Context):
 7193 | 20 |         super().__init__(ctx, timeout=60)
 7194 | 21 | 
 7195 | 22 |         self.ctx = ctx
 7196 | 23 |         self.record: Scrim = None
 7197 | 24 | 
 7198 | 25 |         self.add_item(RegChannel(ctx, "a"))
 7199 | 26 |         self.add_item(SlotChannel(ctx, "b"))
 7200 | 27 |         self.add_item(SetRole(ctx, "c"))
 7201 | 28 |         self.add_item(SetMentions(ctx, "d"))
 7202 | 29 |         self.add_item(TotalSlots(ctx, "e"))
 7203 | 30 |         self.add_item(OpenTime(ctx, "f"))
 7204 | 31 | 
 7205 | 32 |         self.add_item(OpenDays(ctx, "g"))
 7206 | 33 |         self.add_item(SetEmojis(ctx, "h"))
 7207 | 34 |         self.add_item(Discard(ctx, "Cancel"))
 7208 | 35 |         self.add_item(SaveScrim(ctx))
 7209 | 36 | 
 7210 | 37 |     def initial_message(self):
 7211 | 38 |         if not self.record:
 7212 | 39 |             self.record = Scrim(guild_id=self.ctx.guild.id, host_id=self.ctx.author.id)
 7213 | 40 | 
 7214 | 41 |         d_link = "https://quotientbot.xyz/dashboard/{0}/scrims/create".format(self.ctx.guild.id)
 7215 | 42 | 
 7216 | 43 |         _e = discord.Embed(color=0x00FFB3, title="Enter details & Press Save", url=self.bot.config.SERVER_LINK)
 7217 | 44 |         _e.description = f"[`Scrim Creation is a piece of cake through dashboard, Click Me`]({d_link})\n\n"
 7218 | 45 | 
 7219 | 46 |         fields = {
 7220 | 47 |             "Reg. Channel": getattr(self.record.registration_channel, "mention", "`Not-Set`"),
 7221 | 48 |             "Slotlist Channel": getattr(self.record.slotlist_channel, "mention", "`Not-Set`"),
 7222 | 49 |             "Success Role": getattr(self.record.role, "mention", "`Not-Set`"),
 7223 | 50 |             "Req. Mentions": f"`{self.record.required_mentions}`",
 7224 | 51 |             "Total Slots": f"`{self.record.total_slots or 'Not-Set'}`",
 7225 | 52 |             "Open Time": f"{dt(self.record.open_time,'t')} ({dt(self.record.open_time)})"
 7226 | 53 |             if self.record.open_time
 7227 | 54 |             else "`Not-Set`",
 7228 | 55 |             "Scrim Days": ", ".join(map(lambda x: "`{0}`".format(x.name.title()[:2]), self.record.open_days)),
 7229 | 56 |             f"Reactions {self.bot.config.PRIME_EMOJI}": f"{self.record.check_emoji},{self.record.cross_emoji}",
 7230 | 57 |         }
 7231 | 58 | 
 7232 | 59 |         for idx, (name, value) in enumerate(fields.items()):
 7233 | 60 |             _e.add_field(
 7234 | 61 |                 name=f"{ri(ascii_uppercase[idx])} {name}:",
 7235 | 62 |                 value=value,
 7236 | 63 |             )
 7237 | 64 |         _e.add_field(name="\u200b", value="\u200b")
 7238 | 65 |         _e.set_footer(
 7239 | 66 |             text="Quotient Premium servers can set custom reactions.", icon_url=self.ctx.guild.me.display_avatar.url
 7240 | 67 |         )
 7241 | 68 | 
 7242 | 69 |         return _e
 7243 | 70 | 
 7244 | 71 |     async def refresh_view(self):
 7245 | 72 |         _e = self.initial_message()
 7246 | 73 | 
 7247 | 74 |         if all(
 7248 | 75 |             (
 7249 | 76 |                 self.record.registration_channel_id,
 7250 | 77 |                 self.record.slotlist_channel_id,
 7251 | 78 |                 self.record.role_id,
 7252 | 79 |                 self.record.total_slots,
 7253 | 80 |                 self.record.open_time,
 7254 | 81 |             )
 7255 | 82 |         ):
 7256 | 83 |             self.children[-1].disabled = False
 7257 | 84 | 
 7258 | 85 |         try:
 7259 | 86 |             self.message = await self.message.edit(embed=_e, view=self)
 7260 | 87 |         except discord.HTTPException:
 7261 | 88 |             await self.on_timeout()
 7262 | 89 | 
 7263 | 
 7264 | 
 7265 | --------------------------------------------------------------------------------
 7266 | /cogs/esports/views/scrims/main.py:
 7267 | --------------------------------------------------------------------------------
 7268 |   1 | from __future__ import annotations
 7269 |   2 | 
 7270 |   3 | import asyncio
 7271 |   4 | import random
 7272 |   5 | import typing as T
 7273 |   6 | from contextlib import suppress
 7274 |   7 | 
 7275 |   8 | import discord
 7276 |   9 | from discord import ButtonStyle, Interaction, ui
 7277 |  10 | 
 7278 |  11 | from core import Context
 7279 |  12 | from models import Scrim
 7280 |  13 | from utils import discord_timestamp, emote, truncate_string
 7281 |  14 | 
 7282 |  15 | from ._ban import ScrimBanManager
 7283 |  16 | from ._base import ScrimsView
 7284 |  17 | from ._design import ScrimDesign
 7285 |  18 | from ._edit import ScrimsEditor
 7286 |  19 | from ._reserve import ScrimsSlotReserve
 7287 |  20 | from ._slotlist import ManageSlotlist
 7288 |  21 | from ._toggle import ScrimsToggle
 7289 |  22 | from ._wiz import ScrimSetup
 7290 |  23 | 
 7291 |  24 | 
 7292 |  25 | class ScrimsMain(ScrimsView):
 7293 |  26 |     def __init__(self, ctx: Context):
 7294 |  27 |         super().__init__(ctx, timeout=100)
 7295 |  28 | 
 7296 |  29 |         self.ctx = ctx
 7297 |  30 | 
 7298 |  31 |     async def initial_embed(self):
 7299 |  32 |         _e = discord.Embed(color=0x00FFB3, title="Quotient's Smart Scrims Manager", url=self.ctx.config.SERVER_LINK)
 7300 |  33 | 
 7301 |  34 |         to_show = []
 7302 |  35 |         for idx, _r in enumerate(await Scrim.filter(guild_id=self.ctx.guild.id).order_by("open_time"), start=1):
 7303 |  36 |             to_show.append(
 7304 |  37 |                 f"`{idx:02}.` {(emote.xmark,emote.check)[_r.stoggle]}: {str(_r)} - {discord_timestamp(_r.open_time,'t')}"
 7305 |  38 |             )
 7306 |  39 | 
 7307 |  40 |         _e.description = "\n".join(to_show) if to_show else "```Click Create button for new Scrim.```"
 7308 |  41 |         _e.description = truncate_string(_e.description, 3999)
 7309 |  42 | 
 7310 |  43 |         _e.set_footer(
 7311 |  44 |             text=f"Total Scrims in this server: {len(to_show)}",
 7312 |  45 |             icon_url=getattr(self.ctx.author.display_avatar, "url", None),
 7313 |  46 |         )
 7314 |  47 | 
 7315 |  48 |         if not to_show:
 7316 |  49 |             for _ in self.children[1:]:
 7317 |  50 |                 _.disabled = True
 7318 |  51 | 
 7319 |  52 |         return _e
 7320 |  53 | 
 7321 |  54 |     @discord.ui.button(label="Create Scrim", style=ButtonStyle.green)
 7322 |  55 |     async def create_new_scrim(self, interaction: Interaction, button: ui.Button):
 7323 |  56 |         await interaction.response.defer()
 7324 |  57 | 
 7325 |  58 |         if not await self.ctx.is_premium_guild():
 7326 |  59 |             if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 3:
 7327 |  60 |                 return await self.ctx.premium_mango("Only 3 scrims can be created with free plan.")
 7328 |  61 | 
 7329 |  62 |         self.stop()
 7330 |  63 |         v = ScrimSetup(self.ctx)
 7331 |  64 |         v.message = await self.message.edit(embed=v.initial_message(), view=v)
 7332 |  65 | 
 7333 |  66 |     @discord.ui.button(label="Edit Settings", style=ButtonStyle.blurple)
 7334 |  67 |     async def edit_scrim(self, interaction: Interaction, button: ui.Button):
 7335 |  68 |         await interaction.response.defer()
 7336 |  69 |         scrim = await Scrim.show_selector(self.ctx, multi=False)
 7337 |  70 |         self.stop()
 7338 |  71 | 
 7339 |  72 |         if not scrim:
 7340 |  73 |             return
 7341 |  74 | 
 7342 |  75 |         v = ScrimsEditor(self.ctx, scrim)
 7343 |  76 |         await v._add_buttons()
 7344 |  77 |         v.message = await self.message.edit(embed=await v.initial_message, view=v)
 7345 |  78 | 
 7346 |  79 |     @discord.ui.button(label="Instant Start/Stop Reg", style=ButtonStyle.green)
 7347 |  80 |     async def toggle_reg(self, interaction: Interaction, button: ui.Button):
 7348 |  81 |         await interaction.response.defer()
 7349 |  82 | 
 7350 |  83 |         scrim = await Scrim.show_selector(
 7351 |  84 |             self.ctx, multi=False, placeholder="Please select the scrim to stop or start registration."
 7352 |  85 |         )
 7353 |  86 |         self.stop()
 7354 |  87 |         if not scrim:
 7355 |  88 |             return
 7356 |  89 | 
 7357 |  90 |         v = ScrimsToggle(self.ctx, scrim)
 7358 |  91 |         await v._add_buttons()
 7359 |  92 |         v.message = await self.message.edit(embed=await v.initial_message, view=v)
 7360 |  93 | 
 7361 |  94 |     @discord.ui.button(label="Reserve Slots", style=ButtonStyle.green)
 7362 |  95 |     async def reserve_slots(self, interaction: Interaction, button: ui.Button):
 7363 |  96 |         await interaction.response.defer()
 7364 |  97 |         scrim = await Scrim.show_selector(self.ctx, multi=False)
 7365 |  98 |         self.stop()
 7366 |  99 | 
 7367 | 100 |         if not scrim:
 7368 | 101 |             return
 7369 | 102 | 
 7370 | 103 |         view = ScrimsSlotReserve(self.ctx, scrim)
 7371 | 104 |         await view.add_buttons()
 7372 | 105 |         view.message = await self.message.edit(embed=await view.initial_embed, view=view)
 7373 | 106 | 
 7374 | 107 |     @discord.ui.button(label="Ban/Unban", style=ButtonStyle.red)
 7375 | 108 |     async def ban_unban(self, interaction: Interaction, button: ui.Button):
 7376 | 109 |         await interaction.response.defer()
 7377 | 110 | 
 7378 | 111 |         scrim = await Scrim.show_selector(self.ctx, multi=False)
 7379 | 112 |         self.stop()
 7380 | 113 |         if not scrim:
 7381 | 114 |             return
 7382 | 115 | 
 7383 | 116 |         v = ScrimBanManager(self.ctx, scrim)
 7384 | 117 |         await v._add_buttons()
 7385 | 118 |         v.message = await self.message.edit(embed=await v.initial_message, view=v)
 7386 | 119 | 
 7387 | 120 |     @discord.ui.button(label="Design", style=ButtonStyle.red)
 7388 | 121 |     async def change_design(self, interaction: Interaction, button: ui.Button):
 7389 | 122 |         await interaction.response.defer()
 7390 | 123 | 
 7391 | 124 |         scrim = await Scrim.show_selector(self.ctx, multi=False)
 7392 | 125 |         self.stop()
 7393 | 126 | 
 7394 | 127 |         if not scrim:
 7395 | 128 |             return
 7396 | 129 | 
 7397 | 130 |         view = ScrimDesign(self.ctx, scrim)
 7398 | 131 |         await view._add_buttons()
 7399 | 132 |         view.message = await self.message.edit(embed=await view.initial_embed, view=view)
 7400 | 133 | 
 7401 | 134 |     @discord.ui.button(label="Manage Slotlist", style=ButtonStyle.blurple)
 7402 | 135 |     async def manage_slotlist(self, interaction: Interaction, button: ui.Button):
 7403 | 136 |         await interaction.response.defer()
 7404 | 137 | 
 7405 | 138 |         scrim = await Scrim.show_selector(
 7406 | 139 |             self.ctx, multi=False, placeholder="Please select the scrim to manage slotlist."
 7407 | 140 |         )
 7408 | 141 | 
 7409 | 142 |         self.stop()
 7410 | 143 | 
 7411 | 144 |         if not scrim:
 7412 | 145 |             return
 7413 | 146 | 
 7414 | 147 |         v = ScrimsView(self.ctx)
 7415 | 148 |         v.add_item(ManageSlotlist(self.ctx, scrim))
 7416 | 149 |         v.message = await self.message.edit(content="Please choose an action:", embed=None, view=v)
 7417 | 150 | 
 7418 | 151 |     @discord.ui.button(label="Enable/Disable", style=discord.ButtonStyle.red)
 7419 | 152 |     async def toggle(self, interaction: Interaction, button: ui.Button):
 7420 | 153 |         await interaction.response.defer()
 7421 | 154 |         scrims = await Scrim.show_selector(self.ctx, multi=True)
 7422 | 155 |         if not scrims:
 7423 | 156 |             return
 7424 | 157 | 
 7425 | 158 |         scrims = [scrims] if not isinstance(scrims, list) else scrims
 7426 | 159 | 
 7427 | 160 |         self.stop()
 7428 | 161 |         for scrim in scrims:
 7429 | 162 |             await scrim.make_changes(stoggle=not scrim.stoggle)
 7430 | 163 | 
 7431 | 164 |         await self.ctx.success(
 7432 | 165 |             f"Done! Note that registration of disabled scrims will not be opened, until they are enabled back.", 6
 7433 | 166 |         )
 7434 | 167 | 
 7435 | 168 |         v = ScrimsMain(self.ctx)
 7436 | 169 |         v.message = await self.message.edit(embed=await v.initial_embed(), view=v)
 7437 | 170 | 
 7438 | 171 |     # @discord.ui.button(label="Scrim not working, Need Help!", style=ButtonStyle.red)
 7439 | 172 |     # async def troubleshoot_scrim(self, interaction: Interaction, button: ui.Button):
 7440 | 173 |     #     await interaction.response.defer()
 7441 | 174 | 
 7442 | 175 |     #     scrim = await Scrim.show_selector(
 7443 | 176 |     #         self.ctx, multi=False, placeholder="Please select the scrim you need help with."
 7444 | 177 |     #     )
 7445 | 178 | 
 7446 | 179 |     #     if not scrim:
 7447 | 180 |     #         return
 7448 | 181 | 
 7449 | 182 |     #     _e = discord.Embed(
 7450 | 183 |     #         color=self.bot.color, title="Join Support Server for more assistance", url=self.ctx.config.SERVER_LINK
 7451 | 184 |     #     )
 7452 | 185 |     #     _e.description = "**Analyzing {0}...**".format(scrim)
 7453 | 186 | 
 7454 | 187 |     #     m = await self.ctx.send(embed=_e)
 7455 | 188 |     #     _results, t, x = [], emote.check, emote.xmark
 7456 | 189 | 
 7457 | 190 |     #     _results.append(
 7458 | 191 |     #         (f"{x} Registration channel not found.", f"{t} Registration channel found.")[bool(scrim.registration_channel)]
 7459 | 192 |     #     )
 7460 | 193 |     #     _results.append(
 7461 | 194 |     #         (f"{x} Slotlist channel not found.", f"{t} Slotlist channel found.")[bool(scrim.slotlist_channel)]
 7462 | 195 |     #     )
 7463 | 196 | 
 7464 | 197 |     #     perms = False
 7465 | 198 |     #     with suppress(AttributeError):
 7466 | 199 |     #         perms = scrim.registration_channel.permissions_for(self.ctx.guild.me)
 7467 | 200 |     #         perms = all(
 7468 | 201 |     #             (
 7469 | 202 |     #                 perms.manage_channels,
 7470 | 203 |     #                 perms.manage_permissions,
 7471 | 204 |     #                 perms.manage_messages,
 7472 | 205 |     #                 perms.use_external_emojis,
 7473 | 206 |     #                 perms.add_reactions,
 7474 | 207 |     #                 perms.embed_links,
 7475 | 208 |     #             )
 7476 | 209 |     #         )
 7477 | 210 |     #     _results.append(
 7478 | 211 |     #         (f"{x} Need permissions in registration channel", f"{t} Registration channel permissions are ok.")[perms]
 7479 | 212 |     #     )
 7480 | 213 | 
 7481 | 214 |     #     _results.append((f"{x} Success Role not found.", f"{t} Success Role found.")[bool(scrim.role)])
 7482 | 215 |     #     _results.append(
 7483 | 216 |     #         (f"{x} `Manage-Roles` perms required.", f"{t} `Manage-Roles` perms found.")[
 7484 | 217 |     #             scrim.guild.me.guild_permissions.manage_roles
 7485 | 218 |     #         ]
 7486 | 219 |     #     )
 7487 | 220 | 
 7488 | 221 |     #     role_perm = False
 7489 | 222 |     #     if scrim.role:
 7490 | 223 |     #         if not scrim.role >= scrim.guild.me.top_role:
 7491 | 224 |     #             role_perm = True
 7492 | 225 | 
 7493 | 226 |     #     _results.append((f"{x} Success Role is above my toprole.", f"{t} Success Role is below my toprole.")[role_perm])
 7494 | 227 |     #     _results.append((f"{x} Open role not found.", f"{t} Open role found.")[bool(scrim.open_role)])
 7495 | 228 |     #     _results.append((f"{x} Logs-Channel not found", f"{t} Logs-Channel found.")[bool(scrim.logschan)])
 7496 | 229 |     #     _results.append(f"\nRegistration open time is {discord_timestamp(scrim.open_time,'f')}")
 7497 | 230 |     #     _results.append(f"{t} Scrim analyzing complete.")
 7498 | 231 | 
 7499 | 232 |     #     for _ in _results:
 7500 | 233 |     #         _e.description += "\n" + _
 7501 | 234 |     #         await asyncio.sleep(random.randint(1, 3))
 7502 | 235 |     #         with suppress(discord.HTTPException):
 7503 | 236 |     #             await m.edit(embed=_e)
 7504 | 237 | 
 7505 | 238 |     #     await self.ctx.safe_delete(m, 8)
 7506 | 239 | 
 7507 | 
 7508 | 
 7509 | --------------------------------------------------------------------------------
 7510 | /cogs/esports/views/scrims/selector.py:
 7511 | --------------------------------------------------------------------------------
 7512 |   1 | from contextlib import suppress
 7513 |   2 | from typing import List, Union
 7514 |   3 | 
 7515 |   4 | import discord
 7516 |   5 | from aiocache import cached
 7517 |   6 | 
 7518 |   7 | from core.Context import Context
 7519 |   8 | from core.views import QuotientView
 7520 |   9 | from models import Scrim
 7521 |  10 | from utils import emote, split_list
 7522 |  11 | 
 7523 |  12 | __all__ = ("ScrimSelectorView",)
 7524 |  13 | 
 7525 |  14 | 
 7526 |  15 | class ScrimSelector(discord.ui.Select):
 7527 |  16 |     view: "ScrimSelectorView"
 7528 |  17 | 
 7529 |  18 |     def __init__(self, placeholder: str, scrims: List[Scrim], max_values=25):
 7530 |  19 |         _options = []
 7531 |  20 |         for scrim in scrims:
 7532 |  21 |             _options.append(
 7533 |  22 |                 discord.SelectOption(
 7534 |  23 |                     label=scrim.registration_channel.name,  # type: ignore
 7535 |  24 |                     value=scrim.id,
 7536 |  25 |                     description=f"{scrim.name} (ScrimID: {scrim.id})",
 7537 |  26 |                     emoji=emote.TextChannel,
 7538 |  27 |                 )
 7539 |  28 |             )
 7540 |  29 | 
 7541 |  30 |         # print(scrims, _options)
 7542 |  31 |         super().__init__(placeholder=placeholder, options=_options, max_values=max_values)
 7543 |  32 | 
 7544 |  33 |     async def callback(self, interaction: discord.Interaction):
 7545 |  34 |         await interaction.response.defer()
 7546 |  35 |         self.view.custom_id = self.values
 7547 |  36 | 
 7548 |  37 |         self.view.stop()
 7549 |  38 | 
 7550 |  39 | 
 7551 |  40 | class ScrimSelectorView(discord.ui.View):
 7552 |  41 |     message: discord.Message
 7553 |  42 |     custom_id: List[str] = []
 7554 |  43 | 
 7555 |  44 |     def __init__(self, user: Union[discord.Member, discord.User], scrims: List[Scrim], **kwargs):
 7556 |  45 |         self.user = user
 7557 |  46 | 
 7558 |  47 |         timeout = kwargs.get("timeout", 30)
 7559 |  48 |         placeholder = kwargs.get("placeholder", "Select a scrim ...")
 7560 |  49 |         max_values = kwargs.get("max_values", len(scrims))
 7561 |  50 | 
 7562 |  51 |         super().__init__(timeout=timeout)
 7563 |  52 | 
 7564 |  53 |         # scrims = scrims[:25]
 7565 |  54 | 
 7566 |  55 |         self.add_item(ScrimSelector(placeholder, scrims, max_values))
 7567 |  56 | 
 7568 |  57 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
 7569 |  58 |         if interaction.user.id != self.user.id:
 7570 |  59 |             await interaction.response.send_message(f"Sorry, only **{self.user}** can use this dropdown.", ephemeral=True)
 7571 |  60 |             return False
 7572 |  61 | 
 7573 |  62 |         return True
 7574 |  63 | 
 7575 |  64 |     async def on_timeout(self) -> None:
 7576 |  65 |         if hasattr(self, "message"):
 7577 |  66 |             with suppress(discord.HTTPException):
 7578 |  67 |                 await self.message.delete()
 7579 |  68 | 
 7580 |  69 | 
 7581 |  70 | async def prompt_selector(ctx: Context, scrims: List[Scrim] = None, *, placeholder: str = None, multi: bool = True):
 7582 |  71 |     placeholder = placeholder or "Choose {0} to continue...".format("Scrims" if multi else "a Scrim")
 7583 |  72 | 
 7584 |  73 |     scrims = scrims or await Scrim.filter(guild_id=ctx.guild.id).order_by("open_time")
 7585 |  74 |     if not scrims:
 7586 |  75 |         return None
 7587 |  76 | 
 7588 |  77 |     if len(scrims) == 1:
 7589 |  78 |         return scrims[0]
 7590 |  79 | 
 7591 |  80 |     view = QuotientView(ctx)
 7592 |  81 |     if len(scrims) <= 25:
 7593 |  82 |         view.add_item(Select(placeholder, scrims, multi=multi))
 7594 |  83 |     else:
 7595 |  84 |         for scrims_chunk in split_list(scrims, 25):
 7596 |  85 |             view.add_item(Select(placeholder, scrims_chunk, multi=multi))
 7597 |  86 | 
 7598 |  87 |     view.message = await ctx.send(
 7599 |  88 |         "Choose {0} from the dropdown below:".format("Scrims" if multi else "a Scrim"),
 7600 |  89 |         view=view,
 7601 |  90 |     )
 7602 |  91 |     await view.wait()
 7603 |  92 |     if view.custom_id:
 7604 |  93 |         with suppress(discord.HTTPException):
 7605 |  94 |             await view.message.delete()
 7606 |  95 | 
 7607 |  96 |         if not len(view.custom_id) > 1:
 7608 |  97 |             return await Scrim.get_or_none(pk=view.custom_id[0])
 7609 |  98 | 
 7610 |  99 |         return await Scrim.filter(pk__in=view.custom_id)
 7611 | 100 | 
 7612 | 101 | 
 7613 | 102 | class Select(discord.ui.Select):
 7614 | 103 |     view: QuotientView
 7615 | 104 | 
 7616 | 105 |     def __init__(self, placeholder: str, scrims: List[Scrim], multi: bool):
 7617 | 106 |         _options = []
 7618 | 107 |         for scrim in scrims:
 7619 | 108 |             _options.append(
 7620 | 109 |                 discord.SelectOption(
 7621 | 110 |                     label=getattr(scrim.registration_channel, "name", "deleted-channel"),  # type: ignore
 7622 | 111 |                     value=scrim.id,
 7623 | 112 |                     description=f"{scrim.name} (ScrimID: {scrim.id})",
 7624 | 113 |                     emoji=emote.TextChannel,
 7625 | 114 |                 )
 7626 | 115 |             )
 7627 | 116 | 
 7628 | 117 |         super().__init__(placeholder=placeholder, options=_options, max_values=len(_options) if multi else 1)
 7629 | 118 | 
 7630 | 119 |     async def callback(self, interaction: discord.Interaction):
 7631 | 120 |         await interaction.response.defer()
 7632 | 121 |         self.view.custom_id = self.values
 7633 | 122 | 
 7634 | 123 |         self.view.stop()
 7635 | 124 | 
 7636 | 125 | 
 7637 | 126 | @cached(ttl=10)
 7638 | 127 | async def scrim_position(scrim_id: int, guild_id: int):
 7639 | 128 |     """
 7640 | 129 |     returns the position of scrim in all scrims of a server
 7641 | 130 |     """
 7642 | 131 |     scrims = await Scrim.filter(guild_id=guild_id).order_by("open_time")
 7643 | 132 |     return str(scrims.index(next(s for s in scrims if s.pk == scrim_id)) + 1), len(scrims).__str__()
 7644 | 133 | 
 7645 | 
 7646 | 
 7647 | --------------------------------------------------------------------------------
 7648 | /cogs/esports/views/slotm/__init__.py:
 7649 | --------------------------------------------------------------------------------
 7650 | 1 | from .editor import *
 7651 | 2 | from .public import *
 7652 | 3 | from .setup import *
 7653 | 4 | 
 7654 | 
 7655 | 
 7656 | --------------------------------------------------------------------------------
 7657 | /cogs/esports/views/slotm/editor.py:
 7658 | --------------------------------------------------------------------------------
 7659 |   1 | from __future__ import annotations
 7660 |   2 | 
 7661 |   3 | from typing import TYPE_CHECKING
 7662 |   4 | 
 7663 |   5 | from utils.buttons import Prompt
 7664 |   6 | 
 7665 |   7 | if TYPE_CHECKING:
 7666 |   8 |     from core import Quotient
 7667 |   9 | 
 7668 |  10 | from string import ascii_uppercase
 7669 |  11 | 
 7670 |  12 | import discord
 7671 |  13 | 
 7672 |  14 | from core import Context
 7673 |  15 | from models.esports.slotm import ScrimsSlotManager
 7674 |  16 | from utils import plural
 7675 |  17 | from utils import regional_indicator as ri
 7676 |  18 | 
 7677 |  19 | from ...views.base import EsportsBaseView
 7678 |  20 | from .scrimsedit import SlotmScrimsEditor
 7679 |  21 | 
 7680 |  22 | __all__ = ("ScrimsSlotmEditor",)
 7681 |  23 | 
 7682 |  24 | 
 7683 |  25 | class ScrimsSlotmEditor(EsportsBaseView):
 7684 |  26 |     def __init__(self, ctx: Context, *, record: ScrimsSlotManager):
 7685 |  27 |         super().__init__(ctx, timeout=30, title="Slot-M Editor")
 7686 |  28 | 
 7687 |  29 |         self.ctx = ctx
 7688 |  30 |         self.bot: Quotient = ctx.bot
 7689 |  31 |         self.record = record
 7690 |  32 | 
 7691 |  33 |     def initial_embed(self):
 7692 |  34 |         _e = discord.Embed(color=0x00FFB3, title="Slot-M Editor")
 7693 |  35 | 
 7694 |  36 |         fields = {
 7695 |  37 |             "Main Channel": getattr(self.record.main_channel, "mention", "Not-Found"),
 7696 |  38 |             "Slot-m Status": f"{'Enabled' if self.record.toggle else 'Disabled'}",
 7697 |  39 |             "Reminders button": f"{'Enabled' if self.record.allow_reminders else 'Disabled'}",
 7698 |  40 |             "Multi Slot-Claim": f"{'Enabled' if self.record.multiple_slots else 'Disabled'}",
 7699 |  41 |             "Scrims": f"{plural(self.record.scrim_ids):scrim|scrims} (`Click to edit`)",
 7700 |  42 |         }
 7701 |  43 | 
 7702 |  44 |         for idx, (name, value) in enumerate(fields.items()):
 7703 |  45 |             _e.add_field(
 7704 |  46 |                 name=f"{ri(ascii_uppercase[idx])} {name}:",
 7705 |  47 |                 value=value,
 7706 |  48 |             )
 7707 |  49 |         _e.add_field(name=f"🟥 Delete Slot-M", value=f"`Click to delete`")
 7708 |  50 |         return _e
 7709 |  51 | 
 7710 |  52 |     async def __update_record(self, **kwargs):
 7711 |  53 |         await ScrimsSlotManager.filter(pk=self.record.pk).update(**kwargs)
 7712 |  54 |         await self.__refresh_embed()
 7713 |  55 |         await self.record.refresh_public_message()
 7714 |  56 | 
 7715 |  57 |     async def __refresh_embed(self):
 7716 |  58 |         await self.record.refresh_from_db()
 7717 |  59 |         embed = self.initial_embed()
 7718 |  60 | 
 7719 |  61 |         try:
 7720 |  62 |             self.message = await self.message.edit(embed=embed, view=self)
 7721 |  63 |         except discord.HTTPException:
 7722 |  64 |             await self.on_timeout()
 7723 |  65 | 
 7724 |  66 |     @discord.ui.button(custom_id="edit_main_slotm_channel", emoji=ri("A"))
 7725 |  67 |     async def edit_main_slotm_channel(self, interaction: discord.Interaction, button: discord.Button):
 7726 |  68 |         await interaction.response.defer()
 7727 |  69 |         return await interaction.followup.send("Main Channel can't be edited. Sorry 🥲", ephemeral=True)
 7728 |  70 | 
 7729 |  71 |     @discord.ui.button(custom_id="edit_slotm_status", emoji=ri("B"))
 7730 |  72 |     async def edit_slotm_status(self, interaction: discord.Interaction, button: discord.Button):
 7731 |  73 |         await interaction.response.defer()
 7732 |  74 |         await self.__update_record(toggle=not self.record.toggle)
 7733 |  75 | 
 7734 |  76 |     @discord.ui.button(custom_id="edit_slotm_reminders", emoji=ri("C"))
 7735 |  77 |     async def edit_slotm_reminders(self, interaction: discord.Interaction, button: discord.Button):
 7736 |  78 |         await interaction.response.defer()
 7737 |  79 |         await self.__update_record(allow_reminders=not self.record.allow_reminders)
 7738 |  80 | 
 7739 |  81 |     @discord.ui.button(custom_id="edit_slotm_multi_claim", emoji=ri("D"))
 7740 |  82 |     async def edit_slotm_multi_claim(self, interaction: discord.Interaction, button: discord.Button):
 7741 |  83 |         await interaction.response.defer()
 7742 |  84 |         await self.__update_record(multiple_slots=not self.record.multiple_slots)
 7743 |  85 | 
 7744 |  86 |     @discord.ui.button(custom_id="edit_slotm_scrims", emoji=ri("E"))
 7745 |  87 |     async def edit_slotm_scrims(self, interaction: discord.Interaction, button: discord.Button):
 7746 |  88 |         await interaction.response.defer()
 7747 |  89 | 
 7748 |  90 |         _view = SlotmScrimsEditor(self.ctx, self.record)
 7749 |  91 |         await interaction.followup.send(embed=_view.initial_embed(), view=_view, ephemeral=True)
 7750 |  92 |         await self.on_timeout()
 7751 |  93 | 
 7752 |  94 |     @discord.ui.button(custom_id="delete_slotm", label="Delete Slot-Manager", style=discord.ButtonStyle.red)
 7753 |  95 |     async def delete_slotm(self, interaction: discord.Interaction, button: discord.Button):
 7754 |  96 |         await interaction.response.defer()
 7755 |  97 | 
 7756 |  98 |         prompt = Prompt(self.ctx.author.id)
 7757 |  99 |         await interaction.followup.send("Are you sure you want to delete this Slot-Manager?", view=prompt, ephemeral=True)
 7758 | 100 |         await prompt.wait()
 7759 | 101 |         if not prompt.value:
 7760 | 102 |             return await self.ctx.simple("Alright, Aborting.", 2)
 7761 | 103 | 
 7762 | 104 |         await self.record.full_delete()
 7763 | 105 |         await self.ctx.success("Slot-M Deleted.", 2)
 7764 | 106 |         await self.on_timeout()
 7765 | 107 | 
 7766 | 
 7767 | 
 7768 | --------------------------------------------------------------------------------
 7769 | /cogs/esports/views/slotm/public/__init__.py:
 7770 | --------------------------------------------------------------------------------
 7771 |  1 | from __future__ import annotations
 7772 |  2 | 
 7773 |  3 | import typing as T
 7774 |  4 | 
 7775 |  5 | import discord as d
 7776 |  6 | 
 7777 |  7 | from models import Scrim, ScrimsSlotManager
 7778 |  8 | 
 7779 |  9 | __all__ = ("ScrimsSlotmPublicView",)
 7780 | 10 | 
 7781 | 11 | 
 7782 | 12 | class ScrimsSlotmPublicView(d.ui.View):
 7783 | 13 |     children: T.List[d.ui.Button]
 7784 | 14 | 
 7785 | 15 |     def __init__(self, record: ScrimsSlotManager):
 7786 | 16 |         super().__init__(timeout=None)
 7787 | 17 | 
 7788 | 18 |         self.record = record
 7789 | 19 |         self.bot = record.bot
 7790 | 20 |         self.claimable: T.List[Scrim] = []
 7791 | 21 | 
 7792 | 22 |         from ._cancel import ScrimsCancel
 7793 | 23 |         from ._claim import ScrimsClaim
 7794 | 24 |         from ._idp import IdpTransfer
 7795 | 25 |         from ._reminder import ScrimsRemind
 7796 | 26 | 
 7797 | 27 |         self.add_item(ScrimsCancel(style=d.ButtonStyle.danger, custom_id="scrims_slot_cancel", label="Cancel Slot"))
 7798 | 28 |         self.add_item(ScrimsClaim(style=d.ButtonStyle.green, custom_id="scrims_slot_claim", label="Claim Slot"))
 7799 | 29 |         self.add_item(ScrimsRemind(label="Remind Me", custom_id="scrims_slot_reminder", emoji="🔔"))
 7800 | 30 |         self.add_item(
 7801 | 31 |             IdpTransfer(label="Transfer IDP Role", custom_id="scrims_transfer_idp_role", style=d.ButtonStyle.green)
 7802 | 32 |         )
 7803 | 33 | 
 7804 | 34 |         self.bot.loop.create_task(self.__refresh_cache())
 7805 | 35 | 
 7806 | 36 |     async def on_error(self, interaction: d.Interaction, error: Exception, item: d.ui.Item[T.Any]) -> None:
 7807 | 37 |         if isinstance(error, d.NotFound):
 7808 | 38 |             return
 7809 | 39 |         print("Scrims Slotm Public View Error:", error)
 7810 | 40 | 
 7811 | 41 |     async def __refresh_cache(self):
 7812 | 42 |         async for scrim in self.record.claimable_slots:
 7813 | 43 |             self.claimable.append(scrim)
 7814 | 44 | 
 7815 | 
 7816 | 
 7817 | --------------------------------------------------------------------------------
 7818 | /cogs/esports/views/slotm/public/_cancel.py:
 7819 | --------------------------------------------------------------------------------
 7820 |   1 | from __future__ import annotations
 7821 |   2 | 
 7822 |   3 | import typing as T
 7823 |   4 | from contextlib import suppress
 7824 |   5 | 
 7825 |   6 | import discord
 7826 |   7 | 
 7827 |   8 | from models import ArrayAppend, AssignedSlot, Scrim
 7828 |   9 | from utils import BaseSelector, Prompt, emote, plural
 7829 |  10 | 
 7830 |  11 | from ..public import ScrimsSlotmPublicView
 7831 |  12 | 
 7832 |  13 | __all__ = ("ScrimsCancel",)
 7833 |  14 | 
 7834 |  15 | 
 7835 |  16 | class ScrimsCancel(discord.ui.Button):
 7836 |  17 |     view: ScrimsSlotmPublicView
 7837 |  18 | 
 7838 |  19 |     def __init__(self, **kwargs):
 7839 |  20 |         super().__init__(**kwargs)
 7840 |  21 | 
 7841 |  22 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
 7842 |  23 |         await interaction.response.defer(thinking=True, ephemeral=True)
 7843 |  24 | 
 7844 |  25 |         if not (slots := await self.view.record.user_slots(interaction.user.id)):
 7845 |  26 |             return await interaction.followup.send("You have no slots that can be cancelled.", ephemeral=True)
 7846 |  27 | 
 7847 |  28 |         cancel_view = BaseSelector(interaction.user.id, CancelSlotSelector, bot=self.view.bot, records=slots)
 7848 |  29 |         await interaction.followup.send("Select the slots you want to remove:", view=cancel_view, ephemeral=True)
 7849 |  30 |         await cancel_view.wait()
 7850 |  31 |         if not cancel_view.custom_id:
 7851 |  32 |             return
 7852 |  33 | 
 7853 |  34 |         p_str = f"{plural(cancel_view.custom_id):slot|slots}"
 7854 |  35 |         prompt = Prompt(interaction.user.id)
 7855 |  36 |         await interaction.followup.send(
 7856 |  37 |             f"Your `{p_str}` will be cancelled.\n" "*`Are you sure you want to continue?`*",
 7857 |  38 |             view=prompt,
 7858 |  39 |             ephemeral=True,
 7859 |  40 |         )
 7860 |  41 |         await prompt.wait()
 7861 |  42 |         if not prompt.value:
 7862 |  43 |             return await interaction.followup.send("Alright, Aborting.", ephemeral=True)
 7863 |  44 | 
 7864 |  45 |         m = await interaction.followup.send(f"Cancelling your `{p_str}`... {emote.loading}", ephemeral=True)
 7865 |  46 |         for _ in cancel_view.custom_id:
 7866 |  47 |             scrim_id, slot_id = _.split(":")
 7867 |  48 | 
 7868 |  49 |             scrim = await Scrim.get_or_none(pk=scrim_id)
 7869 |  50 |             if not scrim:
 7870 |  51 |                 continue
 7871 |  52 | 
 7872 |  53 |             if not await scrim.assigned_slots.filter(user_id=interaction.user.id, pk__not=slot_id).exists():
 7873 |  54 |                 with suppress(discord.HTTPException):
 7874 |  55 |                     if interaction.user._roles.has(scrim.role_id):
 7875 |  56 |                         await interaction.user.remove_roles(discord.Object(id=scrim.role_id))
 7876 |  57 | 
 7877 |  58 |             _slot = await AssignedSlot.filter(pk=slot_id).first()
 7878 |  59 | 
 7879 |  60 |             await AssignedSlot.filter(pk=slot_id).update(team_name="Cancelled Slot")
 7880 |  61 |             await scrim.refresh_slotlist_message()
 7881 |  62 |             await _slot.delete()
 7882 |  63 | 
 7883 |  64 |             await Scrim.filter(pk=scrim_id).update(available_slots=ArrayAppend("available_slots", _slot.num))
 7884 |  65 | 
 7885 |  66 |             link = f"https://discord.com/channels/{scrim.guild_id}/{interaction.channel_id}/{self.view.record.message_id}"
 7886 |  67 |             await scrim.dispatch_reminders(interaction.channel, link)
 7887 |  68 |             with suppress(discord.HTTPException, AttributeError):
 7888 |  69 |                 user = interaction.user
 7889 |  70 |                 await scrim.logschan.send(
 7890 |  71 |                     embed=discord.Embed(
 7891 |  72 |                         title="Slot-Cancelled",
 7892 |  73 |                         color=self.view.bot.color,
 7893 |  74 |                         description=f"{user} ({user.mention}) cancelled their `Slot {_slot.num}` from {scrim}.",
 7894 |  75 |                     )
 7895 |  76 |                 )
 7896 |  77 | 
 7897 |  78 |         await m.edit(content=f"Alright, Cancelled your `{p_str}`.")
 7898 |  79 |         await self.view.record.refresh_public_message()
 7899 |  80 | 
 7900 |  81 | 
 7901 |  82 | class CancelSlotSelector(discord.ui.Select):
 7902 |  83 |     view: BaseSelector
 7903 |  84 | 
 7904 |  85 |     def __init__(self, bot, records):
 7905 |  86 |         _options = []
 7906 |  87 |         for record in records[:25]:
 7907 |  88 |             reg_channel = bot.get_channel(record["registration_channel_id"])
 7908 |  89 |             _options.append(
 7909 |  90 |                 discord.SelectOption(
 7910 |  91 |                     label=f"Slot {record['num']} ─ #{getattr(reg_channel,'name','deleted-channel')}",
 7911 |  92 |                     description=f"{record['team_name']} (ID: {record['scrim_id']})",
 7912 |  93 |                     value=f"{record['scrim_id']}:{record['assigned_slot_id']}",
 7913 |  94 |                     emoji="📇",
 7914 |  95 |                 )
 7915 |  96 |             )
 7916 |  97 | 
 7917 |  98 |         super().__init__(placeholder="Select slot(s) from this dropdown...", options=_options, max_values=len(records))
 7918 |  99 | 
 7919 | 100 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
 7920 | 101 |         await interaction.response.defer()
 7921 | 102 |         self.view.stop()
 7922 | 103 |         self.view.custom_id = interaction.data["values"]
 7923 | 104 | 
 7924 | 
 7925 | 
 7926 | --------------------------------------------------------------------------------
 7927 | /cogs/esports/views/slotm/public/_claim.py:
 7928 | --------------------------------------------------------------------------------
 7929 |   1 | from __future__ import annotations
 7930 |   2 | 
 7931 |   3 | import asyncio
 7932 |   4 | import re
 7933 |   5 | import typing as T
 7934 |   6 | from contextlib import suppress
 7935 |   7 | 
 7936 |   8 | import discord
 7937 |   9 | 
 7938 |  10 | from models import ArrayRemove, AssignedSlot, Scrim, ScrimsSlotManager
 7939 |  11 | from utils import BaseSelector, emote
 7940 |  12 | 
 7941 |  13 | from ..public import ScrimsSlotmPublicView
 7942 |  14 | 
 7943 |  15 | claim_lock = asyncio.Lock()
 7944 |  16 | 
 7945 |  17 | __all__ = ("ScrimsClaim",)
 7946 |  18 | #!TODO: do some processing on the team name
 7947 |  19 | 
 7948 |  20 | 
 7949 |  21 | class ScrimsClaim(discord.ui.Button):
 7950 |  22 |     view: ScrimsSlotmPublicView
 7951 |  23 | 
 7952 |  24 |     def __init__(self, **kwargs):
 7953 |  25 |         super().__init__(**kwargs)
 7954 |  26 | 
 7955 |  27 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
 7956 |  28 |         if not self.view.claimable:  # this can never be true but still
 7957 |  29 |             await interaction.response.send_message("No slot available right now.", ephemeral=True)
 7958 |  30 |             return await self.view.record.refresh_public_message()
 7959 |  31 | 
 7960 |  32 |         await interaction.response.defer(thinking=True, ephemeral=True)
 7961 |  33 |         claim_view = BaseSelector(
 7962 |  34 |             interaction.user.id,
 7963 |  35 |             ClaimSlotSelector,
 7964 |  36 |             scrims=self.view.claimable,
 7965 |  37 |             multiple_slots=self.view.record.multiple_slots,
 7966 |  38 |         )
 7967 |  39 |         await interaction.followup.send("Select the slot you want to claim:", view=claim_view, ephemeral=True)
 7968 |  40 | 
 7969 |  41 | 
 7970 |  42 | class ClaimSlotModal(discord.ui.Modal, title="Claim Scrims Slot"):
 7971 |  43 |     multiple_slots: bool
 7972 |  44 |     selected_slot: str
 7973 |  45 | 
 7974 |  46 |     async def on_submit(self, interaction: discord.Interaction) -> None:
 7975 |  47 |         await interaction.response.defer(thinking=True, ephemeral=True)
 7976 |  48 | 
 7977 |  49 |         team_name = str(self.children[0])
 7978 |  50 |         scrim_id, num = self.selected_slot.split(":")
 7979 |  51 |         num = int(num)
 7980 |  52 | 
 7981 |  53 |         team_name = "Team " + re.sub(r"team|name|[^\w\s]", "", team_name.lower()).strip().title()
 7982 |  54 | 
 7983 |  55 |         scrim = await Scrim.get_or_none(pk=scrim_id)
 7984 |  56 |         if not scrim:
 7985 |  57 |             return await interaction.followup.send("Scrim not found.", ephemeral=True)
 7986 |  58 | 
 7987 |  59 |         if await scrim.banned_teams.filter(user_id=interaction.user.id).exists():
 7988 |  60 |             return await interaction.followup.send("You are banned from this scrim.", ephemeral=True)
 7989 |  61 | 
 7990 |  62 |         if not self.multiple_slots:
 7991 |  63 |             if await scrim.assigned_slots.filter(user_id=interaction.user.id).exists():
 7992 |  64 |                 return await interaction.followup.send("You already have a slot in this scrim.", ephemeral=True)
 7993 |  65 | 
 7994 |  66 |         async with claim_lock:
 7995 |  67 |             await scrim.refresh_from_db(("available_slots",))
 7996 |  68 | 
 7997 |  69 |             if num not in scrim.available_slots:
 7998 |  70 |                 return await interaction.followup.send("Somebody claimed this slot before you.", ephemeral=True)
 7999 |  71 | 
 8000 |  72 |             await Scrim.filter(pk=scrim_id).update(available_slots=ArrayRemove("available_slots", num))
 8001 |  73 | 
 8002 |  74 |             scrim.bot.loop.create_task(self.add_role(interaction.user, scrim.role_id))
 8003 |  75 | 
 8004 |  76 |             user_id = interaction.user.id
 8005 |  77 |             _slot = await AssignedSlot.create(num=num, user_id=user_id, members=[user_id], team_name=team_name)
 8006 |  78 |             await scrim.assigned_slots.add(_slot)
 8007 |  79 | 
 8008 |  80 |             scrim.bot.loop.create_task(self.proccess_claim(scrim, _slot))
 8009 |  81 |             await interaction.followup.send(f"{emote.check} Slot claimed successfully.", ephemeral=True)
 8010 |  82 | 
 8011 |  83 |     async def add_role(self, user: discord.Member, role_id: int):
 8012 |  84 |         with suppress(discord.HTTPException):
 8013 |  85 |             if not user._roles.has(role_id):
 8014 |  86 |                 await user.add_roles(discord.Object(id=role_id))
 8015 |  87 | 
 8016 |  88 |     async def proccess_claim(self, scrim: Scrim, slot: AssignedSlot):
 8017 |  89 |         await scrim.refresh_slotlist_message()
 8018 |  90 | 
 8019 |  91 |         await ScrimsSlotManager.refresh_guild_message(scrim.guild_id, scrim.id)
 8020 |  92 | 
 8021 |  93 |         with suppress(AttributeError, discord.HTTPException):
 8022 |  94 |             await scrim.slotlist_channel.send(f"{slot.team_name} ({slot.owner.mention}) -> Claimed Slot {slot.num}")
 8023 |  95 | 
 8024 |  96 | 
 8025 |  97 | class ClaimSlotSelector(discord.ui.Select):
 8026 |  98 |     view: BaseSelector
 8027 |  99 | 
 8028 | 100 |     def __init__(self, scrims: T.List[Scrim], multiple_slots: bool):
 8029 | 101 |         _options = []
 8030 | 102 |         for scrim in scrims:
 8031 | 103 |             slots = sorted(scrim.available_slots)
 8032 | 104 | 
 8033 | 105 |             _options.append(
 8034 | 106 |                 discord.SelectOption(
 8035 | 107 |                     label=f"Slot {slots[0]} ─ #{getattr(scrim.registration_channel,'name','deleted-channel')}",
 8036 | 108 |                     description=f"{scrim.name} (ID: {scrim.id})",
 8037 | 109 |                     value=f"{scrim.id}:{slots[0]}",
 8038 | 110 |                     emoji="📇",
 8039 | 111 |                 )
 8040 | 112 |             )
 8041 | 113 | 
 8042 | 114 |         super().__init__(options=_options)
 8043 | 115 |         self.multiple_slots = multiple_slots
 8044 | 116 | 
 8045 | 117 |     async def callback(self, interaction: discord.Interaction):
 8046 | 118 |         self.view.stop()
 8047 | 119 | 
 8048 | 120 |         v = ClaimSlotModal()
 8049 | 121 |         v.multiple_slots = self.multiple_slots
 8050 | 122 |         v.selected_slot = interaction.data["values"][0]
 8051 | 123 | 
 8052 | 124 |         v.add_item(
 8053 | 125 |             discord.ui.TextInput(
 8054 | 126 |                 label="Team Name",
 8055 | 127 |                 style=discord.TextStyle.short,
 8056 | 128 |                 placeholder="Enter your team name here...",
 8057 | 129 |                 min_length=3,
 8058 | 130 |                 max_length=25,
 8059 | 131 |             )
 8060 | 132 |         )
 8061 | 133 |         await interaction.response.send_modal(v)
 8062 | 134 | 
 8063 | 
 8064 | 
 8065 | --------------------------------------------------------------------------------
 8066 | /cogs/esports/views/slotm/public/_idp.py:
 8067 | --------------------------------------------------------------------------------
 8068 |   1 | from __future__ import annotations
 8069 |   2 | 
 8070 |   3 | import typing as T
 8071 |   4 | from contextlib import suppress
 8072 |   5 | 
 8073 |   6 | import discord
 8074 |   7 | 
 8075 |   8 | from models import AssignedSlot, Scrim
 8076 |   9 | from utils import BaseSelector, emote
 8077 |  10 | 
 8078 |  11 | from ..public import ScrimsSlotmPublicView
 8079 |  12 | 
 8080 |  13 | __all__ = ("IdpTransfer",)
 8081 |  14 | 
 8082 |  15 | 
 8083 |  16 | class IdpTransfer(discord.ui.Button):
 8084 |  17 |     view: ScrimsSlotmPublicView
 8085 |  18 | 
 8086 |  19 |     def __init__(self, **kwargs):
 8087 |  20 |         super().__init__(**kwargs)
 8088 |  21 | 
 8089 |  22 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
 8090 |  23 |         await interaction.response.defer(thinking=True, ephemeral=True)
 8091 |  24 | 
 8092 |  25 |         if not await self.view.bot.is_premium_guild(interaction.guild_id):
 8093 |  26 |             return await interaction.followup.send(
 8094 |  27 |                 "IDP Transfer feature is only available for premium servers.\n\n"
 8095 |  28 |                 f"*This server needs to purchase [Quotient Premium]({self.view.bot.prime_link}) to use this feature.*",
 8096 |  29 |                 ephemeral=True,
 8097 |  30 |             )
 8098 |  31 | 
 8099 |  32 |         if not (slots := await self.view.record.user_slots(interaction.user.id)):
 8100 |  33 |             return await interaction.followup.send("You don't have any slot that can be transferred.", ephemeral=True)
 8101 |  34 | 
 8102 |  35 |         transfer_view = BaseSelector(interaction.user.id, SlotSelector, bot=self.view.bot, records=slots)
 8103 |  36 |         await interaction.followup.send(
 8104 |  37 |             "Choose a slot to transfer ID-Pass Role to your teammates:", view=transfer_view, ephemeral=True
 8105 |  38 |         )
 8106 |  39 |         await transfer_view.wait()
 8107 |  40 |         if not transfer_view.custom_id:
 8108 |  41 |             return
 8109 |  42 | 
 8110 |  43 |         scrim_id, slot_id = transfer_view.custom_id.split(":")
 8111 |  44 |         scrim = await Scrim.get(pk=scrim_id)
 8112 |  45 |         _slot = await AssignedSlot.filter(pk=slot_id).first()
 8113 |  46 | 
 8114 |  47 |         with suppress(ValueError):
 8115 |  48 |             _slot.members.remove(interaction.user.id)
 8116 |  49 | 
 8117 |  50 |         if not _slot.members:
 8118 |  51 |             return await interaction.followup.send(
 8119 |  52 |                 f"{interaction.user.mention}, you cannot transfer ID-Pass role to your teammates "
 8120 |  53 |                 "because you didn't mention them during registration.",
 8121 |  54 |                 ephemeral=True,
 8122 |  55 |             )
 8123 |  56 | 
 8124 |  57 |         users = [member async for member in self.view.bot.resolve_member_ids(interaction.guild, _slot.members)]
 8125 |  58 |         if not users:
 8126 |  59 |             return await interaction.followup.send("All your teammates seems to have left the server.", ephemeral=True)
 8127 |  60 | 
 8128 |  61 |         if len(users) == 1:
 8129 |  62 |             user_id = users[0].id
 8130 |  63 | 
 8131 |  64 |         else:
 8132 |  65 |             users_view = BaseSelector(interaction.user.id, UserSelector, users=users)
 8133 |  66 |             await interaction.followup.send(
 8134 |  67 |                 "Please select your teammate to transfer ID-Pass Role.", view=users_view, ephemeral=True
 8135 |  68 |             )
 8136 |  69 |             await users_view.wait()
 8137 |  70 |             if not users_view.custom_id:
 8138 |  71 |                 return
 8139 |  72 | 
 8140 |  73 |             user_id = int(users_view.custom_id)
 8141 |  74 | 
 8142 |  75 |         await AssignedSlot.filter(pk=_slot.pk).update(user_id=user_id)
 8143 |  76 |         self.view.bot.loop.create_task(interaction.user.remove_roles(discord.Object(scrim.role_id)))
 8144 |  77 |         self.view.bot.loop.create_task(interaction.guild.get_member(user_id).add_roles(discord.Object(scrim.role_id)))
 8145 |  78 |         return await interaction.followup.send(
 8146 |  79 |             f"{emote.check} | ID-Pass Role & Slot ownership transferred to <@{user_id}>", ephemeral=True
 8147 |  80 |         )
 8148 |  81 | 
 8149 |  82 | 
 8150 |  83 | class SlotSelector(discord.ui.Select):
 8151 |  84 |     view: BaseSelector
 8152 |  85 | 
 8153 |  86 |     def __init__(self, bot, records):
 8154 |  87 |         _options = []
 8155 |  88 |         for record in records[:25]:
 8156 |  89 |             reg_channel = bot.get_channel(record["registration_channel_id"])
 8157 |  90 |             _options.append(
 8158 |  91 |                 discord.SelectOption(
 8159 |  92 |                     label=f"Slot {record['num']} ─ #{getattr(reg_channel,'name','deleted-channel')}",
 8160 |  93 |                     description=f"{record['team_name']} (ID: {record['scrim_id']})",
 8161 |  94 |                     value=f"{record['scrim_id']}:{record['assigned_slot_id']}",
 8162 |  95 |                     emoji="📇",
 8163 |  96 |                 )
 8164 |  97 |             )
 8165 |  98 | 
 8166 |  99 |         super().__init__(placeholder="Select slot from this dropdown...", options=_options, max_values=1)
 8167 | 100 | 
 8168 | 101 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
 8169 | 102 |         await interaction.response.defer()
 8170 | 103 |         self.view.stop()
 8171 | 104 |         self.view.custom_id = interaction.data["values"][0]
 8172 | 105 | 
 8173 | 106 | 
 8174 | 107 | class UserSelector(discord.ui.Select):
 8175 | 108 |     view: BaseSelector
 8176 | 109 | 
 8177 | 110 |     def __init__(self, users: T.List[discord.Member]):
 8178 | 111 |         _options = []
 8179 | 112 |         for user in users:
 8180 | 113 |             _options.append(
 8181 | 114 |                 discord.SelectOption(
 8182 | 115 |                     label=f"{user.name}#{user.discriminator}",
 8183 | 116 |                     value=user.id,
 8184 | 117 |                     emoji="📇",
 8185 | 118 |                 )
 8186 | 119 |             )
 8187 | 120 | 
 8188 | 121 |         super().__init__(placeholder="Select your teammate from this dropdown", options=_options)
 8189 | 122 | 
 8190 | 123 |     async def callback(self, interaction: discord.Interaction):
 8191 | 124 |         await interaction.response.defer()
 8192 | 125 |         self.view.stop()
 8193 | 126 |         self.view.custom_id = interaction.data["values"][0]
 8194 | 127 | 
 8195 | 
 8196 | 
 8197 | --------------------------------------------------------------------------------
 8198 | /cogs/esports/views/slotm/public/_reminder.py:
 8199 | --------------------------------------------------------------------------------
 8200 |   1 | from __future__ import annotations
 8201 |   2 | 
 8202 |   3 | import typing as T
 8203 |   4 | 
 8204 |   5 | import discord
 8205 |   6 | 
 8206 |   7 | from cogs.esports.views.scrims import ScrimSelectorView
 8207 |   8 | from models import Scrim, ScrimsSlotReminder
 8208 |   9 | from utils import plural
 8209 |  10 | 
 8210 |  11 | from ..public import ScrimsSlotmPublicView
 8211 |  12 | 
 8212 |  13 | __all__ = ("ScrimsRemind",)
 8213 |  14 | 
 8214 |  15 | 
 8215 |  16 | class ScrimsRemind(discord.ui.Button):
 8216 |  17 |     view: ScrimsSlotmPublicView
 8217 |  18 | 
 8218 |  19 |     def __init__(self, **kwargs):
 8219 |  20 |         super().__init__(**kwargs)
 8220 |  21 | 
 8221 |  22 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
 8222 |  23 |         await interaction.response.defer(thinking=True, ephemeral=True)
 8223 |  24 | 
 8224 |  25 |         if not await self.view.bot.is_premium_guild(interaction.guild_id):
 8225 |  26 |             return await interaction.followup.send(
 8226 |  27 |                 "Cancel Reminder feature is only available for premium servers.\n\n"
 8227 |  28 |                 f"*This server needs to purchase [Quotient Premium]({self.view.bot.prime_link}) to use this feature.*",
 8228 |  29 |                 ephemeral=True,
 8229 |  30 |             )
 8230 |  31 | 
 8231 |  32 |         scrims = await Scrim.filter(
 8232 |  33 |             pk__in=self.view.record.scrim_ids,
 8233 |  34 |             closed_at__gt=self.view.bot.current_time.replace(hour=0, minute=0, second=0, microsecond=0),
 8234 |  35 |             match_time__gt=self.view.bot.current_time,
 8235 |  36 |             opened_at__isnull=True,
 8236 |  37 |         ).order_by("open_time")
 8237 |  38 | 
 8238 |  39 |         scrims = [scrim for scrim in scrims if not scrim.available_slots]
 8239 |  40 | 
 8240 |  41 |         for scrim in await self.banned_from(interaction.user.id):
 8241 |  42 |             for _ in scrims:
 8242 |  43 |                 if _.id == scrim["scrim_id"]:
 8243 |  44 |                     scrims.remove(_)
 8244 |  45 | 
 8245 |  46 |         for scrim in await self.already_reminder_of(interaction.user.id):
 8246 |  47 |             for _ in scrims:
 8247 |  48 |                 if _.id == scrim["scrim_id"]:
 8248 |  49 |                     scrims.remove(_)
 8249 |  50 | 
 8250 |  51 |         if not self.view.record.multiple_slots:
 8251 |  52 |             for slot in await self.view.record.user_slots(interaction.user.id):
 8252 |  53 |                 for _ in scrims:
 8253 |  54 |                     if _.id == slot["scrim_id"]:
 8254 |  55 |                         scrims.remove(_)
 8255 |  56 | 
 8256 |  57 |         if not scrims:
 8257 |  58 |             return await interaction.followup.send("You can't set reminder in any scrim at this time.", ephemeral=True)
 8258 |  59 | 
 8259 |  60 |         _view = ScrimSelectorView(interaction.user, scrims[:25], placeholder="Select scrims to add slot reminder")
 8260 |  61 |         await interaction.followup.send(
 8261 |  62 |             "Select 1 or multiple scrims to set reminder\n\n*By selecting scrims, you confirm that Quotient can "
 8262 |  63 |             "DM you when any slot is available of the selected scrims.*",
 8263 |  64 |             view=_view,
 8264 |  65 |             ephemeral=True,
 8265 |  66 |         )
 8266 |  67 |         await _view.wait()
 8267 |  68 |         if not _view.custom_id:
 8268 |  69 |             return
 8269 |  70 | 
 8270 |  71 |         scrims = await Scrim.filter(pk__in=_view.custom_id)
 8271 |  72 | 
 8272 |  73 |         for _ in scrims:
 8273 |  74 |             _r = await ScrimsSlotReminder.create(user_id=interaction.user.id)
 8274 |  75 |             await _.slot_reminders.add(_r)
 8275 |  76 | 
 8276 |  77 |         _e = discord.Embed(
 8277 |  78 |             color=0x00FFB3, description=f"Successfully created reminder for {plural(scrims):scrim|scrims}."
 8278 |  79 |         )
 8279 |  80 | 
 8280 |  81 |         await interaction.followup.send(embed=_e, ephemeral=True)
 8281 |  82 | 
 8282 |  83 |     async def banned_from(self, user_id: int) -> T.List[int]:
 8283 |  84 |         # now, can tortoise do this? - no way
 8284 |  85 |         query = """
 8285 |  86 |         (SELECT *
 8286 |  87 | 		    FROM
 8287 |  88 | 			(SELECT SCRIMS.ID AS SCRIM_ID,
 8288 |  89 | 					*
 8289 |  90 | 				FROM PUBLIC."sm.scrims" AS SCRIMS
 8290 |  91 | 				FULL OUTER JOIN
 8291 |  92 | 					(SELECT ID AS ASSIGNED_SLOT_ID,
 8292 |  93 | 							*
 8293 |  94 | 						FROM PUBLIC."sm.scrims_sm.banned_teams" AS SCRIM_SLOT
 8294 |  95 | 						INNER JOIN PUBLIC."sm.banned_teams" AS SLOTS ON SLOTS.ID = SCRIM_SLOT.BANNEDTEAM_ID) AS SCRIM_SLOT ON SCRIMS.ID = SCRIM_SLOT."sm.scrims_id"
 8295 |  96 | 				WHERE (SCRIMS.ID = ANY ($1)
 8296 |  97 | 										AND SCRIM_SLOT."sm.scrims_id" IS NOT NULL)) AS SM
 8297 |  98 | 		WHERE USER_ID = $2)        
 8298 |  99 |         """
 8299 | 100 | 
 8300 | 101 |         return await self.view.bot.db.fetch(query, self.view.record.scrim_ids, user_id)
 8301 | 102 | 
 8302 | 103 |     async def already_reminder_of(self, user_id: int) -> T.List[int]:
 8303 | 104 |         query = """
 8304 | 105 |         (SELECT *
 8305 | 106 | 		    FROM
 8306 | 107 | 			    (SELECT SCRIMS.ID AS SCRIM_ID,
 8307 | 108 | 					*
 8308 | 109 | 				    FROM PUBLIC."sm.scrims" AS SCRIMS
 8309 | 110 | 				    FULL OUTER JOIN
 8310 | 111 | 					    (SELECT ID AS REMINDER_SLOT_ID,
 8311 | 112 | 							*
 8312 | 113 | 						    FROM PUBLIC."sm.scrims_scrims_slot_reminders" AS REMINDER_SLOT
 8313 | 114 | 						    INNER JOIN PUBLIC."scrims_slot_reminders" AS SLOTS ON SLOTS.ID = REMINDER_SLOT.SCRIMSSLOTREMINDER_ID) AS REMINDER_SLOT ON SCRIMS.ID = REMINDER_SLOT."sm.scrims_id"
 8314 | 115 | 				    WHERE (SCRIMS.ID = ANY ($1)
 8315 | 116 | 											AND REMINDER_SLOT."sm.scrims_id" IS NOT NULL)) AS SM
 8316 | 117 | 		WHERE USER_ID = $2)
 8317 | 118 |         """
 8318 | 119 |         return await self.view.bot.db.fetch(query, self.view.record.scrim_ids, user_id)
 8319 | 120 | 
 8320 | 
 8321 | 
 8322 | --------------------------------------------------------------------------------
 8323 | /cogs/esports/views/slotm/scrimsedit.py:
 8324 | --------------------------------------------------------------------------------
 8325 |  1 | from __future__ import annotations
 8326 |  2 | 
 8327 |  3 | import discord
 8328 |  4 | 
 8329 |  5 | from cogs.esports.views.scrims import ScrimSelectorView
 8330 |  6 | from core import Context
 8331 |  7 | from models import Scrim, ScrimsSlotManager
 8332 |  8 | from utils import emote
 8333 |  9 | 
 8334 | 10 | from ...views.base import EsportsBaseView
 8335 | 11 | 
 8336 | 12 | __all__ = ("SlotmScrimsEditor",)
 8337 | 13 | 
 8338 | 14 | 
 8339 | 15 | class SlotmScrimsEditor(EsportsBaseView):
 8340 | 16 |     def __init__(self, ctx: Context, record: ScrimsSlotManager):
 8341 | 17 |         super().__init__(ctx, timeout=100, title="Slot-M Editor")
 8342 | 18 | 
 8343 | 19 |         self.ctx = ctx
 8344 | 20 |         self.record = record
 8345 | 21 | 
 8346 | 22 |     def initial_embed(self) -> discord.Embed:
 8347 | 23 |         _e = discord.Embed(color=0x00FFB3)
 8348 | 24 |         _e.description = (
 8349 | 25 |             "Do you want to add scrims of remove scrims from this slot-m?\n\n"
 8350 | 26 |             f"Current scrims: {', '.join(f'`{str(_)}`' for _ in self.record.scrim_ids)}"
 8351 | 27 |         )
 8352 | 28 | 
 8353 | 29 |         return _e
 8354 | 30 | 
 8355 | 31 |     @discord.ui.button(custom_id="slotm_scrims_add", emoji=emote.add)
 8356 | 32 |     async def add_new_scrims(self, interaction: discord.Interaction, button: discord.Button):
 8357 | 33 |         await interaction.response.defer()
 8358 | 34 |         await self.record.refresh_from_db()
 8359 | 35 | 
 8360 | 36 |         scrims = await self.record.available_scrims(self.ctx.guild)
 8361 | 37 |         if not scrims:
 8362 | 38 |             return await self.ctx.error("All scrims are already added to this or another slot-m.", 3)
 8363 | 39 | 
 8364 | 40 |         scrims = scrims[:25]
 8365 | 41 |         _view = ScrimSelectorView(interaction.user, scrims, placeholder="Select scrims to add to this slot-manager ...")
 8366 | 42 |         await interaction.followup.send("Choose the scrims you want to add to this slotm.", view=_view, ephemeral=True)
 8367 | 43 | 
 8368 | 44 |         await _view.wait()
 8369 | 45 |         if _view.custom_id:
 8370 | 46 |             _q = "UPDATE slot_manager SET scrim_ids = scrim_ids || $1 WHERE id = $2"
 8371 | 47 |             await self.ctx.bot.db.execute(_q, [int(i) for i in _view.custom_id], self.record.id)
 8372 | 48 |             await self.record.refresh_public_message()
 8373 | 49 |             await self.ctx.success("Successfully added new scrims.", 3)
 8374 | 50 | 
 8375 | 51 |     @discord.ui.button(custom_id="slotm_scrims_remove", emoji=emote.remove)
 8376 | 52 |     async def remove_scrims(self, interaction: discord.Interaction, button: discord.Button):
 8377 | 53 |         await interaction.response.defer()
 8378 | 54 | 
 8379 | 55 |         await self.record.refresh_from_db()
 8380 | 56 |         if not self.record.scrim_ids:
 8381 | 57 |             return await self.ctx.error("There are no scrims added to this slot-m.", 3)
 8382 | 58 | 
 8383 | 59 |         scrims = await Scrim.filter(pk__in=self.record.scrim_ids).limit(25)
 8384 | 60 |         _view = ScrimSelectorView(
 8385 | 61 |             interaction.user, scrims, placeholder="Select scrims to remove from this slot-manager ..."
 8386 | 62 |         )
 8387 | 63 | 
 8388 | 64 |         await interaction.followup.send(
 8389 | 65 |             "Choose the scrims you want to remove from this slotm.", view=_view, ephemeral=True
 8390 | 66 |         )
 8391 | 67 |         await _view.wait()
 8392 | 68 |         if _view.custom_id:
 8393 | 69 |             _q = "UPDATE slot_manager SET scrim_ids = $1 WHERE id = $2"
 8394 | 70 |             await self.ctx.bot.db.execute(
 8395 | 71 |                 _q, [_ for _ in self.record.scrim_ids if not str(_) in _view.custom_id], self.record.id
 8396 | 72 |             )
 8397 | 73 |             await self.record.refresh_public_message()
 8398 | 74 |             await self.ctx.success("Successfully removed selected scrims.", 3)
 8399 | 75 | 
 8400 | 
 8401 | 
 8402 | --------------------------------------------------------------------------------
 8403 | /cogs/esports/views/slotm/setup.py:
 8404 | --------------------------------------------------------------------------------
 8405 |   1 | from __future__ import annotations
 8406 |   2 | 
 8407 |   3 | from code import interact
 8408 |   4 | from typing import TYPE_CHECKING, List
 8409 |   5 | 
 8410 |   6 | if TYPE_CHECKING:
 8411 |   7 |     from core import Quotient
 8412 |   8 | 
 8413 |   9 | import discord
 8414 |  10 | 
 8415 |  11 | from cogs.esports.views.scrims import ScrimSelectorView
 8416 |  12 | from core import Context, QuotientView
 8417 |  13 | from models import Scrim
 8418 |  14 | from models.esports.slotm import ScrimsSlotManager
 8419 |  15 | from utils import Prompt, emote, truncate_string
 8420 |  16 | 
 8421 |  17 | from ...views.base import EsportsBaseView
 8422 |  18 | from .editor import ScrimsSlotmEditor
 8423 |  19 | from .time import MatchTimeEditor
 8424 |  20 | 
 8425 |  21 | __all__ = ("ScrimsSlotManagerSetup",)
 8426 |  22 | 
 8427 |  23 | 
 8428 |  24 | class ScrimsSlotmSelector(discord.ui.Select):
 8429 |  25 |     def __init__(self, records: List[ScrimsSlotManager]):
 8430 |  26 |         _o = []
 8431 |  27 |         for record in records:
 8432 |  28 |             _o.append(
 8433 |  29 |                 discord.SelectOption(
 8434 |  30 |                     label=getattr(record.main_channel, "name", "channel-not-found"),  # type: ignore
 8435 |  31 |                     value=record.id,
 8436 |  32 |                     description=truncate_string(f"Scrims: {', '.join(str(_) for _ in record.scrim_ids)}", 100),
 8437 |  33 |                     emoji=emote.TextChannel,
 8438 |  34 |                 )
 8439 |  35 |             )
 8440 |  36 | 
 8441 |  37 |         super().__init__(placeholder="Select a slot-manager channel ...", options=_o)
 8442 |  38 | 
 8443 |  39 |     async def callback(self, interaction: discord.Interaction):
 8444 |  40 |         await interaction.response.defer()
 8445 |  41 |         self.view.custom_id = self.values[0]
 8446 |  42 | 
 8447 |  43 |         self.view.stop()
 8448 |  44 | 
 8449 |  45 | 
 8450 |  46 | class ScrimsSlotManagerSetup(EsportsBaseView):
 8451 |  47 |     def __init__(self, ctx: Context):
 8452 |  48 |         super().__init__(ctx, timeout=60, title="Scrims Slot Manager")
 8453 |  49 | 
 8454 |  50 |         self.ctx = ctx
 8455 |  51 |         self.bot: Quotient = ctx.bot
 8456 |  52 | 
 8457 |  53 |     @staticmethod
 8458 |  54 |     async def initial_message(guild: discord.Guild):
 8459 |  55 |         records = await ScrimsSlotManager.filter(guild_id=guild.id)
 8460 |  56 |         _to_show = [f"`{idx}.` {_.__str__()}" for idx, _ in enumerate(records, start=1)]
 8461 |  57 | 
 8462 |  58 |         _sm = "\n".join(_to_show) if _to_show else "```Click add-channel to set cancel-claim.```"
 8463 |  59 | 
 8464 |  60 |         _e = discord.Embed(color=0x00FFB3, title=f"Scrims Slot-Manager Setup")
 8465 |  61 | 
 8466 |  62 |         _e.description = (
 8467 |  63 |             "Slot-Manager is a way to ease-up scrims slot management process. With Quotient's slotm users can - "
 8468 |  64 |             "cancel their slot, claim an empty slot and also set reminder for vacant slots, All without bugging any mod.\n\n"
 8469 |  65 |             f"**Current slot-manager channels:**\n{_sm}\n\nDon't forget to set the match times :)"
 8470 |  66 |         )
 8471 |  67 |         # _e.set_thumbnail(url=guild.me.display_avatar.url)
 8472 |  68 |         return _e
 8473 |  69 | 
 8474 |  70 |     @discord.ui.button(label="Add Channel", custom_id="scrims_slotm_addc", emoji=emote.TextChannel)
 8475 |  71 |     async def add_channel(self, interaction: discord.Interaction, button: discord.Button):
 8476 |  72 |         await interaction.response.defer()
 8477 |  73 | 
 8478 |  74 |         if not await self.ctx.is_premium_guild():
 8479 |  75 |             if await ScrimsSlotManager.filter(guild_id=self.ctx.guild.id).count() >= 1:
 8480 |  76 |                 return await self.ctx.premium_mango("You need Quotient Premium to add more than 1 Slot-Manager channel.")
 8481 |  77 | 
 8482 |  78 |         available_scrims = await ScrimsSlotManager.available_scrims(self.ctx.guild)
 8483 |  79 |         if not available_scrims:
 8484 |  80 |             return await self.error_embed(
 8485 |  81 |                 f"There are no scrims available for a new slotmanager channel.\n\n"
 8486 |  82 |                 "If you have other slot-m channel, first remove the scrims from that channel to add them to new slot-m."
 8487 |  83 |             )
 8488 |  84 | 
 8489 |  85 |         available_scrims = available_scrims[:25]
 8490 |  86 |         _view = ScrimSelectorView(
 8491 |  87 |             interaction.user, available_scrims, placeholder="Select scrims to add to slot-manager ..."
 8492 |  88 |         )
 8493 |  89 |         await interaction.followup.send(
 8494 |  90 |             "Choose 1 or multiple scrims that you want to add to new slot-manager."
 8495 |  91 |             "\n\n`If a scrim isn't in the dropdown that means it has been addded to another slotm.`",
 8496 |  92 |             view=_view,
 8497 |  93 |             ephemeral=True,
 8498 |  94 |         )
 8499 |  95 |         await _view.wait()
 8500 |  96 | 
 8501 |  97 |         prompt = Prompt(interaction.user.id)
 8502 |  98 |         await interaction.followup.send(
 8503 |  99 |             "A new channel will be created for the selected scrims slot manager.\n\n`Do you want to continue?`",
 8504 | 100 |             view=prompt,
 8505 | 101 |             ephemeral=True,
 8506 | 102 |         )
 8507 | 103 |         await prompt.wait()
 8508 | 104 | 
 8509 | 105 |         if not prompt.value:
 8510 | 106 |             return await interaction.followup.send("Alright, Aborting.", ephemeral=True)
 8511 | 107 | 
 8512 | 108 |         slotm = ScrimsSlotManager(scrim_ids=_view.custom_id, guild_id=interaction.guild_id)
 8513 | 109 |         self.record = await slotm.setup(self.ctx.guild, interaction.user)
 8514 | 110 |         await self.ctx.success(
 8515 | 111 |             f"Successfully setup slotm for selected scrims in {self.record.main_channel.mention}.\n\n"
 8516 | 112 |             "`You can rename this channel if you want to.`",
 8517 | 113 |             10,
 8518 | 114 |         )
 8519 | 115 | 
 8520 | 116 |     @discord.ui.button(label="Edit Config", custom_id="scrims_slotm_editc", emoji=emote.edit)
 8521 | 117 |     async def edit_config(self, interaction: discord.Interaction, button: discord.Button):
 8522 | 118 |         await interaction.response.defer()
 8523 | 119 | 
 8524 | 120 |         records = await ScrimsSlotManager.filter(guild_id=self.ctx.guild.id)
 8525 | 121 |         if not records:
 8526 | 122 |             return await self.ctx.error(
 8527 | 123 |                 "You haven't added any slot-manager channel yet.\n\nClick `Add Channel` to add a new slot-m channel.", 2
 8528 | 124 |             )
 8529 | 125 | 
 8530 | 126 |         _view = QuotientView(self.ctx)
 8531 | 127 |         _view.add_item(ScrimsSlotmSelector(records))
 8532 | 128 |         # _view.add_item(QuotientView.tricky_invite_button())
 8533 | 129 |         await interaction.followup.send("Kindly choose a slot-manager channel to edit.", view=_view, ephemeral=True)
 8534 | 130 |         await _view.wait()
 8535 | 131 | 
 8536 | 132 |         if _view.custom_id:
 8537 | 133 |             __record = await ScrimsSlotManager.get(pk=_view.custom_id)
 8538 | 134 | 
 8539 | 135 |             __editor_view = ScrimsSlotmEditor(self.ctx, record=__record)
 8540 | 136 |             __editor_view.add_item(QuotientView.tricky_invite_button())
 8541 | 137 | 
 8542 | 138 |             __editor_view.message = await interaction.followup.send(
 8543 | 139 |                 embed=__editor_view.initial_embed(), view=__editor_view
 8544 | 140 |             )
 8545 | 141 | 
 8546 | 142 |     @discord.ui.button(emoji="🔒", label="Match Time", custom_id="scrims_slotm_matcht")
 8547 | 143 |     async def set_match_time(self, interaction: discord.Interaction, button: discord.Button):
 8548 | 144 |         await interaction.response.defer()
 8549 | 145 | 
 8550 | 146 |         scrims = await Scrim.filter(guild_id=self.ctx.guild.id).order_by("open_time")
 8551 | 147 |         _to_show = [
 8552 | 148 |             f"{idx}) {getattr(_.registration_channel,'name','deleted-channel').ljust(18)}"
 8553 | 149 |             f"   {_.match_time.strftime('%I:%M %p') if _.match_time else 'Not-Set'}"
 8554 | 150 |             for idx, _ in enumerate(scrims, start=1)
 8555 | 151 |         ]
 8556 | 152 |         _to_show.insert(0, f"   {'Scrims'.ljust(18)}   Match Time\n")
 8557 | 153 | 
 8558 | 154 |         _e = discord.Embed(color=self.ctx.bot.color, title="Scrims-Match time", url=self.bot.config.SERVER_LINK)
 8559 | 155 | 
 8560 | 156 |         _to_show = "\n".join(_to_show)
 8561 | 157 |         _e.description = (
 8562 | 158 |             f"Match time means the time when `ID/Pass` \nof that particular scrim is shared.\n```{_to_show}```"
 8563 | 159 |         )
 8564 | 160 | 
 8565 | 161 |         _e.set_footer(
 8566 | 162 |             text="Users cannot cancel/claim slots after this time.", icon_url=self.ctx.guild.me.display_avatar.url
 8567 | 163 |         )
 8568 | 164 | 
 8569 | 165 |         _view = QuotientView(self.ctx)
 8570 | 166 |         _view.add_item(MatchTimeEditor(self.ctx))
 8571 | 167 |         _view.add_item(QuotientView.tricky_invite_button())
 8572 | 168 | 
 8573 | 169 |         _view.message = await interaction.followup.send(embed=_e, view=_view, ephemeral=True)
 8574 | 170 | 
 8575 | 
 8576 | 
 8577 | --------------------------------------------------------------------------------
 8578 | /cogs/esports/views/slotm/time.py:
 8579 | --------------------------------------------------------------------------------
 8580 |  1 | from contextlib import suppress
 8581 |  2 | from datetime import timedelta
 8582 |  3 | 
 8583 |  4 | import dateparser
 8584 |  5 | import discord
 8585 |  6 | from discord.ext.commands import ChannelNotFound, TextChannelConverter
 8586 |  7 | 
 8587 |  8 | from core import Context
 8588 |  9 | from models import Scrim
 8589 | 10 | from utils import emote, string_input
 8590 | 11 | 
 8591 | 12 | __all__ = ("MatchTimeEditor",)
 8592 | 13 | 
 8593 | 14 | 
 8594 | 15 | class MatchTimeEditor(discord.ui.Button):
 8595 | 16 |     def __init__(self, ctx: Context):
 8596 | 17 |         self.ctx = ctx
 8597 | 18 | 
 8598 | 19 |         super().__init__(label="Set Match Time", style=discord.ButtonStyle.green)
 8599 | 20 | 
 8600 | 21 |     async def callback(self, interaction: discord.Interaction):
 8601 | 22 |         await interaction.response.defer()
 8602 | 23 | 
 8603 | 24 |         _e = discord.Embed(color=0x00FFB3)
 8604 | 25 |         _e.description = (
 8605 | 26 |             "Please enter the time of matches/scrims in the following format:\n"
 8606 | 27 |             "`#registration_channel match_time`\n\n"
 8607 | 28 |             "Note that slotmanager will automatically lock for the scrim at specified time. This means "
 8608 | 29 |             "that `users will not be able to cancel/claim after the specified time.`\n\n"
 8609 | 30 |             "**Separate multiple match time with a new line.**"
 8610 | 31 |         )
 8611 | 32 |         _e.set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/931035634464849970/unknown.png")
 8612 | 33 |         _e.set_footer(text="You only have to enter match time once, I'll handle the rest automatically.")
 8613 | 34 |         await interaction.followup.send(embed=_e, ephemeral=True)
 8614 | 35 |         match_times = await string_input(
 8615 | 36 |             self.ctx,
 8616 | 37 |             lambda x: x.author == interaction.user and x.channel == self.ctx.channel,
 8617 | 38 |             delete_after=True,
 8618 | 39 |             timeout=300,
 8619 | 40 |         )
 8620 | 41 | 
 8621 | 42 |         match_times = match_times.strip().split("\n")
 8622 | 43 |         for _ in match_times:
 8623 | 44 |             with suppress(AttributeError, ValueError, ChannelNotFound, TypeError):
 8624 | 45 |                 channel, time = _.strip().split()
 8625 | 46 |                 if not all((channel, time)):
 8626 | 47 |                     continue
 8627 | 48 | 
 8628 | 49 |                 _c = await TextChannelConverter().convert(self.ctx, channel.strip())
 8629 | 50 |                 parsed = dateparser.parse(
 8630 | 51 |                     time,
 8631 | 52 |                     settings={
 8632 | 53 |                         # "RELATIVE_BASE": self.ctx.bot.current_time,
 8633 | 54 |                         "TIMEZONE": "Asia/Kolkata",
 8634 | 55 |                         "RETURN_AS_TIMEZONE_AWARE": True,
 8635 | 56 |                     },
 8636 | 57 |                 )
 8637 | 58 | 
 8638 | 59 |                 parsed = parsed + timedelta(hours=24) if parsed < self.ctx.bot.current_time else parsed
 8639 | 60 | 
 8640 | 61 |                 if not all((_c, parsed, parsed > self.ctx.bot.current_time)):
 8641 | 62 |                     continue
 8642 | 63 | 
 8643 | 64 |                 scrim = await Scrim.get_or_none(guild_id=self.ctx.guild.id, registration_channel_id=_c.id)
 8644 | 65 |                 if scrim:
 8645 | 66 |                     await self.ctx.bot.reminders.create_timer(parsed, "scrim_match", scrim_id=scrim.id)
 8646 | 67 |                     await Scrim.filter(pk=scrim.pk).update(match_time=parsed)
 8647 | 68 | 
 8648 | 69 |         await interaction.followup.send(f"{emote.check} Done, click Match-Time button to see changes.", ephemeral=True)
 8649 | 70 | 
 8650 | 
 8651 | 
 8652 | --------------------------------------------------------------------------------
 8653 | /cogs/esports/views/smslotlist/__init__.py:
 8654 | --------------------------------------------------------------------------------
 8655 | 1 | from .button import *
 8656 | 2 | from .editor import *
 8657 | 3 | from .select import *
 8658 | 4 | 
 8659 | 
 8660 | 
 8661 | --------------------------------------------------------------------------------
 8662 | /cogs/esports/views/smslotlist/button.py:
 8663 | --------------------------------------------------------------------------------
 8664 |   1 | from __future__ import annotations
 8665 |   2 | 
 8666 |   3 | import typing as T
 8667 |   4 | from contextlib import suppress
 8668 |   5 | 
 8669 |   6 | import discord
 8670 |   7 | 
 8671 |   8 | from models import AssignedSlot, BanLog, Scrim
 8672 |   9 | 
 8673 |  10 | if T.TYPE_CHECKING:
 8674 |  11 |     from core import Quotient
 8675 |  12 | 
 8676 |  13 | import asyncio
 8677 |  14 | import random
 8678 |  15 | 
 8679 |  16 | from tortoise.exceptions import OperationalError
 8680 |  17 | 
 8681 |  18 | from utils import TimeText, emote
 8682 |  19 | 
 8683 |  20 | from .editor import *
 8684 |  21 | from .select import BanOptions, prompt_slot_selection
 8685 |  22 | 
 8686 |  23 | __all__ = ("SlotlistEditButton",)
 8687 |  24 | 
 8688 |  25 | 
 8689 |  26 | class SlotlistEditButton(discord.ui.View):
 8690 |  27 |     message: discord.Message
 8691 |  28 | 
 8692 |  29 |     def __init__(self, bot: Quotient, scrim: Scrim):
 8693 |  30 |         super().__init__(timeout=None)
 8694 |  31 | 
 8695 |  32 |         self.bot = bot
 8696 |  33 |         self.scrim = scrim
 8697 |  34 | 
 8698 |  35 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
 8699 |  36 |         if not any(
 8700 |  37 |             (
 8701 |  38 |                 interaction.user.guild_permissions.manage_guild,
 8702 |  39 |                 "scrims-mod" in (_.name.strip().lower() for _ in interaction.user.roles),
 8703 |  40 |             )
 8704 |  41 |         ):
 8705 |  42 |             return await interaction.response.send_message(
 8706 |  43 |                 embed=discord.Embed(
 8707 |  44 |                     color=discord.Color.red(),
 8708 |  45 |                     description=("You need `manage server` permissions or `scrims-mod` role to edit this slotlist."),
 8709 |  46 |                 ),
 8710 |  47 |                 ephemeral=True,
 8711 |  48 |             )
 8712 |  49 | 
 8713 |  50 |         return True
 8714 |  51 | 
 8715 |  52 |     @discord.ui.button(label="Edit", emoji="📝", style=discord.ButtonStyle.green, custom_id="scrim_slotlist_edit_b")
 8716 |  53 |     async def edit_slotlist(self, interaction: discord.Interaction, button: discord.Button):
 8717 |  54 |         await interaction.response.defer(thinking=True, ephemeral=True)
 8718 |  55 | 
 8719 |  56 |         try:
 8720 |  57 |             await self.scrim.refresh_from_db()
 8721 |  58 |         except OperationalError:
 8722 |  59 |             await interaction.followup.send("This scrim has been deleted.", ephemeral=True)
 8723 |  60 | 
 8724 |  61 |         _view = ScrimsSlotlistEditor(
 8725 |  62 |             self.bot, self.scrim, await self.scrim.slotlist_channel.fetch_message(self.scrim.slotlist_message_id)
 8726 |  63 |         )
 8727 |  64 |         embed = _view.initial_embed()
 8728 |  65 |         _view.message = await interaction.followup.send(embed=embed, view=_view, ephemeral=True)
 8729 |  66 | 
 8730 |  67 |     @discord.ui.button(label="Punish", emoji="🛠️", style=discord.ButtonStyle.danger, custom_id="scrim_slotlist_ban_b")
 8731 |  68 |     async def ban_slot(self, interaction: discord.Interaction, button: discord.Button):
 8732 |  69 |         await interaction.response.defer(thinking=True, ephemeral=True)
 8733 |  70 | 
 8734 |  71 |         __slots = await self.scrim.assigned_slots.all().order_by("num")
 8735 |  72 |         if not __slots:
 8736 |  73 |             return await interaction.followup.send("No slot in the scrim to ban.", ephemeral=True)
 8737 |  74 | 
 8738 |  75 |         _v = await prompt_slot_selection(__slots, placeholder="Select the slots to ban the teams...", multiple=True)
 8739 |  76 | 
 8740 |  77 |         _e = discord.Embed(color=0x00FFB3, description="Kindly choose slots from the dropdown.")
 8741 |  78 | 
 8742 |  79 |         await interaction.followup.send(embed=_e, view=_v, ephemeral=True)
 8743 |  80 | 
 8744 |  81 |         await _v.wait()
 8745 |  82 |         if slot_ids := _v.custom_id:
 8746 |  83 |             _slots = await AssignedSlot.filter(pk__in=slot_ids)
 8747 |  84 |             _e.description = "Enter the time & reason to ban the teams. (Time is optional)\n\nExamples:"
 8748 |  85 |             _e.set_image(url="https://cdn.discordapp.com/attachments/782161513825042462/947436682800685056/banreason.gif")
 8749 |  86 |             await interaction.followup.send(embed=_e, ephemeral=True)
 8750 |  87 | 
 8751 |  88 |             try:
 8752 |  89 |                 message: discord.Message = await self.bot.wait_for(
 8753 |  90 |                     "message",
 8754 |  91 |                     check=lambda x: x.author == interaction.user and x.channel == interaction.channel,
 8755 |  92 |                     timeout=60,
 8756 |  93 |                 )
 8757 |  94 | 
 8758 |  95 |             except asyncio.TimeoutError:
 8759 |  96 |                 return await interaction.followup.send("Timed out", ephemeral=True)
 8760 |  97 | 
 8761 |  98 |             await message.delete()
 8762 |  99 |             reason = await TimeText().convert(await self.bot.get_context(message), message.content)
 8763 | 100 | 
 8764 | 101 |             _v = BanOptions()
 8765 | 102 |             await interaction.followup.send(embed=_v.initial_embed(), view=_v, ephemeral=True)
 8766 | 103 |             await _v.wait()
 8767 | 104 |             if _v.value:
 8768 | 105 |                 _e.title = "Banning teams..."
 8769 | 106 |                 _e.description = ""
 8770 | 107 |                 _e.set_image(url=None)
 8771 | 108 | 
 8772 | 109 |                 m = await interaction.followup.send(embed=_e, ephemeral=True)
 8773 | 110 | 
 8774 | 111 |                 for idx, _ in enumerate(_slots, start=1):
 8775 | 112 |                     _e.description += f"`{idx}`: {emote.check} {await self.scrim.ban_slot(_,mod=interaction.user,reason=reason,ban_type=_v.value)}\n"
 8776 | 113 |                     with suppress(discord.HTTPException):
 8777 | 114 |                         await m.edit(embed=_e)
 8778 | 115 |                         await asyncio.sleep(0.5)
 8779 | 116 | 
 8780 | 117 |                 _e.title = "Banning Complete!"
 8781 | 118 |                 with suppress(discord.HTTPException):
 8782 | 119 |                     await m.edit(embed=_e)
 8783 | 120 | 
 8784 | 121 |                 if not await BanLog.get(guild_id=interaction.guild_id).exists():
 8785 | 122 |                     if random.randint(1, 50) == 1:
 8786 | 123 |                         _e = discord.Embed(
 8787 | 124 |                             color=0x00FFB3,
 8788 | 125 |                             description=(
 8789 | 126 |                                 "I see You don't have a public banlog channel in your server.\n\n"
 8790 | 127 |                                 "You can set it up with `qbanlog #channel`."
 8791 | 128 |                             ),
 8792 | 129 |                         )
 8793 | 130 |                         return await interaction.followup.send(embed=_e, ephermeral=True)
 8794 | 131 | 
 8795 | 132 |     @discord.ui.button(label="Info", emoji="🧐", style=discord.ButtonStyle.green, custom_id="scrim_slotlist_info_b")
 8796 | 133 |     async def get_slot_info(self, interaction: discord.Interaction, button: discord.Button):
 8797 | 134 |         await interaction.response.defer(thinking=True, ephemeral=True)
 8798 | 135 | 
 8799 | 136 |         __slots = await self.scrim.assigned_slots.all().order_by("num")
 8800 | 137 |         if not __slots:
 8801 | 138 |             return await interaction.followup.send("No slot in the scrim to fetch info.", ephemeral=True)
 8802 | 139 | 
 8803 | 140 |         _v = await prompt_slot_selection(__slots, placeholder="Select the slot to get info...", multiple=False)
 8804 | 141 | 
 8805 | 142 |         _e = discord.Embed(color=0x00FFB3, description="Kindly choose slots from the dropdown.")
 8806 | 143 | 
 8807 | 144 |         await interaction.followup.send(embed=_e, view=_v, ephemeral=True)
 8808 | 145 | 
 8809 | 146 |         await _v.wait()
 8810 | 147 |         if slot_id := _v.custom_id:
 8811 | 148 |             _slot = await AssignedSlot.filter(pk=slot_id).first()
 8812 | 149 | 
 8813 | 150 |             if not _slot.user_id:
 8814 | 151 |                 return await interaction.followup.send(
 8815 | 152 |                     "**This slot was manually added by a Scrims Moderator.**\n\n`No other info present.`", ephemeral=True
 8816 | 153 |                 )
 8817 | 154 | 
 8818 | 155 |             leader = await self.bot.get_or_fetch_member(interaction.guild, _slot.user_id)
 8819 | 156 | 
 8820 | 157 |             _e = discord.Embed(
 8821 | 158 |                 color=0x00FFB3,
 8822 | 159 |                 description=(
 8823 | 160 |                     f"**Slot No:** `{_slot.num}`\n"
 8824 | 161 |                     f"**Name:** `{_slot.team_name}`\n"
 8825 | 162 |                     f"**Captain:** `{leader}` (<@{_slot.user_id}>)\n"
 8826 | 163 |                     f"**Team:** " + ", ".join([f"<@{i}>" for i in _slot.members])
 8827 | 164 |                 ),
 8828 | 165 |             )
 8829 | 166 | 
 8830 | 167 |             if _slot.jump_url:
 8831 | 168 |                 _e.add_field(name="Registration Message", value=f"[Click me to Jump]({_slot.jump_url})", inline=False)
 8832 | 169 | 
 8833 | 170 |             _e.set_author(name="Slot Info", icon_url=self.bot.user.display_avatar.url)
 8834 | 171 |             await interaction.followup.send(embed=_e, ephemeral=True)
 8835 | 172 | 
 8836 | 
 8837 | 
 8838 | --------------------------------------------------------------------------------
 8839 | /cogs/esports/views/smslotlist/editor.py:
 8840 | --------------------------------------------------------------------------------
 8841 |   1 | from __future__ import annotations
 8842 |   2 | 
 8843 |   3 | import asyncio
 8844 |   4 | import re
 8845 |   5 | import typing as T
 8846 |   6 | from contextlib import suppress
 8847 |   7 | 
 8848 |   8 | import discord
 8849 |   9 | 
 8850 |  10 | from models import ArrayAppend, ArrayRemove, AssignedSlot, Scrim, ScrimsSlotManager
 8851 |  11 | from utils import emote, truncate_string
 8852 |  12 | 
 8853 |  13 | from .select import prompt_slot_selection
 8854 |  14 | 
 8855 |  15 | if T.TYPE_CHECKING:
 8856 |  16 |     from core import Quotient
 8857 |  17 | 
 8858 |  18 | __all__ = ("ScrimsSlotlistEditor",)
 8859 |  19 | 
 8860 |  20 | 
 8861 |  21 | class ScrimsSlotlistEditor(discord.ui.View):
 8862 |  22 |     message: discord.Message
 8863 |  23 | 
 8864 |  24 |     def __init__(self, bot: Quotient, scrim: Scrim, slotlist_message: discord.Message):
 8865 |  25 |         super().__init__(timeout=30)
 8866 |  26 | 
 8867 |  27 |         self.bot = bot
 8868 |  28 |         self.scrim = scrim
 8869 |  29 |         self.slotlist_message = slotlist_message
 8870 |  30 | 
 8871 |  31 |         self.custom_id = None
 8872 |  32 | 
 8873 |  33 |     async def on_timeout(self) -> None:
 8874 |  34 |         if not hasattr(self, "message"):
 8875 |  35 |             return
 8876 |  36 | 
 8877 |  37 |         for _ in self.children:
 8878 |  38 |             if isinstance(_, discord.ui.Button):
 8879 |  39 |                 _.disabled = True
 8880 |  40 | 
 8881 |  41 |         with suppress(discord.HTTPException):
 8882 |  42 |             return await self.message.edit(view=self)
 8883 |  43 | 
 8884 |  44 |     def initial_embed(self) -> discord.Embed:
 8885 |  45 |         _e = discord.Embed(color=0x00FFB3, description="Choose an option below to edit the slotlist.")
 8886 |  46 |         return _e
 8887 |  47 | 
 8888 |  48 |     @discord.ui.button(style=discord.ButtonStyle.success, label="Change Team", custom_id="smslot_change_team")
 8889 |  49 |     async def change_team_name(self, interaction: discord.Interaction, button: discord.Button):
 8890 |  50 |         await interaction.response.defer()
 8891 |  51 | 
 8892 |  52 |         __slots = await self.scrim.assigned_slots.all().order_by("num")
 8893 |  53 |         if not __slots:
 8894 |  54 |             return await interaction.followup.send("No slot available to replace.", ephemeral=True)
 8895 |  55 |         _v = await prompt_slot_selection(__slots, placeholder="Select the slot to change...")
 8896 |  56 | 
 8897 |  57 |         _e = discord.Embed(color=0x00FFB3, description="Kindly choose a slot from the dropdown.")
 8898 |  58 | 
 8899 |  59 |         await interaction.followup.send(embed=_e, view=_v, ephemeral=True)
 8900 |  60 | 
 8901 |  61 |         await _v.wait()
 8902 |  62 |         if slot_id := _v.custom_id:
 8903 |  63 |             _slot = await AssignedSlot.get_or_none(pk=slot_id)
 8904 |  64 | 
 8905 |  65 |             _e.description = "Please enter the team name. Also mention the leader of that team (Optional)"
 8906 |  66 |             await interaction.followup.send(embed=_e, ephemeral=True)
 8907 |  67 | 
 8908 |  68 |             try:
 8909 |  69 |                 _ms: discord.Message = await self.bot.wait_for(
 8910 |  70 |                     "message",
 8911 |  71 |                     check=lambda m: m.author == interaction.user and m.channel == interaction.channel,
 8912 |  72 |                     timeout=50,
 8913 |  73 |                 )
 8914 |  74 |             except asyncio.TimeoutError:
 8915 |  75 |                 return await interaction.followup.send("Timed out. Please try again.", ephemeral=True)
 8916 |  76 | 
 8917 |  77 |             await _ms.delete()
 8918 |  78 |             user_id = None
 8919 |  79 |             if _ms.mentions:
 8920 |  80 |                 user_id = _ms.mentions[0].id
 8921 |  81 | 
 8922 |  82 |                 with suppress(discord.HTTPException):
 8923 |  83 |                     await _ms.mentions[0].add_roles(discord.Object(id=self.scrim.role_id))
 8924 |  84 | 
 8925 |  85 |             _ms.content = re.sub(r"<@*!*&*\d+>", "", _ms.content)
 8926 |  86 | 
 8927 |  87 |             team_name = truncate_string(_ms.content, 22)
 8928 |  88 |             if not team_name:
 8929 |  89 |                 return await interaction.followup.send("Team name cannot be empty.", ephemeral=True)
 8930 |  90 | 
 8931 |  91 |             await AssignedSlot.filter(pk=slot_id).update(team_name=team_name, user_id=user_id)
 8932 |  92 | 
 8933 |  93 |             if _slot and _slot.user_id:
 8934 |  94 |                 if not await self.scrim.assigned_slots.filter(user_id=_slot.user_id).exists():
 8935 |  95 |                     member = self.scrim.guild.get_member(_slot.user_id)
 8936 |  96 |                     with suppress(discord.HTTPException):
 8937 |  97 |                         await member.remove_roles(discord.Object(id=self.scrim.role_id))
 8938 |  98 | 
 8939 |  99 |             _e.description = "Slotlist updated successfully."
 8940 | 100 |             await interaction.followup.send(embed=_e, ephemeral=True)
 8941 | 101 |             return await self.scrim.refresh_slotlist_message(self.slotlist_message)
 8942 | 102 | 
 8943 | 103 |     @discord.ui.button(style=discord.ButtonStyle.red, label="Remove Team", custom_id="smslot_remove_team")
 8944 | 104 |     async def remove_team_name(self, interaction: discord.Interaction, button: discord.Button):
 8945 | 105 |         await interaction.response.defer()
 8946 | 106 | 
 8947 | 107 |         __slots = await self.scrim.assigned_slots.all().order_by("num")
 8948 | 108 |         if not __slots:
 8949 | 109 |             return await interaction.followup.send("No slot available to remove.", ephemeral=True)
 8950 | 110 | 
 8951 | 111 |         _v = await prompt_slot_selection(__slots, placeholder="Select the slot to remove...")
 8952 | 112 |         await interaction.followup.send("Kindly choose a slot from the dropdown.", view=_v, ephemeral=True)
 8953 | 113 | 
 8954 | 114 |         await _v.wait()
 8955 | 115 |         if slot_id := _v.custom_id:
 8956 | 116 |             _slot = await AssignedSlot.get_or_none(pk=slot_id)
 8957 | 117 |             if not _slot:
 8958 | 118 |                 return
 8959 | 119 | 
 8960 | 120 |             if _slot.user_id:
 8961 | 121 |                 if await self.scrim.assigned_slots.filter(user_id=_slot.user_id).count() == 1:
 8962 | 122 |                     with suppress(discord.HTTPException, AttributeError):
 8963 | 123 |                         m = self.scrim.guild.get_member(_slot.user_id)
 8964 | 124 |                         await m.remove_roles(discord.Object(id=self.scrim.role_id))
 8965 | 125 | 
 8966 | 126 |             await self.scrim.make_changes(available_slots=ArrayAppend("available_slots", _slot.num))
 8967 | 127 |             await AssignedSlot.filter(pk=slot_id).update(team_name="❌")
 8968 | 128 |             await self.scrim.refresh_slotlist_message(self.slotlist_message)
 8969 | 129 | 
 8970 | 130 |             await AssignedSlot.filter(pk=slot_id).delete()
 8971 | 131 | 
 8972 | 132 |             _e = discord.Embed(color=0x00FFB3, description="Team Removed from slotlist.")
 8973 | 133 | 
 8974 | 134 |             await interaction.followup.send(embed=_e, ephemeral=True)
 8975 | 135 | 
 8976 | 136 |             slotm = await ScrimsSlotManager.get_or_none(guild_id=self.scrim.guild_id, scrim_ids__contains=self.scrim.id)
 8977 | 137 |             if slotm:
 8978 | 138 |                 await slotm.refresh_public_message()
 8979 | 139 | 
 8980 | 140 |     @discord.ui.button(label="Add Team", custom_id="smslot_add_team", style=discord.ButtonStyle.green)
 8981 | 141 |     async def add_new_team(self, interaction: discord.Interaction, button: discord.Button):
 8982 | 142 |         await interaction.response.defer()
 8983 | 143 | 
 8984 | 144 |         _list = list(range(self.scrim.start_from, 30))
 8985 | 145 |         async for _ in self.scrim.assigned_slots.order_by("num"):
 8986 | 146 |             _list.remove(_.num)
 8987 | 147 | 
 8988 | 148 |         _slots = [AssignedSlot(num=_, id=_, team_name="Click to add") for _ in _list]
 8989 | 149 |         if not _slots:
 8990 | 150 |             return await interaction.followup.send("No slots available to add this time.", ephemeral=True)
 8991 | 151 | 
 8992 | 152 |         _v = await prompt_slot_selection(_slots, placeholder="Select the slot to add...")
 8993 | 153 | 
 8994 | 154 |         await interaction.followup.send("Kindly choose a slot from the dropdown.", view=_v, ephemeral=True)
 8995 | 155 |         await _v.wait()
 8996 | 156 |         if slot_id := _v.custom_id:
 8997 | 157 |             await interaction.followup.send(
 8998 | 158 |                 "Please enter the team name. Also mention the leader of that team (Optional)", ephemeral=True
 8999 | 159 |             )
 9000 | 160 | 
 9001 | 161 |             try:
 9002 | 162 |                 _ms: discord.Message = await self.bot.wait_for(
 9003 | 163 |                     "message",
 9004 | 164 |                     check=lambda m: m.author == interaction.user and m.channel == interaction.channel,
 9005 | 165 |                     timeout=50,
 9006 | 166 |                 )
 9007 | 167 |             except asyncio.TimeoutError:
 9008 | 168 |                 return await interaction.followup.send("Timed out. Please try again.", ephemeral=True)
 9009 | 169 | 
 9010 | 170 |             await _ms.delete()
 9011 | 171 |             user_id = None
 9012 | 172 |             if _ms.mentions:
 9013 | 173 |                 user_id = _ms.mentions[0].id
 9014 | 174 | 
 9015 | 175 |                 with suppress(discord.HTTPException):
 9016 | 176 |                     await _ms.mentions[0].add_roles(discord.Object(id=self.scrim.role_id))
 9017 | 177 | 
 9018 | 178 |             _ms.content = re.sub(r"<@*!*&*\d+>", "", _ms.content)
 9019 | 179 | 
 9020 | 180 |             team_name = truncate_string(_ms.content, 22)
 9021 | 181 |             if not team_name:
 9022 | 182 |                 return await interaction.followup.send("Team name cannot be empty.", ephemeral=True)
 9023 | 183 | 
 9024 | 184 |             _slot = await AssignedSlot.create(num=slot_id, team_name=team_name, user_id=user_id)
 9025 | 185 |             await self.scrim.assigned_slots.add(_slot)
 9026 | 186 |             await self.scrim.make_changes(available_slots=ArrayRemove("available_slots", slot_id))
 9027 | 187 | 
 9028 | 188 |             await self.scrim.refresh_slotlist_message(self.slotlist_message)
 9029 | 189 | 
 9030 | 190 |             return await interaction.followup.send(f"{emote.check} Team added successfully.", ephemeral=True)
 9031 | 191 | 
 9032 | 
 9033 | 
 9034 | --------------------------------------------------------------------------------
 9035 | /cogs/esports/views/smslotlist/select.py:
 9036 | --------------------------------------------------------------------------------
 9037 |  1 | from __future__ import annotations
 9038 |  2 | 
 9039 |  3 | from typing import List
 9040 |  4 | 
 9041 |  5 | import discord
 9042 |  6 | 
 9043 |  7 | import config
 9044 |  8 | from models import AssignedSlot
 9045 |  9 | from utils import emote
 9046 | 10 | from utils import keycap_digit as kd
 9047 | 11 | from utils import truncate_string as ts
 9048 | 12 | 
 9049 | 13 | 
 9050 | 14 | class ScrimSlotSelector(discord.ui.Select):
 9051 | 15 |     def __init__(self, slots: List[AssignedSlot], *, placeholder: str, multiple=False):
 9052 | 16 |         _options = []
 9053 | 17 |         for slot in slots:
 9054 | 18 |             _options.append(
 9055 | 19 |                 discord.SelectOption(
 9056 | 20 |                     label=f"Slot {slot.num}", description=ts(slot.team_name, 22), emoji=emote.TextChannel, value=slot.id
 9057 | 21 |                 )
 9058 | 22 |             )
 9059 | 23 | 
 9060 | 24 |         super().__init__(options=_options, placeholder=placeholder, max_values=len(_options) if multiple else 1)
 9061 | 25 | 
 9062 | 26 |     async def callback(self, interaction: discord.Interaction):
 9063 | 27 |         await interaction.response.defer()
 9064 | 28 |         self.view.stop()
 9065 | 29 |         self.view.custom_id = interaction.data["values"][0] if not self.max_values > 1 else interaction.data["values"]
 9066 | 30 | 
 9067 | 31 | 
 9068 | 32 | async def prompt_slot_selection(slots: List[AssignedSlot], placeholder: str, multiple: bool = False):
 9069 | 33 |     first, rest = slots[:25], slots[25:]
 9070 | 34 | 
 9071 | 35 |     _view = discord.ui.View(timeout=60)
 9072 | 36 |     _view.custom_id = None
 9073 | 37 | 
 9074 | 38 |     _view.add_item(ScrimSlotSelector(first, placeholder=placeholder, multiple=multiple))
 9075 | 39 | 
 9076 | 40 |     if rest:
 9077 | 41 |         _view.add_item(ScrimSlotSelector(rest, placeholder=placeholder, multiple=multiple))
 9078 | 42 | 
 9079 | 43 |     return _view
 9080 | 44 | 
 9081 | 45 | 
 9082 | 46 | class BanOptions(discord.ui.View):
 9083 | 47 |     def __init__(self):
 9084 | 48 |         super().__init__(timeout=60)
 9085 | 49 |         self.value: str = None
 9086 | 50 | 
 9087 | 51 |     def initial_embed(self):
 9088 | 52 |         _e = discord.Embed(color=0x00FFB3, title="Ban karne ka style choose karo :)", url=config.SERVER_LINK)
 9089 | 53 |         _e.description = (
 9090 | 54 |             f"{kd(1)} - Ban Team leader from this scrim.\n\n"
 9091 | 55 |             f"{kd(2)} - Ban whole team from this scrim.\n\n"
 9092 | 56 |             f"{kd(3)} - Ban Team leader from all scrims.\n\n"
 9093 | 57 |             f"{kd(4)} - Ban whole team from all scrims."
 9094 | 58 |         )
 9095 | 59 |         return _e
 9096 | 60 | 
 9097 | 61 |     @discord.ui.button(emoji=kd(1))
 9098 | 62 |     async def on_one(self, interaction: discord.Interaction, button: discord.Button):
 9099 | 63 |         await interaction.response.defer()
 9100 | 64 |         self.value = "1"
 9101 | 65 |         self.stop()
 9102 | 66 | 
 9103 | 67 |     @discord.ui.button(emoji=kd(2))
 9104 | 68 |     async def on_two(self, interaction: discord.Interaction, button: discord.Button):
 9105 | 69 |         await interaction.response.defer()
 9106 | 70 |         self.value = "2"
 9107 | 71 |         self.stop()
 9108 | 72 | 
 9109 | 73 |     @discord.ui.button(emoji=kd(3))
 9110 | 74 |     async def on_three(self, interaction: discord.Interaction, button: discord.Button):
 9111 | 75 |         await interaction.response.defer()
 9112 | 76 |         self.value = "3"
 9113 | 77 |         self.stop()
 9114 | 78 | 
 9115 | 79 |     @discord.ui.button(emoji=kd(4))
 9116 | 80 |     async def on_four(self, interaction: discord.Interaction, button: discord.Button):
 9117 | 81 |         await interaction.response.defer()
 9118 | 82 |         self.value = "4"
 9119 | 83 |         self.stop()
 9120 | 84 | 
 9121 | 
 9122 | 
 9123 | --------------------------------------------------------------------------------
 9124 | /cogs/esports/views/ssmod/__init__.py:
 9125 | --------------------------------------------------------------------------------
 9126 | 1 | from ._edit import *  # noqa: F401, F403
 9127 | 2 | from ._setup import *  # noqa: F401, F403
 9128 | 3 | 
 9129 | 
 9130 | 
 9131 | --------------------------------------------------------------------------------
 9132 | /cogs/esports/views/ssmod/_buttons.py:
 9133 | --------------------------------------------------------------------------------
 9134 |   1 | from __future__ import annotations
 9135 |   2 | 
 9136 |   3 | import discord
 9137 |   4 | 
 9138 |   5 | from constants import SSType
 9139 |   6 | from core import Context
 9140 |   7 | from models import SSVerify
 9141 |   8 | from utils import BaseSelector, Prompt, inputs
 9142 |   9 | from utils import keycap_digit as kd
 9143 |  10 | from utils import truncate_string
 9144 |  11 | 
 9145 |  12 | from ._type import SStypeSelector
 9146 |  13 | 
 9147 |  14 | 
 9148 |  15 | class SetChannel(discord.ui.Button):
 9149 |  16 |     def __init__(self, ctx: Context):
 9150 |  17 |         super().__init__(emoji=kd(1))
 9151 |  18 | 
 9152 |  19 |         self.ctx = ctx
 9153 |  20 | 
 9154 |  21 |     async def callback(self, interaction: discord.Interaction):
 9155 |  22 |         await interaction.response.defer()
 9156 |  23 | 
 9157 |  24 |         _m = await self.ctx.simple("Mention the channel you want to use for ssverification.")
 9158 |  25 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
 9159 |  26 | 
 9160 |  27 |         await self.ctx.safe_delete(_m)
 9161 |  28 | 
 9162 |  29 |         if await SSVerify.filter(channel_id=channel.id).exists():
 9163 |  30 |             return await self.ctx.error(f"{channel.mention} is already a ssverification channel.", 3)
 9164 |  31 | 
 9165 |  32 |         if not channel.permissions_for(self.ctx.guild.me).embed_links:
 9166 |  33 |             return await self.ctx.error(f"I need `embed_links` permission in {channel.mention}", 3)
 9167 |  34 | 
 9168 |  35 |         self.view.record.channel_id = channel.id
 9169 |  36 |         self.ctx.bot.cache.ssverify_channels.add(channel.id)
 9170 |  37 | 
 9171 |  38 |         await self.view.refresh_view()
 9172 |  39 | 
 9173 |  40 | 
 9174 |  41 | class SetRole(discord.ui.Button):
 9175 |  42 |     def __init__(self, ctx: Context):
 9176 |  43 |         super().__init__(emoji=kd(2))
 9177 |  44 |         self.ctx = ctx
 9178 |  45 | 
 9179 |  46 |     async def callback(self, interaction: discord.Interaction):
 9180 |  47 |         await interaction.response.defer()
 9181 |  48 | 
 9182 |  49 |         _m = await self.ctx.simple("Mention the role you want to give for ssverification.")
 9183 |  50 |         role = await inputs.role_input(self.ctx, delete_after=True)
 9184 |  51 | 
 9185 |  52 |         await self.ctx.safe_delete(_m)
 9186 |  53 |         self.view.record.role_id = role.id
 9187 |  54 | 
 9188 |  55 |         await self.view.refresh_view()
 9189 |  56 | 
 9190 |  57 | 
 9191 |  58 | class RequiredSS(discord.ui.Button):
 9192 |  59 |     def __init__(self, ctx: Context):
 9193 |  60 |         super().__init__(emoji=kd(3))
 9194 |  61 | 
 9195 |  62 |         self.ctx = ctx
 9196 |  63 | 
 9197 |  64 |     async def callback(self, interaction: discord.Interaction):
 9198 |  65 |         await interaction.response.defer()
 9199 |  66 | 
 9200 |  67 |         _m = await self.ctx.simple("How many screenshots do you need me to verify? (`1-5`)")
 9201 |  68 |         _ss = await inputs.integer_input(self.ctx, delete_after=True, limits=(1, 5))
 9202 |  69 | 
 9203 |  70 |         await self.ctx.safe_delete(_m)
 9204 |  71 |         self.view.record.required_ss = _ss
 9205 |  72 | 
 9206 |  73 |         await self.view.refresh_view()
 9207 |  74 | 
 9208 |  75 | 
 9209 |  76 | class ScreenshotType(discord.ui.Button):
 9210 |  77 |     def __init__(self, ctx: Context):
 9211 |  78 |         super().__init__(emoji=kd(4))
 9212 |  79 | 
 9213 |  80 |         self.ctx = ctx
 9214 |  81 | 
 9215 |  82 |     async def callback(self, interaction: discord.Interaction):
 9216 |  83 |         await interaction.response.defer()
 9217 |  84 | 
 9218 |  85 |         _v = BaseSelector(self.ctx.author.id, SStypeSelector)
 9219 |  86 |         _m = await self.ctx.simple("What type of screenshots do you want to verify?", view=_v)
 9220 |  87 |         await _v.wait()
 9221 |  88 |         await _m.delete()
 9222 |  89 |         if _v.custom_id:
 9223 |  90 |             self.view.record.ss_type = SSType(_v.custom_id)
 9224 |  91 | 
 9225 |  92 |             if not self.view.record.ss_type == SSType.yt:
 9226 |  93 |                 if not await self.ctx.is_premium_guild():
 9227 |  94 |                     return await self.ctx.error("You need Quotient Prime to set this filter. (Use `qperks`)", 4)
 9228 |  95 | 
 9229 |  96 |             if _v.custom_id == "custom":
 9230 |  97 |                 _m = await self.ctx.simple(
 9231 |  98 |                     "What name do want to give this filter?\n\n" "Enter any name relevant to what you want to verify.\n"
 9232 |  99 |                 )
 9233 | 100 |                 _name = await inputs.string_input(self.ctx, delete_after=True)
 9234 | 101 |                 await self.ctx.safe_delete(_m)
 9235 | 102 |                 _name = truncate_string(_name, max_length=50)
 9236 | 103 | 
 9237 | 104 |                 _m = await self.ctx.simple(
 9238 | 105 |                     "What words might appear in the screenshot? Maybe like name of the game/app or "
 9239 | 106 |                     "anything that you believe to be common in the screenshots.\n\n"
 9240 | 107 |                     "*Separate with comma `,`*"
 9241 | 108 |                 )
 9242 | 109 |                 _keys = await inputs.string_input(self.ctx, delete_after=True)
 9243 | 110 |                 await self.ctx.safe_delete(_m)
 9244 | 111 | 
 9245 | 112 |                 _keys = _keys.split(",")
 9246 | 113 |                 self.view.record.keywords = [_name, *[truncate_string(i, 50).strip() for i in _keys]]
 9247 | 114 | 
 9248 | 115 |                 from ._edit import SSmodEditor
 9249 | 116 | 
 9250 | 117 |                 if isinstance(self.view, SSmodEditor):
 9251 | 118 |                     await self.ctx.bot.db.execute(
 9252 | 119 |                         "UPDATE ss_info SET keywords = $2 WHERE id = $1", self.view.record.id, self.view.record.keywords
 9253 | 120 |                     )
 9254 | 121 | 
 9255 | 122 |                 self.view.record.channel_name = _name
 9256 | 123 | 
 9257 | 124 |                 await self.ctx.success(
 9258 | 125 |                     f"Successfully set custom filter.\nKeywords: `{', '.join(self.view.record.keywords)}`", 4
 9259 | 126 |                 )
 9260 | 127 | 
 9261 | 128 |         await self.view.refresh_view()
 9262 | 129 | 
 9263 | 130 | 
 9264 | 131 | class PageName(discord.ui.Button):
 9265 | 132 |     def __init__(self, ctx: Context):
 9266 | 133 |         super().__init__(emoji=kd(5))
 9267 | 134 | 
 9268 | 135 |         self.ctx = ctx
 9269 | 136 | 
 9270 | 137 |     async def callback(self, interaction: discord.Interaction):
 9271 | 138 |         await interaction.response.defer()
 9272 | 139 | 
 9273 | 140 |         _m = await self.ctx.simple("Enter the exact name of your page/channel.")
 9274 | 141 |         _name = await inputs.string_input(self.ctx, delete_after=True)
 9275 | 142 | 
 9276 | 143 |         await self.ctx.safe_delete(_m)
 9277 | 144 |         self.view.record.channel_name = truncate_string(_name, 30)
 9278 | 145 |         await self.view.refresh_view()
 9279 | 146 | 
 9280 | 147 | 
 9281 | 148 | class PageLink(discord.ui.Button):
 9282 | 149 |     def __init__(self, ctx: Context):
 9283 | 150 |         super().__init__(emoji=kd(6))
 9284 | 151 | 
 9285 | 152 |         self.ctx = ctx
 9286 | 153 | 
 9287 | 154 |     async def callback(self, interaction: discord.Interaction):
 9288 | 155 |         await interaction.response.defer()
 9289 | 156 | 
 9290 | 157 |         _m = await self.ctx.simple("Enter the direct link to your page/channel.")
 9291 | 158 |         _name = await inputs.string_input(self.ctx, delete_after=True)
 9292 | 159 | 
 9293 | 160 |         await self.ctx.safe_delete(_m)
 9294 | 161 |         self.view.record.channel_link = truncate_string(_name, 130)
 9295 | 162 |         await self.view.refresh_view()
 9296 | 163 | 
 9297 | 164 | 
 9298 | 165 | class AllowSame(discord.ui.Button):
 9299 | 166 |     def __init__(self):
 9300 | 167 |         super().__init__(emoji=kd(7))
 9301 | 168 | 
 9302 | 169 |     async def callback(self, interaction: discord.Interaction):
 9303 | 170 |         await interaction.response.defer()
 9304 | 171 |         self.view.record.allow_same = not self.view.record.allow_same
 9305 | 172 |         await self.view.refresh_view()
 9306 | 173 | 
 9307 | 174 | 
 9308 | 175 | class SuccessMessage(discord.ui.Button):
 9309 | 176 |     def __init__(self, ctx, **kwargs):
 9310 | 177 |         super().__init__(emoji=kd(8), **kwargs)
 9311 | 178 | 
 9312 | 179 |         self.ctx = ctx
 9313 | 180 | 
 9314 | 181 |     async def callback(self, interaction: discord.Interaction):
 9315 | 182 |         await interaction.response.defer()
 9316 | 183 | 
 9317 | 184 |         m = await self.ctx.simple(
 9318 | 185 |             "What message do you want me to show for successful verification? This message will be sent to "
 9319 | 186 |             "players who verify screenshots successfully.\n\n**Current Success Message:**"
 9320 | 187 |             f"```{self.view.record.success_message if self.view.record.success_message else 'Not Set Yet.'}```"
 9321 | 188 |             "\n`Kindly keep it under 500 characters. Enter none to remove it.`"
 9322 | 189 |         )
 9323 | 190 | 
 9324 | 191 |         msg = await inputs.string_input(self.ctx, delete_after=True)
 9325 | 192 |         await self.ctx.safe_delete(m)
 9326 | 193 | 
 9327 | 194 |         msg = truncate_string(msg, 500)
 9328 | 195 |         if msg.lower().strip() == "none":
 9329 | 196 |             msg = None
 9330 | 197 |             await self.ctx.success("Removed Success Message.", 3)
 9331 | 198 | 
 9332 | 199 |         elif msg.lower().strip() == "cancel":
 9333 | 200 |             return
 9334 | 201 | 
 9335 | 202 |         if msg != None:
 9336 | 203 |             await self.ctx.success("Success Message Updated.", 3)
 9337 | 204 | 
 9338 | 205 |         self.view.record.success_message = msg
 9339 | 206 |         await self.view.refresh_view()
 9340 | 207 | 
 9341 | 208 | 
 9342 | 209 | class DeleteButton(discord.ui.Button):
 9343 | 210 |     def __init__(self, ctx: Context, record: SSVerify):
 9344 | 211 |         super().__init__(label="Delete ssverify", style=discord.ButtonStyle.red)
 9345 | 212 |         self.ctx = ctx
 9346 | 213 |         self.record = record
 9347 | 214 | 
 9348 | 215 |     async def callback(self, interaction: discord.Interaction):
 9349 | 216 |         await interaction.response.defer()
 9350 | 217 |         prompt = await self.ctx.prompt("Are you sure you want to delete this ssverify?")
 9351 | 218 |         if not prompt:
 9352 | 219 |             return await self.ctx.simple("Okay, not deleting.", 3)
 9353 | 220 | 
 9354 | 221 |         await self.record.full_delete()
 9355 | 222 |         await self.ctx.success("Successfully deleted ssverify.", 3)
 9356 | 223 |         return await self.view.on_timeout()
 9357 | 224 | 
 9358 | 225 | 
 9359 | 226 | class DiscardButton(discord.ui.Button):
 9360 | 227 |     def __init__(self):
 9361 | 228 |         super().__init__(label="Cancel", style=discord.ButtonStyle.red)
 9362 | 229 | 
 9363 | 230 |     async def callback(self, interaction: discord.Interaction):
 9364 | 231 |         return await self.view.on_timeout()
 9365 | 232 | 
 9366 | 233 | 
 9367 | 234 | class SaveButton(discord.ui.Button):
 9368 | 235 |     def __init__(self, ctx: Context):
 9369 | 236 |         self.ctx = ctx
 9370 | 237 |         super().__init__(label="Save & Setup", style=discord.ButtonStyle.green, disabled=True)
 9371 | 238 | 
 9372 | 239 |     async def callback(self, interaction: discord.Interaction):
 9373 | 240 |         await interaction.response.defer()
 9374 | 241 | 
 9375 | 242 |         if not await self.ctx.is_premium_guild():
 9376 | 243 |             if await SSVerify.filter(guild_id=self.ctx.guild.id).exists():
 9377 | 244 |                 return await self.ctx.premium_mango("You need Quotient Premium to setup more than 1 ssverify.")
 9378 | 245 | 
 9379 | 246 |         await self.view.record.save()
 9380 | 247 |         self.ctx.bot.cache.ssverify_channels.add(self.view.record.channel_id)
 9381 | 248 |         await self.view.on_timeout()
 9382 | 249 |         await self.ctx.success(f"Successfully set ssverification in {self.view.record.channel.mention}.", 3)
 9383 | 250 | 
 9384 | 
 9385 | 
 9386 | --------------------------------------------------------------------------------
 9387 | /cogs/esports/views/ssmod/_edit.py:
 9388 | --------------------------------------------------------------------------------
 9389 |   1 | from __future__ import annotations
 9390 |   2 | 
 9391 |   3 | from typing import TYPE_CHECKING, List
 9392 |   4 | 
 9393 |   5 | if TYPE_CHECKING:
 9394 |   6 |     from core import Quotient
 9395 |   7 | 
 9396 |   8 | import config
 9397 |   9 | from core import Context
 9398 |  10 | from models import SSVerify
 9399 |  11 | 
 9400 |  12 | from ...views.base import EsportsBaseView
 9401 |  13 | from ..paginator import NextButton, PrevButton, StopButton
 9402 |  14 | from ._buttons import *
 9403 |  15 | 
 9404 |  16 | 
 9405 |  17 | class SSmodEditor(EsportsBaseView):
 9406 |  18 |     def __init__(self, ctx: Context, records: List[SSVerify]):
 9407 |  19 |         super().__init__(ctx)
 9408 |  20 | 
 9409 |  21 |         self.ctx = ctx
 9410 |  22 |         self.bot: Quotient = ctx.bot
 9411 |  23 | 
 9412 |  24 |         self.records = records
 9413 |  25 | 
 9414 |  26 |         self.record = self.records[0]
 9415 |  27 | 
 9416 |  28 |         self.current_page = 1
 9417 |  29 | 
 9418 |  30 |     async def refresh_view(self):
 9419 |  31 |         self.record = self.records[self.current_page - 1]
 9420 |  32 | 
 9421 |  33 |         _d = dict(self.record)
 9422 |  34 | 
 9423 |  35 |         del _d["id"]
 9424 |  36 |         del _d["keywords"]
 9425 |  37 | 
 9426 |  38 |         await SSVerify.filter(pk=self.record.pk).update(**_d)
 9427 |  39 | 
 9428 |  40 |         _e = await self.initial_embed(self.record)
 9429 |  41 | 
 9430 |  42 |         await self._add_buttons(self.ctx)
 9431 |  43 | 
 9432 |  44 |         try:
 9433 |  45 |             self.message = await self.message.edit(embed=_e, view=self)
 9434 |  46 |         except discord.HTTPException:
 9435 |  47 |             await self.on_timeout()
 9436 |  48 | 
 9437 |  49 |     async def initial_embed(self, record: SSVerify):
 9438 |  50 |         _index = self.records.index(record)
 9439 |  51 |         await record.refresh_from_db()
 9440 |  52 |         self.records[_index] = record
 9441 |  53 | 
 9442 |  54 |         _e = discord.Embed(color=0x00FFB3, title=f"Screenshots Manager - Edit Config", url=config.SERVER_LINK)
 9443 |  55 | 
 9444 |  56 |         fields = {
 9445 |  57 |             "Channel": getattr(record.channel, "mention", "`deleted-channel`"),
 9446 |  58 |             "Role": getattr(record.role, "mention", "`deleted-role`"),
 9447 |  59 |             "Required ss": f"`{record.required_ss}`",
 9448 |  60 |             "Screenshot Type": f"`{record.ss_type.value.title()}`",
 9449 |  61 |             "Page Name": f"`{record.channel_name}`",
 9450 |  62 |             "Page URL": f"[Click Here]({record.channel_link})",
 9451 |  63 |             "Allow Same SS": "`Yes`" if record.allow_same else "`No`",
 9452 |  64 |             f"Success Message {config.PRIME_EMOJI}": "`Click to view or edit`",
 9453 |  65 |         }
 9454 |  66 | 
 9455 |  67 |         for _idx, (name, value) in enumerate(fields.items(), start=1):
 9456 |  68 |             _e.add_field(
 9457 |  69 |                 name=f"{kd(_idx)} {name}:",
 9458 |  70 |                 value=value,
 9459 |  71 |             )
 9460 |  72 |         _e.add_field(name="\u200b", value="\u200b")
 9461 |  73 |         _e.set_footer(text=f"Page {self.current_page}/{len(self.records)}")
 9462 |  74 | 
 9463 |  75 |         return _e
 9464 |  76 | 
 9465 |  77 |     async def _add_buttons(self, ctx):
 9466 |  78 |         self.clear_items()
 9467 |  79 | 
 9468 |  80 |         cur_page = self.current_page - 1
 9469 |  81 | 
 9470 |  82 |         if cur_page > 0:
 9471 |  83 |             self.add_item(PrevButton())
 9472 |  84 | 
 9473 |  85 |         self.add_item(StopButton())
 9474 |  86 | 
 9475 |  87 |         if len(self.records) > 1 and cur_page < len(self.records) - 1:
 9476 |  88 |             self.add_item(NextButton())
 9477 |  89 | 
 9478 |  90 |         self.add_item(SetChannel(ctx))
 9479 |  91 |         self.add_item(SetRole(ctx))
 9480 |  92 |         self.add_item(RequiredSS(ctx))
 9481 |  93 |         self.add_item(ScreenshotType(ctx))
 9482 |  94 |         self.add_item(PageName(ctx))
 9483 |  95 |         self.add_item(PageLink(ctx))
 9484 |  96 |         self.add_item(AllowSame())
 9485 |  97 | 
 9486 |  98 |         self.add_item(SuccessMessage(ctx))
 9487 |  99 |         self.add_item(DeleteButton(ctx, self.record))
 9488 | 100 | 
 9489 | 101 |         if not await self.ctx.is_premium_guild():
 9490 | 102 |             self.children[-2].disabled = True
 9491 | 103 | 
 9492 | 
 9493 | 
 9494 | --------------------------------------------------------------------------------
 9495 | /cogs/esports/views/ssmod/_setup.py:
 9496 | --------------------------------------------------------------------------------
 9497 |  1 | from __future__ import annotations
 9498 |  2 | 
 9499 |  3 | from typing import TYPE_CHECKING
 9500 |  4 | 
 9501 |  5 | if TYPE_CHECKING:
 9502 |  6 |     from core import Quotient
 9503 |  7 | 
 9504 |  8 | import discord
 9505 |  9 | 
 9506 | 10 | from core import Context
 9507 | 11 | from models import SSVerify
 9508 | 12 | from utils import emote
 9509 | 13 | 
 9510 | 14 | from ...views.base import EsportsBaseView
 9511 | 15 | from ._edit import SSmodEditor
 9512 | 16 | from ._wiz import SetupWizard
 9513 | 17 | 
 9514 | 18 | 
 9515 | 19 | class SsmodMainView(EsportsBaseView):
 9516 | 20 |     def __init__(self, ctx: Context):
 9517 | 21 |         super().__init__(ctx, timeout=90, title="Screenshots Manager")
 9518 | 22 | 
 9519 | 23 |         self.ctx = ctx
 9520 | 24 |         self.bot: Quotient = ctx.bot
 9521 | 25 | 
 9522 | 26 |     async def initial_message(self):
 9523 | 27 |         records = await SSVerify.filter(guild_id=self.ctx.guild.id).order_by("id")
 9524 | 28 |         if not records:
 9525 | 29 |             self.children[-2].disabled = True
 9526 | 30 | 
 9527 | 31 |         _to_show = [f"`{idx}.` {_.__str__()}" for idx, _ in enumerate(records, start=1)]
 9528 | 32 | 
 9529 | 33 |         _sm = "\n".join(_to_show) if _to_show else "```Click Setup button for new ssverify.```"
 9530 | 34 | 
 9531 | 35 |         _e = discord.Embed(color=0x00FFB3, title=f"Advanced Screenshots Manager", url=self.ctx.config.SERVER_LINK)
 9532 | 36 |         _e.set_thumbnail(url=self.bot.user.display_avatar.url)
 9533 | 37 |         _e.description = _sm
 9534 | 38 |         _e.set_footer(text="When in doubt, press '?' :)", icon_url=getattr(self.ctx.author, "url", None))
 9535 | 39 |         return _e
 9536 | 40 | 
 9537 | 41 |     @discord.ui.button(label="Setup ssverify", custom_id="setup_ssverify_button", emoji=emote.add)
 9538 | 42 |     async def setup_ssverify_button(self, interaction: discord.Interaction, button: discord.Button):
 9539 | 43 |         await interaction.response.defer()
 9540 | 44 | 
 9541 | 45 |         if not await self.ctx.is_premium_guild():
 9542 | 46 |             if await SSVerify.filter(guild_id=self.ctx.guild.id).exists():
 9543 | 47 |                 return await self.ctx.premium_mango("You need Quotient Premium to setup more than 1 ssverify.")
 9544 | 48 | 
 9545 | 49 |         view = SetupWizard(self.ctx)
 9546 | 50 |         _e = view.initial_message()
 9547 | 51 |         view.message = await interaction.followup.send(embed=_e, view=view)
 9548 | 52 | 
 9549 | 53 |     @discord.ui.button(label="Change Settings", custom_id="edit_ssmod_config", emoji="⚒️")
 9550 | 54 |     async def edit_ssmod_config(self, interaction: discord.Interaction, button: discord.Button):
 9551 | 55 |         await interaction.response.defer()
 9552 | 56 | 
 9553 | 57 |         records = await SSVerify.filter(guild_id=self.ctx.guild.id).order_by("id")
 9554 | 58 |         _view = SSmodEditor(self.ctx, records)
 9555 | 59 |         await _view._add_buttons(self.ctx)
 9556 | 60 |         _view.message = await interaction.followup.send(embed=await _view.initial_embed(records[0]), view=_view)
 9557 | 61 | 
 9558 | 62 |     @discord.ui.button(emoji="❔", custom_id="info_ssmod_button")
 9559 | 63 |     async def stop_ssmod_button(self, interaction: discord.Interaction, button: discord.Button):
 9560 | 64 |         _e = discord.Embed(color=0x00FFB3, title="Screenshots Manager FAQ", url=self.ctx.config.SERVER_LINK)
 9561 | 65 |         _e.description = (
 9562 | 66 |             "**How to setup Quotient ssverification?**\n"
 9563 | 67 |             "> Click the `Setup ssverify` button to set up ssverify.\n\n"
 9564 | 68 |             "**What is Custom Filter?**\n"
 9565 | 69 |             "> Custom Filter allows you to set ssverification for any app or for any type of ss.\n\n"
 9566 | 70 |             "**My question isn't listed here. What should I do?**\n"
 9567 | 71 |             "> You can talk to us directly in the support server: {0}".format(self.ctx.config.SERVER_LINK)
 9568 | 72 |         )
 9569 | 73 |         return await interaction.response.send_message(embed=_e, ephemeral=True)
 9570 | 74 | 
 9571 | 
 9572 | 
 9573 | --------------------------------------------------------------------------------
 9574 | /cogs/esports/views/ssmod/_type.py:
 9575 | --------------------------------------------------------------------------------
 9576 |  1 | from __future__ import annotations
 9577 |  2 | 
 9578 |  3 | import discord
 9579 |  4 | 
 9580 |  5 | from constants import SSType
 9581 |  6 | from utils import BaseSelector
 9582 |  7 | 
 9583 |  8 | 
 9584 |  9 | class SStypeSelector(discord.ui.Select):
 9585 | 10 |     view: BaseSelector
 9586 | 11 | 
 9587 | 12 |     def __init__(self):
 9588 | 13 |         super().__init__(
 9589 | 14 |             placeholder="Select the type of screenshots ... ",
 9590 | 15 |             options=[
 9591 | 16 |                 discord.SelectOption(
 9592 | 17 |                     label="Youtube",
 9593 | 18 |                     emoji="<:youtube:938835185976344576>",
 9594 | 19 |                     value=SSType.yt.value,
 9595 | 20 |                     description="Youtube Channel Screenshots",
 9596 | 21 |                 ),
 9597 | 22 |                 discord.SelectOption(
 9598 | 23 |                     label="Instagram",
 9599 | 24 |                     emoji="<:instagram:938834438656249896>",
 9600 | 25 |                     value=SSType.insta.value,
 9601 | 26 |                     description="Instagram Screenshots (Premium only)",
 9602 | 27 |                 ),
 9603 | 28 |                 discord.SelectOption(
 9604 | 29 |                     label="Rooter",
 9605 | 30 |                     emoji="<:rooter:938834226483171418>",
 9606 | 31 |                     value=SSType.rooter.value,
 9607 | 32 |                     description="Rooter Screenshots (Premium only)",
 9608 | 33 |                 ),
 9609 | 34 |                 discord.SelectOption(
 9610 | 35 |                     label="Loco",
 9611 | 36 |                     emoji="<:loco:938834181088219146>",
 9612 | 37 |                     value=SSType.loco.value,
 9613 | 38 |                     description="Loco Screenshots (Premium only)",
 9614 | 39 |                 ),
 9615 | 40 |                 discord.SelectOption(
 9616 | 41 |                     label="Any SS",
 9617 | 42 |                     emoji="<:hehe:874303673981878272>",
 9618 | 43 |                     value=SSType.anyss.value,
 9619 | 44 |                     description="Verify any Image (Premium only)",
 9620 | 45 |                 ),
 9621 | 46 |                 discord.SelectOption(
 9622 | 47 |                     label="Create Custom Filter",
 9623 | 48 |                     emoji="<a:rooCoder:881404453415186502>",
 9624 | 49 |                     value=SSType.custom.value,
 9625 | 50 |                     description="For anything like app installation, any mobile app,etc.",
 9626 | 51 |                 ),
 9627 | 52 |             ],
 9628 | 53 |         )
 9629 | 54 | 
 9630 | 55 |     async def callback(self, interaction: discord.Interaction):
 9631 | 56 |         await interaction.response.defer()
 9632 | 57 |         self.view.stop()
 9633 | 58 |         self.view.custom_id = interaction.data["values"][0]
 9634 | 59 | 
 9635 | 
 9636 | 
 9637 | --------------------------------------------------------------------------------
 9638 | /cogs/esports/views/ssmod/_wiz.py:
 9639 | --------------------------------------------------------------------------------
 9640 |  1 | from __future__ import annotations
 9641 |  2 | 
 9642 |  3 | import discord
 9643 |  4 | 
 9644 |  5 | import config
 9645 |  6 | from core import Context
 9646 |  7 | from models import SSVerify
 9647 |  8 | from utils import keycap_digit as kd
 9648 |  9 | 
 9649 | 10 | from ...views.base import EsportsBaseView
 9650 | 11 | from ._buttons import *
 9651 | 12 | 
 9652 | 13 | __all__ = ("SetupWizard",)
 9653 | 14 | 
 9654 | 15 | 
 9655 | 16 | class SetupWizard(EsportsBaseView):
 9656 | 17 |     def __init__(self, ctx: Context):
 9657 | 18 |         super().__init__(ctx)
 9658 | 19 | 
 9659 | 20 |         self.ctx = ctx
 9660 | 21 |         self.record = None
 9661 | 22 | 
 9662 | 23 |         self.add_item(SetChannel(ctx))
 9663 | 24 |         self.add_item(SetRole(ctx))
 9664 | 25 |         self.add_item(RequiredSS(ctx))
 9665 | 26 |         self.add_item(ScreenshotType(ctx))
 9666 | 27 |         self.add_item(PageName(ctx))
 9667 | 28 |         self.add_item(PageLink(ctx))
 9668 | 29 |         self.add_item(AllowSame())
 9669 | 30 |         self.add_item(DiscardButton())
 9670 | 31 |         self.add_item(SaveButton(ctx))
 9671 | 32 | 
 9672 | 33 |     def initial_message(self):
 9673 | 34 |         if not self.record:
 9674 | 35 |             self.record = SSVerify(guild_id=self.ctx.guild.id)
 9675 | 36 | 
 9676 | 37 |         _e = discord.Embed(color=0x00FFB3, title="Enter details & Press Save", url=config.SERVER_LINK)
 9677 | 38 | 
 9678 | 39 |         fields = {
 9679 | 40 |             "Channel": getattr(self.record.channel, "mention", "`Not-Set`"),
 9680 | 41 |             "Role": getattr(self.record.role, "mention", "`Not-Set`"),
 9681 | 42 |             "Required ss": f"`{self.record.required_ss}`",
 9682 | 43 |             "Screenshot Type": "`Not-Set`" if not self.record.ss_type else f"`{self.record.ss_type.value.title()}`",
 9683 | 44 |             "Page Name": f"`{self.record.channel_name or '`Not-Set`'}`",
 9684 | 45 |             "Page URL": "`Not-Set (Not Required)`"
 9685 | 46 |             if self.record.channel_link == config.SERVER_LINK
 9686 | 47 |             else f"[Click Here]({self.record.channel_link})",
 9687 | 48 |             "Allow Same SS": "`Yes`" if self.record.allow_same else "`No`",
 9688 | 49 |         }
 9689 | 50 | 
 9690 | 51 |         for _idx, (name, value) in enumerate(fields.items(), start=1):
 9691 | 52 |             _e.add_field(
 9692 | 53 |                 name=f"{kd(_idx)} {name}:",
 9693 | 54 |                 value=value,
 9694 | 55 |             )
 9695 | 56 | 
 9696 | 57 |         return _e
 9697 | 58 | 
 9698 | 59 |     async def refresh_view(self):
 9699 | 60 |         _e = self.initial_message()
 9700 | 61 | 
 9701 | 62 |         if all(
 9702 | 63 |             (
 9703 | 64 |                 self.record.channel_id,
 9704 | 65 |                 self.record.role_id,
 9705 | 66 |                 self.record.required_ss,
 9706 | 67 |                 self.record.ss_type,
 9707 | 68 |                 self.record.channel_name,
 9708 | 69 |             )
 9709 | 70 |         ):
 9710 | 71 |             self.children[-1].disabled = False
 9711 | 72 | 
 9712 | 73 |         try:
 9713 | 74 |             self.message = await self.message.edit(embed=_e, view=self)
 9714 | 75 |         except discord.HTTPException:
 9715 | 76 |             await self.on_timeout()
 9716 | 77 | 
 9717 | 
 9718 | 
 9719 | --------------------------------------------------------------------------------
 9720 | /cogs/esports/views/tagcheck/__init__.py:
 9721 | --------------------------------------------------------------------------------
 9722 |  1 | from __future__ import annotations
 9723 |  2 | 
 9724 |  3 | from typing import TYPE_CHECKING
 9725 |  4 | 
 9726 |  5 | from ...views.base import EsportsBaseView
 9727 |  6 | 
 9728 |  7 | if TYPE_CHECKING:
 9729 |  8 |     from core import Quotient
 9730 |  9 | 
 9731 | 10 | import discord
 9732 | 11 | 
 9733 | 12 | from core import Context
 9734 | 13 | from models import TagCheck
 9735 | 14 | 
 9736 | 15 | 
 9737 | 16 | class TagCheckView(EsportsBaseView):
 9738 | 17 |     def __init__(self, ctx: Context):
 9739 | 18 |         super().__init__(ctx)
 9740 | 19 | 
 9741 | 20 |         self.ctx = ctx
 9742 | 21 |         self.bot: Quotient = ctx.bot
 9743 | 22 | 
 9744 | 23 |     async def initial_embed(self):
 9745 | 24 |         records = await TagCheck.filter(guild_id=self.ctx.guild.id)
 9746 | 25 |         to_show = [f"`{idx}.` {_.__str__()}" for idx, _ in enumerate(records, start=1)]
 9747 | 26 |         _m = "\n".join(to_show) if to_show else "```No TagCheck channels found.```"
 9748 | 27 |         _e = discord.Embed(color=0x00FFB3, title="TagCheck Editor")
 9749 | 28 |         _e.description = "**Current TagCheck channels:**\n" + _m
 9750 | 29 |         _e.set_footer(text="Click Add Channel to set up a new TagCheck channel.")
 9751 | 30 |         return _e
 9752 | 31 | 
 9753 | 32 |     @discord.ui.button(label="Add Channel", custom_id="add_tc_channel")
 9754 | 33 |     async def add_tc_channel(self, interaction: discord.Interaction, button: discord.Button):
 9755 | 34 |         await interaction.response.defer()
 9756 | 35 | 
 9757 | 36 |     @discord.ui.button(label="Remove Channel", custom_id="remove_tc_channel")
 9758 | 37 |     async def remove_tc_channel(self, interaction: discord.Interaction, button: discord.Button):
 9759 | 38 |         await interaction.response.defer()
 9760 | 39 | 
 9761 | 
 9762 | 
 9763 | --------------------------------------------------------------------------------
 9764 | /cogs/esports/views/tourney/__init__.py:
 9765 | --------------------------------------------------------------------------------
 9766 | 1 | from .groups import *
 9767 | 2 | from .slotm import *
 9768 | 3 | 
 9769 | 
 9770 | 
 9771 | --------------------------------------------------------------------------------
 9772 | /cogs/esports/views/tourney/_base.py:
 9773 | --------------------------------------------------------------------------------
 9774 |  1 | from __future__ import annotations
 9775 |  2 | 
 9776 |  3 | import discord
 9777 |  4 | 
 9778 |  5 | from models import Tourney
 9779 |  6 | 
 9780 |  7 | from ...views.base import EsportsBaseView
 9781 |  8 | 
 9782 |  9 | 
 9783 | 10 | class TourneyView(EsportsBaseView):
 9784 | 11 |     record: Tourney
 9785 | 12 | 
 9786 | 13 |     def __init__(self, ctx, **kwargs):
 9787 | 14 |         super().__init__(ctx, **kwargs)
 9788 | 15 | 
 9789 | 16 | 
 9790 | 17 | class TourneyButton(discord.ui.Button):
 9791 | 18 |     view: TourneyView
 9792 | 19 | 
 9793 | 20 |     def __init__(self, **kwargs):
 9794 | 21 |         super().__init__(**kwargs)
 9795 | 22 | 
 9796 | 
 9797 | 
 9798 | --------------------------------------------------------------------------------
 9799 | /cogs/esports/views/tourney/_buttons.py:
 9800 | --------------------------------------------------------------------------------
 9801 |   1 | from __future__ import annotations
 9802 |   2 | 
 9803 |   3 | from contextlib import suppress
 9804 |   4 | 
 9805 |   5 | import discord
 9806 |   6 | 
 9807 |   7 | from core import Context
 9808 |   8 | from models import Tourney
 9809 |   9 | from utils import emote, inputs
 9810 |  10 | from utils import regional_indicator as ri
 9811 |  11 | from utils import truncate_string
 9812 |  12 | 
 9813 |  13 | from ._base import TourneyButton
 9814 |  14 | 
 9815 |  15 | #! increase success message limit to 500
 9816 |  16 | #! fake tags maybe
 9817 |  17 | #! disable tourney slotm in delete
 9818 |  18 | 
 9819 |  19 | 
 9820 |  20 | class SetTourneyname(TourneyButton):
 9821 |  21 |     def __init__(self, ctx: Context, letter: str):
 9822 |  22 |         super().__init__(emoji=ri(letter))
 9823 |  23 | 
 9824 |  24 |         self.ctx = ctx
 9825 |  25 | 
 9826 |  26 |     async def callback(self, interaction: discord.Interaction):
 9827 |  27 |         await interaction.response.defer()
 9828 |  28 |         m = await self.ctx.simple("Enter the new name of the tournament. (`Max 30 characters`)")
 9829 |  29 |         name = await inputs.string_input(self.ctx, delete_after=True)
 9830 |  30 |         await self.ctx.safe_delete(m)
 9831 |  31 |         self.view.record.name = truncate_string(name, 30)
 9832 |  32 | 
 9833 |  33 |         await self.view.refresh_view()
 9834 |  34 | 
 9835 |  35 | 
 9836 |  36 | class RegChannel(TourneyButton):
 9837 |  37 |     def __init__(self, ctx: Context, letter: str):
 9838 |  38 |         super().__init__(emoji=ri(letter))
 9839 |  39 | 
 9840 |  40 |         self.ctx = ctx
 9841 |  41 | 
 9842 |  42 |     async def callback(self, interaction: discord.Interaction):
 9843 |  43 |         await interaction.response.defer()
 9844 |  44 | 
 9845 |  45 |         m = await self.ctx.simple("Mention the channel where you want to take registrations.")
 9846 |  46 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
 9847 |  47 |         await self.ctx.safe_delete(m)
 9848 |  48 | 
 9849 |  49 |         if await Tourney.filter(registration_channel_id=channel.id).exists():
 9850 |  50 |             return await self.ctx.error(f"Another tourney is running in {channel.mention}.", 4)
 9851 |  51 |         self.view.record.registration_channel_id = channel.id
 9852 |  52 | 
 9853 |  53 |         self.ctx.bot.cache.tourney_channels.add(channel.id)
 9854 |  54 | 
 9855 |  55 |         if not self.view.record.confirm_channel_id:
 9856 |  56 |             with suppress(StopIteration, AttributeError):
 9857 |  57 |                 self.view.record.confirm_channel_id = next(
 9858 |  58 |                     (c.id for c in channel.category.text_channels if "confirm" in c.name.lower())
 9859 |  59 |                 )
 9860 |  60 | 
 9861 |  61 |         if not self.view.record.role_id:
 9862 |  62 |             for r in channel.guild.roles:
 9863 |  63 |                 if "confirm" in r.name and not await Tourney.get(role_id=r.id).exists():
 9864 |  64 |                     self.view.record.role_id = r.id
 9865 |  65 |                     break
 9866 |  66 | 
 9867 |  67 |         await self.view.refresh_view()
 9868 |  68 | 
 9869 |  69 | 
 9870 |  70 | class ConfirmChannel(TourneyButton):
 9871 |  71 |     def __init__(self, ctx: Context, letter: str):
 9872 |  72 |         super().__init__(emoji=ri(letter))
 9873 |  73 | 
 9874 |  74 |         self.ctx = ctx
 9875 |  75 | 
 9876 |  76 |     async def callback(self, interaction: discord.Interaction):
 9877 |  77 |         await interaction.response.defer()
 9878 |  78 | 
 9879 |  79 |         m = await self.ctx.simple("Mention the channel where you want me to post registration confirm messages.")
 9880 |  80 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
 9881 |  81 |         await self.ctx.safe_delete(m)
 9882 |  82 | 
 9883 |  83 |         self.view.record.confirm_channel_id = channel.id
 9884 |  84 | 
 9885 |  85 |         await self.view.refresh_view()
 9886 |  86 | 
 9887 |  87 | 
 9888 |  88 | class SetRole(TourneyButton):
 9889 |  89 |     def __init__(self, ctx: Context, letter: str):
 9890 |  90 |         super().__init__(emoji=ri(letter))
 9891 |  91 | 
 9892 |  92 |         self.ctx = ctx
 9893 |  93 | 
 9894 |  94 |     async def callback(self, interaction: discord.Interaction):
 9895 |  95 |         await interaction.response.defer()
 9896 |  96 | 
 9897 |  97 |         m = await self.ctx.simple("Mention the role you want to give for correct registration.")
 9898 |  98 |         role = await inputs.role_input(self.ctx, delete_after=True)
 9899 |  99 |         await self.ctx.safe_delete(m)
 9900 | 100 | 
 9901 | 101 |         self.view.record.role_id = role.id
 9902 | 102 | 
 9903 | 103 |         await self.view.refresh_view()
 9904 | 104 | 
 9905 | 105 | 
 9906 | 106 | class SetMentions(TourneyButton):
 9907 | 107 |     def __init__(self, ctx: Context, letter: str):
 9908 | 108 |         super().__init__(emoji=ri(letter))
 9909 | 109 | 
 9910 | 110 |         self.ctx = ctx
 9911 | 111 | 
 9912 | 112 |     async def callback(self, interaction: discord.Interaction):
 9913 | 113 |         await interaction.response.defer()
 9914 | 114 | 
 9915 | 115 |         m = await self.ctx.simple("How many mentions are required for registration? (Max `10`)")
 9916 | 116 |         mentions = await inputs.integer_input(self.ctx, delete_after=True, limits=(0, 10))
 9917 | 117 |         await self.ctx.safe_delete(m)
 9918 | 118 | 
 9919 | 119 |         self.view.record.required_mentions = mentions
 9920 | 120 | 
 9921 | 121 |         await self.view.refresh_view()
 9922 | 122 | 
 9923 | 123 | 
 9924 | 124 | class MinLines(TourneyButton):
 9925 | 125 |     def __init__(self, ctx: Context, letter: str):
 9926 | 126 |         super().__init__(emoji=ri(letter))
 9927 | 127 |         self.ctx = ctx
 9928 | 128 | 
 9929 | 129 |     async def callback(self, interaction: discord.Interaction):
 9930 | 130 |         await interaction.response.defer()
 9931 | 131 |         if not await self.ctx.is_premium_guild():
 9932 | 132 |             return await self.ctx.error(
 9933 | 133 |                 "**Quotient Premium is required to use this feature.**\n\n`Use qpro command to activate Premium.`", 5
 9934 | 134 |             )
 9935 | 135 | 
 9936 | 136 |         m = await self.ctx.simple("How many lines in registration message are required for registration? (Max `100`)")
 9937 | 137 |         self.view.record.required_lines = await inputs.integer_input(self.ctx, delete_after=True, limits=(0, 10))
 9938 | 138 |         await self.ctx.safe_delete(m)
 9939 | 139 | 
 9940 | 140 |         await self.view.refresh_view()
 9941 | 141 | 
 9942 | 142 | 
 9943 | 143 | class SetPingRole(TourneyButton):
 9944 | 144 |     def __init__(self, ctx: Context, letter: str):
 9945 | 145 |         super().__init__(emoji=ri(letter))
 9946 | 146 | 
 9947 | 147 |         self.ctx = ctx
 9948 | 148 | 
 9949 | 149 |     async def callback(self, interaction: discord.Interaction):
 9950 | 150 |         await interaction.response.defer()
 9951 | 151 | 
 9952 | 152 |         m = await self.ctx.simple("Mention the role you want to ping with registration open message.")
 9953 | 153 |         role = await inputs.role_input(self.ctx, delete_after=True)
 9954 | 154 |         await self.ctx.safe_delete(m)
 9955 | 155 | 
 9956 | 156 |         self.view.record.ping_role_id = role.id
 9957 | 157 | 
 9958 | 158 |         await self.view.refresh_view()
 9959 | 159 | 
 9960 | 160 | 
 9961 | 161 | class SetSlots(TourneyButton):
 9962 | 162 |     def __init__(self, ctx: Context, letter: str):
 9963 | 163 |         super().__init__(emoji=ri(letter))
 9964 | 164 | 
 9965 | 165 |         self.ctx = ctx
 9966 | 166 | 
 9967 | 167 |     async def callback(self, interaction: discord.Interaction):
 9968 | 168 |         await interaction.response.defer()
 9969 | 169 | 
 9970 | 170 |         m = await self.ctx.simple("How many total slots are there? (Max `15000`)")
 9971 | 171 |         slots = await inputs.integer_input(self.ctx, delete_after=True, limits=(1, 15000))
 9972 | 172 |         await self.ctx.safe_delete(m)
 9973 | 173 | 
 9974 | 174 |         self.view.record.total_slots = slots
 9975 | 175 | 
 9976 | 176 |         await self.view.refresh_view()
 9977 | 177 | 
 9978 | 178 | 
 9979 | 179 | class SetEmojis(TourneyButton):
 9980 | 180 |     def __init__(self, ctx: Context, letter: str):
 9981 | 181 |         super().__init__(emoji=ri(letter))
 9982 | 182 | 
 9983 | 183 |         self.ctx = ctx
 9984 | 184 | 
 9985 | 185 |     async def callback(self, interaction: discord.Interaction):
 9986 | 186 |         await interaction.response.defer()
 9987 | 187 |         if not await self.ctx.is_premium_guild():
 9988 | 188 |             return await self.ctx.error(
 9989 | 189 |                 "[Quotient Premium](https://quotientbot.xyz/premium) is required to use this feature.", 4
 9990 | 190 |             )
 9991 | 191 | 
 9992 | 192 |         e = discord.Embed(color=self.ctx.bot.color, title="Edit tourney emojis")
 9993 | 193 |         e.description = (
 9994 | 194 |             "Which emojis do you want to use for tick and cross in tournament registrations?\n\n"
 9995 | 195 |             "`Please enter two emojis and separate them with a comma`"
 9996 | 196 |         )
 9997 | 197 |         e.set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/888097255607906354/unknown.png")
 9998 | 198 |         e.set_footer(text="The first emoji must be the emoji for tick mark.")
 9999 | 199 | 
10000 | 200 |         m = await interaction.followup.send(embed=e)
10001 | 201 |         emojis = await inputs.string_input(self.ctx, delete_after=True)
10002 | 202 | 
10003 | 203 |         await self.ctx.safe_delete(m)
10004 | 204 | 
10005 | 205 |         emojis = emojis.strip().split(",")
10006 | 206 |         if not len(emojis) == 2:
10007 | 207 |             return await interaction.followup.send("You didn't enter the correct format.", ephemeral=True)
10008 | 208 | 
10009 | 209 |         check, cross = emojis
10010 | 210 | 
10011 | 211 |         for emoji in emojis:
10012 | 212 |             try:
10013 | 213 |                 await self.view.message.add_reaction(emoji.strip())
10014 | 214 |                 await self.view.message.clear_reactions()
10015 | 215 |             except discord.HTTPException:
10016 | 216 |                 return await interaction.followup.send("One of the emojis you entered is invalid.", ephemeral=True)
10017 | 217 | 
10018 | 218 |         self.view.record.emojis = {"tick": check.strip(), "cross": cross.strip()}
10019 | 219 |         await self.view.refresh_view()
10020 | 220 | 
10021 | 221 | 
10022 | 222 | class OpenRole(TourneyButton):
10023 | 223 |     def __init__(self, ctx: Context, letter: str):
10024 | 224 |         super().__init__(emoji=ri(letter))
10025 | 225 | 
10026 | 226 |         self.ctx = ctx
10027 | 227 | 
10028 | 228 |     async def callback(self, interaction: discord.Interaction):
10029 | 229 |         await interaction.response.defer()
10030 | 230 | 
10031 | 231 |         m = await self.ctx.simple("Mention the role for which you want to open/close registrations.")
10032 | 232 |         role = await inputs.role_input(self.ctx, delete_after=True)
10033 | 233 |         await self.ctx.safe_delete(m)
10034 | 234 | 
10035 | 235 |         self.view.record.open_role_id = role.id
10036 | 236 | 
10037 | 237 |         await self.view.refresh_view()
10038 | 238 | 
10039 | 239 | 
10040 | 240 | class SetGroupSize(TourneyButton):
10041 | 241 |     def __init__(self, ctx: Context, letter: str):
10042 | 242 |         super().__init__(emoji=ri(letter))
10043 | 243 | 
10044 | 244 |         self.ctx = ctx
10045 | 245 | 
10046 | 246 |     async def callback(self, interaction: discord.Interaction):
10047 | 247 |         await interaction.response.defer()
10048 | 248 | 
10049 | 249 |         m = await self.ctx.simple("How many teams will there be per group? (Max `25`)")
10050 | 250 |         n = await inputs.integer_input(self.ctx, limits=(2, 25), delete_after=True)
10051 | 251 |         await self.ctx.safe_delete(m)
10052 | 252 |         self.view.record.group_size = n
10053 | 253 |         await self.view.refresh_view()
10054 | 254 | 
10055 | 255 | 
10056 | 256 | class MultiReg(TourneyButton):
10057 | 257 |     def __init__(self, ctx: Context, letter: str):
10058 | 258 |         super().__init__(emoji=ri(letter))
10059 | 259 | 
10060 | 260 |         self.ctx = ctx
10061 | 261 | 
10062 | 262 |     async def callback(self, interaction: discord.Interaction):
10063 | 263 |         await interaction.response.defer()
10064 | 264 | 
10065 | 265 |         self.view.record.multiregister = not self.view.record.multiregister
10066 | 266 |         await self.ctx.success(
10067 | 267 |             f"Now users **{'can' if self.view.record.multiregister else 'can not'}** register more than once.", 3
10068 | 268 |         )
10069 | 269 |         await self.view.refresh_view()
10070 | 270 | 
10071 | 271 | 
10072 | 272 | class TeamCompulsion(TourneyButton):
10073 | 273 |     def __init__(self, ctx: Context, letter: str):
10074 | 274 |         super().__init__(emoji=ri(letter))
10075 | 275 | 
10076 | 276 |         self.ctx = ctx
10077 | 277 | 
10078 | 278 |     async def callback(self, interaction: discord.Interaction):
10079 | 279 |         await interaction.response.defer()
10080 | 280 | 
10081 | 281 |         self.view.record.teamname_compulsion = not self.view.record.teamname_compulsion
10082 | 282 |         await self.ctx.success(
10083 | 283 |             f"Now Team Name **{'is' if self.view.record.teamname_compulsion else 'is not'}** required to register.", 3
10084 | 284 |         )
10085 | 285 |         await self.view.refresh_view()
10086 | 286 | 
10087 | 287 | 
10088 | 288 | class DuplicateTags(TourneyButton):
10089 | 289 |     def __init__(self, ctx: Context, letter: str):
10090 | 290 |         super().__init__(emoji=ri(letter))
10091 | 291 | 
10092 | 292 |         self.ctx = ctx
10093 | 293 | 
10094 | 294 |     async def callback(self, interaction: discord.Interaction):
10095 | 295 |         await interaction.response.defer()
10096 | 296 | 
10097 | 297 |         if not await self.ctx.is_premium_guild():
10098 | 298 |             return await self.ctx.error(
10099 | 299 |                 "[Quotient Premium](https://quotientbot.xyz/premium) is required to use this feature.", 4
10100 | 300 |             )
10101 | 301 | 
10102 | 302 |         self.view.record.allow_duplicate_tags = not self.view.record.allow_duplicate_tags
10103 | 303 |         await self.ctx.success(
10104 | 304 |             f"Registrations with fake / duplicate mentions are now **{'allowed' if self.view.record.allow_duplicate_tags else 'not allowed'}**.",
10105 | 305 |             3,
10106 | 306 |         )
10107 | 307 |         await self.view.refresh_view()
10108 | 308 | 
10109 | 309 | 
10110 | 310 | class DuplicateTeamName(TourneyButton):
10111 | 311 |     def __init__(self, ctx: Context, letter: str):
10112 | 312 |         super().__init__(emoji=ri(letter))
10113 | 313 | 
10114 | 314 |         self.ctx = ctx
10115 | 315 | 
10116 | 316 |     async def callback(self, interaction: discord.Interaction):
10117 | 317 |         await interaction.response.defer()
10118 | 318 | 
10119 | 319 |         self.view.record.no_duplicate_name = not self.view.record.no_duplicate_name
10120 | 320 |         await self.ctx.success(
10121 | 321 |             f"Duplicate team names are now **{'not allowed' if self.view.record.no_duplicate_name else 'allowed'}**.", 3
10122 | 322 |         )
10123 | 323 |         await self.view.refresh_view()
10124 | 324 | 
10125 | 325 | 
10126 | 326 | class AutodeleteRejected(TourneyButton):
10127 | 327 |     def __init__(self, ctx: Context, letter: str):
10128 | 328 |         super().__init__(emoji=ri(letter))
10129 | 329 | 
10130 | 330 |         self.ctx = ctx
10131 | 331 | 
10132 | 332 |     async def callback(self, interaction: discord.Interaction):
10133 | 333 |         await interaction.response.defer()
10134 | 334 | 
10135 | 335 |         self.view.record.autodelete_rejected = not self.view.record.autodelete_rejected
10136 | 336 |         await self.ctx.success(
10137 | 337 |             f"Rejected registrations will **{'be' if self.view.record.autodelete_rejected else 'not be'}** deleted automatically.",
10138 | 338 |             3,
10139 | 339 |         )
10140 | 340 |         await self.view.refresh_view()
10141 | 341 | 
10142 | 342 | 
10143 | 343 | class SuccessMessage(TourneyButton):
10144 | 344 |     def __init__(self, ctx: Context, letter: str):
10145 | 345 |         super().__init__(emoji=ri(letter))
10146 | 346 | 
10147 | 347 |         self.ctx = ctx
10148 | 348 | 
10149 | 349 |     async def callback(self, interaction: discord.Interaction):
10150 | 350 |         await interaction.response.defer()
10151 | 351 | 
10152 | 352 |         m = await self.ctx.simple(
10153 | 353 |             "What message do you want me to show for successful registration? This message will be sent to "
10154 | 354 |             "DM of players who register successfully.\n\n**Current Success Message:**"
10155 | 355 |             f"```{self.view.record.success_message if self.view.record.success_message else 'Not Set Yet.'}```"
10156 | 356 |             "\n`Kindly keep it under 500 characters. Enter none to remove it.`",
10157 | 357 |             image="https://cdn.discordapp.com/attachments/851846932593770496/900977642382163988/unknown.png",
10158 | 358 |         )
10159 | 359 | 
10160 | 360 |         msg = await inputs.string_input(self.ctx, delete_after=True)
10161 | 361 |         await self.ctx.safe_delete(m)
10162 | 362 | 
10163 | 363 |         msg = truncate_string(msg, 500)
10164 | 364 |         if msg.lower().strip() == "none":
10165 | 365 |             msg = None
10166 | 366 |             await self.ctx.success("Removed Success Message.", 3)
10167 | 367 | 
10168 | 368 |         elif msg.lower().strip() == "cancel":
10169 | 369 |             return
10170 | 370 | 
10171 | 371 |         if msg != None:
10172 | 372 |             await self.ctx.success("Success Message Updated.", 3)
10173 | 373 | 
10174 | 374 |         self.view.record.success_message = msg
10175 | 375 |         await self.view.refresh_view()
10176 | 376 | 
10177 | 377 | 
10178 | 378 | class DeleteTourney(TourneyButton):
10179 | 379 |     def __init__(self, ctx: Context):
10180 | 380 |         super().__init__(emoji=emote.trash)
10181 | 381 | 
10182 | 382 |         self.ctx = ctx
10183 | 383 | 
10184 | 384 |     async def callback(self, interaction: discord.Interaction):
10185 | 385 |         await interaction.response.defer()
10186 | 386 | 
10187 | 387 |         prompt = await self.ctx.prompt(
10188 | 388 |             "Are you sure you want to delete this tourney?\n\n`This action is not reversible.`"
10189 | 389 |         )
10190 | 390 |         if not prompt:
10191 | 391 |             return await self.ctx.simple("Okay, not deleting.", 3)
10192 | 392 | 
10193 | 393 |         await self.view.record.full_delete(interaction.user)
10194 | 394 |         await self.ctx.success("Successfully deleted tourney.", 3)
10195 | 395 | 
10196 | 396 |         from .main import TourneyManager as TM
10197 | 397 | 
10198 | 398 |         self.view.stop()
10199 | 399 |         v = TM(self.ctx)
10200 | 400 |         v.message = await self.view.message.edit(embed=await v.initial_embed(), view=v)
10201 | 401 | 
10202 | 402 | 
10203 | 403 | class DiscardButton(TourneyButton):
10204 | 404 |     def __init__(self, ctx: Context, label: str = "Go Back", row: int = None):
10205 | 405 |         super().__init__(label=label, style=discord.ButtonStyle.red, row=row)
10206 | 406 |         self.ctx = ctx
10207 | 407 | 
10208 | 408 |     async def callback(self, interaction: discord.Interaction):
10209 | 409 |         await interaction.response.defer()
10210 | 410 | 
10211 | 411 |         from .main import TourneyManager as TM
10212 | 412 | 
10213 | 413 |         self.view.stop()
10214 | 414 |         v = TM(self.ctx)
10215 | 415 |         v.message = await self.view.message.edit(embed=await v.initial_embed(), view=v)
10216 | 416 | 
10217 | 417 | 
10218 | 418 | class SaveTourney(TourneyButton):
10219 | 419 |     def __init__(self, ctx: Context):
10220 | 420 |         super().__init__(style=discord.ButtonStyle.green, label="Save", disabled=True)
10221 | 421 |         self.ctx = ctx
10222 | 422 | 
10223 | 423 |     async def callback(self, interaction: discord.Interaction):
10224 | 424 |         await interaction.response.defer()
10225 | 425 | 
10226 | 426 |         message = await self.view.record.setup_slotm()
10227 | 427 |         self.view.record.slotm_channel_id = message.channel.id
10228 | 428 |         self.view.record.slotm_message_id = message.id
10229 | 429 | 
10230 | 430 |         await self.view.record.save()
10231 | 431 |         self.ctx.bot.loop.create_task(self.view.record.setup_logs())
10232 | 432 | 
10233 | 433 |         self.view.stop()
10234 | 434 | 
10235 | 435 |         await self.ctx.success("Successfully saved tourney.\n\n`Click start button to start registrations.`", 4)
10236 | 436 |         from .main import TourneyManager
10237 | 437 | 
10238 | 438 |         v = TourneyManager(self.ctx)
10239 | 439 |         v.message = await self.view.message.edit(embed=await v.initial_embed(), view=v)
10240 | 440 | 
10241 | 
10242 | 
10243 | --------------------------------------------------------------------------------
10244 | /cogs/esports/views/tourney/_editor.py:
10245 | --------------------------------------------------------------------------------
10246 |   1 | from __future__ import annotations
10247 |   2 | 
10248 |   3 | from string import ascii_uppercase
10249 |   4 | from typing import List
10250 |   5 | 
10251 |   6 | import discord
10252 |   7 | 
10253 |   8 | from core import Context
10254 |   9 | from models import Tourney
10255 |  10 | from utils import regional_indicator as ri
10256 |  11 | 
10257 |  12 | from ..paginator import NextButton, PrevButton, StopButton
10258 |  13 | from ._base import TourneyView
10259 |  14 | from ._buttons import (
10260 |  15 |     AutodeleteRejected,
10261 |  16 |     ConfirmChannel,
10262 |  17 |     DeleteTourney,
10263 |  18 |     DiscardButton,
10264 |  19 |     DuplicateTags,
10265 |  20 |     DuplicateTeamName,
10266 |  21 |     MinLines,
10267 |  22 |     MultiReg,
10268 |  23 |     OpenRole,
10269 |  24 |     RegChannel,
10270 |  25 |     SetEmojis,
10271 |  26 |     SetGroupSize,
10272 |  27 |     SetMentions,
10273 |  28 |     SetPingRole,
10274 |  29 |     SetRole,
10275 |  30 |     SetSlots,
10276 |  31 |     SetTourneyname,
10277 |  32 |     SuccessMessage,
10278 |  33 |     TeamCompulsion,
10279 |  34 | )
10280 |  35 | 
10281 |  36 | 
10282 |  37 | class TourneyEditor(TourneyView):
10283 |  38 |     record: Tourney
10284 |  39 | 
10285 |  40 |     def __init__(self, ctx: Context, records):
10286 |  41 |         super().__init__(ctx, timeout=60, name="Tourney Editor")
10287 |  42 | 
10288 |  43 |         self.ctx = ctx
10289 |  44 | 
10290 |  45 |         self.records: List[Tourney] = records
10291 |  46 | 
10292 |  47 |         self.record = records[0]
10293 |  48 | 
10294 |  49 |         self.current_page = 1
10295 |  50 | 
10296 |  51 |     async def refresh_view(self):
10297 |  52 |         self.record = self.records[self.current_page - 1]
10298 |  53 | 
10299 |  54 |         _d = dict(self.record)
10300 |  55 | 
10301 |  56 |         del _d["id"]
10302 |  57 |         del _d["banned_users"]
10303 |  58 | 
10304 |  59 |         await Tourney.filter(pk=self.record.pk).update(**_d)
10305 |  60 | 
10306 |  61 |         _e = await self.initial_message()
10307 |  62 | 
10308 |  63 |         await self._add_buttons(self.ctx)
10309 |  64 | 
10310 |  65 |         try:
10311 |  66 |             self.message = await self.message.edit(embed=_e, view=self)
10312 |  67 |         except discord.HTTPException:
10313 |  68 |             await self.on_timeout()
10314 |  69 | 
10315 |  70 |     async def initial_message(self):
10316 |  71 |         tourney = self.record
10317 |  72 |         _e = discord.Embed(color=self.ctx.bot.color, url=self.ctx.config.SERVER_LINK)
10318 |  73 |         _e.title = "Tournament Editor - Edit Settings"
10319 |  74 | 
10320 |  75 |         fields = {
10321 |  76 |             "Name": f"`{tourney.name}`",
10322 |  77 |             "Registration Channel": getattr(tourney.registration_channel, "mention", "`channel-deleted`"),
10323 |  78 |             "Confirm Channel": getattr(tourney.confirm_channel, "mention", "`channel-deleted`"),
10324 |  79 |             "Success Role": getattr(tourney.role, "mention", "`role-deleted`"),
10325 |  80 |             "Mentions": f"`{tourney.required_mentions}`",
10326 |  81 |             "Slots": f"`{tourney.total_slots:,}`",
10327 |  82 |             f"Reactions {self.bot.config.PRIME_EMOJI}": f"{tourney.check_emoji},{tourney.cross_emoji}",
10328 |  83 |             "Ping Role": getattr(tourney.ping_role, "mention", "`Not-Set`"),
10329 |  84 |             "Open Role": getattr(tourney.open_role, "mention", "`role-deleted`"),
10330 |  85 |             "Multi-Register": ("`Not allowed!`", "`Allowed`")[tourney.multiregister],
10331 |  86 |             "Team-Name Compulsion": ("`No!`", "`Yes!`")[tourney.teamname_compulsion],
10332 |  87 |             "Duplicate Team Name": ("`Allowed`", "`Not allowed!`")[tourney.no_duplicate_name],
10333 |  88 |             "Autodelete Rejected": ("`No!`", "`Yes!`")[tourney.autodelete_rejected],
10334 |  89 |             "Success Message": f"`Click to view / edit`",
10335 |  90 |             "Teams per Group": f"`{self.record.group_size or 'Not set'}`",
10336 |  91 |             f"Required Lines {self.bot.config.PRIME_EMOJI}": ("`Not set`", f"`{tourney.required_lines}`")[
10337 |  92 |                 bool(tourney.required_lines)
10338 |  93 |             ],
10339 |  94 |             f"Duplicate / Fake Tags {self.bot.config.PRIME_EMOJI}": ("`Not allowed!`", "`Allowed`")[
10340 |  95 |                 tourney.allow_duplicate_tags
10341 |  96 |             ],
10342 |  97 |         }
10343 |  98 | 
10344 |  99 |         for idx, (name, value) in enumerate(fields.items()):
10345 | 100 |             _e.add_field(
10346 | 101 |                 name=f"{ri(ascii_uppercase[idx])} {name}:",
10347 | 102 |                 value=value,
10348 | 103 |             )
10349 | 104 | 
10350 | 105 |         _e.add_field(name="\u200b", value="\u200b")
10351 | 106 |         _e.set_footer(text=f"Page {self.current_page}/{len(self.records)}")
10352 | 107 |         return _e
10353 | 108 | 
10354 | 109 |     async def _add_buttons(self, ctx: Context):
10355 | 110 |         self.clear_items()
10356 | 111 | 
10357 | 112 |         cur_page = self.current_page - 1
10358 | 113 | 
10359 | 114 |         if cur_page > 0:
10360 | 115 |             self.add_item(PrevButton())
10361 | 116 | 
10362 | 117 |         self.add_item(StopButton())
10363 | 118 | 
10364 | 119 |         if len(self.records) > 1 and cur_page < len(self.records) - 1:
10365 | 120 |             self.add_item(NextButton())
10366 | 121 | 
10367 | 122 |         self.add_item(SetTourneyname(ctx, "a"))
10368 | 123 |         self.add_item(RegChannel(ctx, "b"))
10369 | 124 |         self.add_item(ConfirmChannel(ctx, "c"))
10370 | 125 |         self.add_item(SetRole(ctx, "d"))
10371 | 126 |         self.add_item(SetMentions(ctx, "e"))
10372 | 127 |         self.add_item(SetSlots(ctx, "f"))
10373 | 128 |         self.add_item(SetEmojis(ctx, "g"))
10374 | 129 |         self.add_item(SetPingRole(ctx, "h"))
10375 | 130 |         self.add_item(OpenRole(ctx, "i"))
10376 | 131 |         self.add_item(MultiReg(ctx, "j"))
10377 | 132 |         self.add_item(TeamCompulsion(ctx, "k"))
10378 | 133 |         self.add_item(DuplicateTeamName(ctx, "l"))
10379 | 134 |         self.add_item(AutodeleteRejected(ctx, "m"))
10380 | 135 |         self.add_item(SuccessMessage(ctx, "n"))
10381 | 136 |         self.add_item(SetGroupSize(ctx, "o"))
10382 | 137 |         self.add_item(MinLines(ctx, "p"))
10383 | 138 |         self.add_item(DuplicateTags(ctx, "q"))
10384 | 139 |         self.add_item(DeleteTourney(ctx))
10385 | 140 |         self.add_item(DiscardButton(ctx))
10386 | 141 | 
10387 | 
10388 | 
10389 | --------------------------------------------------------------------------------
10390 | /cogs/esports/views/tourney/_partner.py:
10391 | --------------------------------------------------------------------------------
10392 |   1 | import discord
10393 |   2 | 
10394 |   3 | from core import Context
10395 |   4 | from models import MediaPartner, Tourney
10396 |   5 | from utils import aenumerate, channel_input, integer_input
10397 |   6 | 
10398 |   7 | from ..base import EsportsBaseView
10399 |   8 | 
10400 |   9 | 
10401 |  10 | class MediaPartnerView(EsportsBaseView):
10402 |  11 |     def __init__(self, ctx: Context, *, tourney: Tourney):
10403 |  12 |         super().__init__(ctx, timeout=30, title="Tourney Media Partner")
10404 |  13 |         self.tourney = tourney
10405 |  14 |         self.ctx = ctx
10406 |  15 | 
10407 |  16 |     async def initial_embed(self):
10408 |  17 |         embed = discord.Embed(title="Tournament Media Partnership", url=self.ctx.config.SERVER_LINK)
10409 |  18 |         embed.color = self.bot.color
10410 |  19 |         embed.description = (
10411 |  20 |             "With media-partnership you can make Quotient handle media partner registrations "
10412 |  21 |             "that means in Quotient will check if the user have registered in the partner server "
10413 |  22 |             "and if they have, their registration will be accepted and slot will be given to them.\n\n"
10414 |  23 |         )
10415 |  24 | 
10416 |  25 |         async for idx, partner in aenumerate(self.tourney.media_partners.all(), start=1):
10417 |  26 |             embed.description += f"`{idx:02}.` {getattr(partner.channel,'mention','deleted-channel')} - **{await partner.slots.all().count()} players**\n"
10418 |  27 | 
10419 |  28 |         embed.description += "\n`Click Add New to create a new media partner.`"
10420 |  29 |         return embed
10421 |  30 | 
10422 |  31 |     async def __refresh_embed(self):
10423 |  32 |         await self.tourney.refresh_from_db()
10424 |  33 |         try:
10425 |  34 |             self.message = await self.message.edit(embed=await self.initial_embed(), view=self)
10426 |  35 |         except discord.HTTPException:
10427 |  36 |             await self.on_timeout()
10428 |  37 | 
10429 |  38 |     @discord.ui.button(label="Add New", style=discord.ButtonStyle.green)
10430 |  39 |     async def add_partner(self, interaction: discord.Interaction, button: discord.Button):
10431 |  40 |         await interaction.response.defer(ephemeral=True)
10432 |  41 | 
10433 |  42 |         if await self.tourney.media_partners.all().count() >= 1 and not await self.ctx.is_premium_guild():
10434 |  43 |             return await self.ctx.error(
10435 |  44 |                 "You need Quotient Premium to download Ms Excel file containing all the "
10436 |  45 |                 f"registration data of your tourneys.\n\n"
10437 |  46 |                 "Buy Premium for just ₹29 here: https://quotientbot.xyz/premium",
10438 |  47 |                 6,
10439 |  48 |             )
10440 |  49 | 
10441 |  50 |         m = await self.ask_embed("Enter the tourney ID of the tournament you want to partner with.")
10442 |  51 | 
10443 |  52 |         tourney_id = await integer_input(self.ctx, self.check, delete_after=True)
10444 |  53 | 
10445 |  54 |         await self.ctx.safe_delete(m)
10446 |  55 | 
10447 |  56 |         tourney = await Tourney.get_or_none(pk=tourney_id)
10448 |  57 |         if tourney is None or not (guild := tourney.guild):
10449 |  58 |             return await self.error_embed(
10450 |  59 |                 "The tourney ID you entered is invalid. \n\nKindly use `qt` in the partner server"
10451 |  60 |                 "to get the correct ID."
10452 |  61 |             )
10453 |  62 | 
10454 |  63 |         if guild == self.ctx.guild:
10455 |  64 |             return await self.error_embed("You can't partner with a tournament running in your server.")
10456 |  65 | 
10457 |  66 |         if tourney_id in (p.tourney_id for p in await self.tourney.media_partners.all()):
10458 |  67 |             return await self.error_embed(f"The tourney you entered is already partnered with {tourney}.")
10459 |  68 | 
10460 |  69 |         if not guild.chunked:
10461 |  70 |             self.bot.loop.create_task(guild.chunk())
10462 |  71 | 
10463 |  72 |         if not await self.bot.get_or_fetch_member(guild, self.ctx.author.id):
10464 |  73 |             return await self.error_embed(
10465 |  74 |                 "You are not even in the server you are trying to media partner with.\n\n"
10466 |  75 |                 "Kindly join the server first or gimme right ID."
10467 |  76 |             )
10468 |  77 | 
10469 |  78 |         m = await self.ask_embed(
10470 |  79 |             "Which channel do you want to use for Media-Partner?\n\n" "`Mention the channel or enter its ID.`"
10471 |  80 |         )
10472 |  81 |         channel = await channel_input(self.ctx, self.check, delete_after=True)
10473 |  82 | 
10474 |  83 |         await self.ctx.safe_delete(m)
10475 |  84 | 
10476 |  85 |         channel_check = await MediaPartner.get(channel_id=channel.id).exists()
10477 |  86 |         if channel_check:
10478 |  87 |             return await self.error_embed(f"{channel.mention} is already a media partner channel")
10479 |  88 | 
10480 |  89 |         tourney_check = await MediaPartner.get(tourney_id=tourney_id).exists()
10481 |  90 |         if tourney_check:
10482 |  91 |             return await self.error_embed(f"{str(tourney)} is already media-partnered in other channel.")
10483 |  92 | 
10484 |  93 |         partner = await MediaPartner.create(tourney_id=tourney.id, channel_id=channel.id)
10485 |  94 |         await self.tourney.media_partners.add(partner)
10486 |  95 |         self.bot.cache.media_partner_channels.add(channel.id)
10487 |  96 |         await self.__refresh_embed()
10488 |  97 | 
10489 |  98 |     @discord.ui.button(style=discord.ButtonStyle.red, label="Remove")
10490 |  99 |     async def remove_partner(self, interaction: discord.Interaction, button: discord.Button):
10491 | 100 |         await interaction.response.defer(ephemeral=True)
10492 | 101 | 
10493 | 102 |         m = await self.ask_embed(
10494 | 103 |             "Which channel do you want to remove from media partner?\n\n"
10495 | 104 |             "`Note that this will not impact slots in anyway.`"
10496 | 105 |         )
10497 | 106 | 
10498 | 107 |         _channel = await channel_input(self.ctx, self.check, delete_after=True)
10499 | 108 |         await self.ctx.safe_delete(m)
10500 | 109 | 
10501 | 110 |         if not await self.tourney.media_partners.filter(pk=_channel.id).exists():
10502 | 111 |             return await self.error_embed("This is not a media-partner channel of {0}".format(self.tourney))
10503 | 112 | 
10504 | 113 |         self.bot.cache.media_partner_channels.discard(_channel.id)
10505 | 114 |         await MediaPartner.filter(pk=_channel.id).delete()
10506 | 115 |         await self.ctx.success(f"Removed {_channel.mention} from Media-Partner Channels.", 4)
10507 | 116 |         await self.__refresh_embed()
10508 | 117 | 
10509 | 
10510 | 
10511 | --------------------------------------------------------------------------------
10512 | /cogs/esports/views/tourney/_select.py:
10513 | --------------------------------------------------------------------------------
10514 |  1 | from __future__ import annotations
10515 |  2 | 
10516 |  3 | import typing as T
10517 |  4 | 
10518 |  5 | import discord
10519 |  6 | 
10520 |  7 | from core import QuotientView
10521 |  8 | from models import TMSlot, Tourney
10522 |  9 | from utils import emote
10523 | 10 | 
10524 | 11 | 
10525 | 12 | class TourneySelector(discord.ui.Select):
10526 | 13 |     view: QuotientView
10527 | 14 | 
10528 | 15 |     def __init__(self, placeholder: str, tourneys: T.List[Tourney]):
10529 | 16 |         _options = []
10530 | 17 |         for tourney in tourneys:
10531 | 18 |             _options.append(
10532 | 19 |                 discord.SelectOption(
10533 | 20 |                     label=f"{getattr(tourney.registration_channel,'name','channel-deleted')} - (ID:{tourney.id})",
10534 | 21 |                     emoji=emote.TextChannel,
10535 | 22 |                     value=tourney.id,
10536 | 23 |                 )
10537 | 24 |             )
10538 | 25 | 
10539 | 26 |         super().__init__(placeholder=placeholder, options=_options)
10540 | 27 | 
10541 | 28 |     async def callback(self, interaction: discord.Interaction):
10542 | 29 |         await interaction.response.defer()
10543 | 30 |         self.view.custom_id = self.values[0]
10544 | 31 | 
10545 | 32 |         self.view.stop()
10546 | 33 | 
10547 | 34 | 
10548 | 35 | class TourneySlotSelec(discord.ui.Select):
10549 | 36 |     view: QuotientView
10550 | 37 | 
10551 | 38 |     def __init__(self, slots: T.List[TMSlot], placeholder: str = "Select a slot to cancel"):
10552 | 39 |         _options = []
10553 | 40 | 
10554 | 41 |         for slot in slots:
10555 | 42 |             _options.append(
10556 | 43 |                 discord.SelectOption(
10557 | 44 |                     emoji=emote.TextChannel,
10558 | 45 |                     label=f"Slot {slot.num} - {slot.team_name}",
10559 | 46 |                     description=f"#{getattr(slot.tourney.registration_channel,'name','channel-deleted')} - (ID:{slot.tourney.id})",
10560 | 47 |                     value=f"{slot.id}:{slot.tourney.id}",
10561 | 48 |                 )
10562 | 49 |             )
10563 | 50 | 
10564 | 51 |         super().__init__(options=_options, placeholder=placeholder, max_values=len(_options))
10565 | 52 | 
10566 | 53 |     async def callback(self, interaction: discord.Interaction):
10567 | 54 |         await interaction.response.defer()
10568 | 55 |         self.view.stop()
10569 | 56 |         self.view.custom_id = interaction.data["values"]
10570 | 57 | 
10571 | 
10572 | 
10573 | --------------------------------------------------------------------------------
10574 | /cogs/esports/views/tourney/_wiz.py:
10575 | --------------------------------------------------------------------------------
10576 |  1 | from __future__ import annotations
10577 |  2 | 
10578 |  3 | from string import ascii_uppercase
10579 |  4 | 
10580 |  5 | from core import Context
10581 |  6 | from models import Tourney
10582 |  7 | 
10583 |  8 | from ._base import TourneyView
10584 |  9 | from ._buttons import *
10585 | 10 | 
10586 | 11 | 
10587 | 12 | class TourneySetupWizard(TourneyView):
10588 | 13 |     record: Tourney
10589 | 14 | 
10590 | 15 |     def __init__(self, ctx: Context):
10591 | 16 |         super().__init__(ctx)
10592 | 17 | 
10593 | 18 |         self.ctx = ctx
10594 | 19 |         self.record = None
10595 | 20 | 
10596 | 21 |         self.add_item(RegChannel(ctx, "a"))
10597 | 22 |         self.add_item(ConfirmChannel(ctx, "b"))
10598 | 23 |         self.add_item(SetRole(ctx, "c"))
10599 | 24 |         self.add_item(SetMentions(ctx, "d"))
10600 | 25 |         self.add_item(SetGroupSize(ctx, "e"))
10601 | 26 |         self.add_item(SetSlots(ctx, "f"))
10602 | 27 |         self.add_item(SetEmojis(ctx, "g"))
10603 | 28 |         self.add_item(DiscardButton(ctx))
10604 | 29 |         self.add_item(SaveTourney(ctx))
10605 | 30 | 
10606 | 31 |     def initial_message(self):
10607 | 32 |         if not self.record:
10608 | 33 |             self.record = Tourney(guild_id=self.ctx.guild.id, host_id=self.ctx.author.id)
10609 | 34 | 
10610 | 35 |         fields = {
10611 | 36 |             "Registration Channel": getattr(self.record.registration_channel, "mention", "`Not-Set`"),
10612 | 37 |             "Confirm Channel": getattr(self.record.confirm_channel, "mention", "`Not-Set`"),
10613 | 38 |             "Success Role": getattr(self.record.role, "mention", "`Not-Set`"),
10614 | 39 |             "Required Mentions": f"`{self.record.required_mentions}`",
10615 | 40 |             "Teams per Group": f"`{self.record.group_size or 'Not-Set'}`",
10616 | 41 |             "Total Slots": f"`{self.record.total_slots or 'Not-Set'}`",
10617 | 42 |             f"Reactions {self.bot.config.PRIME_EMOJI}": f"{self.record.check_emoji},{self.record.cross_emoji}",
10618 | 43 |         }
10619 | 44 | 
10620 | 45 |         _e = discord.Embed(color=0x00FFB3, title="Enter details & Press Save", url=self.bot.config.SERVER_LINK)
10621 | 46 | 
10622 | 47 |         for idx, (name, value) in enumerate(fields.items()):
10623 | 48 |             _e.add_field(
10624 | 49 |                 name=f"{ri(ascii_uppercase[idx])} {name}:",
10625 | 50 |                 value=value,
10626 | 51 |             )
10627 | 52 | 
10628 | 53 |         return _e
10629 | 54 | 
10630 | 55 |     async def refresh_view(self):
10631 | 56 |         _e = self.initial_message()
10632 | 57 | 
10633 | 58 |         if all(
10634 | 59 |             (
10635 | 60 |                 self.record.registration_channel_id,
10636 | 61 |                 self.record.role_id,
10637 | 62 |                 self.record.confirm_channel_id,
10638 | 63 |                 self.record.total_slots,
10639 | 64 |                 self.record.group_size,
10640 | 65 |             )
10641 | 66 |         ):
10642 | 67 |             self.children[-1].disabled = False
10643 | 68 | 
10644 | 69 |         try:
10645 | 70 |             self.message = await self.message.edit(embed=_e, view=self)
10646 | 71 |         except discord.HTTPException:
10647 | 72 |             await self.on_timeout()
10648 | 73 | 
10649 | 
10650 | 
10651 | --------------------------------------------------------------------------------
10652 | /cogs/esports/views/tourney/groups.py:
10653 | --------------------------------------------------------------------------------
10654 |   1 | from __future__ import annotations
10655 |   2 | 
10656 |   3 | from datetime import datetime
10657 |   4 | from typing import TYPE_CHECKING, List
10658 |   5 | 
10659 |   6 | from models import Guild, Tourney
10660 |   7 | 
10661 |   8 | from ...views.base import EsportsBaseView
10662 |   9 | 
10663 |  10 | if TYPE_CHECKING:
10664 |  11 |     from core import Quotient
10665 |  12 | 
10666 |  13 | import asyncio
10667 |  14 | 
10668 |  15 | import discord
10669 |  16 | from discord.ext import commands
10670 |  17 | from humanize import precisedelta
10671 |  18 | 
10672 |  19 | import config
10673 |  20 | from core import Context
10674 |  21 | from utils import QuoRole, emote, get_chunks, inputs, truncate_string
10675 |  22 | 
10676 |  23 | 
10677 |  24 | class TourneyGroupManager(EsportsBaseView):
10678 |  25 |     def __init__(self, ctx: Context, *, tourney: Tourney, size: int = 20):
10679 |  26 |         super().__init__(ctx, timeout=60, title="Tourney Group Manager")
10680 |  27 | 
10681 |  28 |         self.ctx = ctx
10682 |  29 |         self.tourney = tourney
10683 |  30 |         self.size = size
10684 |  31 |         self.bot: Quotient = ctx.bot
10685 |  32 | 
10686 |  33 |     @staticmethod
10687 |  34 |     def initial_embed(tourney: Tourney, size: int) -> discord.Embed:
10688 |  35 |         e = discord.Embed(color=0x00FFB3, title="Tourney Group Manager")
10689 |  36 |         e.description = (
10690 |  37 |             f"**[Tourney Slot Manager]({config.SERVER_LINK})** ─ {tourney}\n"
10691 |  38 |             f"**Group Size: `{size}`**\n\n"
10692 |  39 |             "• Click `Publish` to send group embeds in a channel.\n"
10693 |  40 |             "• Click `Give Roles` to provide group roles to team leaders.\n"
10694 |  41 |         )
10695 |  42 | 
10696 |  43 |         return e
10697 |  44 | 
10698 |  45 |     @discord.ui.button(custom_id="publish_groups", label="Publish Group List")
10699 |  46 |     async def publish_tourney_groups(self, interaction: discord.Interaction, button: discord.Button):
10700 |  47 |         await interaction.response.defer(ephemeral=True)
10701 |  48 | 
10702 |  49 |         m = await self.ask_embed(
10703 |  50 |             "Kindly mention the channel where you want me to send group list.\n\n"
10704 |  51 |             "`Make sure I have embed_links and manage_webhooks permission there.`"
10705 |  52 |         )
10706 |  53 | 
10707 |  54 |         _channel = await inputs.channel_input(self.ctx, self.check, delete_after=True)
10708 |  55 |         await self.ctx.maybe_delete(m)
10709 |  56 | 
10710 |  57 |         if not _channel.permissions_for(self.ctx.guild.me).manage_webhooks:
10711 |  58 |             return await self.error_embed(f"Make sure I have `manage_webhooks` permission in {_channel.mention}.")
10712 |  59 | 
10713 |  60 |         _list = []
10714 |  61 | 
10715 |  62 |         for idx, _chunk in enumerate(await self.tourney.get_groups(self.size), start=1):
10716 |  63 |             e = discord.Embed(color=self.bot.color, title=f"{self.tourney.name} Group {idx}")
10717 |  64 |             e.set_footer(text=self.ctx.guild.name, icon_url=getattr(self.ctx.guild.icon, "url", None))
10718 |  65 |             e.description = ""
10719 |  66 |             for count, _slot in enumerate(_chunk, start=1):
10720 |  67 |                 e.description += f"`{count:02}` • **{truncate_string(_slot.team_name,30)}** (<@{_slot.leader_id}>)\n"
10721 |  68 | 
10722 |  69 |             _list.append(e)
10723 |  70 | 
10724 |  71 |         _view = GroupListView(self.ctx, tourney=self.tourney, size=self.size, channel=_channel, embeds=_list)
10725 |  72 |         _view.message = await interaction.followup.send(embed=GroupListView.initial_embed(self.tourney), view=_view)
10726 |  73 | 
10727 |  74 |     @discord.ui.button(custom_id="give_group_roles", label="Give Roles")
10728 |  75 |     async def give_group_roles(self, interaction: discord.Interaction, button: discord.Button):
10729 |  76 |         await interaction.response.defer(ephemeral=True)
10730 |  77 |         if not len(self.ctx.guild.roles) < 235:
10731 |  78 |             return await self.error_embed(
10732 |  79 |                 "Your server is about to hit the max roles limit (250 roles), please delete some first."
10733 |  80 |             )
10734 |  81 | 
10735 |  82 |         if not self.ctx.guild.me.guild_permissions.manage_roles:
10736 |  83 |             return await self.error_embed(
10737 |  84 |                 "Kindly give me `manage_roles` permission and move my role above your group roles."
10738 |  85 |             )
10739 |  86 | 
10740 |  87 |         # TODO: check manager roles , total roles less than 195
10741 |  88 |         m = await self.ask_embed(
10742 |  89 |             f"Write the group number and the name of group role.\n"
10743 |  90 |             "**Format:** `Group Number, Name of Group Role`\n\n"
10744 |  91 |             "Note that you can also mention the role instead of name to give it to users, "
10745 |  92 |             "or just write its name, if there is no role of that name, Quotient "
10746 |  93 |             "will create the role and give it to group leaders.\n\n"
10747 |  94 |             "**Example:**```1, @group_role\n2, Group role\n3, @3rd_group```\n"
10748 |  95 |             "*Enter upto 15 roles at a time.*",
10749 |  96 |             image="https://cdn.discordapp.com/attachments/851846932593770496/901862381473374299/unknown.png",
10750 |  97 |         )
10751 |  98 | 
10752 |  99 |         _roleinfo = await inputs.string_input(self.ctx, self.check, delete_after=True)
10753 | 100 |         await self.ctx.safe_delete(m)
10754 | 101 | 
10755 | 102 |         if (_roleinfo := _roleinfo.strip()) == "cancel":
10756 | 103 |             return
10757 | 104 | 
10758 | 105 |         _split = _roleinfo.split("\n")
10759 | 106 | 
10760 | 107 |         if len(_split) > 15:
10761 | 108 |             return await self.error_embed(f"Group Roles can be given to upto 15 groups at a time.")
10762 | 109 | 
10763 | 110 |         for _group in _split:
10764 | 111 |             try:
10765 | 112 |                 group, role = _group.strip().strip(",").split(",")
10766 | 113 |                 group = int(group)
10767 | 114 | 
10768 | 115 |             except ValueError:
10769 | 116 |                 return await self.error_embed(
10770 | 117 |                     f"Invalid format given in `line {_split.index(_group) + 1}`.```{_roleinfo}```",
10771 | 118 |                     footer="Auto-deleting this message in 10s.",
10772 | 119 |                     delete_after=10,
10773 | 120 |                 )
10774 | 121 | 
10775 | 122 |         _e = discord.Embed(
10776 | 123 |             color=self.bot.color,
10777 | 124 |             title="Giving Group Roles:",
10778 | 125 |             description=f"{emote.check} Starting the role distribution!\n",
10779 | 126 |         )
10780 | 127 | 
10781 | 128 |         m: discord.Message = await self.ctx.send(embed=_e)
10782 | 129 | 
10783 | 130 |         _t = datetime.now()
10784 | 131 | 
10785 | 132 |         for _group in _split:
10786 | 133 |             group, role = _group.strip().strip(",").split(",")
10787 | 134 |             group = int(group)
10788 | 135 | 
10789 | 136 |             try:
10790 | 137 |                 role = await QuoRole().convert(self.ctx, role := role.strip())
10791 | 138 |                 _e.description += f"{emote.check} {role.mention} Found...\n"
10792 | 139 |                 await m.edit(embed=_e)
10793 | 140 | 
10794 | 141 |                 if not role < self.ctx.guild.me.top_role:
10795 | 142 |                     _e.description += f"{emote.error} Skipping {role.mention}, because it is above my highest role ({self.ctx.guild.me.top_role.mention}).\n"
10796 | 143 |                     await m.edit(embed=_e)
10797 | 144 |                     continue
10798 | 145 | 
10799 | 146 |             except commands.RoleNotFound:
10800 | 147 |                 _e.description += f"{emote.xmark} {role} Not Found, Creating new role..\n"
10801 | 148 |                 role = await self.ctx.guild.create_role(name=role, reason=f"Created by {self.ctx.author} for grouping")
10802 | 149 | 
10803 | 150 |             _e.description += f"{emote.check} {role.mention} Assigning to team leaders of Group {group}\n"
10804 | 151 |             await m.edit(embed=_e)
10805 | 152 | 
10806 | 153 |             actual_group = await self.tourney.get_group(group, self.size)
10807 | 154 | 
10808 | 155 |             try:
10809 | 156 |                 counter = 0
10810 | 157 |                 for _slot in actual_group:
10811 | 158 |                     member = self.ctx.guild.get_member(_slot.leader_id)
10812 | 159 |                     if member:
10813 | 160 |                         counter += 1
10814 | 161 |                         if not role in member.roles:
10815 | 162 |                             self.bot.loop.create_task(
10816 | 163 |                                 member.add_roles(role, reason=f"Given by {self.ctx.author} for tourney grouping")
10817 | 164 |                             )
10818 | 165 | 
10819 | 166 |                 _e.description += f"{emote.check} {counter} people are given {role.mention}\n"
10820 | 167 |                 await m.edit(embed=_e)
10821 | 168 |                 counter = 0
10822 | 169 | 
10823 | 170 |             except TypeError:
10824 | 171 |                 _e.description += f"{emote.xmark} Group {group} is empty.\n"
10825 | 172 |                 await m.edit(embed=_e)
10826 | 173 |                 continue
10827 | 174 | 
10828 | 175 |             await asyncio.sleep(0.6)
10829 | 176 | 
10830 | 177 |         _e.description += f"{emote.check} Done! (Time taken: `{precisedelta(datetime.now()-_t)}`)\n"
10831 | 178 |         await m.edit(embed=_e)
10832 | 179 |         await self.ctx.safe_delete(m, 10)
10833 | 180 | 
10834 | 181 | 
10835 | 182 | class GroupListView(EsportsBaseView):
10836 | 183 |     def __init__(
10837 | 184 |         self,
10838 | 185 |         ctx: Context,
10839 | 186 |         *,
10840 | 187 |         tourney: Tourney,
10841 | 188 |         size: int,
10842 | 189 |         channel: discord.TextChannel,
10843 | 190 |         embeds: List[discord.Embed],
10844 | 191 |     ):
10845 | 192 |         super().__init__(ctx, timeout=30, title="Group List Publisher")
10846 | 193 | 
10847 | 194 |         self.ctx = ctx
10848 | 195 |         self.bot: Quotient = ctx.bot
10849 | 196 |         self.tourney = tourney
10850 | 197 |         self.size = size
10851 | 198 |         self.channel = channel
10852 | 199 |         self.embeds = embeds
10853 | 200 | 
10854 | 201 |     @staticmethod
10855 | 202 |     def initial_embed(tourney: Tourney) -> discord.Embed:
10856 | 203 |         _e = discord.Embed(
10857 | 204 |             color=0x00FFB3,
10858 | 205 |             description=(
10859 | 206 |                 f"**How would you like to publish the group list of {tourney}?**\n\n"
10860 | 207 |                 "• `Webhook` will create a webhook in the channel and will send group embeds with your server's logo and name.\n"
10861 | 208 |                 "• `Bot Option` will just make Quotient send the embeds.\n\n"
10862 | 209 |                 "*Webhook Option is more cool.*"
10863 | 210 |             ),
10864 | 211 |         )
10865 | 212 | 
10866 | 213 |         return _e
10867 | 214 | 
10868 | 215 |     @discord.ui.button(custom_id="publish_g_hook", emoji="<a:diamond:899295009289949235>", label="Webhook (Recommended)")
10869 | 216 |     async def publish_groups_webhook(self, interaction: discord.Interaction, button: discord.Button):
10870 | 217 |         await interaction.response.defer(ephemeral=True)
10871 | 218 | 
10872 | 219 |         if not await self.ctx.is_premium_guild():
10873 | 220 |             from cogs.premium.views import PremiumView
10874 | 221 | 
10875 | 222 |             _view = PremiumView()
10876 | 223 |             return await interaction.followup.send(embed=_view.premium_embed, view=_view)
10877 | 224 | 
10878 | 225 |         try:
10879 | 226 |             _webhook = await self.channel.create_webhook(
10880 | 227 |                 name="Quotient Group List", reason=f"Created by {self.ctx.author} to send group list"
10881 | 228 |             )
10882 | 229 |         except Exception as e:
10883 | 230 |             return await self.error_embed(e)
10884 | 231 | 
10885 | 232 |         m = await self.ctx.simple(f"Publishing, please wait {emote.loading}")
10886 | 233 |         for _chunk in get_chunks(self.embeds, 2):
10887 | 234 |             await _webhook.send(
10888 | 235 |                 embeds=_chunk,
10889 | 236 |                 username=self.ctx.guild.name,
10890 | 237 |                 avatar_url=getattr(self.ctx.guild.icon, "url", None),
10891 | 238 |             )
10892 | 239 | 
10893 | 240 |         await _webhook.delete()
10894 | 241 |         await self.ctx.safe_delete(m)
10895 | 242 |         await self.ctx.success("Group list published.", 4)
10896 | 243 | 
10897 | 244 |     @discord.ui.button(custom_id="publish_g_bot", emoji="<:pain:837567768106238002>", label="With Bot")
10898 | 245 |     async def publish_groups_bot(self, interaction: discord.Interaction, button: discord.Button):
10899 | 246 |         await interaction.response.defer(ephemeral=True)
10900 | 247 | 
10901 | 248 |         m = await self.ctx.simple(f"Publishing, please wait {emote.loading}")
10902 | 249 |         for _chunk in get_chunks(self.embeds, 2):
10903 | 250 |             await self.channel.send(embeds=_chunk)
10904 | 251 | 
10905 | 252 |         await self.ctx.safe_delete(m)
10906 | 253 |         await self.ctx.success("Group list published.", 4)
10907 | 254 | 
10908 | 255 |     @discord.ui.button(custom_id="publish_g_delete", emoji=emote.trash)
10909 | 256 |     async def publish_groups_delete(self, interaction: discord.Interaction, button: discord.Button):
10910 | 257 |         await interaction.response.defer(ephemeral=True)
10911 | 258 |         await interaction.delete_original_message()
10912 | 259 | 
10913 | 
10914 | 
10915 | --------------------------------------------------------------------------------
10916 | /cogs/esports/views/tourney/main.py:
10917 | --------------------------------------------------------------------------------
10918 |   1 | from __future__ import annotations
10919 |   2 | 
10920 |   3 | from typing import TYPE_CHECKING
10921 |   4 | 
10922 |   5 | from models.esports.tourney import TMSlot
10923 |   6 | 
10924 |   7 | if TYPE_CHECKING:
10925 |   8 |     from core import Quotient
10926 |   9 | 
10927 |  10 | import asyncio
10928 |  11 | import re
10929 |  12 | from contextlib import suppress
10930 |  13 | 
10931 |  14 | import discord
10932 |  15 | from discord import ButtonStyle
10933 |  16 | from tortoise.expressions import Q
10934 |  17 | 
10935 |  18 | from core import Context, QuotientView
10936 |  19 | from models import Tourney
10937 |  20 | from utils import emote, member_input, plural, truncate_string
10938 |  21 | 
10939 |  22 | from ..base import EsportsBaseView
10940 |  23 | from ..groupm import TourneyGroupManager
10941 |  24 | from ._buttons import DiscardButton
10942 |  25 | from ._editor import TourneyEditor
10943 |  26 | from ._partner import MediaPartnerView
10944 |  27 | from ._select import TourneySlotSelec
10945 |  28 | from ._wiz import TourneySetupWizard
10946 |  29 | from .slotm import TourneySlotManager
10947 |  30 | 
10948 |  31 | 
10949 |  32 | class TourneyManager(EsportsBaseView):
10950 |  33 |     def __init__(self, ctx: Context):
10951 |  34 |         super().__init__(ctx, timeout=100, name="Tourney Manager")
10952 |  35 |         self.ctx = ctx
10953 |  36 |         self.bot: Quotient = ctx.bot
10954 |  37 | 
10955 |  38 |     async def initial_embed(self) -> discord.Embed:
10956 |  39 |         to_show = [
10957 |  40 |             f"`{idx}.` {str(_r)} — Slots: `{await _r.assigned_slots.all().count()}/{_r.total_slots}`"
10958 |  41 |             for idx, _r in enumerate(await Tourney.filter(guild_id=self.ctx.guild.id).order_by("id"), start=1)
10959 |  42 |         ]
10960 |  43 | 
10961 |  44 |         _e = discord.Embed(
10962 |  45 |             color=self.bot.color, title="Quotient Smart Tournament Manager", url=self.bot.config.SERVER_LINK
10963 |  46 |         )
10964 |  47 |         _e.description = "\n".join(to_show) if to_show else "```Click Create button for new tourney.```"
10965 |  48 |         _e.set_thumbnail(url=self.ctx.guild.me.display_avatar.url)
10966 |  49 |         _e.set_footer(
10967 |  50 |             text="Quotient Prime allows unlimited tournaments.",
10968 |  51 |             icon_url=getattr(self.ctx.author.display_avatar, "url", None),
10969 |  52 |         )
10970 |  53 | 
10971 |  54 |         if not to_show:
10972 |  55 |             for _ in self.children[1:]:
10973 |  56 |                 _.disabled = True
10974 |  57 | 
10975 |  58 |         return _e
10976 |  59 | 
10977 |  60 |     @discord.ui.button(style=ButtonStyle.blurple, label="Create Tournament")
10978 |  61 |     async def create_tournament(self, interaction: discord.Interaction, button: discord.Button):
10979 |  62 |         await interaction.response.defer()
10980 |  63 |         if not await self.ctx.is_premium_guild():
10981 |  64 |             if await Tourney.filter(guild_id=self.ctx.guild.id).count() >= 1:
10982 |  65 |                 return await self.ctx.error(
10983 |  66 |                     f"You need [Quotient Premium](https://quotientbot.xyz/premium) to create more than one tournament.\n"
10984 |  67 |                     "\nBuy Prime for just ₹29 here: https://quotientbot.xyz/premium",
10985 |  68 |                     7,
10986 |  69 |                 )
10987 |  70 | 
10988 |  71 |         self.stop()
10989 |  72 |         _v = TourneySetupWizard(self.ctx)
10990 |  73 |         _v.message = await self.message.edit(embed=_v.initial_message(), view=_v)
10991 |  74 | 
10992 |  75 |     @discord.ui.button(style=ButtonStyle.blurple, label="Edit Settings")
10993 |  76 |     async def edit_tournament(self, interaction: discord.Interaction, button: discord.Button):
10994 |  77 |         await interaction.response.defer()
10995 |  78 |         self.stop()
10996 |  79 |         records = await Tourney.filter(guild_id=self.ctx.guild.id).order_by("id")
10997 |  80 | 
10998 |  81 |         _v = TourneyEditor(self.ctx, records)
10999 |  82 |         await _v._add_buttons(self.ctx)
11000 |  83 | 
11001 |  84 |         _v.message = await self.message.edit(embed=await _v.initial_message(), view=_v)
11002 |  85 | 
11003 |  86 |     @discord.ui.button(style=discord.ButtonStyle.green, label="Start/Pause Reg")
11004 |  87 |     async def start_or_pause(self, interaction: discord.Interaction, button: discord.Button):
11005 |  88 |         await interaction.response.defer()
11006 |  89 | 
11007 |  90 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to start/pause")
11008 |  91 |         if tourney:
11009 |  92 |             p = await self.ctx.prompt(
11010 |  93 |                 f"Are you sure you want to {'pause' if tourney.started_at else 'start'} the registrations of {tourney}?"
11011 |  94 |             )
11012 |  95 |             if not p:
11013 |  96 |                 return await self.ctx.error("Ok, Aborting", 4)
11014 |  97 | 
11015 |  98 |             b, r = await tourney.toggle_registrations()
11016 |  99 |             if not b:
11017 | 100 |                 return await self.ctx.error(r, 4)
11018 | 101 | 
11019 | 102 |             return await self.ctx.success(f"Done! Check {tourney.registration_channel.mention}", 4)
11020 | 103 | 
11021 | 104 |     @discord.ui.button(style=ButtonStyle.red, label="Ban/Unban")
11022 | 105 |     async def ban_or_unban(self, interaction: discord.Interaction, btn: discord.Button):
11023 | 106 |         await interaction.response.defer()
11024 | 107 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to ban/unban users.")
11025 | 108 |         if tourney:
11026 | 109 |             m = await self.ctx.simple("Mention the users you want to ban or unban.")
11027 | 110 | 
11028 | 111 |             msg = None
11029 | 112 |             with suppress(asyncio.TimeoutError):
11030 | 113 |                 msg: discord.Message = await self.ctx.bot.wait_for(
11031 | 114 |                     "message", check=lambda m: m.author == self.ctx.author and m.channel == self.ctx.channel, timeout=60
11032 | 115 |                 )
11033 | 116 | 
11034 | 117 |             await m.delete()
11035 | 118 | 
11036 | 119 |             if not msg or not msg.mentions:
11037 | 120 |                 return await self.ctx.error("You need to mention at least one user.", 4)
11038 | 121 | 
11039 | 122 |             await msg.delete()
11040 | 123 |             banned, unbanned = [], []
11041 | 124 |             for m in msg.mentions:
11042 | 125 |                 if m.id in tourney.banned_users:
11043 | 126 |                     await tourney.unban_user(m)
11044 | 127 |                     unbanned.append(m.mention)
11045 | 128 | 
11046 | 129 |                 else:
11047 | 130 |                     await tourney.ban_user(m)
11048 | 131 |                     banned.append(m.mention)
11049 | 132 | 
11050 | 133 |         await self.ctx.simple(
11051 | 134 |             f"{emote.check} | Banned: {', '.join(banned) if banned else 'None'}\n"
11052 | 135 |             f"{emote.check} | Unbanned: {', '.join(unbanned) if unbanned else 'None'}",
11053 | 136 |             10,
11054 | 137 |         )
11055 | 138 | 
11056 | 139 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="tourney_groups_send", label="Manage Groups")
11057 | 140 |     async def send_tourney_group(self, interaction: discord.Interaction, button: discord.Button):
11058 | 141 |         await interaction.response.defer()
11059 | 142 | 
11060 | 143 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to manage groups.")
11061 | 144 |         if tourney:
11062 | 145 |             self.stop()
11063 | 146 |             _v = TourneyGroupManager(self.ctx, tourney, timeout=100)
11064 | 147 |             _v.add_item(DiscardButton(self.ctx))
11065 | 148 |             _v.message = await self.message.edit(embed=_v.initial_embed, view=_v)
11066 | 149 | 
11067 | 150 |     @discord.ui.button(style=discord.ButtonStyle.red, label="Cancel Slots")
11068 | 151 |     async def remove_user_slots(self, interaction: discord.Interaction, button: discord.Button):
11069 | 152 |         await interaction.response.defer()
11070 | 153 | 
11071 | 154 |         m = await self.ctx.simple("Mention the user whose slot you want to remove.")
11072 | 155 |         member = await member_input(self.ctx, delete_after=True)
11073 | 156 |         await m.delete()
11074 | 157 | 
11075 | 158 |         if not member:
11076 | 159 |             return await self.ctx.error("You need to mention a user.", 4)
11077 | 160 | 
11078 | 161 |         _slots = []
11079 | 162 |         async for tourney in Tourney.filter(guild_id=self.ctx.guild.id).order_by("id"):
11080 | 163 |             async for slot in tourney.assigned_slots.filter(
11081 | 164 |                 Q(Q(leader_id=member.id), Q(members__contains=member.id), join_type="OR")
11082 | 165 |             ).order_by("num"):
11083 | 166 |                 setattr(slot, "tourney", tourney)
11084 | 167 |                 _slots.append(slot)
11085 | 168 | 
11086 | 169 |         if not _slots:
11087 | 170 |             return await self.ctx.error(f"{member.mention} don't have any slot in any tourney of this server.", 4)
11088 | 171 | 
11089 | 172 |         _v = QuotientView(self.ctx)
11090 | 173 |         _v.add_item(TourneySlotSelec(_slots))
11091 | 174 |         _v.message = await interaction.followup.send("select the slots you want to cancel", view=_v, ephemeral=True)
11092 | 175 | 
11093 | 176 |         await _v.wait()
11094 | 177 | 
11095 | 178 |         if _v.custom_id:
11096 | 179 |             p = await self.ctx.prompt(
11097 | 180 |                 f"{plural(_v.custom_id):slot|slots} of {member.mention} will be permanently removed.",
11098 | 181 |                 title="Are you sure you want to continue?",
11099 | 182 |             )
11100 | 183 |             if not p:
11101 | 184 |                 return await self.ctx.success("Ok, Aborting", 4)
11102 | 185 | 
11103 | 186 |             c = 0
11104 | 187 |             for _ in _v.custom_id:
11105 | 188 |                 slot_id, tourney_id = _.split(":")
11106 | 189 |                 tourney = await Tourney.get_or_none(id=tourney_id)
11107 | 190 |                 slot = await TMSlot.get_or_none(id=slot_id)
11108 | 191 | 
11109 | 192 |                 if not tourney or not slot:
11110 | 193 |                     continue
11111 | 194 | 
11112 | 195 |                 await tourney.remove_slot(slot)
11113 | 196 |                 c += 1
11114 | 197 | 
11115 | 198 |             return await self.ctx.success(f"Done! {c} slot(s) of {member.mention} removed.", 6)
11116 | 199 | 
11117 | 200 |     @discord.ui.button(style=discord.ButtonStyle.green, label="Manually Add Slot")
11118 | 201 |     async def reserve_user_slot(self, interaction: discord.Interaction, button: discord.Button):
11119 | 202 |         await interaction.response.defer()
11120 | 203 |         m = await self.ctx.simple("Mention the team leader and Enter the team name.")
11121 | 204 | 
11122 | 205 |         try:
11123 | 206 |             msg: discord.Message = await self.bot.wait_for(
11124 | 207 |                 "message", check=lambda x: x.author == self.ctx.author and x.channel == interaction.channel, timeout=100
11125 | 208 |             )
11126 | 209 | 
11127 | 210 |         except asyncio.TimeoutError:
11128 | 211 |             await self.ctx.safe_delete(m)
11129 | 212 |             return await self.ctx.error("You didn't reply in time.", 3)
11130 | 213 | 
11131 | 214 |         await self.ctx.safe_delete(m)
11132 | 215 |         await self.ctx.safe_delete(msg)
11133 | 216 | 
11134 | 217 |         if not msg.mentions:
11135 | 218 |             return await self.ctx.error("You need to mention team leader.", 4)
11136 | 219 | 
11137 | 220 |         leader = msg.mentions[0]
11138 | 221 | 
11139 | 222 |         team_name = truncate_string(re.sub(r"<@*!*&*\d+>", "", msg.content), 22)
11140 | 223 |         if not team_name:
11141 | 224 |             return await self.ctx.error("You need to enter a team name.", 4)
11142 | 225 | 
11143 | 226 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to add slot.")
11144 | 227 |         if tourney:
11145 | 228 |             last_slot = await tourney.assigned_slots.order_by("-num").first()
11146 | 229 |             slot = TMSlot(leader_id=leader.id, team_name=team_name, num=last_slot.num + 1 if last_slot else 1)
11147 | 230 | 
11148 | 231 |             _e = discord.Embed(color=0x00FFB3)
11149 | 232 |             _e.description = f"**{slot.num}) NAME: {slot.team_name.upper()}**\n"
11150 | 233 | 
11151 | 234 |             _e.set_footer(
11152 | 235 |                 text="Added by: {}".format(self.ctx.author),
11153 | 236 |                 icon_url=getattr(self.ctx.author.display_avatar, "url", None),
11154 | 237 |             )
11155 | 238 | 
11156 | 239 |             m = await tourney.confirm_channel.send(leader.mention, embed=_e)
11157 | 240 |             slot.confirm_jump_url = m.jump_url
11158 | 241 | 
11159 | 242 |             await slot.save()
11160 | 243 |             await tourney.assigned_slots.add(slot)
11161 | 244 | 
11162 | 245 |             await leader.add_roles(tourney.role)
11163 | 246 | 
11164 | 247 |             await self.ctx.success(f"Added slot successfully, [Click Here]({m.jump_url}) ", 4)
11165 | 248 | 
11166 | 249 |             if tourney.total_slots <= await tourney.assigned_slots.all().count():
11167 | 250 |                 await tourney.end_process()
11168 | 251 | 
11169 | 252 |     @discord.ui.button(style=discord.ButtonStyle.blurple, label="Slot-Manager channel")
11170 | 253 |     async def tourney_slotmanager(self, interaction: discord.Interaction, button: discord.Button):
11171 | 254 |         await interaction.response.defer()
11172 | 255 | 
11173 | 256 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to add cancel-claim...")
11174 | 257 |         if tourney:
11175 | 258 |             if _channel := tourney.slotm_channel:
11176 | 259 |                 await tourney.refresh_slotlm()
11177 | 260 |                 return await self.ctx.simple(f"Current slotmanager channel for {tourney} is {_channel.mention}.", 7)
11178 | 261 | 
11179 | 262 |         _view = TourneySlotManager(self.bot, tourney=tourney)
11180 | 263 | 
11181 | 264 |         _category = tourney.registration_channel.category
11182 | 265 |         overwrites = {
11183 | 266 |             self.ctx.guild.default_role: discord.PermissionOverwrite(
11184 | 267 |                 read_messages=True, send_messages=False, read_message_history=True
11185 | 268 |             ),
11186 | 269 |             self.ctx.guild.me: discord.PermissionOverwrite(
11187 | 270 |                 manage_channels=True, manage_permissions=True, manage_messages=True
11188 | 271 |             ),
11189 | 272 |         }
11190 | 273 |         slotm_channel = await _category.create_text_channel(name="tourney-slotmanager", overwrites=overwrites)
11191 | 274 | 
11192 | 275 |         _e = TourneySlotManager.initial_embed(tourney)
11193 | 276 |         slotm_message = await slotm_channel.send(embed=_e, view=_view)
11194 | 277 | 
11195 | 278 |         await Tourney.get(pk=tourney.id).update(slotm_channel_id=slotm_channel.id, slotm_message_id=slotm_message.id)
11196 | 279 |         await self.ctx.success(f"Slotmanager channel for {tourney} created successfully. ({slotm_channel.mention})", 7)
11197 | 280 | 
11198 | 281 |     @discord.ui.button(style=discord.ButtonStyle.green, label="Media-Partner")
11199 | 282 |     async def manage_media_partner(self, interaction: discord.Interaction, button: discord.ui.Button):
11200 | 283 |         await interaction.response.defer()
11201 | 284 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to set media-partner..")
11202 | 285 |         if tourney:
11203 | 286 |             view = MediaPartnerView(self.ctx, tourney=tourney)
11204 | 287 |             view.add_item(DiscardButton(self.ctx))
11205 | 288 |             self.stop()
11206 | 289 |             view.message = await self.message.edit(embed=await view.initial_embed(), view=view)
11207 | 290 | 
11208 | 291 |     @discord.ui.button(style=discord.ButtonStyle.blurple, label="MS Excel File")
11209 | 292 |     async def download_excel_data(self, interaction: discord.Interaction, button: discord.Button):
11210 | 293 |         await interaction.response.defer()
11211 | 294 |         # if not await self.ctx.is_premium_guild():
11212 | 295 |         #     return await self.ctx.error(
11213 | 296 |         #         "You need Quotient Premium to download Ms Excel file containing all the "
11214 | 297 |         #         f"registration data of your tourneys.\n\n"
11215 | 298 |         #         "Buy Premium for just ₹29 here: https://quotientbot.xyz/premium",
11216 | 299 |         #         6,
11217 | 300 |         #     )
11218 | 301 | 
11219 | 302 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to download data...")
11220 | 303 |         if tourney:
11221 | 304 |             _m = await self.ctx.simple(f"Crunching the data for you.... {emote.loading}")
11222 | 305 |             await asyncio.sleep(1)
11223 | 306 | 
11224 | 307 |             _log_chan = await self.bot.getch(self.bot.get_channel, self.bot.fetch_channel, 899185364500099083)
11225 | 308 |             m: discord.Message = await _log_chan.send(file=await tourney.get_csv())
11226 | 309 | 
11227 | 310 |             e = discord.Embed(
11228 | 311 |                 color=self.bot.color,
11229 | 312 |                 description=(
11230 | 313 |                     f"**[Click Here]({m.attachments[0].url})** to download `.csv` file "
11231 | 314 |                     f"containing all the registration records of {tourney}\n\n"
11232 | 315 |                     "*`To Open`: Use Microsoft Excel, Libre Office or any other softwares that is compatible with .csv files.*"
11233 | 316 |                 ),
11234 | 317 |             )
11235 | 318 | 
11236 | 319 |             with suppress(discord.HTTPException):
11237 | 320 |                 await _m.edit(embed=e, delete_after=10)
11238 | 321 | 
11239 | 
11240 | 
11241 | --------------------------------------------------------------------------------
11242 | /cogs/esports/views/tourney/slotm.py:
11243 | --------------------------------------------------------------------------------
11244 |   1 | from __future__ import annotations
11245 |   2 | 
11246 |   3 | from contextlib import suppress
11247 |   4 | from typing import TYPE_CHECKING, Any, List
11248 |   5 | 
11249 |   6 | from models import TMSlot, Tourney
11250 |   7 | from utils import BaseSelector, Prompt, emote, truncate_string
11251 |   8 | 
11252 |   9 | if TYPE_CHECKING:
11253 |  10 |     from core import Quotient
11254 |  11 | 
11255 |  12 | import asyncio
11256 |  13 | 
11257 |  14 | import discord
11258 |  15 | from tortoise.expressions import Q
11259 |  16 | 
11260 |  17 | import config
11261 |  18 | 
11262 |  19 | from ...helpers import update_confirmed_message
11263 |  20 | 
11264 |  21 | 
11265 |  22 | class TCancelSlotSelector(discord.ui.Select):
11266 |  23 |     def __init__(self, bot: Quotient, slots: List[TMSlot], placeholder: str = "Select a slot to cancel"):
11267 |  24 |         _options = []
11268 |  25 |         for slot in slots:
11269 |  26 |             slot.members.append(slot.leader_id)
11270 |  27 | 
11271 |  28 |             description = f"Team: {', '.join((str(m) for m in map(bot.get_user, set(slot.members))))}"
11272 |  29 |             _options.append(
11273 |  30 |                 discord.SelectOption(
11274 |  31 |                     label=f"Number {slot.num} ─ {slot.team_name.title()}",
11275 |  32 |                     description=truncate_string(description, 100),
11276 |  33 |                     value=slot.id,
11277 |  34 |                     emoji="<:text:815827264679706624>",
11278 |  35 |                 )
11279 |  36 |             )
11280 |  37 | 
11281 |  38 |         super().__init__(placeholder=placeholder, options=_options)
11282 |  39 | 
11283 |  40 |     async def callback(self, interaction: discord.Interaction):
11284 |  41 |         await interaction.response.defer()
11285 |  42 |         self.view.stop()
11286 |  43 |         self.view.custom_id = interaction.data["values"][0]
11287 |  44 | 
11288 |  45 | 
11289 |  46 | class TourneySlotManager(discord.ui.View):
11290 |  47 |     def __init__(self, bot: Quotient, *, tourney: Tourney):
11291 |  48 |         self.tourney = tourney
11292 |  49 |         self.bot = bot
11293 |  50 |         self.title = "Tourney Slot Manager"
11294 |  51 |         super().__init__(timeout=None)
11295 |  52 | 
11296 |  53 |     def red_embed(self, description: str) -> discord.Embed:
11297 |  54 |         return discord.Embed(color=discord.Color.red(), title=self.title, description=description)
11298 |  55 | 
11299 |  56 |     async def update_channel_for(self, channel: discord.TextChannel, user, allow=True):
11300 |  57 |         if allow:
11301 |  58 |             return await channel.set_permissions(user, send_messages=True)
11302 |  59 | 
11303 |  60 |         return await channel.set_permissions(user, overwrite=None)
11304 |  61 | 
11305 |  62 |     async def on_error(self, interaction: discord.Interaction, error: Exception, item: discord.ui.Item[Any]) -> None:
11306 |  63 |         if isinstance(error, discord.NotFound):
11307 |  64 |             return
11308 |  65 |         print("Tourney Slotm Error:", error)
11309 |  66 | 
11310 |  67 |     @staticmethod
11311 |  68 |     def initial_embed(tourney: Tourney) -> discord.Embed:
11312 |  69 |         embed = discord.Embed(
11313 |  70 |             color=config.COLOR,
11314 |  71 |             description=(
11315 |  72 |                 f"**[Tourney Slot Manager]({config.SERVER_LINK})** ─ {tourney}\n\n"
11316 |  73 |                 "• Click `Cancel My Slot` below to cancel your slot.\n"
11317 |  74 |                 "• Click `My Slots` to get info about all your slots.\n"
11318 |  75 |                 "• Click `Change Team Name` if you want to update your team's name.\n\n"
11319 |  76 |                 "*Note that slot cancel is irreversible.*"
11320 |  77 |             ),
11321 |  78 |         )
11322 |  79 |         return embed
11323 |  80 | 
11324 |  81 |     @discord.ui.button(style=discord.ButtonStyle.danger, custom_id="tourney-cancel-slot", label="Cancel My Slot")
11325 |  82 |     async def cancel_slot(self, interaction: discord.Interaction, button: discord.ui.Button):
11326 |  83 |         await interaction.response.defer(ephemeral=True)
11327 |  84 | 
11328 |  85 |         _slots = await self.tourney.assigned_slots.filter(
11329 |  86 |             Q(leader_id=interaction.user.id) | Q(members__contains=interaction.user.id)
11330 |  87 |         ).order_by("num")
11331 |  88 | 
11332 |  89 |         if not _slots:
11333 |  90 |             return await interaction.followup.send(
11334 |  91 |                 embed=self.red_embed(f"You don't have any slot, because you haven't registered in {self.tourney} yet."),
11335 |  92 |                 ephemeral=True,
11336 |  93 |             )
11337 |  94 | 
11338 |  95 |         cancel_view = BaseSelector(interaction.user.id, TCancelSlotSelector, bot=self.bot, slots=_slots)
11339 |  96 |         await interaction.followup.send("Kindly choose one of the following slots", view=cancel_view, ephemeral=True)
11340 |  97 | 
11341 |  98 |         await cancel_view.wait()
11342 |  99 | 
11343 | 100 |         if _id := cancel_view.custom_id:
11344 | 101 |             prompt = Prompt(interaction.user.id)
11345 | 102 |             await interaction.followup.send("Are you sure you want to cancel your slot?", view=prompt, ephemeral=True)
11346 | 103 |             await prompt.wait()
11347 | 104 | 
11348 | 105 |             if not prompt.value:
11349 | 106 |                 return await interaction.followup.send("Alright, Aborting.", ephemeral=True)
11350 | 107 | 
11351 | 108 |             slot = await TMSlot.get_or_none(pk=_id)
11352 | 109 |             if not slot:
11353 | 110 |                 return await interaction.followup.send(embed=self.red_embed("Slot is already deleted."), ephemeral=True)
11354 | 111 | 
11355 | 112 |             if slot.confirm_jump_url:
11356 | 113 |                 self.bot.loop.create_task(update_confirmed_message(self.tourney, slot.confirm_jump_url))
11357 | 114 | 
11358 | 115 |             if len(_slots) == 1:
11359 | 116 |                 member = interaction.guild.get_member(slot.leader_id)
11360 | 117 |                 if member:
11361 | 118 |                     self.bot.loop.create_task(member.remove_roles(self.tourney.role))
11362 | 119 | 
11363 | 120 |             await TMSlot.filter(pk=slot.id).delete()
11364 | 121 |             return await interaction.followup.send(f"{emote.check} | Your slot was removed.", ephemeral=True)
11365 | 122 | 
11366 | 123 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="tourney-slot-info", label="My Groups")
11367 | 124 |     async def _slots_info(self, interaction: discord.Interaction, button: discord.ui.Button):
11368 | 125 |         await interaction.response.defer(ephemeral=True)
11369 | 126 | 
11370 | 127 |         _slots = await self.tourney.assigned_slots.filter(
11371 | 128 |             Q(leader_id=interaction.user.id) | Q(members__contains=interaction.user.id)
11372 | 129 |         ).order_by("num")
11373 | 130 | 
11374 | 131 |         if not _slots:
11375 | 132 |             return await interaction.followup.send(
11376 | 133 |                 embed=self.red_embed(f"You don't have any slot, because you haven't registered in {self.tourney} yet."),
11377 | 134 |                 ephemeral=True,
11378 | 135 |             )
11379 | 136 | 
11380 | 137 |         embed = discord.Embed(color=config.COLOR)
11381 | 138 |         embed.description = f"Your have the following slots in {self.tourney}:\n\n"
11382 | 139 | 
11383 | 140 |         for idx, slot in enumerate(_slots, start=1):
11384 | 141 |             embed.description += (
11385 | 142 |                 f"`{idx}.` **{slot.team_name.title()}** (**[Slot {slot.num}]({slot.confirm_jump_url})**)\n"
11386 | 143 |             )
11387 | 144 | 
11388 | 145 |         return await interaction.followup.send(embed=embed, ephemeral=True)
11389 | 146 | 
11390 | 147 |     @discord.ui.button(style=discord.ButtonStyle.blurple, custom_id="tourney-slot_name", label="Change Team Name")
11391 | 148 |     async def _change_slot_name(self, interaction: discord.Interaction, button: discord.ui.Button):
11392 | 149 |         await interaction.response.defer(ephemeral=True)
11393 | 150 | 
11394 | 151 |         _slots = await self.tourney.assigned_slots.filter(
11395 | 152 |             Q(leader_id=interaction.user.id) | Q(members__contains=interaction.user.id)
11396 | 153 |         ).order_by("num")
11397 | 154 | 
11398 | 155 |         if not _slots:
11399 | 156 |             return await interaction.followup.send(
11400 | 157 |                 embed=self.red_embed(f"You don't have any slot, because you haven't registered in {self.tourney} yet."),
11401 | 158 |                 ephemeral=True,
11402 | 159 |             )
11403 | 160 | 
11404 | 161 |         cancel_view = BaseSelector(
11405 | 162 |             interaction.user.id,
11406 | 163 |             TCancelSlotSelector,
11407 | 164 |             bot=self.bot,
11408 | 165 |             slots=_slots,
11409 | 166 |             placeholder="Select a slot to change Name",
11410 | 167 |         )
11411 | 168 |         await interaction.followup.send("Kindly choose one of the following slots", view=cancel_view, ephemeral=True)
11412 | 169 | 
11413 | 170 |         await cancel_view.wait()
11414 | 171 | 
11415 | 172 |         if _id := cancel_view.custom_id:
11416 | 173 |             await interaction.followup.send("Enter the new name for your team.", ephemeral=True)
11417 | 174 | 
11418 | 175 |             await self.update_channel_for(interaction.channel, interaction.user)
11419 | 176 | 
11420 | 177 |             try:
11421 | 178 |                 team_name: discord.Message = await self.bot.wait_for(
11422 | 179 |                     "message",
11423 | 180 |                     check=lambda msg: msg.author.id == interaction.user.id and msg.channel.id == interaction.channel.id,
11424 | 181 |                     timeout=30,
11425 | 182 |                 )
11426 | 183 |             except asyncio.TimeoutError:
11427 | 184 |                 await self.update_channel_for(interaction.channel, interaction.user, False)
11428 | 185 |                 return await interaction.followup.send("Timed out. Please try again later.", ephemeral=True)
11429 | 186 | 
11430 | 187 |             with suppress(discord.HTTPException):
11431 | 188 |                 await self.update_channel_for(interaction.channel, interaction.user, False)
11432 | 189 | 
11433 | 190 |                 await team_name.delete()
11434 | 191 | 
11435 | 192 |                 await TMSlot.filter(pk=_id).update(team_name=truncate_string(team_name.content, 30))
11436 | 193 |                 return await interaction.followup.send(f"{emote.check} | Your team name was changed.", ephemeral=True)
11437 | 194 | 
11438 | 195 |     @discord.ui.button(emoji="<:swap:954022423542509598>", label="Swap Groups", custom_id="tourney-swap-groups")
11439 | 196 |     async def tourney_group_swap(self, inter: discord.Interaction, button: discord.Button):
11440 | 197 |         await inter.response.defer()
11441 | 198 | 
11442 | 199 |         if not inter.user.guild_permissions.manage_guild and not Tourney.is_ignorable(inter.user):
11443 | 200 |             return await inter.followup.send(
11444 | 201 |                 "You need either `@tourney-mod` role or `manage-server` permissions to swap groups.", ephemeral=True
11445 | 202 |             )
11446 | 203 | 
11447 | 204 |         m = await inter.followup.send("Mention first user.", ephemeral=True)
11448 | 205 |         try:
11449 | 206 |             first_msg: discord.Message = await self.bot.wait_for(
11450 | 207 |                 "message", check=lambda msg: msg.author.id == inter.user.id, timeout=30
11451 | 208 |             )
11452 | 209 |             await first_msg.delete()
11453 | 210 | 
11454 | 211 |         except asyncio.TimeoutError:
11455 | 212 |             return await m.edit(content="Timed out. Please try again later.")
11456 | 213 | 
11457 | 214 |         if not first_msg.mentions:
11458 | 215 |             await m.edit(content="You didn't mention first user.")
11459 | 216 | 
11460 | 217 |         first_user: discord.User = first_msg.mentions[0]
11461 | 218 | 
11462 | 219 |         _slots = await self.tourney.assigned_slots.filter(
11463 | 220 |             Q(leader_id=first_user.id) | Q(members__contains=first_user.id)
11464 | 221 |         ).order_by("num")
11465 | 222 | 
11466 | 223 |         if not _slots:
11467 | 224 |             return await inter.followup.send(
11468 | 225 |                 f"{first_user.mention} don't have any slot in {self.tourney}.", ephemeral=True
11469 | 226 |             )
11470 | 227 | 
11471 | 228 |         first_slot = None
11472 | 229 |         if len(_slots) == 1:
11473 | 230 |             first_slot = _slots[0]
11474 | 231 | 
11475 | 232 |         else:
11476 | 233 |             cancel_view = BaseSelector(
11477 | 234 |                 inter.user.id,
11478 | 235 |                 TCancelSlotSelector,
11479 | 236 |                 bot=self.bot,
11480 | 237 |                 slots=_slots,
11481 | 238 |                 placeholder=f"Select a slot of {str(first_user)}",
11482 | 239 |             )
11483 | 240 | 
11484 | 241 |             await inter.followup.send(
11485 | 242 |                 f"{first_user.mention} has the following slots in {self.tourney}:", view=cancel_view, ephemeral=True
11486 | 243 |             )
11487 | 244 |             await cancel_view.wait()
11488 | 245 | 
11489 | 246 |             if cancel_view.custom_id:
11490 | 247 |                 first_slot = await TMSlot.get(pk=cancel_view.custom_id)
11491 | 248 | 
11492 | 249 |         if not first_slot:
11493 | 250 |             return
11494 | 251 | 
11495 | 252 |         m = await inter.followup.send("Mention second user.", ephemeral=True)
11496 | 253 |         try:
11497 | 254 |             second_msg: discord.Message = await self.bot.wait_for(
11498 | 255 |                 "message", check=lambda msg: msg.author.id == inter.user.id, timeout=30
11499 | 256 |             )
11500 | 257 |             await second_msg.delete()
11501 | 258 | 
11502 | 259 |         except asyncio.TimeoutError:
11503 | 260 |             return await m.edit(content="Timed out. Please try again later.")
11504 | 261 | 
11505 | 262 |         if not second_msg.mentions:
11506 | 263 |             await m.edit(content="You didn't mention second user.")
11507 | 264 | 
11508 | 265 |         second_user: discord.User = second_msg.mentions[0]
11509 | 266 |         if second_user == first_user:
11510 | 267 |             return await inter.followup.send("You can't mention the same user twice.")
11511 | 268 | 
11512 | 269 |         _slots = await self.tourney.assigned_slots.filter(
11513 | 270 |             Q(leader_id=second_user.id) | Q(members__contains=second_user.id)
11514 | 271 |         ).order_by("num")
11515 | 272 | 
11516 | 273 |         if not _slots:
11517 | 274 |             return await inter.followup.send(
11518 | 275 |                 f"{second_user.mention} don't have any slot in {self.tourney}.", ephemeral=True
11519 | 276 |             )
11520 | 277 | 
11521 | 278 |         second_slot = None
11522 | 279 |         if len(_slots) == 1:
11523 | 280 |             second_slot = _slots[0]
11524 | 281 | 
11525 | 282 |         else:
11526 | 283 |             cancel_view = BaseSelector(
11527 | 284 |                 inter.user.id,
11528 | 285 |                 TCancelSlotSelector,
11529 | 286 |                 bot=self.bot,
11530 | 287 |                 slots=_slots,
11531 | 288 |                 placeholder=f"Select a slot of {str(second_user)}",
11532 | 289 |             )
11533 | 290 | 
11534 | 291 |             await inter.followup.send(
11535 | 292 |                 f"{second_user.mention} has the following slots in {self.tourney}:", view=cancel_view, ephemeral=True
11536 | 293 |             )
11537 | 294 |             await cancel_view.wait()
11538 | 295 | 
11539 | 296 |             if cancel_view.custom_id:
11540 | 297 |                 second_slot = await TMSlot.get(pk=cancel_view.custom_id)
11541 | 298 | 
11542 | 299 |         if not second_slot:
11543 | 300 |             return
11544 | 301 | 
11545 | 302 |         await TMSlot.get(pk=first_slot.id).update(num=second_slot.num)
11546 | 303 |         await TMSlot.get(pk=second_slot.id).update(num=first_slot.num)
11547 | 304 | 
11548 | 305 |         await inter.followup.send(
11549 | 306 |             f"{emote.check} | Groups were swapped. Press 'Refresh' button under grouplist.", ephemeral=True
11550 | 307 |         )
11551 | 308 | 
11552 | 
11553 | 
11554 | --------------------------------------------------------------------------------
11555 | /cogs/events/__init__.py:
11556 | --------------------------------------------------------------------------------
11557 |  1 | from .cmds import CmdEvents
11558 |  2 | from .errors import Errors
11559 |  3 | from .interaction import InteractionErrors
11560 |  4 | from .logs import LogEvents
11561 |  5 | from .main import MainEvents
11562 |  6 | from .tasks import QuoTasks
11563 |  7 | from .votes import VotesCog
11564 |  8 | 
11565 |  9 | 
11566 | 10 | async def setup(bot):
11567 | 11 |     await bot.add_cog(MainEvents(bot))
11568 | 12 |     await bot.add_cog(QuoTasks(bot))
11569 | 13 |     await bot.add_cog(CmdEvents(bot))
11570 | 14 |     await bot.add_cog(VotesCog(bot))
11571 | 15 |     await bot.add_cog(Errors(bot))
11572 | 16 |     await bot.add_cog(InteractionErrors(bot))
11573 | 17 |     await bot.add_cog(LogEvents(bot))
11574 | 18 | 
11575 | 
11576 | 
11577 | --------------------------------------------------------------------------------
11578 | /cogs/events/cmds.py:
11579 | --------------------------------------------------------------------------------
11580 |   1 | from __future__ import annotations
11581 |   2 | 
11582 |   3 | import typing
11583 |   4 | 
11584 |   5 | if typing.TYPE_CHECKING:
11585 |   6 |     from core import Quotient
11586 |   7 | 
11587 |   8 | import asyncio
11588 |   9 | from collections import defaultdict
11589 |  10 | from contextlib import suppress
11590 |  11 | from datetime import timedelta
11591 |  12 | 
11592 |  13 | import discord
11593 |  14 | 
11594 |  15 | from core import Cog, Context, cooldown
11595 |  16 | from models import ArrayRemove, Autorole, Commands
11596 |  17 | 
11597 |  18 | 
11598 |  19 | class UserCommandLimits(defaultdict):
11599 |  20 |     def __missing__(self, key):
11600 |  21 |         r = self[key] = cooldown.QuotientRatelimiter(2, 10)
11601 |  22 |         return r
11602 |  23 | 
11603 |  24 | 
11604 |  25 | class CmdEvents(Cog):
11605 |  26 |     def __init__(self, bot: Quotient):
11606 |  27 |         self.bot = bot
11607 |  28 | 
11608 |  29 |         self.command_ratelimited_users = {}
11609 |  30 |         self.command_ratelimiter = UserCommandLimits(cooldown.QuotientRatelimiter)
11610 |  31 | 
11611 |  32 |     async def bot_check(self, ctx: Context):
11612 |  33 |         author = ctx.author
11613 |  34 |         message = ctx.message
11614 |  35 | 
11615 |  36 |         if author.id in self.bot.config.DEVS:
11616 |  37 |             return True
11617 |  38 | 
11618 |  39 |         if not ctx.guild:
11619 |  40 |             return False
11620 |  41 | 
11621 |  42 |         if author.id in self.bot.cache.blocked_ids or ctx.guild.id in self.bot.cache.blocked_ids:
11622 |  43 |             return False
11623 |  44 | 
11624 |  45 |         if retry_after := self.command_ratelimiter[message.author].is_ratelimited(message.author):
11625 |  46 |             if author.id in self.command_ratelimited_users:
11626 |  47 |                 return
11627 |  48 | 
11628 |  49 |             self.command_ratelimited_users[author.id] = self.bot.current_time + timedelta(seconds=retry_after)
11629 |  50 |             self.bot.loop.create_task(self.remove_from_ratelimited_users(author.id, retry_after))
11630 |  51 | 
11631 |  52 |             await ctx.error(
11632 |  53 |                 f"You are being ratelimited for using commands too fast. \n\n**Try again after `{retry_after:.2f} seconds`**."
11633 |  54 |             )
11634 |  55 |             return False
11635 |  56 | 
11636 |  57 |         if self.bot.lockdown is True:
11637 |  58 |             t = (
11638 |  59 |                 "**Quotient is getting new features** 🥳\n"
11639 |  60 |                 "Dear user, Quotient is updating and is not accepting any commands.\n"
11640 |  61 |                 "It will back within **2 minutes**.\n"
11641 |  62 |             )
11642 |  63 | 
11643 |  64 |             if self.bot.lockdown_msg:
11644 |  65 |                 t += f"\n\n**Message from developer:**\n{self.bot.lockdown_msg} ~ deadshot#7999"
11645 |  66 | 
11646 |  67 |             await ctx.error(t)
11647 |  68 |             return False
11648 |  69 | 
11649 |  70 |         return True
11650 |  71 | 
11651 |  72 |     async def remove_from_ratelimited_users(self, user_id: int, after: int):
11652 |  73 |         await asyncio.sleep(after)
11653 |  74 |         self.command_ratelimited_users.pop(user_id, None)
11654 |  75 | 
11655 |  76 |     @Cog.listener()
11656 |  77 |     async def on_command_completion(self, ctx: Context):
11657 |  78 |         if not ctx.command or not ctx.guild:
11658 |  79 |             return
11659 |  80 | 
11660 |  81 |         cmd = ctx.command.qualified_name
11661 |  82 | 
11662 |  83 |         await Commands.create(
11663 |  84 |             guild_id=ctx.guild.id,
11664 |  85 |             channel_id=ctx.channel.id,
11665 |  86 |             user_id=ctx.author.id,
11666 |  87 |             cmd=cmd,
11667 |  88 |             prefix=ctx.prefix,
11668 |  89 |             failed=ctx.command_failed,
11669 |  90 |         )
11670 |  91 | 
11671 |  92 |     @Cog.listener(name="on_member_join")
11672 |  93 |     async def on_autorole(self, member: discord.Member):
11673 |  94 |         guild = member.guild
11674 |  95 | 
11675 |  96 |         with suppress(discord.HTTPException):
11676 |  97 |             record = await Autorole.get_or_none(guild_id=guild.id)
11677 |  98 |             if not record:
11678 |  99 |                 return
11679 | 100 | 
11680 | 101 |             if not member.bot and record.humans:
11681 | 102 |                 for role in record.humans:
11682 | 103 |                     try:
11683 | 104 |                         await member.add_roles(discord.Object(id=role), reason="Quotient's autorole")
11684 | 105 |                     except (discord.NotFound, discord.Forbidden):
11685 | 106 |                         await Autorole.filter(guild_id=guild.id).update(humans=ArrayRemove("humans", role))
11686 | 107 |                         continue
11687 | 108 | 
11688 | 109 |             elif member.bot and record.bots:
11689 | 110 |                 for role in record.bots:
11690 | 111 |                     try:
11691 | 112 |                         await member.add_roles(discord.Object(id=role), reason="Quotient's autorole")
11692 | 113 |                     except (discord.Forbidden, discord.NotFound):
11693 | 114 |                         await Autorole.filter(guild_id=guild.id).update(bots=ArrayRemove("bots", role))
11694 | 115 |                         continue
11695 | 116 |             else:
11696 | 117 |                 return
11697 | 118 | 
11698 | 
11699 | 
11700 | --------------------------------------------------------------------------------
11701 | /cogs/events/errors.py:
11702 | --------------------------------------------------------------------------------
11703 |   1 | from __future__ import annotations
11704 |   2 | 
11705 |   3 | import typing
11706 |   4 | 
11707 |   5 | if typing.TYPE_CHECKING:
11708 |   6 |     from core import Quotient
11709 |   7 | 
11710 |   8 | import discord
11711 |   9 | from discord.ext import commands
11712 |  10 | 
11713 |  11 | from constants import random_greeting
11714 |  12 | from core import Cog, Context
11715 |  13 | from utils import exceptions
11716 |  14 | 
11717 |  15 | 
11718 |  16 | class Errors(Cog):
11719 |  17 |     def __init__(self, bot: Quotient):
11720 |  18 |         self.bot = bot
11721 |  19 | 
11722 |  20 |     @Cog.listener()
11723 |  21 |     async def on_command_error(self, ctx: Context, err):
11724 |  22 |         ignored = (
11725 |  23 |             commands.CommandNotFound,
11726 |  24 |             commands.NoPrivateMessage,
11727 |  25 |             discord.Forbidden,
11728 |  26 |             discord.NotFound,
11729 |  27 |         )
11730 |  28 | 
11731 |  29 |         if isinstance(err, ignored):
11732 |  30 |             return
11733 |  31 | 
11734 |  32 |         if isinstance(err, commands.NotOwner):
11735 |  33 |             return await ctx.send("Hmmm!😷")
11736 |  34 | 
11737 |  35 |         if not hasattr(ctx, "error"):
11738 |  36 |             ctx.error = ctx.reply
11739 |  37 | 
11740 |  38 |         if isinstance(err, exceptions.QuotientError):
11741 |  39 |             return await ctx.error(err.__str__().format(ctx=ctx), ephemeral=True)
11742 |  40 | 
11743 |  41 |         if isinstance(err, commands.MissingRequiredArgument):
11744 |  42 |             return await ctx.send(
11745 |  43 |                 f"{random_greeting()}, You missed the `{err.param.name}` argument.\n\nDo it like: `{ctx.prefix}{ctx.command.qualified_name} {ctx.command.signature}`"
11746 |  44 |             )
11747 |  45 | 
11748 |  46 |         if isinstance(err, commands.BadArgument):
11749 |  47 |             if isinstance(err, commands.MessageNotFound):
11750 |  48 |                 return await ctx.error("Try the command again, and this time with a real message.")
11751 |  49 |             if isinstance(err, commands.MemberNotFound):
11752 |  50 |                 return await ctx.error("Use the command again, and this time mention a real user.")
11753 |  51 |             if isinstance(err, commands.ChannelNotFound):
11754 |  52 |                 return await ctx.error("Use the command again, and this time mention a real channel/category.")
11755 |  53 |             if isinstance(err, commands.RoleNotFound):
11756 |  54 |                 await ctx.error("Try again and this time use a real role.")
11757 |  55 |             elif isinstance(err, commands.EmojiNotFound):
11758 |  56 |                 await ctx.error("Try again and this time use a real emoji.")
11759 |  57 |             elif isinstance(err, commands.ChannelNotReadable):
11760 |  58 |                 await ctx.error(
11761 |  59 |                     f"It looks like I do not have permissions to read the channel `{err.argument}`\n\nYou can fix it by going to channel settings and giving me permissions to view channel."
11762 |  60 |                 )
11763 |  61 |             elif isinstance(err, commands.PartialEmojiConversionFailure):
11764 |  62 |                 await ctx.error(f"The argument `{err.argument}` did not match the partial emoji format.")
11765 |  63 |             elif isinstance(err, commands.BadInviteArgument):
11766 |  64 |                 await ctx.error(f"The invite that matched that argument was not valid or is expired.")
11767 |  65 |             elif isinstance(err, commands.BadBoolArgument):
11768 |  66 |                 await ctx.error(f"The argument `{err.argument}` was not a valid True/False value.")
11769 |  67 |             elif isinstance(err, commands.BadColourArgument):
11770 |  68 |                 await ctx.error(f"The argument `{err.argument}` was not a valid colour.")
11771 |  69 | 
11772 |  70 |             else:
11773 |  71 |                 return await ctx.error(err)
11774 |  72 | 
11775 |  73 |         elif isinstance(err, commands.MissingRole):
11776 |  74 |             return await ctx.error(f"You need `{err.missing_role}` role to use this command.")
11777 |  75 | 
11778 |  76 |         elif isinstance(err, commands.MaxConcurrencyReached):
11779 |  77 |             return await ctx.error(f"This command is already running in this server. You have wait for it to finish.")
11780 |  78 | 
11781 |  79 |         elif isinstance(err, commands.CommandOnCooldown):
11782 |  80 |             if await ctx.bot.is_owner(ctx.author):
11783 |  81 |                 return await ctx.reinvoke()
11784 |  82 |             return await ctx.send(f"You are in cooldown.\n\nTry again in `{err.retry_after:.2f}` seconds.")
11785 |  83 | 
11786 |  84 |         elif isinstance(err, commands.MissingPermissions):
11787 |  85 |             permissions = ", ".join(
11788 |  86 |                 [
11789 |  87 |                     f"{permission.replace('_', ' ').replace('guild', 'server').title()}"
11790 |  88 |                     for permission in err.missing_permissions
11791 |  89 |                 ]
11792 |  90 |             )
11793 |  91 |             await ctx.error(f"You lack **`{permissions}`** permissions to run this command.")
11794 |  92 | 
11795 |  93 |         elif isinstance(err, commands.BotMissingPermissions):
11796 |  94 |             permissions = ", ".join(
11797 |  95 |                 [
11798 |  96 |                     f"{permission.replace('_', ' ').replace('guild', 'server').title()}"
11799 |  97 |                     for permission in err.missing_permissions
11800 |  98 |                 ]
11801 |  99 |             )
11802 | 100 |             message = f"Unfortunately I am missing **`{permissions}`** permissions to run the command `{ctx.command}`.\nThis can be fixed by going to server settings > roles > Quotient and granting Quotient role **`{permissions}`** there."
11803 | 101 |             try:
11804 | 102 |                 await ctx.send(message)
11805 | 103 |             except discord.Forbidden:
11806 | 104 |                 try:
11807 | 105 |                     await ctx.author.send(
11808 | 106 |                         "Hey It looks like, I can't send messages in that channel.",
11809 | 107 |                         view=ctx.get_dm_view(f"Sent from {ctx.guild.name}"),
11810 | 108 |                     )
11811 | 109 |                 except discord.Forbidden:
11812 | 110 |                     pass
11813 | 111 | 
11814 | 112 |             return
11815 | 113 | 
11816 | 114 |         else:  # will setup logging later
11817 | 115 |             raise err
11818 | 116 | 
11819 | 
11820 | 
11821 | --------------------------------------------------------------------------------
11822 | /cogs/events/interaction.py:
11823 | --------------------------------------------------------------------------------
11824 |  1 | from __future__ import annotations
11825 |  2 | 
11826 |  3 | import typing as T
11827 |  4 | 
11828 |  5 | if T.TYPE_CHECKING:
11829 |  6 |     from core import Quotient
11830 |  7 | 
11831 |  8 | import discord
11832 |  9 | from discord.app_commands import AppCommandError
11833 | 10 | 
11834 | 11 | from core import Cog
11835 | 12 | 
11836 | 13 | __all__ = ("InteractionErrors",)
11837 | 14 | 
11838 | 15 | 
11839 | 16 | class InteractionErrors(Cog):
11840 | 17 |     def __init__(self, bot: Quotient):
11841 | 18 |         self.bot = bot
11842 | 19 |         self.bot.tree.interaction_check = self.global_interaction_check
11843 | 20 |         self.bot.tree.on_error = self.on_app_command_error
11844 | 21 | 
11845 | 22 |     async def global_interaction_check(self, interaction: discord.Interaction) -> bool:
11846 | 23 |         if not interaction.guild_id:
11847 | 24 |             await interaction.response.send_message(
11848 | 25 |                 embed=discord.Embed(
11849 | 26 |                     color=discord.Color.red(),
11850 | 27 |                     description="Application commands can not be used in Private Messages.",
11851 | 28 |                 ),
11852 | 29 |                 ephemeral=True,
11853 | 30 |             )
11854 | 31 | 
11855 | 32 |             return False
11856 | 33 | 
11857 | 34 |         return True
11858 | 35 | 
11859 | 36 |     async def on_app_command_error(self, interaction: discord.Interaction, error: AppCommandError):
11860 | 37 |         if isinstance(error, discord.NotFound):
11861 | 38 |             return  # these unknown interactions are annoying :pain:
11862 | 39 | 
11863 | 40 |         # rest later
11864 | 41 | 
11865 | 
11866 | 
11867 | --------------------------------------------------------------------------------
11868 | /cogs/events/logs.py:
11869 | --------------------------------------------------------------------------------
11870 |  1 | from __future__ import annotations
11871 |  2 | 
11872 |  3 | import typing
11873 |  4 | 
11874 |  5 | if typing.TYPE_CHECKING:
11875 |  6 |     from core import Quotient
11876 |  7 | 
11877 |  8 | import discord
11878 |  9 | 
11879 | 10 | from core import Cog
11880 | 11 | 
11881 | 12 | 
11882 | 13 | class LogEvents(Cog):
11883 | 14 |     def __init__(self, bot: Quotient) -> None:
11884 | 15 |         self.bot = bot
11885 | 16 |         # self.guild_log = discord.Webhook.from_url(self.bot.config.GUILD_LOGS, session=self.bot.session)
11886 | 17 | 
11887 | 18 |     # @Cog.listener()
11888 | 19 |     # async def on_guild_join(self, guild: discord.Guild):
11889 | 20 |     #     if not guild:
11890 | 21 |     #         return  # we get these during the boot up
11891 | 22 | 
11892 | 23 |     #     await self.guild_log.send(
11893 | 24 |     #         "```diff\n"
11894 | 25 |     #         f"+ [Joined] {guild.name} ({guild.id})\n"
11895 | 26 |     #         f"+ Owner: {guild.owner} ({guild.owner_id})\n"
11896 | 27 |     #         f"+ Members: {guild.member_count}\n"
11897 | 28 |     #         f"+ Created at: {guild.created_at.strftime('%d/%m/%Y, %H:%M') if guild.created_at else 'Unknown'}\n"
11898 | 29 |     #         "```"
11899 | 30 |     #     )
11900 | 31 | 
11901 | 32 |     # @Cog.listener()
11902 | 33 |     # async def on_guild_remove(self, guild: discord.Guild):
11903 | 34 |     #     if not guild:
11904 | 35 |     #         return
11905 | 36 | 
11906 | 37 |     #     await self.guild_log.send(
11907 | 38 |     #         "```diff\n"
11908 | 39 |     #         f"- [Left] {guild.name} ({guild.id})\n"
11909 | 40 |     #         f"- Owner: {guild.owner} ({guild.owner_id})\n"
11910 | 41 |     #         f"- Members: {guild.member_count}\n"
11911 | 42 |     #         f"- Created at: {guild.created_at.strftime('%d/%m/%Y, %H:%M')}\n"
11912 | 43 |     #         f"- Joined at: {guild.me.joined_at.strftime('%d/%m/%Y, %H:%M') if guild.me.joined_at else 'Unknown'}\n"
11913 | 44 |     #         "```"
11914 | 45 |     #     )
11915 | 46 | 
11916 | 
11917 | 
11918 | --------------------------------------------------------------------------------
11919 | /cogs/events/main.py:
11920 | --------------------------------------------------------------------------------
11921 |  1 | from __future__ import annotations
11922 |  2 | 
11923 |  3 | import typing
11924 |  4 | from collections import defaultdict
11925 |  5 | 
11926 |  6 | if typing.TYPE_CHECKING:
11927 |  7 |     from core import Quotient
11928 |  8 | 
11929 |  9 | import re
11930 | 10 | from contextlib import suppress
11931 | 11 | 
11932 | 12 | import discord
11933 | 13 | 
11934 | 14 | import config
11935 | 15 | from constants import random_greeting
11936 | 16 | from core import Cog, Context, cooldown
11937 | 17 | from models import Guild
11938 | 18 | 
11939 | 19 | 
11940 | 20 | class MentionLimits(defaultdict):
11941 | 21 |     def __missing__(self, key):
11942 | 22 |         r = self[key] = cooldown.QuotientRatelimiter(2, 12)
11943 | 23 |         return r
11944 | 24 | 
11945 | 25 | 
11946 | 26 | class MainEvents(Cog, name="Main Events"):
11947 | 27 |     def __init__(self, bot: Quotient) -> None:
11948 | 28 |         self.bot = bot
11949 | 29 |         self.mentions_limiter = MentionLimits(cooldown.QuotientRatelimiter)
11950 | 30 | 
11951 | 31 |     # incomplete?, I know
11952 | 32 |     @Cog.listener()
11953 | 33 |     async def on_guild_join(self, guild: discord.Guild) -> None:
11954 | 34 |         with suppress(AttributeError):
11955 | 35 |             g, b = await Guild.get_or_create(guild_id=guild.id)
11956 | 36 |             self.bot.cache.guild_data[guild.id] = {
11957 | 37 |                 "prefix": g.prefix,
11958 | 38 |                 "color": g.embed_color or self.bot.color,
11959 | 39 |                 "footer": g.embed_footer or config.FOOTER,
11960 | 40 |             }
11961 | 41 |             self.bot.loop.create_task(guild.chunk())
11962 | 42 | 
11963 | 43 |     @Cog.listener()
11964 | 44 |     async def on_message(self, message: discord.Message) -> None:
11965 | 45 |         if message.author.bot or message.guild is None:
11966 | 46 |             return
11967 | 47 | 
11968 | 48 |         if re.match(f"^<@!?{self.bot.user.id}>
11969 | quot;, message.content):
11970 | 49 |             if self.mentions_limiter[message.author].is_ratelimited(message.author):
11971 | 50 |                 return
11972 | 51 | 
11973 | 52 |             ctx: Context = await self.bot.get_context(message)
11974 | 53 |             self.bot.dispatch("mention", ctx)
11975 | 54 | 
11976 | 55 |     @Cog.listener()
11977 | 56 |     async def on_mention(self, ctx: Context) -> None:
11978 | 57 |         prefix: str = self.bot.cache.guild_data[ctx.guild.id].get("prefix", "q")
11979 | 58 |         await ctx.send(
11980 | 59 |             f"{random_greeting()} You seem lost. Are you?\n"
11981 | 60 |             f"Current prefix for this server is: `{prefix}`.\n\nUse it like: `{prefix}help`"
11982 | 61 |         )
11983 | 62 | 
11984 | 
11985 | 
11986 | --------------------------------------------------------------------------------
11987 | /cogs/events/tasks.py:
11988 | --------------------------------------------------------------------------------
11989 |  1 | from __future__ import annotations
11990 |  2 | 
11991 |  3 | from typing import TYPE_CHECKING
11992 |  4 | 
11993 |  5 | if TYPE_CHECKING:
11994 |  6 |     from core import Quotient
11995 |  7 | 
11996 |  8 | from discord.ext import tasks
11997 |  9 | 
11998 | 10 | import config
11999 | 11 | from core import Cog
12000 | 12 | 
12001 | 13 | 
12002 | 14 | class QuoTasks(Cog):
12003 | 15 |     def __init__(self, bot: Quotient):
12004 | 16 |         self.bot = bot
12005 | 17 | 
12006 | 18 |         self.insert_guilds.start()
12007 | 19 | 
12008 | 20 |     @tasks.loop(count=1)
12009 | 21 |     async def insert_guilds(self):
12010 | 22 |         query = "INSERT INTO guild_data (guild_id , prefix , embed_color , embed_footer) VALUES ($1 , $2 , $3, $4) ON CONFLICT DO NOTHING"
12011 | 23 |         for guild in self.bot.guilds:
12012 | 24 |             await self.bot.db.execute(query, guild.id, config.PREFIX, config.COLOR, config.FOOTER)
12013 | 25 | 
12014 | 26 |     @insert_guilds.before_loop
12015 | 27 |     async def before_loops(self):
12016 | 28 |         await self.bot.wait_until_ready()
12017 | 29 | 
12018 | 
12019 | 
12020 | --------------------------------------------------------------------------------
12021 | /cogs/events/votes.py:
12022 | --------------------------------------------------------------------------------
12023 |  1 | from __future__ import annotations
12024 |  2 | 
12025 |  3 | import typing
12026 |  4 | 
12027 |  5 | if typing.TYPE_CHECKING:
12028 |  6 |     from core import Quotient
12029 |  7 | 
12030 |  8 | import discord
12031 |  9 | from discord import Webhook
12032 | 10 | 
12033 | 11 | import constants
12034 | 12 | from core import Cog
12035 | 13 | from models import Timer, User, Votes
12036 | 14 | 
12037 | 15 | 
12038 | 16 | class VotesCog(Cog):
12039 | 17 |     def __init__(self, bot: Quotient):
12040 | 18 |         self.bot = bot
12041 | 19 |         self.hook = Webhook.from_url(self.bot.config.PUBLIC_LOG, session=self.bot.session)
12042 | 20 | 
12043 | 21 |     @Cog.listener()
12044 | 22 |     async def on_member_join(self, member: discord.Member):
12045 | 23 |         """we grant users voter, premium role if they join later."""
12046 | 24 | 
12047 | 25 |         if not member.guild or not member.guild.id == self.bot.config.SERVER_ID:
12048 | 26 |             return
12049 | 27 | 
12050 | 28 |         if await Votes.get(user_id=member.id, is_voter=True).exists():
12051 | 29 |             await member.add_roles(discord.Object(id=self.bot.config.VOTER_ROLE))
12052 | 30 | 
12053 | 31 |         if await User.get(pk=member.id, is_premium=True).exists():
12054 | 32 |             await member.add_roles(discord.Object(id=self.bot.config.PREMIUM_ROLE))
12055 | 33 | 
12056 | 34 |     @Cog.listener()
12057 | 35 |     async def on_vote_timer_complete(self, timer: Timer):
12058 | 36 |         user_id = timer.kwargs["user_id"]
12059 | 37 |         vote = await Votes.get(user_id=user_id)
12060 | 38 | 
12061 | 39 |         await Votes.get(pk=user_id).update(is_voter=False, notified=False)
12062 | 40 | 
12063 | 41 |         member = self.bot.server.get_member(user_id)
12064 | 42 |         if member is not None:
12065 | 43 |             await member.remove_roles(discord.Object(id=self.bot.config.VOTER_ROLE), reason="Their vote expired.")
12066 | 44 | 
12067 | 45 |         else:
12068 | 46 |             member = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, user_id)
12069 | 47 | 
12070 | 48 |         if vote.reminder:
12071 | 49 |             embed = discord.Embed(
12072 | 50 |                 color=self.bot.color,
12073 | 51 |                 description=f"{constants.random_greeting()}, You asked me to remind you to vote.",
12074 | 52 |                 title="Vote Expired!",
12075 | 53 |                 url="https://quotientbot.xyz/vote",
12076 | 54 |             )
12077 | 55 |             try:
12078 | 56 |                 await member.send(embed=embed)
12079 | 57 |             except discord.Forbidden:
12080 | 58 |                 pass
12081 | 59 | 
12082 | 
12083 | 
12084 | --------------------------------------------------------------------------------
12085 | /cogs/mod/__init__.py:
12086 | --------------------------------------------------------------------------------
12087 |   1 | from __future__ import annotations
12088 |   2 | 
12089 |   3 | from typing import TYPE_CHECKING, List, Optional, Union
12090 |   4 | 
12091 |   5 | if TYPE_CHECKING:
12092 |   6 |     from core import Quotient
12093 |   7 | 
12094 |   8 | import re
12095 |   9 | 
12096 |  10 | import discord
12097 |  11 | from discord.ext import commands
12098 |  12 | 
12099 |  13 | from constants import LockType
12100 |  14 | from core import Cog, Context, QuotientView, role_command_check
12101 |  15 | from models import Lockdown
12102 |  16 | from utils import ActionReason, BannedMember, FutureTime, MemberID, QuoUser, emote, human_timedelta, plural
12103 |  17 | 
12104 |  18 | from .events import *
12105 |  19 | from .utils import _complex_cleanup_strategy, _self_clean_system, do_removal
12106 |  20 | from .views import *
12107 |  21 | 
12108 |  22 | 
12109 |  23 | class Mod(Cog):
12110 |  24 |     def __init__(self, bot: Quotient):
12111 |  25 |         self.bot = bot
12112 |  26 | 
12113 |  27 |     @commands.command()
12114 |  28 |     @commands.has_permissions(manage_guild=True)
12115 |  29 |     @commands.cooldown(5, 1, type=commands.BucketType.user)
12116 |  30 |     async def selfclean(self, ctx: Context, search=100):
12117 |  31 |         """
12118 |  32 |         Clean Quotient's messages,
12119 |  33 |         Note: If bot has `manage_messages` permissions then it will delete the command messages too.
12120 |  34 |         """
12121 |  35 |         strategy = _self_clean_system
12122 |  36 |         if ctx.channel.permissions_for(ctx.me).manage_messages:
12123 |  37 |             strategy = _complex_cleanup_strategy
12124 |  38 | 
12125 |  39 |         search = min(max(2, search), 1000)
12126 |  40 | 
12127 |  41 |         spammers = await strategy(ctx, search)
12128 |  42 |         deleted = sum(spammers.values())
12129 |  43 |         messages = [f'{deleted} message{" was" if deleted == 1 else "s were"} removed.']
12130 |  44 |         if deleted:
12131 |  45 |             messages.append("")
12132 |  46 |             spammers = sorted(spammers.items(), key=lambda t: t[1], reverse=True)
12133 |  47 |             messages.extend(f"- **{author}**: {count}" for author, count in spammers)
12134 |  48 | 
12135 |  49 |         await ctx.send("\n".join(messages), delete_after=10)
12136 |  50 | 
12137 |  51 |     @commands.group(invoke_without_command=True, aliases=["purge"])
12138 |  52 |     @commands.has_permissions(manage_messages=True)
12139 |  53 |     @commands.cooldown(7, 1, type=commands.BucketType.guild)
12140 |  54 |     async def clear(self, ctx: Context, Choice: Union[discord.Member, int], amount: int = 5):
12141 |  55 |         """
12142 |  56 |         An all in one purge command.
12143 |  57 |         Choice can be a Member or a number
12144 |  58 |         """
12145 |  59 |         if isinstance(Choice, discord.Member):
12146 |  60 |             await do_removal(ctx, amount, lambda e: e.author == Choice)
12147 |  61 | 
12148 |  62 |         elif isinstance(Choice, int):
12149 |  63 |             await do_removal(ctx, Choice, lambda e: not e.pinned)
12150 |  64 | 
12151 |  65 |         await ctx.message.delete()
12152 |  66 | 
12153 |  67 |     @clear.command()
12154 |  68 |     @commands.has_permissions(manage_messages=True)
12155 |  69 |     async def embeds(self, ctx, search=100):
12156 |  70 |         """Removes messages that have embeds in them."""
12157 |  71 |         await do_removal(ctx, search, lambda e: len(e.embeds))
12158 |  72 | 
12159 |  73 |     @clear.command()
12160 |  74 |     @commands.has_permissions(manage_messages=True)
12161 |  75 |     async def files(self, ctx, search=100):
12162 |  76 |         """Removes messages that have attachments in them."""
12163 |  77 |         await do_removal(ctx, search, lambda e: len(e.attachments))
12164 |  78 | 
12165 |  79 |     @clear.command()
12166 |  80 |     @commands.has_permissions(manage_messages=True)
12167 |  81 |     async def images(self, ctx, search=100):
12168 |  82 |         """Removes messages that have embeds or attachments."""
12169 |  83 |         await do_removal(ctx, search, lambda e: len(e.embeds) or len(e.attachments))
12170 |  84 | 
12171 |  85 |     @clear.command(name="all")
12172 |  86 |     @commands.has_permissions(manage_messages=True)
12173 |  87 |     async def _remove_all(self, ctx, search=100):
12174 |  88 |         """Removes all messages."""
12175 |  89 |         await do_removal(ctx, search, lambda e: not e.pinned)
12176 |  90 | 
12177 |  91 |     @clear.command()
12178 |  92 |     @commands.has_permissions(manage_messages=True)
12179 |  93 |     async def user(self, ctx, member: QuoUser, search=100):
12180 |  94 |         """Removes all messages by the member."""
12181 |  95 |         await do_removal(ctx, search, lambda e: e.author == member)
12182 |  96 | 
12183 |  97 |     @clear.command()
12184 |  98 |     @commands.has_permissions(manage_messages=True)
12185 |  99 |     async def contains(self, ctx, *, substr: str):
12186 | 100 |         """Removes all messages containing a substring.
12187 | 101 |         The substring must be at least 3 characters long.
12188 | 102 |         """
12189 | 103 |         if len(substr) < 3:
12190 | 104 |             await ctx.error("The substring length must be at least 3 characters.")
12191 | 105 |         else:
12192 | 106 |             await do_removal(ctx, 100, lambda e: substr in e.content)
12193 | 107 | 
12194 | 108 |     @clear.command(name="bot", aliases=["bots"])
12195 | 109 |     @commands.has_permissions(manage_messages=True)
12196 | 110 |     async def _bot(self, ctx, prefix=None, search=100):
12197 | 111 |         """Removes a bot user's messages and messages with their optional prefix."""
12198 | 112 | 
12199 | 113 |         def predicate(m):
12200 | 114 |             return (m.webhook_id is None and m.author.bot) or (prefix and m.content.startswith(prefix))
12201 | 115 | 
12202 | 116 |         await do_removal(ctx, search, predicate)
12203 | 117 | 
12204 | 118 |     @clear.command(name="emoji", aliases=["emojis"])
12205 | 119 |     @commands.has_permissions(manage_messages=True)
12206 | 120 |     async def _emoji(self, ctx, search=100):
12207 | 121 |         """Removes all messages containing custom emoji."""
12208 | 122 |         custom_emoji = re.compile(r"<a?:[a-zA-Z0-9\_]+:([0-9]+)>")
12209 | 123 | 
12210 | 124 |         def predicate(m):
12211 | 125 |             return custom_emoji.search(m.content)
12212 | 126 | 
12213 | 127 |         await do_removal(ctx, search, predicate)
12214 | 128 | 
12215 | 129 |     @clear.command(name="reactions")
12216 | 130 |     @commands.has_permissions(manage_messages=True)
12217 | 131 |     async def _reactions(self, ctx, search=100):
12218 | 132 |         """Removes all reactions from messages that have them."""
12219 | 133 |         if search > 2000:
12220 | 134 |             return await ctx.send(f"Too many messages to search for ({search}/2000)")
12221 | 135 | 
12222 | 136 |         total_reactions = 0
12223 | 137 |         async for message in ctx.history(limit=search, before=ctx.message):
12224 | 138 |             if message.reactions:
12225 | 139 |                 total_reactions += sum(r.count for r in message.reactions)
12226 | 140 |                 await message.clear_reactions()
12227 | 141 | 
12228 | 142 |         await ctx.success(f"Successfully removed {total_reactions} reactions.")
12229 | 143 | 
12230 | 144 |     @commands.command()
12231 | 145 |     @commands.has_permissions(kick_members=True)
12232 | 146 |     @commands.bot_has_guild_permissions(kick_members=True)
12233 | 147 |     @commands.cooldown(3, 1, type=commands.BucketType.user)
12234 | 148 |     async def kick(self, ctx, member: MemberID, *, reason: ActionReason = None):
12235 | 149 |         """Kicks a member from the server.
12236 | 150 |         In order for this to work, the bot must have Kick Member permissions.
12237 | 151 |         To use this command you must have Kick Members permission.
12238 | 152 |         """
12239 | 153 |         if reason is None:
12240 | 154 |             reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
12241 | 155 | 
12242 | 156 |         await ctx.guild.kick(member, reason=reason)
12243 | 157 |         await ctx.success(f"{str(member)} has been successfully kicked out!")
12244 | 158 | 
12245 | 159 |     @commands.command()
12246 | 160 |     @commands.has_permissions(ban_members=True)
12247 | 161 |     @commands.cooldown(3, 1, type=commands.BucketType.user)
12248 | 162 |     @commands.bot_has_guild_permissions(ban_members=True)
12249 | 163 |     async def ban(self, ctx, member: MemberID, *, reason: ActionReason = None):
12250 | 164 |         """Bans a member from the server.
12251 | 165 |         You can also ban from ID to ban regardless whether they're
12252 | 166 |         in the server or not.
12253 | 167 |         In order for this to work, the bot must have Ban Member permissions.
12254 | 168 |         To use this command you must have Ban Members permission.
12255 | 169 |         """
12256 | 170 |         if reason is None:
12257 | 171 |             reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
12258 | 172 | 
12259 | 173 |         await ctx.guild.ban(member, reason=reason)
12260 | 174 |         await ctx.success(f"{str(member)} has been successfully banned!")
12261 | 175 | 
12262 | 176 |     @commands.command()
12263 | 177 |     @commands.has_permissions(ban_members=True)
12264 | 178 |     @commands.bot_has_guild_permissions(ban_members=True)
12265 | 179 |     @commands.cooldown(3, 1, type=commands.BucketType.user)
12266 | 180 |     async def unban(self, ctx: Context, member: BannedMember, *, reason: ActionReason = None):
12267 | 181 |         """Unbans a member from the server.
12268 | 182 |         You can pass either the ID of the banned member or the Name#Discrim
12269 | 183 |         combination of the member. Typically the ID is easiest to use.
12270 | 184 |         In order for this to work, the bot must have Ban Member permissions.
12271 | 185 |         To use this command you must have Ban Members permissions.
12272 | 186 |         """
12273 | 187 |         if reason is None:
12274 | 188 |             reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
12275 | 189 | 
12276 | 190 |         await ctx.guild.unban(member.user, reason=reason)
12277 | 191 |         if member.reason:
12278 | 192 |             await ctx.send(f"Unbanned {member.user} (ID: {member.user.id}), previously banned for {member.reason}.")
12279 | 193 |         else:
12280 | 194 |             await ctx.success(f"Unbanned {member.user} (ID: {member.user.id}).")
12281 | 195 | 
12282 | 196 |     @commands.group(
12283 | 197 |         invoke_without_command=True,
12284 | 198 |         aliases=["addrole", "giverole"],
12285 | 199 |         extras={"examples": ["role @role @user1 @user2 @user3 ..."]},
12286 | 200 |     )
12287 | 201 |     @commands.has_guild_permissions(manage_roles=True)
12288 | 202 |     @commands.bot_has_guild_permissions(manage_roles=True)
12289 | 203 |     @commands.cooldown(4, 1, type=commands.BucketType.guild)
12290 | 204 |     @role_command_check()
12291 | 205 |     async def role(self, ctx: Context, role: discord.Role, members: commands.Greedy[discord.Member]):
12292 | 206 |         """
12293 | 207 |         Add a role to one or multiple users.
12294 | 208 |         """
12295 | 209 | 
12296 | 210 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
12297 | 211 | 
12298 | 212 |         if not members:
12299 | 213 |             members = ctx.guild.members
12300 | 214 | 
12301 | 215 |             prompt = await ctx.prompt("No members were specified, do you want to add the role to all members?")
12302 | 216 |             if not prompt:
12303 | 217 |                 return await ctx.simple(
12304 | 218 |                     f"Alright, Aborting. If you wish to add the role to limited users, do:\n\n`{ctx.prefix}role @role @user1 @user2 @user3 ...`"
12305 | 219 |                 )
12306 | 220 | 
12307 | 221 |         m = await ctx.simple(f"{emote.loading} Adding {role.mention} to {plural(members):member|members}.")
12308 | 222 | 
12309 | 223 |         for member in members:
12310 | 224 |             if role not in member.roles:
12311 | 225 |                 await member.add_roles(role, reason=reason)
12312 | 226 | 
12313 | 227 |         _view = QuotientView(ctx)
12314 | 228 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members))
12315 | 229 | 
12316 | 230 |         await ctx.safe_delete(m)
12317 | 231 |         _view.message = await ctx.success(
12318 | 232 |             f"Added {role.mention} to {plural(members):member|members}.\n\n"
12319 | 233 |             "```If you cannot see the role in any of the user's profile, just restart your discord app or check audit log.```",
12320 | 234 |             view=_view,
12321 | 235 |         )
12322 | 236 | 
12323 | 237 |     @role.command(name="humans", extras={"examples": ["role humans @role", "role humans role_id"]})
12324 | 238 |     @commands.has_guild_permissions(manage_roles=True)
12325 | 239 |     @commands.bot_has_guild_permissions(manage_roles=True)
12326 | 240 |     @commands.cooldown(5, 1, type=commands.BucketType.guild)
12327 | 241 |     @role_command_check()
12328 | 242 |     async def role_humans(self, ctx: Context, role: discord.Role):
12329 | 243 |         """Add a role to all human users."""
12330 | 244 | 
12331 | 245 |         members = [m for m in ctx.guild.members if all([not role in m.roles, not m.bot])]
12332 | 246 | 
12333 | 247 |         prompt = await ctx.prompt(
12334 | 248 |             title="Are you sure you want to continue?",
12335 | 249 |             message=f"{role.mention} will be added to all {plural(members):human|humans} in the server.",
12336 | 250 |         )
12337 | 251 | 
12338 | 252 |         if not prompt:
12339 | 253 |             return await ctx.success("Alright, Aborting.")
12340 | 254 | 
12341 | 255 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
12342 | 256 |         m = await ctx.simple(f"{emote.loading} Adding {role.mention} to {plural(members):human|humans}.")
12343 | 257 | 
12344 | 258 |         success, failed = 0, 0
12345 | 259 | 
12346 | 260 |         for member in members:
12347 | 261 |             try:
12348 | 262 |                 await member.add_roles(role, reason=reason)
12349 | 263 |                 success += 1
12350 | 264 |             except discord.HTTPException:
12351 | 265 |                 failed += 1
12352 | 266 | 
12353 | 267 |         _view = QuotientView(ctx)
12354 | 268 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members))
12355 | 269 | 
12356 | 270 |         await ctx.safe_delete(m)
12357 | 271 |         _view.message = await ctx.success(
12358 | 272 |             f"Successfully added {role.mention} to {plural(success):human|humans}. (Failed: {failed})", view=_view
12359 | 273 |         )
12360 | 274 | 
12361 | 275 |     @role.command(name="bots", extras={"examples": ["role bots @role", "role bots role_id"]})
12362 | 276 |     @commands.has_guild_permissions(manage_roles=True)
12363 | 277 |     @commands.bot_has_guild_permissions(manage_roles=True)
12364 | 278 |     @role_command_check()
12365 | 279 |     async def role_bots(self, ctx: Context, role: discord.Role):
12366 | 280 |         """Add a role to all bot users."""
12367 | 281 |         members = [m for m in ctx.guild.members if all([not role in m.roles, m.bot])]
12368 | 282 | 
12369 | 283 |         prompt = await ctx.prompt(
12370 | 284 |             title="Are you sure you want to continue?",
12371 | 285 |             message=f"{role.mention} will be added to all {plural(members):bot|bots} in the server.",
12372 | 286 |         )
12373 | 287 | 
12374 | 288 |         if not prompt:
12375 | 289 |             return await ctx.success("Alright, Aborting.")
12376 | 290 | 
12377 | 291 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
12378 | 292 |         m = await ctx.simple(f"{emote.loading} Adding {role.mention} to {plural(members):bot|bots}.")
12379 | 293 | 
12380 | 294 |         success, failed = 0, 0
12381 | 295 | 
12382 | 296 |         for member in members:
12383 | 297 |             try:
12384 | 298 |                 await member.add_roles(role, reason=reason)
12385 | 299 |                 success += 1
12386 | 300 |             except discord.HTTPException:
12387 | 301 |                 failed += 1
12388 | 302 | 
12389 | 303 |         _view = QuotientView(ctx)
12390 | 304 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members))
12391 | 305 | 
12392 | 306 |         await ctx.safe_delete(m)
12393 | 307 |         _view.message = await ctx.success(
12394 | 308 |             f"Successfully added {role.mention} to {plural(success):bot|bots}. (Failed: {failed})", view=_view
12395 | 309 |         )
12396 | 310 | 
12397 | 311 |     @role.command(name="all", extras={"examples": ["role all @role", "role all role_id"]})
12398 | 312 |     @commands.has_guild_permissions(manage_roles=True)
12399 | 313 |     @commands.bot_has_guild_permissions(manage_roles=True)
12400 | 314 |     @role_command_check()
12401 | 315 |     async def role_all(self, ctx: Context, role: discord.Role):
12402 | 316 |         """Add a role to everyone on the server"""
12403 | 317 | 
12404 | 318 |         members = [m for m in ctx.guild.members if not role in m.roles]
12405 | 319 | 
12406 | 320 |         prompt = await ctx.prompt(
12407 | 321 |             title="Are you sure you want to continue?",
12408 | 322 |             message=f"{role.mention} will be added to all {plural(members):user|users} in the server.",
12409 | 323 |         )
12410 | 324 | 
12411 | 325 |         if not prompt:
12412 | 326 |             return await ctx.success("Alright, Aborting.")
12413 | 327 | 
12414 | 328 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
12415 | 329 |         m = await ctx.simple(f"{emote.loading} Adding {role.mention} to {plural(members):user|users}.")
12416 | 330 | 
12417 | 331 |         success, failed = 0, 0
12418 | 332 | 
12419 | 333 |         for member in members:
12420 | 334 |             try:
12421 | 335 |                 await member.add_roles(role, reason=reason)
12422 | 336 |                 success += 1
12423 | 337 |             except discord.HTTPException:
12424 | 338 |                 failed += 1
12425 | 339 | 
12426 | 340 |         _view = QuotientView(ctx)
12427 | 341 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members))
12428 | 342 | 
12429 | 343 |         await ctx.safe_delete(m)
12430 | 344 |         _view.message = await ctx.success(
12431 | 345 |             f"Successfully added {role.mention} to {plural(success):user|users}. (Failed: {failed})", view=_view
12432 | 346 |         )
12433 | 347 | 
12434 | 348 |     @commands.group(invoke_without_command=True, aliases=["removerole", "takerole"])
12435 | 349 |     @commands.has_guild_permissions(manage_roles=True)
12436 | 350 |     @commands.bot_has_guild_permissions(manage_roles=True)
12437 | 351 |     @role_command_check()
12438 | 352 |     async def rrole(self, ctx: Context, role: discord.Role, members: commands.Greedy[discord.Member]):
12439 | 353 |         """Remove a role from one or multiple users."""
12440 | 354 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
12441 | 355 |         if not members:
12442 | 356 |             members = [m for m in ctx.guild.members if role in m.roles]
12443 | 357 | 
12444 | 358 |             prompt = await ctx.prompt("No members were specified, do you want to remove the role from all members?")
12445 | 359 |             if not prompt:
12446 | 360 |                 return await ctx.simple(
12447 | 361 |                     f"Alright, Aborting. If you wish to remove the role from limited users, do:\n\n`{ctx.prefix}rrole @role @user1 @user2 @user3 ...`"
12448 | 362 |                 )
12449 | 363 | 
12450 | 364 |         m = await ctx.simple(f"{emote.loading} Removing {role.mention} from {plural(members):member|members}.")
12451 | 365 | 
12452 | 366 |         for member in members:
12453 | 367 |             await member.remove_roles(role, reason=reason)
12454 | 368 | 
12455 | 369 |         _view = QuotientView(ctx)
12456 | 370 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members, take_role=False))
12457 | 371 | 
12458 | 372 |         await ctx.safe_delete(m)
12459 | 373 |         _view.message = await ctx.success(
12460 | 374 |             f"Removed {role.mention} from {plural(members):member|members}.",
12461 | 375 |             view=_view,
12462 | 376 |         )
12463 | 377 | 
12464 | 378 |     @rrole.command(name="humans")
12465 | 379 |     @commands.has_guild_permissions(manage_roles=True)
12466 | 380 |     @commands.bot_has_guild_permissions(manage_roles=True)
12467 | 381 |     @role_command_check()
12468 | 382 |     async def rrole_humans(self, ctx: Context, role: discord.Role):
12469 | 383 |         """Remove a role from all human users."""
12470 | 384 | 
12471 | 385 |         members = [m for m in ctx.guild.members if all([role in m.roles, not m.bot])]
12472 | 386 | 
12473 | 387 |         prompt = await ctx.prompt(
12474 | 388 |             title="Are you sure you want to continue?",
12475 | 389 |             message=f"{role.mention} will be removed from all {plural(members):human|humans} in the server.",
12476 | 390 |         )
12477 | 391 | 
12478 | 392 |         if not prompt:
12479 | 393 |             return await ctx.success("Alright, Aborting.")
12480 | 394 | 
12481 | 395 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
12482 | 396 |         m = await ctx.simple(f"{emote.loading} Remove {role.mention} from {plural(members):human|humans}.")
12483 | 397 | 
12484 | 398 |         success, failed = 0, 0
12485 | 399 | 
12486 | 400 |         for member in members:
12487 | 401 |             try:
12488 | 402 |                 await member.remove_roles(role, reason=reason)
12489 | 403 |                 success += 1
12490 | 404 |             except discord.HTTPException:
12491 | 405 |                 failed += 1
12492 | 406 | 
12493 | 407 |         _view = QuotientView(ctx)
12494 | 408 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members, take_role=False))
12495 | 409 | 
12496 | 410 |         await ctx.safe_delete(m)
12497 | 411 |         _view.message = await ctx.success(
12498 | 412 |             f"Successfully removed {role.mention} from {plural(success):human|humans}. (Failed: {failed})", view=_view
12499 | 413 |         )
12500 | 414 | 
12501 | 415 |     @rrole.command(name="bots")
12502 | 416 |     @commands.has_guild_permissions(manage_roles=True)
12503 | 417 |     @commands.bot_has_guild_permissions(manage_roles=True)
12504 | 418 |     @role_command_check()
12505 | 419 |     async def rrole_bots(self, ctx: Context, role: discord.Role):
12506 | 420 |         """Remove a role from all the bots."""
12507 | 421 |         members = [m for m in ctx.guild.members if all([role in m.roles, m.bot])]
12508 | 422 | 
12509 | 423 |         prompt = await ctx.prompt(
12510 | 424 |             title="Are you sure you want to continue?",
12511 | 425 |             message=f"{role.mention} will be removed from all {plural(members):bot|bots} in the server.",
12512 | 426 |         )
12513 | 427 | 
12514 | 428 |         if not prompt:
12515 | 429 |             return await ctx.success("Alright, Aborting.")
12516 | 430 | 
12517 | 431 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
12518 | 432 |         m = await ctx.simple(f"{emote.loading} Remove {role.mention} from {plural(members):bot|bots}.")
12519 | 433 | 
12520 | 434 |         success, failed = 0, 0
12521 | 435 | 
12522 | 436 |         for member in members:
12523 | 437 |             try:
12524 | 438 |                 await member.remove_roles(role, reason=reason)
12525 | 439 |                 success += 1
12526 | 440 |             except discord.HTTPException:
12527 | 441 |                 failed += 1
12528 | 442 | 
12529 | 443 |         _view = QuotientView(ctx)
12530 | 444 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members, take_role=False))
12531 | 445 | 
12532 | 446 |         await ctx.safe_delete(m)
12533 | 447 |         _view.message = await ctx.success(
12534 | 448 |             f"Successfully removed {role.mention} from {plural(success):bot|bots}. (Failed: {failed})", view=_view
12535 | 449 |         )
12536 | 450 | 
12537 | 451 |     @rrole.command(name="all")
12538 | 452 |     @commands.has_guild_permissions(manage_roles=True)
12539 | 453 |     @commands.bot_has_guild_permissions(manage_roles=True)
12540 | 454 |     @role_command_check()
12541 | 455 |     async def rrole_all(self, ctx: Context, role: discord.Role):
12542 | 456 |         """Remove a role from everyone on the server."""
12543 | 457 |         members = [m for m in ctx.guild.members if role in m.roles]
12544 | 458 | 
12545 | 459 |         prompt = await ctx.prompt(
12546 | 460 |             title="Are you sure you want to continue?",
12547 | 461 |             message=f"{role.mention} will be removed from all {plural(members):user|users} in the server.",
12548 | 462 |         )
12549 | 463 | 
12550 | 464 |         if not prompt:
12551 | 465 |             return await ctx.success("Alright, Aborting.")
12552 | 466 | 
12553 | 467 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
12554 | 468 |         m = await ctx.simple(f"{emote.loading} Removing {role.mention} from {plural(members):user|users}.")
12555 | 469 | 
12556 | 470 |         success, failed = 0, 0
12557 | 471 | 
12558 | 472 |         for member in members:
12559 | 473 |             try:
12560 | 474 |                 await member.remove_roles(role, reason=reason)
12561 | 475 |                 success += 1
12562 | 476 |             except discord.HTTPException:
12563 | 477 |                 failed += 1
12564 | 478 | 
12565 | 479 |         _view = QuotientView(ctx)
12566 | 480 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members, take_role=False))
12567 | 481 | 
12568 | 482 |         await ctx.safe_delete(m)
12569 | 483 |         _view.message = await ctx.success(
12570 | 484 |             f"Successfully removed {role.mention} from {plural(success):user|users}. (Failed: {failed})", view=_view
12571 | 485 |         )
12572 | 486 | 
12573 | 487 |     @commands.group(invoke_without_command=True, aliases=("lockdown",))
12574 | 488 |     async def lock(self, ctx: Context, channel: Optional[discord.TextChannel], duration: Optional[FutureTime]):
12575 | 489 |         """Lock a channel , category or the whole server."""
12576 | 490 |         channel = channel or ctx.channel
12577 | 491 |         check = await Lockdown.filter(guild_id=ctx.guild.id, channel_id=channel.id, type=LockType.channel).first()
12578 | 492 | 
12579 | 493 |         if check is not None:
12580 | 494 |             return await ctx.error(
12581 | 495 |                 f"**{channel}** is already locked.\n\nTime Remaining: {human_timedelta(check.expire_time)}"
12582 | 496 |             )
12583 | 497 | 
12584 | 498 |         if not channel.permissions_for(ctx.me).manage_channels:
12585 | 499 |             return await ctx.error(f"I need `manage_channels` permission in **{channel}**")
12586 | 500 | 
12587 | 501 |         if not channel.permissions_for(ctx.author).manage_channels:
12588 | 502 |             return await ctx.error(f"You need `manage channels` permission in **{channel}** to use this.")
12589 | 503 | 
12590 | 504 |         perms = channel.overwrites_for(ctx.guild.default_role)
12591 | 505 |         perms.send_messages = False
12592 | 506 |         await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
12593 | 507 | 
12594 | 508 |         if duration is None:  # we don't want to store if duration is None.
12595 | 509 |             return await ctx.success(f"Locked down **{channel.name}**")
12596 | 510 | 
12597 | 511 |         await Lockdown.create(
12598 | 512 |             guild_id=ctx.guild.id,
12599 | 513 |             type=LockType.channel,
12600 | 514 |             expire_time=duration.dt,
12601 | 515 |             channel_id=channel.id,
12602 | 516 |             author_id=ctx.author.id,
12603 | 517 |         )
12604 | 518 |         timer = await self.bot.reminders.create_timer(
12605 | 519 |             duration.dt, "lockdown", _type=LockType.channel.value, channel_id=channel.id
12606 | 520 |         )
12607 | 521 |         await ctx.success(f"Locked down **{channel}** for {human_timedelta(duration.dt,source= timer.created)}")
12608 | 522 | 
12609 | 523 |     @lock.command(name="server", aliases=("guild",))
12610 | 524 |     @commands.bot_has_guild_permissions(manage_channels=True)
12611 | 525 |     @commands.has_permissions(manage_guild=True)
12612 | 526 |     async def lock_server(self, ctx, duration: Optional[FutureTime]):
12613 | 527 |         check = await Lockdown.filter(guild_id=ctx.guild.id, type=LockType.guild).first()
12614 | 528 |         if check is not None:
12615 | 529 |             text = f"Server is already locked."
12616 | 530 |             if check.expire_time:
12617 | 531 |                 text += f"\n\nTime Remaining: {human_timedelta(check.expire_time)}"
12618 | 532 |             return await ctx.error(text)
12619 | 533 | 
12620 | 534 |         channels = list(filter(lambda x: x.overwrites_for(ctx.guild.default_role).send_messages, ctx.guild.channels))
12621 | 535 |         mine = sum(1 for i in filter(lambda x: x.permissions_for(ctx.me).manage_channels, (channels)))
12622 | 536 |         # len list would use additional memory so : )
12623 | 537 | 
12624 | 538 |         if not (channels):
12625 | 539 |             return await ctx.error(f"@everyone doesn't have `send_messages` enabled in any channel.")
12626 | 540 | 
12627 | 541 |         if not mine:
12628 | 542 |             return await ctx.error(
12629 | 543 |                 f"`{sum(1 for i in channels)} channels` have send messages enabled. But unfortunately I don't permission to edit any of them."
12630 | 544 |             )
12631 | 545 | 
12632 | 546 |         prompt = await ctx.prompt(
12633 | 547 |             f"`{sum(1 for i in channels)} channels` have send messages enabled for @everyone,\nI have permissions to modify `{mine} channels`.",
12634 | 548 |             title="Do you want me to continue?",
12635 | 549 |         )
12636 | 550 |         if not prompt:
12637 | 551 |             return await ctx.success(f"Alright, aborting.")
12638 | 552 | 
12639 | 553 |         await ctx.send(f"Kindly wait.. {emote.loading}", delete_after=3)
12640 | 554 | 
12641 | 555 |         success, failed = [], 0
12642 | 556 |         reason = f"Action done by -> {str(ctx.author)} ({ctx.author.id})"
12643 | 557 |         for channel in channels:
12644 | 558 |             overwrite = channel.overwrites_for(ctx.guild.default_role)
12645 | 559 |             overwrite.send_messages = False
12646 | 560 | 
12647 | 561 |             try:
12648 | 562 |                 await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite, reason=reason)
12649 | 563 |                 success.append(channel.id)
12650 | 564 |             except:
12651 | 565 |                 failed += 1
12652 | 566 |                 continue
12653 | 567 | 
12654 | 568 |         await Lockdown.create(
12655 | 569 |             guild_id=ctx.guild.id,
12656 | 570 |             type=LockType.guild,
12657 | 571 |             channel_id=ctx.channel.id,
12658 | 572 |             author_id=ctx.author.id,
12659 | 573 |             channel_ids=success,
12660 | 574 |             expire_time=duration.dt,
12661 | 575 |         )
12662 | 576 | 
12663 | 577 |         if duration is None:
12664 | 578 |             return await ctx.success(f"Locked down `{len(success)} channels` (Failed: `{failed}`)")
12665 | 579 | 
12666 | 580 |         timer = await self.bot.reminders.create_timer(
12667 | 581 |             duration.dt, "lockdown", _type=LockType.guild.value, guild_id=ctx.guild.id
12668 | 582 |         )
12669 | 583 |         await ctx.success(
12670 | 584 |             f"Locked down `{len(success)} channels` (Failed: `{failed}`) for {human_timedelta(duration.dt, source=timer.created)}"
12671 | 585 |         )
12672 | 586 | 
12673 | 587 |     @commands.group(aliases=("unlockdown",), invoke_without_command=True)
12674 | 588 |     async def unlock(self, ctx, *, channel: Optional[discord.TextChannel]):
12675 | 589 |         channel = channel or ctx.channel
12676 | 590 | 
12677 | 591 |         if not channel.permissions_for(ctx.me).manage_channels:
12678 | 592 |             return await ctx.error(f"I need `manage_channels` permission in **{channel}**")
12679 | 593 | 
12680 | 594 |         if not channel.permissions_for(ctx.author).manage_channels:
12681 | 595 |             return await ctx.error(f"You need `manage channels` permission in **{channel}** to use this.")
12682 | 596 | 
12683 | 597 |         perms = channel.overwrites_for(ctx.guild.default_role)
12684 | 598 |         perms.send_messages = True
12685 | 599 |         await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
12686 | 600 | 
12687 | 601 |         await ctx.success(f"Unlocked **{channel}**")
12688 | 602 | 
12689 | 603 |         await Lockdown.filter(channel_id=channel.id, type=LockType.channel).delete()
12690 | 604 | 
12691 | 605 |     @unlock.command(name="server", aliases=("guild",))
12692 | 606 |     @commands.has_permissions(manage_guild=True)
12693 | 607 |     @commands.bot_has_guild_permissions(manage_channels=True)
12694 | 608 |     async def unlock_guild(self, ctx):
12695 | 609 |         check = await Lockdown.get_or_none(guild_id=ctx.guild.id, type=LockType.guild).first()
12696 | 610 |         if not check:
12697 | 611 |             return await ctx.error(f"The server is not locked.")
12698 | 612 | 
12699 | 613 |         success = 0
12700 | 614 |         for channel in check.channels:
12701 | 615 |             if channel is not None and channel.permissions_for(channel.guild.me).manage_channels:
12702 | 616 |                 perms = channel.overwrites_for(channel.guild.default_role)
12703 | 617 |                 perms.send_messages = True
12704 | 618 |                 await channel.set_permissions(
12705 | 619 |                     channel.guild.default_role, overwrite=perms, reason="Lockdown timer complete!"
12706 | 620 |                 )
12707 | 621 |                 success += 1
12708 | 622 | 
12709 | 623 |         await ctx.success(
12710 | 624 |             f"Successfully unlocked `{success}` channels. (`{sum(1 for i in check.channels)}` were locked.)"
12711 | 625 |         )
12712 | 626 |         await Lockdown.filter(guild_id=ctx.guild.id, type=LockType.guild).delete()
12713 | 627 | 
12714 | 628 |     @commands.group(invoke_without_command=True)
12715 | 629 |     async def maintenance(self, ctx: Context):
12716 | 630 |         """Maintenance ON/ OFF for the server."""
12717 | 631 |         await ctx.send_help(ctx.command)
12718 | 632 | 
12719 | 633 |     @maintenance.command(name="on")
12720 | 634 |     @commands.has_permissions(administrator=True)
12721 | 635 |     @commands.bot_has_guild_permissions(manage_channels=True)
12722 | 636 |     async def maintenace_on(self, ctx: Context, *, role: discord.Role = None):
12723 | 637 |         """
12724 | 638 |         Turn ON maintenance mode.
12725 | 639 |         You can turn on maintenance for a specific role too , the default role is everyone.
12726 | 640 |         This will hide all the channels where `role` has `read_messages` permission enabled.
12727 | 641 |         """
12728 | 642 |         role = role or ctx.guild.default_role
12729 | 643 |         check = await Lockdown.filter(type=LockType.maintenance, guild_id=ctx.guild.id, role_id=role.id).first()
12730 | 644 |         if check:
12731 | 645 |             return await ctx.error(f"The server is already under maintenance for **{role}**")
12732 | 646 | 
12733 | 647 |         channels = list(filter(lambda x: x.overwrites_for(role).read_messages, ctx.guild.channels))
12734 | 648 |         mine = sum(1 for i in filter(lambda x: x.permissions_for(ctx.me).manage_channels, (channels)))
12735 | 649 |         # len list would use additional memory so : )
12736 | 650 | 
12737 | 651 |         if not (channels):
12738 | 652 |             return await ctx.error(f"**{role}** doesn't have `read_messages` enabled in any channel.")
12739 | 653 | 
12740 | 654 |         if not mine:
12741 | 655 |             return await ctx.error(
12742 | 656 |                 f"`{sum(1 for i in channels)} channels` have read messages enabled. But unfortunately I don't permission to edit any of them."
12743 | 657 |             )
12744 | 658 | 
12745 | 659 |         prompt = await ctx.prompt(
12746 | 660 |             f"`{sum(1 for i in channels)} channels` have read messages enabled for **{role}**,\nI have permissions to modify `{mine} channels`.",
12747 | 661 |             title="Do you want me to continue?",
12748 | 662 |         )
12749 | 663 |         if not prompt:
12750 | 664 |             return await ctx.success(f"Alright, aborting.")
12751 | 665 | 
12752 | 666 |         await ctx.send(f"Kindly wait.. {emote.loading}", delete_after=3)
12753 | 667 | 
12754 | 668 |         success, failed = [], 0
12755 | 669 |         reason = f"Action done by -> {str(ctx.author)} ({ctx.author.id})"
12756 | 670 |         for channel in channels:
12757 | 671 |             overwrite = channel.overwrites_for(role)
12758 | 672 |             overwrite.read_messages = False
12759 | 673 | 
12760 | 674 |             try:
12761 | 675 |                 await channel.set_permissions(role, overwrite=overwrite, reason=reason)
12762 | 676 |                 success.append(channel.id)
12763 | 677 |             except:
12764 | 678 |                 failed += 1
12765 | 679 |                 continue
12766 | 680 | 
12767 | 681 |         await ctx.success(f"Updated settings for `{len(success)} channels`.(`{failed}` failed)")
12768 | 682 |         if success:
12769 | 683 |             await Lockdown.create(
12770 | 684 |                 guild_id=ctx.guild.id,
12771 | 685 |                 type=LockType.maintenance,
12772 | 686 |                 channel_id=ctx.channel.id,
12773 | 687 |                 author_id=ctx.author.id,
12774 | 688 |                 role_id=role.id,
12775 | 689 |                 channel_ids=success,
12776 | 690 |             )
12777 | 691 | 
12778 | 692 |         prompt = await ctx.prompt(f"Do you want me to make maintenance channels?")
12779 | 693 | 
12780 | 694 |         if prompt:
12781 | 695 |             overwrites = {
12782 | 696 |                 role: discord.PermissionOverwrite(read_messages=True, send_messages=True, read_message_history=True),
12783 | 697 |                 ctx.guild.me: discord.PermissionOverwrite(
12784 | 698 |                     read_messages=True, send_messages=True, read_message_history=True
12785 | 699 |                 ),
12786 | 700 |             }
12787 | 701 |             await ctx.guild.create_text_channel("maintenance-chat", overwrites=overwrites, reason=reason)
12788 | 702 |             await ctx.guild.create_voice_channel("maintenance-vc", overwrites=overwrites, reason=reason)
12789 | 703 |             await ctx.success(f"Done")
12790 | 704 | 
12791 | 705 |         else:
12792 | 706 |             await ctx.success(f"Ok! Aborting")
12793 | 707 | 
12794 | 708 |     @maintenance.command(name="off")
12795 | 709 |     @commands.bot_has_guild_permissions(manage_channels=True)
12796 | 710 |     @commands.has_permissions(administrator=True)
12797 | 711 |     async def maintenance_off(self, ctx: Context, *, role: discord.Role = None):
12798 | 712 |         """
12799 | 713 |         Turn OFF maintenance mode.
12800 | 714 |         If you turned ON maintenance mode for a specific role , you need to mention it here too.
12801 | 715 |         """
12802 | 716 |         role = role or ctx.guild.default_role
12803 | 717 | 
12804 | 718 |         check = await Lockdown.filter(type=LockType.maintenance, guild_id=ctx.guild.id, role_id=role.id).first()
12805 | 719 |         if not check:
12806 | 720 |             return await ctx.error(f"The server not under maintenance for **{role}**")
12807 | 721 | 
12808 | 722 |         success = 0
12809 | 723 |         for channel in check.channels:
12810 | 724 |             if channel is not None and channel.permissions_for(channel.guild.me).manage_channels:
12811 | 725 |                 perms = channel.overwrites_for(role)
12812 | 726 |                 perms.read_messages = True
12813 | 727 |                 await channel.set_permissions(role, overwrite=perms, reason="Lockdown timer complete!")
12814 | 728 |                 success += 1
12815 | 729 | 
12816 | 730 |         await ctx.success(
12817 | 731 |             f"Successfully changed settings for `{success}` channels. (`{sum(1 for i in check.channels)}` were hidden.)"
12818 | 732 |         )
12819 | 733 | 
12820 | 734 |         await Lockdown.filter(type=LockType.maintenance, guild_id=ctx.guild.id, role_id=role.id).delete()
12821 | 735 | 
12822 | 736 |         tc = discord.utils.get(ctx.guild.channels, name="maintenance-chat")
12823 | 737 |         vc = discord.utils.get(ctx.guild.channels, name="maintenance-vc")
12824 | 738 | 
12825 | 739 |         if tc and vc:
12826 | 740 |             prompt = await ctx.prompt(message=f"Do you want me to delete maintenance channels?")
12827 | 741 |             if prompt:
12828 | 742 |                 await tc.delete()
12829 | 743 |                 await vc.delete()
12830 | 744 |                 await ctx.success(f"Success")
12831 | 745 |             else:
12832 | 746 |                 await ctx.success(f"OK!")
12833 | 747 | 
12834 | 748 | 
12835 | 749 | async def setup(bot: Quotient) -> None:
12836 | 750 |     await bot.add_cog(Mod(bot))
12837 | 751 |     await bot.add_cog(LockEvents(bot))
12838 | 752 |     await bot.add_cog(RoleEvents(bot))
12839 | 753 | 
12840 | 
12841 | 
12842 | --------------------------------------------------------------------------------
12843 | /cogs/mod/events/__init__.py:
12844 | --------------------------------------------------------------------------------
12845 | 1 | from .lockdown import LockEvents
12846 | 2 | from .roles import RoleEvents
12847 | 3 | 
12848 | 
12849 | 
12850 | --------------------------------------------------------------------------------
12851 | /cogs/mod/events/lockdown.py:
12852 | --------------------------------------------------------------------------------
12853 |  1 | from __future__ import annotations
12854 |  2 | 
12855 |  3 | import typing
12856 |  4 | 
12857 |  5 | if typing.TYPE_CHECKING:
12858 |  6 |     from core import Quotient
12859 |  7 | 
12860 |  8 | from constants import LockType
12861 |  9 | from core import Cog
12862 | 10 | from models import Lockdown, Timer
12863 | 11 | 
12864 | 12 | 
12865 | 13 | class LockEvents(Cog):
12866 | 14 |     def __init__(self, bot: Quotient):
12867 | 15 |         self.bot = bot
12868 | 16 | 
12869 | 17 |     @Cog.listener()
12870 | 18 |     async def on_lockdown_timer_complete(self, timer: Timer):
12871 | 19 |         _type = timer.kwargs["_type"]
12872 | 20 | 
12873 | 21 |         if _type == LockType.channel.value:
12874 | 22 |             channel_id = timer.kwargs["channel_id"]
12875 | 23 | 
12876 | 24 |             check = await Lockdown.get_or_none(channel_id=channel_id, type=LockType.channel)
12877 | 25 |             if not check or check.expire_time != timer.expires:
12878 | 26 |                 return
12879 | 27 | 
12880 | 28 |             channel = self.bot.get_channel(channel_id)
12881 | 29 |             if not channel or not channel.permissions_for(channel.guild.me).manage_channels:
12882 | 30 |                 return
12883 | 31 | 
12884 | 32 |             perms = channel.overwrites_for(channel.guild.default_role)
12885 | 33 |             perms.send_messages = True
12886 | 34 |             await channel.set_permissions(channel.guild.default_role, overwrite=perms, reason="Lockdown timer complete!")
12887 | 35 |             await Lockdown.filter(channel_id=channel.id).delete()
12888 | 36 |             await channel.send(f"Unlocked **{channel}**")
12889 | 37 | 
12890 | 38 |         elif _type == LockType.guild.value:
12891 | 39 |             guild_id = timer.kwargs["guild_id"]
12892 | 40 | 
12893 | 41 |             check = await Lockdown.get_or_none(guild_id=guild_id, type=LockType.guild)
12894 | 42 |             if not check or check.expire_time != timer.expires:
12895 | 43 |                 return
12896 | 44 | 
12897 | 45 |             for channel in check.channels:
12898 | 46 |                 if channel is not None and channel.permissions_for(channel.guild.me).manage_channels:
12899 | 47 |                     perms = channel.overwrites_for(channel.guild.default_role)
12900 | 48 |                     perms.send_messages = True
12901 | 49 |                     await channel.set_permissions(
12902 | 50 |                         channel.guild.default_role,
12903 | 51 |                         overwrite=perms,
12904 | 52 |                         reason="Lockdown timer complete!",
12905 | 53 |                     )
12906 | 54 |             await Lockdown.filter(guild_id=guild_id, type=LockType.guild).delete()
12907 | 55 |             channel = self.bot.get_channel(check.channel_id)
12908 | 56 |             if channel is not None and channel.permissions_for(channel.guild.me).send_messages:
12909 | 57 |                 await channel.send(f"Unlocked **server**.")
12910 | 58 | 
12911 | 
12912 | 
12913 | --------------------------------------------------------------------------------
12914 | /cogs/mod/events/roles.py:
12915 | --------------------------------------------------------------------------------
12916 |  1 | from __future__ import annotations
12917 |  2 | 
12918 |  3 | import typing
12919 |  4 | 
12920 |  5 | if typing.TYPE_CHECKING:
12921 |  6 |     from core import Quotient
12922 |  7 | 
12923 |  8 | from core import Cog
12924 |  9 | 
12925 | 10 | 
12926 | 11 | class RoleEvents(Cog):
12927 | 12 |     def __init__(self, bot: Quotient):
12928 | 13 |         self.bot = bot
12929 | 14 | 
12930 | 
12931 | 
12932 | --------------------------------------------------------------------------------
12933 | /cogs/mod/utils.py:
12934 | --------------------------------------------------------------------------------
12935 |  1 | from collections import Counter
12936 |  2 | 
12937 |  3 | import discord
12938 |  4 | 
12939 |  5 | from core import Context
12940 |  6 | 
12941 |  7 | 
12942 |  8 | async def _self_clean_system(ctx: Context, search: int) -> dict:
12943 |  9 |     count = 0
12944 | 10 |     async for msg in ctx.history(limit=search, before=ctx.message):
12945 | 11 |         if msg.author == ctx.me:
12946 | 12 |             await msg.delete()
12947 | 13 |             count += 1
12948 | 14 |     return {"Bot": count}
12949 | 15 | 
12950 | 16 | 
12951 | 17 | async def _complex_cleanup_strategy(ctx: Context, search) -> Counter:
12952 | 18 |     def check(m: discord.Message):
12953 | 19 |         return m.author == ctx.me or m.content.startswith(ctx.prefix)
12954 | 20 | 
12955 | 21 |     deleted = await ctx.channel.purge(limit=search, check=check, before=ctx.message)
12956 | 22 |     return Counter(m.author.display_name for m in deleted)
12957 | 23 | 
12958 | 24 | 
12959 | 25 | async def do_removal(ctx: Context, limit, predicate, *, before=None, after=None):
12960 | 26 |     if limit > 2000:
12961 | 27 |         return await ctx.error(f"Too many messages to search given ({limit}/2000)")
12962 | 28 | 
12963 | 29 |     if before is None:
12964 | 30 |         before = ctx.message
12965 | 31 |     else:
12966 | 32 |         before = discord.Object(id=before)
12967 | 33 | 
12968 | 34 |     if after is not None:
12969 | 35 |         after = discord.Object(id=after)
12970 | 36 | 
12971 | 37 |     try:
12972 | 38 |         deleted = await ctx.channel.purge(limit=limit, before=before, after=after, check=predicate)
12973 | 39 |     except discord.Forbidden as e:
12974 | 40 |         return await ctx.error("I do not have permissions to delete messages.")
12975 | 41 |     except discord.HTTPException as e:
12976 | 42 |         return await ctx.error(f"Error: {e} (try a smaller search?)")
12977 | 43 | 
12978 | 44 |     spammers = Counter(m.author.display_name for m in deleted)
12979 | 45 |     deleted = len(deleted)
12980 | 46 |     messages = [f'{deleted} message{" was" if deleted == 1 else "s were"} removed.']
12981 | 47 |     if deleted:
12982 | 48 |         messages.append("")
12983 | 49 |         spammers = sorted(spammers.items(), key=lambda t: t[1], reverse=True)
12984 | 50 |         messages.extend(f"**{name}**: {count}" for name, count in spammers)
12985 | 51 | 
12986 | 52 |     to_send = "\n".join(messages)
12987 | 53 | 
12988 | 54 |     if len(to_send) > 2000:
12989 | 55 |         await ctx.send(f"Successfully removed {deleted} messages.", delete_after=10)
12990 | 56 |     else:
12991 | 57 |         await ctx.send(to_send, delete_after=10)
12992 | 58 | 
12993 | 
12994 | 
12995 | --------------------------------------------------------------------------------
12996 | /cogs/mod/views/__init__.py:
12997 | --------------------------------------------------------------------------------
12998 | 1 | from .role import *  # noqa: F401, F403
12999 | 2 | 
13000 | 
13001 | 
13002 | --------------------------------------------------------------------------------
13003 | /cogs/mod/views/role.py:
13004 | --------------------------------------------------------------------------------
13005 |  1 | from __future__ import annotations
13006 |  2 | 
13007 |  3 | import typing
13008 |  4 | 
13009 |  5 | if typing.TYPE_CHECKING:
13010 |  6 |     from core import Quotient
13011 |  7 | 
13012 |  8 | from contextlib import suppress
13013 |  9 | 
13014 | 10 | import discord
13015 | 11 | 
13016 | 12 | from core import Context
13017 | 13 | from utils import emote
13018 | 14 | 
13019 | 15 | 
13020 | 16 | class RoleRevertButton(discord.ui.Button):
13021 | 17 |     def __init__(self, ctx: Context, *, role: discord.Role, members: typing.List[discord.Member], take_role=True):
13022 | 18 |         super().__init__()
13023 | 19 | 
13024 | 20 |         self.emoji = emote.exit
13025 | 21 |         self.label = "Take Back" if take_role else "Give Back"
13026 | 22 |         self.custom_id = "role_revert_action_button"
13027 | 23 | 
13028 | 24 |         self.ctx = ctx
13029 | 25 |         self.role = role
13030 | 26 |         self.members = members
13031 | 27 |         self.take_role = take_role
13032 | 28 | 
13033 | 29 |     async def callback(self, interaction: discord.Interaction):
13034 | 30 |         await interaction.response.defer()
13035 | 31 |         await self.view.on_timeout()
13036 | 32 | 
13037 | 33 |         for _ in self.members:
13038 | 34 |             with suppress(discord.HTTPException):
13039 | 35 |                 await _.remove_roles(self.role) if self.take_role else await _.add_roles(self.role)
13040 | 36 | 
13041 | 37 |         return await self.ctx.success("Succesfully reverted the action.")
13042 | 38 | 
13043 | 39 | 
13044 | 40 | class RoleCancelButton(discord.ui.Button):
13045 | 41 |     def __init__(self, ctx: Context, *, role: discord.Role, members: typing.List[discord.Member]):
13046 | 42 |         super().__init__()
13047 | 43 |         self.ctx = ctx
13048 | 44 |         self.role = role
13049 | 45 |         self.members = members
13050 | 46 | 
13051 | 
13052 | 
13053 | --------------------------------------------------------------------------------
13054 | /cogs/premium/__init__.py:
13055 | --------------------------------------------------------------------------------
13056 |   1 | from __future__ import annotations
13057 |   2 | 
13058 |   3 | import asyncio
13059 |   4 | import typing
13060 |   5 | 
13061 |   6 | if typing.TYPE_CHECKING:
13062 |   7 |     from core import Quotient
13063 |   8 | 
13064 |   9 | from contextlib import suppress
13065 |  10 | from datetime import datetime, timedelta
13066 |  11 | 
13067 |  12 | import discord
13068 |  13 | from discord.ext import commands, tasks
13069 |  14 | from tortoise.expressions import Q
13070 |  15 | 
13071 |  16 | import config
13072 |  17 | from constants import random_greeting, random_thanks
13073 |  18 | from core import Cog, Context
13074 |  19 | from models import Guild, PremiumTxn, Timer, User
13075 |  20 | from utils import IST, discord_timestamp, emote, strtime
13076 |  21 | 
13077 |  22 | from .expire import deactivate_premium, extra_guild_perks, remind_guild_to_pay, remind_user_to_pay
13078 |  23 | from .views import PremiumPurchaseBtn, PremiumView
13079 |  24 | 
13080 |  25 | 
13081 |  26 | class PremiumCog(Cog, name="Premium"):
13082 |  27 |     def __init__(self, bot: Quotient):
13083 |  28 |         self.bot = bot
13084 |  29 |         self.remind_peeps_to_pay.start()
13085 |  30 |         self.hook = discord.Webhook.from_url(self.bot.config.PUBLIC_LOG, session=self.bot.session)
13086 |  31 | 
13087 |  32 |     @commands.command()
13088 |  33 |     @commands.bot_has_permissions(embed_links=True)
13089 |  34 |     async def pstatus(self, ctx: Context):
13090 |  35 |         """Get your Quotient Premium status and the current server's."""
13091 |  36 |         user = await User.get_or_none(user_id=ctx.author.id)
13092 |  37 |         guild = await Guild.filter(guild_id=ctx.guild.id).first()
13093 |  38 | 
13094 |  39 |         if not user.is_premium:
13095 |  40 |             atext = "\n> Activated: No!"
13096 |  41 | 
13097 |  42 |         else:
13098 |  43 |             atext = f"\n> Activated: Yes!\n> Ending: {discord_timestamp(user.premium_expire_time,'f')}"
13099 |  44 | 
13100 |  45 |         if not guild.is_premium:
13101 |  46 |             btext = "\n> Activated: No!"
13102 |  47 | 
13103 |  48 |         else:
13104 |  49 |             booster = guild.booster or await self.bot.fetch_user(guild.made_premium_by)
13105 |  50 |             btext = f"\n> Activated: Yes!\n> Ending: {discord_timestamp(guild.premium_end_time,'f')}\n> Upgraded by: **{booster}**"
13106 |  51 | 
13107 |  52 |         embed = self.bot.embed(ctx, title="Quotient Premium", url=f"{self.bot.config.WEBSITE}")
13108 |  53 |         embed.add_field(name="User", value=atext, inline=False)
13109 |  54 |         embed.add_field(name="Server", value=btext, inline=False)
13110 |  55 |         embed.set_thumbnail(url=ctx.guild.me.display_avatar.url)
13111 |  56 |         return await ctx.send(embed=embed)
13112 |  57 | 
13113 |  58 |     @commands.hybrid_command(aliases=("perks", "pro"))
13114 |  59 |     async def premium(self, ctx: Context):
13115 |  60 |         """Checkout Quotient Premium Plans."""
13116 |  61 |         _e = discord.Embed(
13117 |  62 |             color=self.bot.color,
13118 |  63 |             description=f"[**Features of Quotient Pro -**]({self.bot.config.SERVER_LINK})\n\n"
13119 |  64 |             f"{emote.check} Access to `Quotient Pro` bot.\n"
13120 |  65 |             f"{emote.check} Unlimited Scrims.\n"
13121 |  66 |             f"{emote.check} Unlimited Tournaments.\n"
13122 |  67 |             f"{emote.check} Custom Reactions for Regs.\n"
13123 |  68 |             f"{emote.check} Smart SSverification.\n"
13124 |  69 |             f"{emote.check} Cancel-Claim Panel.\n"
13125 |  70 |             f"{emote.check} Premium Role + more...\n",
13126 |  71 |         )
13127 |  72 | 
13128 |  73 |         v = discord.ui.View(timeout=None)
13129 |  74 |         v.add_item(PremiumPurchaseBtn())
13130 |  75 |         await ctx.send(embed=_e, view=v)
13131 |  76 | 
13132 |  77 |     @tasks.loop(hours=48)
13133 |  78 |     async def remind_peeps_to_pay(self):
13134 |  79 |         await self.bot.wait_until_ready()
13135 |  80 | 
13136 |  81 |         await asyncio.sleep(900)
13137 |  82 |         async for user in User.filter(is_premium=True, premium_expire_time__lte=datetime.now(tz=IST) + timedelta(days=4)):
13138 |  83 |             _u = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, user.pk)
13139 |  84 |             if _u:
13140 |  85 |                 if not await self.ensure_reminders(user.pk, user.premium_expire_time):
13141 |  86 |                     await self.bot.reminders.create_timer(user.premium_expire_time, "user_premium", user_id=user.pk)
13142 |  87 | 
13143 |  88 |                 await remind_user_to_pay(_u, user)
13144 |  89 | 
13145 |  90 |         async for guild in Guild.filter(is_premium=True, premium_end_time__lte=datetime.now(IST) + timedelta(days=4)):
13146 |  91 |             _g = self.bot.get_guild(guild.pk)
13147 |  92 | 
13148 |  93 |             if not await self.ensure_reminders(guild.pk, guild.premium_end_time):
13149 |  94 |                 await self.bot.reminders.create_timer(guild.premium_end_time, "guild_premium", guild_id=guild.pk)
13150 |  95 | 
13151 |  96 |             if _g:
13152 |  97 |                 await remind_guild_to_pay(_g, guild)
13153 |  98 | 
13154 |  99 |     async def ensure_reminders(self, _id: int, _time: datetime) -> bool:
13155 | 100 |         return await Timer.filter(
13156 | 101 |             Q(event="guild_premium", extra={"args": [], "kwargs": {"guild_id": _id}})
13157 | 102 |             | Q(event="user_premium", extra={"args": [], "kwargs": {"user_id": _id}}),
13158 | 103 |             expires=_time,
13159 | 104 |         ).exists()
13160 | 105 | 
13161 | 106 |     def cog_unload(self):
13162 | 107 |         self.remind_peeps_to_pay.stop()
13163 | 108 | 
13164 | 109 |     @Cog.listener()
13165 | 110 |     async def on_guild_premium_timer_complete(self, timer: Timer):
13166 | 111 |         guild_id = timer.kwargs["guild_id"]
13167 | 112 | 
13168 | 113 |         _g = await Guild.get_or_none(pk=guild_id)
13169 | 114 |         if not _g:
13170 | 115 |             return
13171 | 116 | 
13172 | 117 |         if not _g.premium_end_time == timer.expires:
13173 | 118 |             return
13174 | 119 | 
13175 | 120 |         _perks = "\n".join(await extra_guild_perks(guild_id))
13176 | 121 | 
13177 | 122 |         await deactivate_premium(guild_id)
13178 | 123 | 
13179 | 124 |         if (_ch := _g.private_ch) and _ch.permissions_for(_ch.guild.me).embed_links:
13180 | 125 |             _e = discord.Embed(
13181 | 126 |                 color=discord.Color.red(), title="⚠️__**Quotient Pro Subscription Ended**__⚠️", url=config.SERVER_LINK
13182 | 127 |             )
13183 | 128 |             _e.description = (
13184 | 129 |                 "This is to inform you that your subscription of Quotient Pro has been ended.\n\n"
13185 | 130 |                 "*Following is a list of perks or data you lost:*"
13186 | 131 |             )
13187 | 132 | 
13188 | 133 |             _e.description += f"```diff\n{_perks}```"
13189 | 134 | 
13190 | 135 |             _roles = [
13191 | 136 |                 role.mention
13192 | 137 |                 for role in _ch.guild.roles
13193 | 138 |                 if all((role.permissions.administrator, not role.managed, role.members))
13194 | 139 |             ]
13195 | 140 | 
13196 | 141 |             _view = PremiumView()
13197 | 142 |             await _ch.send(
13198 | 143 |                 embed=_e,
13199 | 144 |                 view=_view,
13200 | 145 |                 content=", ".join(_roles[:2]) if _roles else _ch.guild.owner.mention,
13201 | 146 |                 allowed_mentions=discord.AllowedMentions(roles=True),
13202 | 147 |             )
13203 | 148 | 
13204 | 149 |     @Cog.listener()
13205 | 150 |     async def on_user_premium_timer_complete(self, timer: Timer):
13206 | 151 |         user_id = timer.kwargs["user_id"]
13207 | 152 |         _user = await User.get(pk=user_id)
13208 | 153 | 
13209 | 154 |         if not _user.premium_expire_time == timer.expires:
13210 | 155 |             return
13211 | 156 | 
13212 | 157 |         _q = "UPDATE user_data SET is_premium = FALSE ,premiums=0 ,made_premium = '{}' WHERE user_id = $1"
13213 | 158 |         await self.bot.db.execute(_q, user_id)
13214 | 159 | 
13215 | 160 |         member = await self.bot.get_or_fetch_member(self.bot.server, _user.pk)
13216 | 161 |         if member:
13217 | 162 |             await member.remove_roles(discord.Object(id=config.PREMIUM_ROLE))
13218 | 163 | 
13219 | 164 |     @Cog.listener()
13220 | 165 |     async def on_premium_purchase(self, txnId: str):
13221 | 166 |         record = await PremiumTxn.get(txnid=txnId)
13222 | 167 | 
13223 | 168 |         member = self.bot.server.get_member(record.user_id)
13224 | 169 |         if member is not None:
13225 | 170 |             await member.add_roles(discord.Object(id=self.bot.config.PREMIUM_ROLE), reason="They purchased premium.")
13226 | 171 | 
13227 | 172 |         else:
13228 | 173 |             member = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, record.user_id)
13229 | 174 | 
13230 | 175 |         with suppress(discord.HTTPException, AttributeError):
13231 | 176 |             _e = discord.Embed(
13232 | 177 |                 color=discord.Color.gold(), description=f"Thanks **{member}** for purchasing Quotient Premium."
13233 | 178 |             )
13234 | 179 |             _e.set_image(url=random_thanks())
13235 | 180 |             await self.hook.send(embed=_e, username="premium-logs", avatar_url=self.bot.config.PREMIUM_AVATAR)
13236 | 181 | 
13237 | 182 |         upgraded_guild = self.bot.get_guild(record.guild_id)
13238 | 183 |         _guild = await Guild.get_or_none(pk=record.guild_id)
13239 | 184 | 
13240 | 185 |         _e = discord.Embed(
13241 | 186 |             color=self.bot.color,
13242 | 187 |             title="Quotient Pro Purchase Successful!",
13243 | 188 |             url=self.bot.config.SERVER_LINK,
13244 | 189 |             description=(
13245 | 190 |                 f"{random_greeting()} {member.mention},\n"
13246 | 191 |                 f"Thanks for purchasing Quotient Premium. Your server **{upgraded_guild}** has access to Quotient Pro features until `{_guild.premium_end_time.strftime('%d-%b-%Y %I:%M %p')}`.\n\n"
13247 | 192 |                 "[Click me to Invite Quotient Pro Bot to your server](https://discord.com/oauth2/authorize?client_id=902856923311919104&scope=applications.commands%20bot&permissions=21175985838)\n"
13248 | 193 |             ),
13249 | 194 |         )
13250 | 195 | 
13251 | 196 |         if member not in self.bot.server.members:
13252 | 197 |             _e.description += f"\n\n[To claim your Premium Role, Join Quotient HQ]({self.bot.config.SERVER_LINK})."
13253 | 198 | 
13254 | 199 |         _view = discord.ui.View(timeout=None)
13255 | 200 | 
13256 | 201 |         try:
13257 | 202 |             await member.send(embed=_e, view=_view)
13258 | 203 |         except discord.HTTPException:
13259 | 204 |             pass
13260 | 205 | 
13261 | 206 | 
13262 | 207 | async def setup(bot: Quotient) -> None:
13263 | 208 |     await bot.add_cog(PremiumCog(bot))
13264 | 209 | 
13265 | 
13266 | 
13267 | --------------------------------------------------------------------------------
13268 | /cogs/premium/expire.py:
13269 | --------------------------------------------------------------------------------
13270 |   1 | from __future__ import annotations
13271 |   2 | 
13272 |   3 | import typing
13273 |   4 | from contextlib import suppress
13274 |   5 | 
13275 |   6 | import discord
13276 |   7 | 
13277 |   8 | import config
13278 |   9 | from models import EasyTag, Guild, Scrim, ScrimsSlotManager, SSVerify, TagCheck, Tourney, User
13279 |  10 | from utils import discord_timestamp, plural
13280 |  11 | 
13281 |  12 | from .views import PremiumView
13282 |  13 | 
13283 |  14 | 
13284 |  15 | async def deactivate_premium(guild_id: int):
13285 |  16 |     await Guild.filter(guild_id=guild_id).update(embed_color=config.COLOR, embed_footer=config.FOOTER, is_premium=False)
13286 |  17 | 
13287 |  18 |     _s: typing.List[Scrim] = (await Scrim.filter(guild_id=guild_id).order_by("id"))[3:]
13288 |  19 |     await Scrim.filter(id__in=(s.pk for s in _s)).delete()
13289 |  20 | 
13290 |  21 |     _t: typing.List[Tourney] = (await Tourney.filter(guild_id=guild_id).order_by("id"))[1:]
13291 |  22 |     await Tourney.filter(id__in=(t.pk for t in _t)).delete()
13292 |  23 | 
13293 |  24 |     _tc: typing.List[TagCheck] = (await TagCheck.filter(guild_id=guild_id).order_by("id"))[1:]
13294 |  25 |     await TagCheck.filter(id__in=(t.pk for t in _tc)).delete()
13295 |  26 | 
13296 |  27 |     _ez: typing.List[EasyTag] = (await EasyTag.filter(guild_id=guild_id).order_by("id"))[1:]
13297 |  28 |     await EasyTag.filter(id__in=(e.pk for e in _ez)).delete()
13298 |  29 | 
13299 |  30 |     await Tourney.filter(guild_id=guild_id).update(emojis={})
13300 |  31 | 
13301 |  32 |     ssverify = await SSVerify.filter(guild_id=guild_id)
13302 |  33 |     for _ in ssverify:
13303 |  34 |         await _.full_delete()
13304 |  35 | 
13305 |  36 |     _slotm = (await ScrimsSlotManager.filter(guild_id=guild_id).order_by("id"))[1:]
13306 |  37 |     for _ in _slotm:
13307 |  38 |         await _.full_delete()
13308 |  39 | 
13309 |  40 |     return
13310 |  41 | 
13311 |  42 | 
13312 |  43 | async def extra_guild_perks(guild_id: int):
13313 |  44 |     _list = [
13314 |  45 |         "- Can't use Quotient Pro bot.",
13315 |  46 |         "- Tourney reactions emojis will be changed to default.",
13316 |  47 |         "- No more than 1 Media Partner Channel per tourney.",
13317 |  48 |     ]
13318 |  49 | 
13319 |  50 |     if (_s := await Scrim.filter(guild_id=guild_id).order_by("id"))[3:]:
13320 |  51 |         _list.append(f"- {plural(len(_s)):scrim|scrims} will be deleted. (ID: {', '.join((str(s.pk) for s in _s))})")
13321 |  52 | 
13322 |  53 |     if (_t := await Tourney.filter(guild_id=guild_id).order_by("id"))[1:]:
13323 |  54 |         _list.append(f"- {plural(len(_t)):tourney|tourneys} will be deleted. (ID: {', '.join(str(t.pk) for t in _t)})")
13324 |  55 | 
13325 |  56 |     if (_tc := await TagCheck.filter(guild_id=guild_id).order_by("id"))[1:]:
13326 |  57 |         _list.append(
13327 |  58 |             f"- {len(_tc)} tagcheck setup will be removed. (Channels: {', '.join((str(ch.channel) for ch in _tc))})"
13328 |  59 |         )
13329 |  60 | 
13330 |  61 |     if (_ez := await EasyTag.filter(guild_id=guild_id).order_by("id"))[1:]:
13331 |  62 |         _list.append(
13332 |  63 |             f"- {len(_ez)} easytag setup will be removed. (Channels: {', '.join((str(ch.channel) for ch in _ez))})"
13333 |  64 |         )
13334 |  65 | 
13335 |  66 |     if (_slotm := await ScrimsSlotManager.filter(guild_id=guild_id).order_by("id"))[1:]:
13336 |  67 |         _list.append(
13337 |  68 |             f"- {len(_slotm)} scrims slot manager setup will be removed. (Channels: {', '.join((str(ch.main_channel) for ch in _slotm))})"
13338 |  69 |         )
13339 |  70 | 
13340 |  71 |     if _ss := await SSVerify.filter(guild_id=guild_id).order_by("id"):
13341 |  72 |         _list.append(
13342 |  73 |             f"- {len(_ss)} SSVerify setup will be removed. (Channels: {', '.join((str(ch.channel) for ch in _ss))})"
13343 |  74 |         )
13344 |  75 | 
13345 |  76 |     return _list
13346 |  77 | 
13347 |  78 | 
13348 |  79 | async def remind_guild_to_pay(guild: discord.Guild, model: Guild):
13349 |  80 |     if (_ch := model.private_ch) and _ch.permissions_for(_ch.guild.me).embed_links:
13350 |  81 |         _e = discord.Embed(
13351 |  82 |             color=discord.Color.red(),
13352 |  83 |             title="⚠️__**Quotient Pro Ending Soon**__⚠️",
13353 |  84 |             url=config.SERVER_LINK,
13354 |  85 |         )
13355 |  86 | 
13356 |  87 |         _e.description = (
13357 |  88 |             f"This is to inform you that your subscription of **Quotient Pro** is ending soon "
13358 |  89 |             f"({discord_timestamp(model.premium_end_time,'D')})"
13359 |  90 |             "\n\n*Kindly renew your subscription to continue using Quotient Premium features.*"
13360 |  91 |         )
13361 |  92 | 
13362 |  93 |         _roles = [
13363 |  94 |             role.mention for role in guild.roles if all((role.permissions.administrator, not role.managed, role.members))
13364 |  95 |         ]
13365 |  96 | 
13366 |  97 |         _view = PremiumView(label="Renew Quotient Pro")
13367 |  98 |         await _ch.send(
13368 |  99 |             embed=_e,
13369 | 100 |             view=_view,
13370 | 101 |             content=", ".join(_roles[:2]) if _roles else getattr(guild.owner, "mention", ""),
13371 | 102 |             allowed_mentions=discord.AllowedMentions(roles=True),
13372 | 103 |         )
13373 | 104 | 
13374 | 105 | 
13375 | 106 | async def remind_user_to_pay(user: discord.User, model: User):
13376 | 107 |     _e = discord.Embed(color=discord.Color.red(), title="⚠️__**IMPORTANT**__⚠️")
13377 | 108 |     _e.description = (
13378 | 109 |         f"This is to remind you that your subscription of **Quotient Pro** is ending {discord_timestamp(model.premium_expire_time)}"
13379 | 110 |         f"\n[*Click Me To Continue Enjoying Quotient Pro*](https://quotientbot.xyz/premium)"
13380 | 111 |     )
13381 | 112 |     with suppress(discord.HTTPException):
13382 | 113 |         await user.send(embed=_e)
13383 | 114 | 
13384 | 
13385 | 
13386 | --------------------------------------------------------------------------------
13387 | /cogs/premium/views.py:
13388 | --------------------------------------------------------------------------------
13389 |  1 | from typing import List
13390 |  2 | 
13391 |  3 | import discord
13392 |  4 | 
13393 |  5 | import config
13394 |  6 | from models import PremiumPlan, PremiumTxn
13395 |  7 | from utils import emote
13396 |  8 | 
13397 |  9 | 
13398 | 10 | class PlanSelector(discord.ui.Select):
13399 | 11 |     def __init__(self, plans: List[PremiumPlan]):
13400 | 12 |         super().__init__(placeholder="Select a Quotient Premium Plan... ")
13401 | 13 | 
13402 | 14 |         for _ in plans:
13403 | 15 |             self.add_option(label=f"{_.name} - ₹{_.price}", description=_.description, value=_.id)
13404 | 16 | 
13405 | 17 |     async def callback(self, interaction: discord.Interaction):
13406 | 18 |         await interaction.response.defer()
13407 | 19 |         self.view.plan = self.values[0]
13408 | 20 |         self.view.stop()
13409 | 21 | 
13410 | 22 | 
13411 | 23 | class PremiumPurchaseBtn(discord.ui.Button):
13412 | 24 |     def __init__(self, label="Get Quotient Pro", emoji=emote.diamond, style=discord.ButtonStyle.grey):
13413 | 25 |         super().__init__(style=style, label=label, emoji=emoji)
13414 | 26 | 
13415 | 27 |     async def callback(self, interaction: discord.Interaction):
13416 | 28 |         await interaction.response.defer()
13417 | 29 |         v = discord.ui.View(timeout=100)
13418 | 30 |         v.plan: str = None
13419 | 31 | 
13420 | 32 |         v.add_item(PlanSelector(await PremiumPlan.all().order_by("id")))
13421 | 33 |         await interaction.followup.send("Please select the Quotient Pro plan, you want to opt:", view=v, ephemeral=True)
13422 | 34 |         await v.wait()
13423 | 35 | 
13424 | 36 |         if not v.plan:
13425 | 37 |             return
13426 | 38 | 
13427 | 39 |         txn = await PremiumTxn.create(
13428 | 40 |             txnid=await PremiumTxn.gen_txnid(),
13429 | 41 |             user_id=interaction.user.id,
13430 | 42 |             guild_id=interaction.guild.id,
13431 | 43 |             plan_id=v.plan,
13432 | 44 |         )
13433 | 45 |         _link = config.PAY_LINK + "getpremium" + "?txnId=" + txn.txnid
13434 | 46 | 
13435 | 47 |         await interaction.followup.send(
13436 | 48 |             f"You are about to purchase Quotient Premium for **{interaction.guild.name}**.\n"
13437 | 49 |             "If you want to purchase for another server, use `qpremium` or `/premium` command in that server.\n\n"
13438 | 50 |             f"[*Click Me to Complete the Payment*]({_link})",
13439 | 51 |             ephemeral=True,
13440 | 52 |         )
13441 | 53 | 
13442 | 54 | 
13443 | 55 | class PremiumView(discord.ui.View):
13444 | 56 |     def __init__(self, text="This feature requires Quotient Premium.", *, label="Get Quotient Pro"):
13445 | 57 |         super().__init__(timeout=None)
13446 | 58 |         self.text = text
13447 | 59 |         self.add_item(PremiumPurchaseBtn(label=label))
13448 | 60 | 
13449 | 61 |     @property
13450 | 62 |     def premium_embed(self) -> discord.Embed:
13451 | 63 |         _e = discord.Embed(
13452 | 64 |             color=0x00FFB3, description=f"**You discovered a premium feature <a:premium:807911675981201459>**"
13453 | 65 |         )
13454 | 66 |         _e.description = (
13455 | 67 |             f"\n*`{self.text}`*\n\n"
13456 | 68 |             "__Perks you get with Quotient Pro:__\n"
13457 | 69 |             f"{emote.check} Access to `Quotient Pro` bot.\n"
13458 | 70 |             f"{emote.check} Unlimited Scrims.\n"
13459 | 71 |             f"{emote.check} Unlimited Tournaments.\n"
13460 | 72 |             f"{emote.check} Custom Reactions for Regs.\n"
13461 | 73 |             f"{emote.check} Smart SSverification.\n"
13462 | 74 |             f"{emote.check} Cancel-Claim Panel.\n"
13463 | 75 |             f"{emote.check} Premium Role + more...\n"
13464 | 76 |         )
13465 | 77 |         return _e
13466 | 78 | 
13467 | 
13468 | 
13469 | --------------------------------------------------------------------------------
13470 | /cogs/quomisc/__init__.py:
13471 | --------------------------------------------------------------------------------
13472 |   1 | from __future__ import annotations
13473 |   2 | 
13474 |   3 | import typing
13475 |   4 | 
13476 |   5 | if typing.TYPE_CHECKING:
13477 |   6 |     from core import Quotient
13478 |   7 | 
13479 |   8 | import inspect
13480 |   9 | import itertools
13481 |  10 | import os
13482 |  11 | from collections import Counter
13483 |  12 | from datetime import datetime, timedelta, timezone
13484 |  13 | 
13485 |  14 | import discord
13486 |  15 | import pkg_resources
13487 |  16 | import psutil
13488 |  17 | import pygit2
13489 |  18 | from discord.ext import commands
13490 |  19 | 
13491 |  20 | from cogs.quomisc.helper import format_relative
13492 |  21 | from core import Cog, Context, QuotientView
13493 |  22 | from models import Commands, Guild, User, Votes
13494 |  23 | from utils import LinkButton, LinkType, QuoColor, checks, get_ipm, human_timedelta, truncate_string
13495 |  24 | 
13496 |  25 | from .alerts import *
13497 |  26 | from .dev import *
13498 |  27 | from .views import MoneyButton, SetupButtonView, VoteButton
13499 |  28 | 
13500 |  29 | 
13501 |  30 | class Quomisc(Cog, name="quomisc"):
13502 |  31 |     def __init__(self, bot: Quotient):
13503 |  32 |         self.bot = bot
13504 |  33 | 
13505 |  34 |     @commands.command(aliases=("src",))
13506 |  35 |     async def source(self, ctx: Context, *, search: typing.Optional[str]):
13507 |  36 |         """Refer to the source code of the bot commands."""
13508 |  37 |         source_url = "https://github.com/quotientbot/Quotient-Bot"
13509 |  38 | 
13510 |  39 |         if search is None:
13511 |  40 |             return await ctx.send(f"<{source_url}>")
13512 |  41 | 
13513 |  42 |         command = ctx.bot.get_command(search)
13514 |  43 | 
13515 |  44 |         if not command:
13516 |  45 |             return await ctx.send("Couldn't find that command.")
13517 |  46 | 
13518 |  47 |         src = command.callback.__code__
13519 |  48 |         filename = src.co_filename
13520 |  49 |         lines, firstlineno = inspect.getsourcelines(src)
13521 |  50 | 
13522 |  51 |         location = os.path.relpath(filename).replace("\\", "/")
13523 |  52 | 
13524 |  53 |         final_url = f"<{source_url}/blob/main/{location}#L{firstlineno}-L{firstlineno + len(lines) - 1}>"
13525 |  54 |         await ctx.send(final_url)
13526 |  55 | 
13527 |  56 |     @commands.command(aliases=("inv",))
13528 |  57 |     async def invite(self, ctx: Context):
13529 |  58 |         """Quotient Invite Links."""
13530 |  59 |         v = discord.ui.View(timeout=None)
13531 |  60 |         v.add_item(
13532 |  61 |             discord.ui.Button(
13533 |  62 |                 style=discord.ButtonStyle.link, label="Invite Quotient (Me)", url=self.bot.config.BOT_INVITE, row=1
13534 |  63 |             )
13535 |  64 |         )
13536 |  65 |         v.add_item(
13537 |  66 |             discord.ui.Button(
13538 |  67 |                 style=discord.ButtonStyle.link, label="Invite Quotient Pro", url=self.bot.config.PRO_LINK, row=2
13539 |  68 |             )
13540 |  69 |         )
13541 |  70 |         v.add_item(
13542 |  71 |             discord.ui.Button(
13543 |  72 |                 style=discord.ButtonStyle.link, label="Join Support Server", url=self.bot.config.SERVER_LINK, row=3
13544 |  73 |             )
13545 |  74 |         )
13546 |  75 | 
13547 |  76 |         await ctx.reply(view=v)
13548 |  77 | 
13549 |  78 |     async def make_private_channel(self, ctx: Context) -> discord.TextChannel:
13550 |  79 |         support_link = f"[Support Server]({ctx.config.SERVER_LINK})"
13551 |  80 |         invite_link = f"[Invite Me]({ctx.config.BOT_INVITE})"
13552 |  81 |         vote_link = f"[Vote]({ctx.config.WEBSITE}/vote)"
13553 |  82 |         source = f"[Source]({ctx.config.REPOSITORY})"
13554 |  83 | 
13555 |  84 |         guild = ctx.guild
13556 |  85 |         overwrites = {
13557 |  86 |             guild.default_role: discord.PermissionOverwrite(read_messages=False),
13558 |  87 |             guild.me: discord.PermissionOverwrite(
13559 |  88 |                 read_messages=True,
13560 |  89 |                 send_messages=True,
13561 |  90 |                 read_message_history=True,
13562 |  91 |                 embed_links=True,
13563 |  92 |                 attach_files=True,
13564 |  93 |                 manage_channels=True,
13565 |  94 |             ),
13566 |  95 |             ctx.author: discord.PermissionOverwrite(read_messages=True, send_messages=True, read_message_history=True),
13567 |  96 |         }
13568 |  97 |         channel = await guild.create_text_channel(
13569 |  98 |             "quotient-private", overwrites=overwrites, reason=f"Made by {str(ctx.author)}"
13570 |  99 |         )
13571 | 100 |         await Guild.filter(guild_id=ctx.guild.id).update(private_channel=channel.id)
13572 | 101 | 
13573 | 102 |         e = self.bot.embed(ctx)
13574 | 103 |         e.add_field(
13575 | 104 |             name="**What is this channel for?**",
13576 | 105 |             inline=False,
13577 | 106 |             value="This channel is made for Quotient to send important announcements and activities that need your attention. If anything goes wrong with any of my functionality I will notify you here. Important announcements from the developer will be sent directly here too.\n\nYou can test my commands in this channel if you like. Kindly don't delete it , some of my commands won't work without this channel.",
13578 | 107 |         )
13579 | 108 |         e.add_field(
13580 | 109 |             name="**__Important Links__**", value=f"{support_link} | {invite_link} | {vote_link} | {source}", inline=False
13581 | 110 |         )
13582 | 111 | 
13583 | 112 |         links = [LinkType("Support Server", ctx.config.SERVER_LINK)]
13584 | 113 |         view = LinkButton(links)
13585 | 114 |         m = await channel.send(embed=e, view=view)
13586 | 115 |         await m.pin()
13587 | 116 | 
13588 | 117 |         return channel
13589 | 118 | 
13590 | 119 |     @commands.command(name="setup")
13591 | 120 |     @commands.has_permissions(manage_guild=True)
13592 | 121 |     @commands.bot_has_guild_permissions(manage_channels=True, manage_webhooks=True)
13593 | 122 |     async def setup_cmd(self, ctx: Context):
13594 | 123 |         """
13595 | 124 |         Setup Quotient in the current server.
13596 | 125 |         This creates a private channel in the server. You can rename that if you like.
13597 | 126 |         Quotient requires manage channels and manage wehooks permissions for this to work.
13598 | 127 |         You must have manage server permission.
13599 | 128 |         """
13600 | 129 | 
13601 | 130 |         _view = SetupButtonView(ctx)
13602 | 131 |         _view.add_item(QuotientView.tricky_invite_button())
13603 | 132 |         record = await Guild.get(guild_id=ctx.guild.id)
13604 | 133 | 
13605 | 134 |         if record.private_ch is not None:
13606 | 135 |             return await ctx.error(f"You already have a private channel ({record.private_ch.mention})", view=_view)
13607 | 136 |         channel = await self.make_private_channel(ctx)
13608 | 137 |         await ctx.success(f"Created {channel.mention}", view=_view)
13609 | 138 | 
13610 | 139 |     def get_bot_uptime(self, *, brief=False):
13611 | 140 |         return human_timedelta(self.bot.start_time, accuracy=None, brief=brief, suffix=False)
13612 | 141 | 
13613 | 142 |     @staticmethod
13614 | 143 |     def format_commit(commit):  # source: R danny
13615 | 144 |         short, _, _ = commit.message.partition("\n")
13616 | 145 |         short_sha2 = commit.hex[0:6]
13617 | 146 |         commit_tz = timezone(timedelta(minutes=commit.commit_time_offset))
13618 | 147 |         commit_time = datetime.fromtimestamp(commit.commit_time).astimezone(commit_tz)
13619 | 148 | 
13620 | 149 |         # [`hash`](url) message (offset)
13621 | 150 |         offset = format_relative(commit_time.astimezone(timezone.utc))
13622 | 151 |         return f"[`{short_sha2}`](https://github.com/quotientbot/Quotient-Bot/commit/{commit.hex}) {truncate_string(short,40)} ({offset})"
13623 | 152 | 
13624 | 153 |     def get_last_commits(self, count=3):
13625 | 154 |         repo = pygit2.Repository(".git")
13626 | 155 |         commits = list(itertools.islice(repo.walk(repo.head.target, pygit2.GIT_SORT_TOPOLOGICAL), count))
13627 | 156 |         return "\n".join(self.format_commit(c) for c in commits)
13628 | 157 | 
13629 | 158 |     @commands.command(aliases=("stats",))
13630 | 159 |     @commands.cooldown(1, 10, commands.BucketType.guild)
13631 | 160 |     async def about(self, ctx: Context):
13632 | 161 |         """Statistics of Quotient."""
13633 | 162 |         db_latency = await self.bot.db_latency
13634 | 163 | 
13635 | 164 |         version = pkg_resources.get_distribution("discord.py").version
13636 | 165 |         revision = self.get_last_commits()
13637 | 166 | 
13638 | 167 |         total_memory = psutil.virtual_memory().total >> 20
13639 | 168 |         used_memory = psutil.virtual_memory().used >> 20
13640 | 169 |         cpu_used = str(psutil.cpu_percent())
13641 | 170 | 
13642 | 171 |         total_members = sum(g.member_count for g in self.bot.guilds)
13643 | 172 |         cached_members = len(self.bot.users)
13644 | 173 | 
13645 | 174 |         total_command_uses = await Commands.all().count()
13646 | 175 |         user_invokes = await Commands.filter(user_id=ctx.author.id, guild_id=ctx.guild.id).count() or 0
13647 | 176 |         server_invokes = await Commands.filter(guild_id=ctx.guild.id).count() or 0
13648 | 177 | 
13649 | 178 |         chnl_count = Counter(map(lambda ch: ch.type, self.bot.get_all_channels()))
13650 | 179 | 
13651 | 180 |         owner = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, 548163406537162782)
13652 | 181 | 
13653 | 182 |         msges = self.bot.seen_messages
13654 | 183 | 
13655 | 184 |         embed = discord.Embed(description="Latest Changes:\n" + revision)
13656 | 185 |         embed.title = "Quotient Official Support Server"
13657 | 186 |         embed.url = ctx.config.SERVER_LINK
13658 | 187 |         embed.colour = self.bot.color
13659 | 188 |         embed.set_author(name=str(owner), icon_url=owner.display_avatar.url)
13660 | 189 | 
13661 | 190 |         guild_value = len(self.bot.guilds)
13662 | 191 | 
13663 | 192 |         embed.add_field(name="Servers", value=f"{guild_value:,} total\n{len(self.bot.shards)} shards")
13664 | 193 |         embed.add_field(name="Uptime", value=f"{self.get_bot_uptime(brief=True)}\n{msges:,} messages seen")
13665 | 194 |         embed.add_field(name="Members", value=f"{total_members:,} Total\n{cached_members:,} cached")
13666 | 195 |         embed.add_field(
13667 | 196 |             name="Channels",
13668 | 197 |             value=f"{chnl_count[discord.ChannelType.text] + chnl_count[discord.ChannelType.voice]:,} total\n{chnl_count[discord.ChannelType.text]:,} text\n{chnl_count[discord.ChannelType.voice]:,} voice",
13669 | 198 |         )
13670 | 199 |         embed.add_field(
13671 | 200 |             name="Total Commands Used",
13672 | 201 |             value=f"{total_command_uses:,} globally\n{server_invokes:,} in this server\n{user_invokes:,} by you.",
13673 | 202 |         )
13674 | 203 |         embed.add_field(
13675 | 204 |             name="Stats",
13676 | 205 |             value=f"Ping: {round(self.bot.latency * 1000, 2)}ms\nDatabase: {db_latency}\nIPM: {round(get_ipm(ctx.bot), 2)}",
13677 | 206 |         )
13678 | 207 |         embed.add_field(name="System", value=f"**RAM**: {used_memory}/{total_memory} MB\n**CPU:** {cpu_used}% used."),
13679 | 208 |         embed.set_footer(text=f"Made with discord.py v{version}", icon_url="http://i.imgur.com/5BFecvA.png")
13680 | 209 | 
13681 | 210 |         links = [LinkType("Support Server", ctx.config.SERVER_LINK), LinkType("Invite Me", ctx.config.BOT_INVITE)]
13682 | 211 |         await ctx.send(embed=embed, embed_perms=True, view=LinkButton(links))
13683 | 212 | 
13684 | 213 |     @commands.command()
13685 | 214 |     async def ping(self, ctx: Context):
13686 | 215 |         """Check how the bot is doing"""
13687 | 216 |         await ctx.send(f"Bot: `{round(self.bot.latency*1000, 2)} ms`, Database: `{await self.bot.db_latency}`")
13688 | 217 | 
13689 | 218 |     @commands.command()
13690 | 219 |     async def voteremind(self, ctx: Context):
13691 | 220 |         """Get a reminder when your vote expires"""
13692 | 221 |         check = await Votes.get_or_none(user_id=ctx.author.id)
13693 | 222 |         if check:
13694 | 223 |             await Votes.filter(user_id=ctx.author.id).update(reminder=not (check.reminder))
13695 | 224 |             await ctx.success(f"Turned vote-reminder {'ON' if not check.reminder else 'OFF'}!")
13696 | 225 |         else:
13697 | 226 |             await Votes.create(user_id=ctx.author.id, reminder=True)
13698 | 227 |             await ctx.success(f"Turned vote-reminder ON!")
13699 | 228 | 
13700 | 229 |     @commands.command()
13701 | 230 |     @commands.has_permissions(manage_guild=True)
13702 | 231 |     async def prefix(self, ctx: Context, *, new_prefix: str = None):
13703 | 232 |         """Change your server's prefix"""
13704 | 233 | 
13705 | 234 |         if not new_prefix:
13706 | 235 |             prefix = self.bot.cache.guild_data[ctx.guild.id].get("prefix", "q")
13707 | 236 |             return await ctx.simple(f"Prefix for this server is `{prefix}`")
13708 | 237 | 
13709 | 238 |         if len(new_prefix) > 5:
13710 | 239 |             return await ctx.error(f"Prefix cannot contain more than 5 characters.")
13711 | 240 | 
13712 | 241 |         self.bot.cache.guild_data[ctx.guild.id]["prefix"] = new_prefix
13713 | 242 |         await Guild.filter(guild_id=ctx.guild.id).update(prefix=new_prefix)
13714 | 243 |         await ctx.success(f"Updated server prefix to: `{new_prefix}`")
13715 | 244 | 
13716 | 245 |     @commands.command()
13717 | 246 |     @commands.has_permissions(manage_guild=True)
13718 | 247 |     @checks.is_premium_guild()
13719 | 248 |     async def color(self, ctx: Context, *, new_color: QuoColor):
13720 | 249 |         """Change color of Quotient's embeds"""
13721 | 250 |         color = int(str(new_color).replace("#", ""), 16)  # The hex value of a color.
13722 | 251 | 
13723 | 252 |         self.bot.cache.guild_data[ctx.guild.id]["color"] = color
13724 | 253 |         await Guild.filter(guild_id=ctx.guild.id).update(embed_color=color)
13725 | 254 |         await ctx.success(f"Updated server color.")
13726 | 255 | 
13727 | 256 |     @commands.command()
13728 | 257 |     @checks.is_premium_guild()
13729 | 258 |     @commands.has_permissions(manage_guild=True)
13730 | 259 |     async def footer(self, ctx: Context, *, new_footer: str):
13731 | 260 |         """Change footer of embeds sent by Quotient"""
13732 | 261 |         if len(new_footer) > 50:
13733 | 262 |             return await ctx.success(f"Footer cannot contain more than 50 characters.")
13734 | 263 | 
13735 | 264 |         self.bot.cache.guild_data[ctx.guild.id]["footer"] = new_footer
13736 | 265 |         await Guild.filter(guild_id=ctx.guild.id).update(embed_footer=new_footer)
13737 | 266 |         await ctx.send(f"Updated server footer.")
13738 | 267 | 
13739 | 268 |     @commands.command()
13740 | 269 |     async def money(self, ctx: Context):
13741 | 270 |         user = await User.get(user_id=ctx.author.id)
13742 | 271 | 
13743 | 272 |         e = self.bot.embed(ctx, title="Your Quo Coins")
13744 | 273 |         e.set_thumbnail(url=self.bot.user.display_avatar.url)
13745 | 274 | 
13746 | 275 |         e.description = (
13747 | 276 |             f"💰 | You have a total of `{user.money} Quo Coins`.\n"
13748 | 277 |             f"*Quo Coins can be earned by voting [here]({ctx.config.WEBSITE}/vote)*"
13749 | 278 |         )
13750 | 279 | 
13751 | 280 |         _view = MoneyButton(ctx)
13752 | 281 |         if not user.money >= 120:
13753 | 282 |             _view.children[0] = discord.ui.Button(
13754 | 283 |                 label=f"Claim Prime (120 coins)", custom_id="claim_prime", style=discord.ButtonStyle.grey, disabled=True
13755 | 284 |             )
13756 | 285 | 
13757 | 286 |         _view.message = await ctx.send(embed=e, embed_perms=True, view=_view)
13758 | 287 | 
13759 | 288 |     @commands.command()
13760 | 289 |     async def vote(self, ctx: Context):
13761 | 290 |         e = self.bot.embed(ctx, title="Vote for Quotient")
13762 | 291 |         e.description = (
13763 | 292 |             "**Rewards**\n"
13764 | 293 |             "<a:roocool:962749077831942276> Voter Role `12 hrs`\n"
13765 | 294 |             f"{self.bot.config.PRIME_EMOJI} Quo Coin `x1`"
13766 | 295 |         )
13767 | 296 |         e.set_thumbnail(url=self.bot.user.display_avatar.url)
13768 | 297 | 
13769 | 298 |         _view = VoteButton(ctx)
13770 | 299 | 
13771 | 300 |         vote = await Votes.get_or_none(pk=ctx.author.id)
13772 | 301 |         if vote and vote.is_voter:
13773 | 302 |             _b: discord.ui.Button = discord.ui.Button(
13774 | 303 |                 disabled=True,
13775 | 304 |                 style=discord.ButtonStyle.grey,
13776 | 305 |                 custom_id="vote_quo",
13777 | 306 |                 label=f"Vote in {human_timedelta(vote.expire_time,accuracy=1,suffix=False)}",
13778 | 307 |             )
13779 | 308 |             _view.children[0] = _b
13780 | 309 | 
13781 | 310 |         e.set_footer(
13782 | 311 |             text=f"Your votes: {vote.total_votes if vote else 0}",
13783 | 312 |             icon_url=getattr(ctx.author.display_avatar, "url", self.bot.user.display_avatar.url),
13784 | 313 |         )
13785 | 314 |         _view.message = await ctx.send(embed=e, view=_view, embed_perms=True)
13786 | 315 | 
13787 | 316 |     @commands.command()
13788 | 317 |     async def dashboard(self, ctx: Context):
13789 | 318 |         await ctx.send(
13790 | 319 |             f"Here is the direct link to this server's dashboard:\n<https://quotientbot.xyz/dashboard/{ctx.guild.id}>"
13791 | 320 |         )
13792 | 321 | 
13793 | 322 |     @commands.hybrid_command()
13794 | 323 |     @commands.cooldown(1, 5, commands.BucketType.user)
13795 | 324 |     async def contributors(self, ctx):
13796 | 325 |         """People who made Quotient Possible."""
13797 | 326 |         url = f"https://api.github.com/repos/quotientbot/Quotient-Bot/contributors"
13798 | 327 | 
13799 | 328 |         e = discord.Embed(title=f"Project Contributors", color=self.bot.color, timestamp=self.bot.current_time)
13800 | 329 |         e.description = ""
13801 | 330 |         async with self.bot.session.get(url) as response:
13802 | 331 |             data = await response.json()
13803 | 332 |             for idx, contributor in enumerate(data, start=1):
13804 | 333 |                 if contributor["type"] == "Bot":
13805 | 334 |                     continue
13806 | 335 | 
13807 | 336 |                 e.description += (
13808 | 337 |                     f"`{idx:02}.` [{contributor['login']} ({contributor['contributions']})]({contributor['html_url']})\n"
13809 | 338 |                 )
13810 | 339 | 
13811 | 340 |         await ctx.send(embed=e)
13812 | 341 | 
13813 | 342 | 
13814 | 343 | async def setup(bot: Quotient) -> None:
13815 | 344 |     await bot.add_cog(Quomisc(bot))
13816 | 345 |     await bot.add_cog(Dev(bot))
13817 | 346 |     await bot.add_cog(QuoAlerts(bot))
13818 | 347 | 
13819 | 
13820 | 
13821 | --------------------------------------------------------------------------------
13822 | /cogs/quomisc/alerts.py:
13823 | --------------------------------------------------------------------------------
13824 |   1 | from __future__ import annotations
13825 |   2 | 
13826 |   3 | import typing as T
13827 |   4 | from os import truncate
13828 |   5 | 
13829 |   6 | if T.TYPE_CHECKING:
13830 |   7 |     from core import Quotient
13831 |   8 | 
13832 |   9 | from datetime import timedelta
13833 |  10 | 
13834 |  11 | import discord
13835 |  12 | from discord.ext import commands
13836 |  13 | 
13837 |  14 | from core import Cog, Context, QuotientView, embeds
13838 |  15 | from models import Alert, Prompt, Read, Timer
13839 |  16 | from utils import QuoPaginator, discord_timestamp
13840 |  17 | 
13841 |  18 | __all__ = ("QuoAlerts",)
13842 |  19 | 
13843 |  20 | 
13844 |  21 | class PromptView(QuotientView):
13845 |  22 |     def __init__(self, ctx: Context, alert: Alert):
13846 |  23 |         super().__init__(ctx, timeout=300)
13847 |  24 |         self.ctx = ctx
13848 |  25 |         self.alert = alert
13849 |  26 | 
13850 |  27 |     @discord.ui.button(style=discord.ButtonStyle.green, label="Read Now")
13851 |  28 |     async def read_now(self, inter: discord.Interaction, btn: discord.Button):
13852 |  29 |         _e = discord.Embed.from_dict(self.alert.message)
13853 |  30 |         await inter.response.send_message(embed=_e, ephemeral=True)
13854 |  31 | 
13855 |  32 |         self.stop()
13856 |  33 |         await self.message.delete(delay=0)
13857 |  34 | 
13858 |  35 |         await self.alert.refresh_from_db()
13859 |  36 |         read = await Read.create(user_id=inter.user.id)
13860 |  37 |         await self.alert.reads.add(read)
13861 |  38 | 
13862 |  39 |     @discord.ui.button(style=discord.ButtonStyle.red, label="Dismiss")
13863 |  40 |     async def dismiss(self, inter: discord.Interaction, btn: discord.Button):
13864 |  41 |         self.stop()
13865 |  42 |         await self.message.delete(delay=0)
13866 |  43 | 
13867 |  44 | 
13868 |  45 | class CreateAlert(discord.ui.Button):
13869 |  46 |     view: embeds.EmbedBuilder
13870 |  47 | 
13871 |  48 |     def __init__(self, ctx: Context):
13872 |  49 |         super().__init__(label="Create Alert", style=discord.ButtonStyle.green)
13873 |  50 |         self.ctx = ctx
13874 |  51 | 
13875 |  52 |     async def callback(self, interaction: discord.Interaction):
13876 |  53 |         await interaction.response.defer()
13877 |  54 | 
13878 |  55 |         await Alert.filter(active=True).update(active=False)
13879 |  56 |         record = await Alert.create(author_id=interaction.user.id, message=self.view.formatted)
13880 |  57 |         await self.ctx.bot.reminders.create_timer(record.created_at + timedelta(days=10), "alert", alert_id=record.id)
13881 |  58 | 
13882 |  59 |         await self.ctx.success("Created a new alert with `ID: {}`".format(record.id))
13883 |  60 | 
13884 |  61 | 
13885 |  62 | class QuoAlerts(Cog):
13886 |  63 |     def __init__(self, bot: Quotient):
13887 |  64 |         self.bot = bot
13888 |  65 | 
13889 |  66 |     def cog_check(self, ctx: Context):
13890 |  67 |         return ctx.author.id in ctx.config.DEVS
13891 |  68 | 
13892 |  69 |     @Cog.listener()
13893 |  70 |     async def on_command_completion(self, ctx: Context):
13894 |  71 |         record = await Alert.filter(active=True).order_by("-created_at").first()
13895 |  72 |         if not record:
13896 |  73 |             return
13897 |  74 | 
13898 |  75 |         if await record.reads.filter(user_id=ctx.author.id).exists():
13899 |  76 |             return
13900 |  77 | 
13901 |  78 |         user_prompts = await record.prompts.filter(user_id=ctx.author.id).order_by("-prompted_at")
13902 |  79 |         if len(user_prompts) >= 3:
13903 |  80 |             return
13904 |  81 | 
13905 |  82 |         if user_prompts and user_prompts[0].prompted_at > (ctx.bot.current_time - timedelta(minutes=5)):
13906 |  83 |             return
13907 |  84 | 
13908 |  85 |         _e = discord.Embed(
13909 |  86 |             color=self.bot.color, title="You have an unread alert!", description="Click `Read Now` to read it."
13910 |  87 |         )
13911 |  88 |         _e.set_thumbnail(url="https://cdn.discordapp.com/attachments/851846932593770496/1031240353489109112/alert.gif")
13912 |  89 |         v = PromptView(ctx, record)
13913 |  90 |         v.message = await ctx.message.reply(embed=_e, view=v)
13914 |  91 | 
13915 |  92 |         prompt = await Prompt.create(user_id=ctx.author.id)
13916 |  93 |         await record.prompts.add(prompt)
13917 |  94 | 
13918 |  95 |     @Cog.listener()
13919 |  96 |     async def on_alert_timer_complete(self, timer: Timer):
13920 |  97 |         record_id = timer.kwargs["alert_id"]
13921 |  98 |         await Alert.filter(pk=record_id).update(active=False)
13922 |  99 | 
13923 | 100 |     @commands.group(hidden=True, invoke_without_command=True)
13924 | 101 |     async def alr(self, ctx: Context):
13925 | 102 |         await ctx.send_help(ctx.command)
13926 | 103 | 
13927 | 104 |     @alr.command(name="list")
13928 | 105 |     async def alr_list(self, ctx: Context):
13929 | 106 |         records = await Alert.all().order_by("created_at")
13930 | 107 |         if not records:
13931 | 108 |             return await ctx.error("No alerts present at the moment, create one.")
13932 | 109 | 
13933 | 110 |         paginator = QuoPaginator(ctx, title="List of Alerts")
13934 | 111 |         for idx, record in enumerate(records, start=1):
13935 | 112 |             paginator.add_line(f"`{idx:02}` Created: {discord_timestamp(record.created_at)} (ID: `{record.pk}`)")
13936 | 113 | 
13937 | 114 |         await paginator.start()
13938 | 115 | 
13939 | 116 |     @alr.command(name="create")
13940 | 117 |     async def alr_create(self, ctx: Context):
13941 | 118 |         _v = embeds.EmbedBuilder(ctx, items=[CreateAlert(ctx)])
13942 | 119 | 
13943 | 120 |         await _v.rendor()
13944 | 121 | 
13945 | 
13946 | 
13947 | --------------------------------------------------------------------------------
13948 | /cogs/quomisc/dev.py:
13949 | --------------------------------------------------------------------------------
13950 |   1 | from __future__ import annotations
13951 |   2 | 
13952 |   3 | import typing as T
13953 |   4 | 
13954 |   5 | if T.TYPE_CHECKING:
13955 |   6 |     from core import Quotient
13956 |   7 | 
13957 |   8 | import asyncio
13958 |   9 | import datetime
13959 |  10 | 
13960 |  11 | import discord
13961 |  12 | from discord.ext import commands
13962 |  13 | from prettytable import PrettyTable
13963 |  14 | 
13964 |  15 | from core import Cog, Context
13965 |  16 | from models import BlockIdType, BlockList, Commands
13966 |  17 | from utils import get_ipm
13967 |  18 | 
13968 |  19 | from .helper import tabulate_query
13969 |  20 | 
13970 |  21 | __all__ = ("Dev",)
13971 |  22 | 
13972 |  23 | 
13973 |  24 | class Dev(Cog):
13974 |  25 |     def __init__(self, bot: Quotient):
13975 |  26 |         self.bot = bot
13976 |  27 | 
13977 |  28 |     def cog_check(self, ctx: Context):
13978 |  29 |         return ctx.author.id in ctx.config.DEVS
13979 |  30 | 
13980 |  31 |     @commands.group(hidden=True, invoke_without_command=True)
13981 |  32 |     async def bl(self, ctx: Context):
13982 |  33 |         """Blocklist commands."""
13983 |  34 |         await ctx.send_help(ctx.command)
13984 |  35 | 
13985 |  36 |     @bl.command(name="add")
13986 |  37 |     async def bl_add(self, ctx: Context, item: discord.User | int, *, reason: str = None):
13987 |  38 |         """Block a user or guild from using the bot."""
13988 |  39 |         block_id_type = BlockIdType.USER if isinstance(item, discord.User) else BlockIdType.GUILD
13989 |  40 |         block_id = item.id if isinstance(item, discord.User) else item
13990 |  41 | 
13991 |  42 |         record = await BlockList.get_or_none(block_id=block_id, block_id_type=block_id_type)
13992 |  43 |         if record:
13993 |  44 |             return await ctx.error(f"{item} is already blocked.")
13994 |  45 | 
13995 |  46 |         await BlockList.create(block_id=block_id, block_id_type=block_id_type, reason=reason)
13996 |  47 |         self.bot.cache.blocked_ids.add(block_id)
13997 |  48 |         await ctx.success(f"{item} has been blocked.")
13998 |  49 | 
13999 |  50 |     @bl.command(name="remove")
14000 |  51 |     async def bl_remove(self, ctx: Context, item: discord.User | int):
14001 |  52 |         """Unblock a user or guild from using the bot."""
14002 |  53 |         block_id = item.id if isinstance(item, discord.User) else item
14003 |  54 | 
14004 |  55 |         record = await BlockList.get_or_none(block_id=block_id)
14005 |  56 |         if not record:
14006 |  57 |             return await ctx.error(f"{item} is not blocked.")
14007 |  58 | 
14008 |  59 |         await record.delete()
14009 |  60 |         self.bot.cache.blocked_ids.remove(block_id)
14010 |  61 |         await ctx.success(f"{item} has been unblocked.")
14011 |  62 | 
14012 |  63 |     @commands.command(hidden=True)
14013 |  64 |     async def sync(
14014 |  65 |         self,
14015 |  66 |         ctx: commands.Context,
14016 |  67 |         guilds: commands.Greedy[discord.Object],
14017 |  68 |         spec: T.Optional[T.Literal["~", "*", "^"]] = None,
14018 |  69 |     ) -> None:
14019 |  70 |         if not guilds:
14020 |  71 |             if spec == "~":
14021 |  72 |                 synced = await self.bot.tree.sync(guild=ctx.guild)
14022 |  73 |             elif spec == "*":
14023 |  74 |                 self.bot.tree.copy_global_to(guild=ctx.guild)
14024 |  75 |                 synced = await self.bot.tree.sync(guild=ctx.guild)
14025 |  76 |             elif spec == "^":
14026 |  77 |                 self.bot.tree.clear_commands(guild=ctx.guild)
14027 |  78 |                 await self.bot.tree.sync(guild=ctx.guild)
14028 |  79 |                 synced = []
14029 |  80 |             else:
14030 |  81 |                 synced = await self.bot.tree.sync()
14031 |  82 | 
14032 |  83 |             await ctx.send(f"Synced {len(synced)} commands {'globally' if spec is None else 'to the current guild.'}")
14033 |  84 |             return
14034 |  85 | 
14035 |  86 |         ret = 0
14036 |  87 |         for guild in guilds:
14037 |  88 |             try:
14038 |  89 |                 await self.bot.tree.sync(guild=guild)
14039 |  90 |             except discord.HTTPException:
14040 |  91 |                 pass
14041 |  92 |             else:
14042 |  93 |                 ret += 1
14043 |  94 | 
14044 |  95 |         await ctx.send(f"Synced the tree to {ret}/{len(guilds)}.")
14045 |  96 | 
14046 |  97 |     @commands.group(hidden=True, invoke_without_command=True)
14047 |  98 |     async def botupdate(self, ctx: Context):
14048 |  99 |         await ctx.send_help(ctx.command)
14049 | 100 | 
14050 | 101 |     @botupdate.command(name="on")
14051 | 102 |     async def botmaintenance_on(self, ctx: Context, *, msg: str = None):
14052 | 103 |         self.bot.lockdown = True
14053 | 104 |         self.bot.lockdown_msg = msg
14054 | 105 |         await ctx.success("Now in maintenance mode")
14055 | 106 |         await asyncio.sleep(120)
14056 | 107 | 
14057 | 108 |         if not self.bot.lockdown:
14058 | 109 |             return await ctx.error("Lockdown mode has been cancelled")
14059 | 110 | 
14060 | 111 |         await ctx.success("Reloading...")
14061 | 112 |         self.bot.reboot()
14062 | 113 | 
14063 | 114 |     @botupdate.command(name="off")
14064 | 115 |     async def botmaintenance_off(self, ctx: Context):
14065 | 116 |         self.bot.lockdown, self.bot.lockdown_msg = False, None
14066 | 117 |         await ctx.success("Okay, stopped reload.")
14067 | 118 | 
14068 | 119 |     @commands.command(hidden=True)
14069 | 120 |     async def cmds(self, ctx: Context):
14070 | 121 |         total_uses = await Commands.all().count()
14071 | 122 | 
14072 | 123 |         records = await ctx.db.fetch(
14073 | 124 |             "SELECT cmd, COUNT(*) AS uses FROM commands GROUP BY cmd ORDER BY uses DESC LIMIT 15 "
14074 | 125 |         )
14075 | 126 | 
14076 | 127 |         table = PrettyTable()
14077 | 128 |         table.field_names = ["Command", "Invoke Count"]
14078 | 129 |         for record in records:
14079 | 130 |             table.add_row([record["cmd"], record["uses"]])
14080 | 131 | 
14081 | 132 |         table = table.get_string()
14082 | 133 |         embed = self.bot.embed(ctx, title=f"Command Usage ({total_uses})")
14083 | 134 |         embed.description = f"```{table}```"
14084 | 135 | 
14085 | 136 |         cmds = sum(1 for i in self.bot.walk_commands())
14086 | 137 | 
14087 | 138 |         embed.set_footer(text="Total Commands: {}  | Invoke rate per minute: {}".format(cmds, round(get_ipm(ctx.bot), 2)))
14088 | 139 | 
14089 | 140 |         await ctx.send(embed=embed)
14090 | 141 | 
14091 | 142 |     @commands.group(hidden=True, invoke_without_command=True, name="history")
14092 | 143 |     async def command_history(self, ctx):
14093 | 144 |         """Command history."""
14094 | 145 |         query = """SELECT
14095 | 146 |                         CASE failed
14096 | 147 |                             WHEN TRUE THEN cmd || ' [!]'
14097 | 148 |                             ELSE cmd
14098 | 149 |                         END AS "cmd",
14099 | 150 |                         to_char(used_at, 'Mon DD HH12:MI:SS AM') AS "invoked",
14100 | 151 |                         user_id,
14101 | 152 |                         guild_id
14102 | 153 |                    FROM commands
14103 | 154 |                    ORDER BY used_at DESC
14104 | 155 |                    LIMIT 15;
14105 | 156 |                 """
14106 | 157 |         await tabulate_query(ctx, query)
14107 | 158 | 
14108 | 159 |     @command_history.command(name="for")
14109 | 160 |     async def command_history_for(self, ctx, days: T.Optional[int] = 7, *, command: str):
14110 | 161 |         """Command history for a command."""
14111 | 162 |         query = """SELECT *, t.success + t.failed AS "total"
14112 | 163 |                    FROM (
14113 | 164 |                        SELECT guild_id,
14114 | 165 |                               SUM(CASE WHEN failed THEN 0 ELSE 1 END) AS "success",
14115 | 166 |                               SUM(CASE WHEN failed THEN 1 ELSE 0 END) AS "failed"
14116 | 167 |                        FROM commands
14117 | 168 |                        WHERE cmd=$1
14118 | 169 |                        AND used_at > (CURRENT_TIMESTAMP - $2::interval)
14119 | 170 |                        GROUP BY guild_id
14120 | 171 |                    ) AS t
14121 | 172 |                    ORDER BY "total" DESC
14122 | 173 |                    LIMIT 30;
14123 | 174 |                 """
14124 | 175 | 
14125 | 176 |         await tabulate_query(ctx, query, command, datetime.timedelta(days=days))
14126 | 177 | 
14127 | 178 |     @command_history.command(name="guild", aliases=["server"])
14128 | 179 |     async def command_history_guild(self, ctx, guild_id: int):
14129 | 180 |         """Command history for a guild."""
14130 | 181 |         query = """SELECT
14131 | 182 |                         CASE failed
14132 | 183 |                             WHEN TRUE THEN cmd || ' [!]'
14133 | 184 |                             ELSE cmd
14134 | 185 |                         END AS "cmd",
14135 | 186 |                         channel_id,
14136 | 187 |                         user_id,
14137 | 188 |                         used_at
14138 | 189 |                    FROM commands
14139 | 190 |                    WHERE guild_id=$1
14140 | 191 |                    ORDER BY used_at DESC
14141 | 192 |                    LIMIT 15;
14142 | 193 |                 """
14143 | 194 |         await tabulate_query(ctx, query, guild_id)
14144 | 195 | 
14145 | 196 |     @command_history.command(name="user", aliases=["member"])
14146 | 197 |     async def command_history_user(self, ctx, user_id: int):
14147 | 198 |         """Command history for a user."""
14148 | 199 |         query = """SELECT
14149 | 200 |                         CASE failed
14150 | 201 |                             WHEN TRUE THEN cmd || ' [!]'
14151 | 202 |                             ELSE cmd
14152 | 203 |                         END AS "cmd",
14153 | 204 |                         guild_id,
14154 | 205 |                         used_at
14155 | 206 |                    FROM commands
14156 | 207 |                    WHERE user_id=$1
14157 | 208 |                    ORDER BY used_at DESC
14158 | 209 |                    LIMIT 20;
14159 | 210 |                 """
14160 | 211 |         await tabulate_query(ctx, query, user_id)
14161 | 212 | 
14162 | 213 |     @command_history.command(name="cog")
14163 | 214 |     async def command_history_cog(self, ctx, days: T.Optional[int] = 7, *, cog: str = None):
14164 | 215 |         """Command history for a cog or grouped by a cog."""
14165 | 216 |         interval = datetime.timedelta(days=days)
14166 | 217 |         if cog is not None:
14167 | 218 |             cog = self.bot.get_cog(cog)
14168 | 219 |             if cog is None:
14169 | 220 |                 return await ctx.send(f"Unknown cog: {cog}")
14170 | 221 | 
14171 | 222 |             query = """SELECT *, t.success + t.failed AS "total"
14172 | 223 |                        FROM (
14173 | 224 |                            SELECT command,
14174 | 225 |                                   SUM(CASE WHEN failed THEN 0 ELSE 1 END) AS "success",
14175 | 226 |                                   SUM(CASE WHEN failed THEN 1 ELSE 0 END) AS "failed"
14176 | 227 |                            FROM commands
14177 | 228 |                            WHERE cmd = any($1::text[])
14178 | 229 |                            AND used_at > (CURRENT_TIMESTAMP - $2::interval)
14179 | 230 |                            GROUP BY cmd
14180 | 231 |                        ) AS t
14181 | 232 |                        ORDER BY "total" DESC
14182 | 233 |                        LIMIT 30;
14183 | 234 |                     """
14184 | 235 |             return await tabulate_query(ctx, query, [c.qualified_name for c in cog.walk_commands()], interval)
14185 | 236 | 
14186 | 
14187 | 
14188 | --------------------------------------------------------------------------------
14189 | /cogs/quomisc/helper.py:
14190 | --------------------------------------------------------------------------------
14191 |  1 | import datetime
14192 |  2 | import io
14193 |  3 | 
14194 |  4 | import discord
14195 |  5 | 
14196 |  6 | 
14197 |  7 | class TabularData:
14198 |  8 |     def __init__(self):
14199 |  9 |         self._widths = []
14200 | 10 |         self._columns = []
14201 | 11 |         self._rows = []
14202 | 12 | 
14203 | 13 |     def set_columns(self, columns):
14204 | 14 |         self._columns = columns
14205 | 15 |         self._widths = [len(c) + 2 for c in columns]
14206 | 16 | 
14207 | 17 |     def add_row(self, row):
14208 | 18 |         rows = [str(r) for r in row]
14209 | 19 |         self._rows.append(rows)
14210 | 20 |         for index, element in enumerate(rows):
14211 | 21 |             width = len(element) + 2
14212 | 22 |             if width > self._widths[index]:
14213 | 23 |                 self._widths[index] = width
14214 | 24 | 
14215 | 25 |     def add_rows(self, rows):
14216 | 26 |         for row in rows:
14217 | 27 |             self.add_row(row)
14218 | 28 | 
14219 | 29 |     def render(self):
14220 | 30 |         """Renders a table in rST format.
14221 | 31 |         Example:
14222 | 32 |         +-------+-----+
14223 | 33 |         | Name  | Age |
14224 | 34 |         +-------+-----+
14225 | 35 |         | Alice | 24  |
14226 | 36 |         |  Bob  | 19  |
14227 | 37 |         +-------+-----+
14228 | 38 |         """
14229 | 39 |         sep = "+".join("-" * w for w in self._widths)
14230 | 40 |         sep = f"+{sep}+"
14231 | 41 | 
14232 | 42 |         to_draw = [sep]
14233 | 43 | 
14234 | 44 |         def get_entry(d):
14235 | 45 |             elem = "|".join(f"{e:^{self._widths[i]}}" for i, e in enumerate(d))
14236 | 46 |             return f"|{elem}|"
14237 | 47 | 
14238 | 48 |         to_draw.append(get_entry(self._columns))
14239 | 49 |         to_draw.append(sep)
14240 | 50 | 
14241 | 51 |         for row in self._rows:
14242 | 52 |             to_draw.append(get_entry(row))
14243 | 53 | 
14244 | 54 |         to_draw.append(sep)
14245 | 55 |         return "\n".join(to_draw)
14246 | 56 | 
14247 | 57 | 
14248 | 58 | async def tabulate_query(ctx, query, *args):
14249 | 59 |     records = await ctx.db.fetch(query, *args)
14250 | 60 | 
14251 | 61 |     if len(records) == 0:
14252 | 62 |         return await ctx.send("No results found.")
14253 | 63 | 
14254 | 64 |     headers = list(records[0].keys())
14255 | 65 |     table = TabularData()
14256 | 66 |     table.set_columns(headers)
14257 | 67 |     table.add_rows(list(r.values()) for r in records)
14258 | 68 |     render = table.render()
14259 | 69 | 
14260 | 70 |     fmt = f"```\n{render}\n```"
14261 | 71 |     if len(fmt) > 2000:
14262 | 72 |         fp = io.BytesIO(fmt.encode("utf-8"))
14263 | 73 |         await ctx.send("Too many results...", file=discord.File(fp, "results.txt"))
14264 | 74 |     else:
14265 | 75 |         await ctx.send(fmt)
14266 | 76 | 
14267 | 77 | 
14268 | 78 | def format_dt(dt, style=None):
14269 | 79 |     if dt.tzinfo is None:
14270 | 80 |         dt = dt.replace(tzinfo=datetime.timezone.utc)
14271 | 81 | 
14272 | 82 |     if style is None:
14273 | 83 |         return f"<t:{int(dt.timestamp())}>"
14274 | 84 |     return f"<t:{int(dt.timestamp())}:{style}>"
14275 | 85 | 
14276 | 86 | 
14277 | 87 | def format_relative(dt):
14278 | 88 |     return format_dt(dt, "R")
14279 | 89 | 
14280 | 90 | 
14281 | 91 | # async def find_query(ctx, query):
14282 | 92 | #     record = await FAQ.filter(aliases__icontains=query).all().first()
14283 | 93 | #     if record:
14284 | 94 | #         return record
14285 | 95 | 
14286 | 96 | #     return "\n".join(get_close_matches(query, (faq.aliases for faq in await FAQ.all())))
14287 | 97 | 
14288 | 
14289 | 
14290 | --------------------------------------------------------------------------------
14291 | /cogs/quomisc/views.py:
14292 | --------------------------------------------------------------------------------
14293 |   1 | from __future__ import annotations
14294 |   2 | 
14295 |   3 | import typing
14296 |   4 | from datetime import datetime, timedelta
14297 |   5 | 
14298 |   6 | from models import User
14299 |   7 | 
14300 |   8 | if typing.TYPE_CHECKING:
14301 |   9 |     from core import Quotient
14302 |  10 | 
14303 |  11 | from contextlib import suppress
14304 |  12 | 
14305 |  13 | import discord
14306 |  14 | 
14307 |  15 | from constants import IST
14308 |  16 | from core import Context, QuotientView
14309 |  17 | from utils import emote
14310 |  18 | 
14311 |  19 | 
14312 |  20 | class BaseView(discord.ui.View):
14313 |  21 |     def __init__(self, ctx: Context, *, timeout=30.0):
14314 |  22 |         self.ctx = ctx
14315 |  23 |         self.message: typing.Optional[discord.Message] = None
14316 |  24 |         self.bot: Quotient = ctx.bot
14317 |  25 | 
14318 |  26 |         super().__init__(timeout=timeout)
14319 |  27 | 
14320 |  28 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
14321 |  29 |         if interaction.user.id != self.ctx.author.id:
14322 |  30 |             await interaction.response.send_message(
14323 |  31 |                 "Sorry, you can't use this interaction as it is not started by you.",
14324 |  32 |                 ephemeral=True,
14325 |  33 |             )
14326 |  34 |             return False
14327 |  35 |         return True
14328 |  36 | 
14329 |  37 |     async def on_timeout(self) -> None:
14330 |  38 |         if hasattr(self, "message"):
14331 |  39 |             for b in self.children:
14332 |  40 |                 if isinstance(b, discord.ui.Button) and not b.style == discord.ButtonStyle.link:
14333 |  41 |                     b.style, b.disabled = discord.ButtonStyle.grey, True
14334 |  42 | 
14335 |  43 |             with suppress(discord.HTTPException):
14336 |  44 |                 if self.message is not None:
14337 |  45 |                     await self.message.edit(view=self)
14338 |  46 | 
14339 |  47 | 
14340 |  48 | class VoteButton(BaseView):
14341 |  49 |     def __init__(self, ctx: Context):
14342 |  50 |         super().__init__(ctx, timeout=None)
14343 |  51 | 
14344 |  52 |         self.add_item(
14345 |  53 |             discord.ui.Button(
14346 |  54 |                 style=discord.ButtonStyle.link,
14347 |  55 |                 url="https://quotientbot.xyz/vote",
14348 |  56 |                 label="Click Here",
14349 |  57 |             )
14350 |  58 |         )
14351 |  59 | 
14352 |  60 | 
14353 |  61 | class MoneyButton(BaseView):
14354 |  62 |     def __init__(self, ctx: Context):
14355 |  63 |         super().__init__(ctx)
14356 |  64 | 
14357 |  65 |         self.ctx = ctx
14358 |  66 |         self.bot: Quotient = ctx.bot
14359 |  67 | 
14360 |  68 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="claim_prime", label="Claim Prime (120 coins)")
14361 |  69 |     async def claim_premium(self, interaction: discord.Interaction, button: discord.Button):
14362 |  70 |         await interaction.response.defer(ephemeral=True)
14363 |  71 | 
14364 |  72 |         self.children[0].disabled = True
14365 |  73 |         await self.message.edit(view=self)
14366 |  74 | 
14367 |  75 |         _u = await User.get(pk=self.ctx.author.id)
14368 |  76 |         if not _u.money >= 120:
14369 |  77 |             return await interaction.followup.send(
14370 |  78 |                 f"{emote.error} Insufficient Quo Coins in your account.", ephemeral=True
14371 |  79 |             )
14372 |  80 | 
14373 |  81 |         end_time = (
14374 |  82 |             _u.premium_expire_time + timedelta(days=30) if _u.is_premium else datetime.now(tz=IST) + timedelta(days=30)
14375 |  83 |         )
14376 |  84 | 
14377 |  85 |         await User.get(pk=self.ctx.author.id).update(
14378 |  86 |             is_premium=True,
14379 |  87 |             premium_expire_time=end_time,
14380 |  88 |             money=_u.money - 120,
14381 |  89 |             premiums=_u.premiums + 1,
14382 |  90 |         )
14383 |  91 | 
14384 |  92 |         member = self.bot.server.get_member(self.ctx.author.id)
14385 |  93 |         if member is not None:
14386 |  94 |             await member.add_roles(discord.Object(id=self.bot.config.PREMIUM_ROLE), reason="They purchased premium.")
14387 |  95 | 
14388 |  96 |         await self.ctx.success(
14389 |  97 |             "Credited Quotient Prime for 1 Month to your account,\n\n"
14390 |  98 |             "Use `qboost` in any server to upgrade it with Prime."
14391 |  99 |         )
14392 | 100 | 
14393 | 101 | 
14394 | 102 | class SetupButtonView(QuotientView):
14395 | 103 |     def __init__(self, ctx: Context):
14396 | 104 |         super().__init__(ctx, timeout=None)
14397 | 105 |         self.ctx = ctx
14398 | 106 | 
14399 | 107 |     @discord.ui.button(label="setup scrims", custom_id="setup_scrims_button")
14400 | 108 |     async def setup_scrims_button(self, interaction: discord.Interaction, button: discord.Button):
14401 | 109 |         await interaction.response.defer()
14402 | 110 |         return await self.ctx.simple(f"Kindly use `{self.ctx.prefix}sm setup` to setup a scrim.")
14403 | 111 | 
14404 | 112 |     @discord.ui.button(label="setup tourney", custom_id="setup_tourney_button")
14405 | 113 |     async def setup_tourney_button(self, interaction: discord.Interaction, button: discord.Button):
14406 | 114 |         return await self.ctx.simple(f"Kindly use `{self.ctx.prefix}t setup` to setup a tournament.")
14407 | 115 | 
14408 | 
14409 | 
14410 | --------------------------------------------------------------------------------
14411 | /cogs/reminder/__init__.py:
14412 | --------------------------------------------------------------------------------
14413 |   1 | from __future__ import annotations
14414 |   2 | 
14415 |   3 | import typing
14416 |   4 | 
14417 |   5 | if typing.TYPE_CHECKING:
14418 |   6 |     from core import Quotient
14419 |   7 | 
14420 |   8 | import asyncio
14421 |   9 | from datetime import datetime, timedelta
14422 |  10 | 
14423 |  11 | import asyncpg
14424 |  12 | import discord
14425 |  13 | 
14426 |  14 | from core import Cog
14427 |  15 | from models import Timer
14428 |  16 | from utils import IST
14429 |  17 | 
14430 |  18 | 
14431 |  19 | class Reminders(Cog):
14432 |  20 |     """Reminders to do something."""
14433 |  21 | 
14434 |  22 |     def __init__(self, bot: Quotient):
14435 |  23 |         self.bot = bot
14436 |  24 |         self._have_data = asyncio.Event()
14437 |  25 |         self._current_timer = None
14438 |  26 |         self._task = bot.loop.create_task(self.dispatch_timers())
14439 |  27 | 
14440 |  28 |     def cog_unload(self):
14441 |  29 |         self._task.cancel()
14442 |  30 | 
14443 |  31 |     async def get_active_timer(self, *, days=7):
14444 |  32 |         return await Timer.filter(expires__lte=datetime.now(tz=IST) + timedelta(days=days)).order_by("expires").first()
14445 |  33 | 
14446 |  34 |     async def wait_for_active_timers(self, *, days=7):
14447 |  35 |         timer = await self.get_active_timer(days=days)
14448 |  36 |         if timer is not None:
14449 |  37 |             self._have_data.set()
14450 |  38 |             return timer
14451 |  39 | 
14452 |  40 |         self._have_data.clear()
14453 |  41 |         self._current_timer = None
14454 |  42 |         await self._have_data.wait()
14455 |  43 |         return await self.get_active_timer(days=days)
14456 |  44 | 
14457 |  45 |     async def call_timer(self, timer: Timer):
14458 |  46 |         # delete the timer
14459 |  47 |         deleted = await Timer.filter(pk=timer.id, expires=timer.expires).delete()
14460 |  48 | 
14461 |  49 |         if deleted == 0:  # Probably a task is already deleted or its expire time changed.
14462 |  50 |             return
14463 |  51 | 
14464 |  52 |         # dispatch the event
14465 |  53 |         event_name = f"{timer.event}_timer_complete"
14466 |  54 |         self.bot.dispatch(event_name, timer)
14467 |  55 | 
14468 |  56 |     async def dispatch_timers(self):
14469 |  57 |         try:
14470 |  58 |             while not self.bot.is_closed():
14471 |  59 |                 timer = self._current_timer = await self.wait_for_active_timers(days=40)
14472 |  60 | 
14473 |  61 |                 now = datetime.now(tz=IST)
14474 |  62 | 
14475 |  63 |                 # print(now, timer.expires)
14476 |  64 | 
14477 |  65 |                 if timer.expires >= now:
14478 |  66 |                     to_sleep = (timer.expires - now).total_seconds()
14479 |  67 |                     # print(to_sleep)
14480 |  68 |                     await asyncio.sleep(to_sleep)
14481 |  69 | 
14482 |  70 |                 await self.call_timer(timer)
14483 |  71 |         except (OSError, discord.ConnectionClosed, asyncpg.PostgresConnectionError):
14484 |  72 |             self._task.cancel()
14485 |  73 |             self._task = self.bot.loop.create_task(self.dispatch_timers())
14486 |  74 | 
14487 |  75 |     async def short_timer_optimisation(self, seconds, timer: Timer):
14488 |  76 |         await asyncio.sleep(seconds)
14489 |  77 |         event_name = f"{timer.event}_timer_complete"
14490 |  78 |         self.bot.dispatch(event_name, timer)
14491 |  79 | 
14492 |  80 |     async def create_timer(self, *args, **kwargs):
14493 |  81 |         when, event, *args = args
14494 |  82 | 
14495 |  83 |         try:
14496 |  84 |             now = kwargs.pop("created")
14497 |  85 |         except KeyError:
14498 |  86 |             now = datetime.now(tz=IST)
14499 |  87 | 
14500 |  88 |         delta = (when - now).total_seconds()
14501 |  89 | 
14502 |  90 |         timer = await Timer.create(
14503 |  91 |             expires=when,
14504 |  92 |             created=now,
14505 |  93 |             event=event,
14506 |  94 |             extra={"kwargs": kwargs, "args": args},
14507 |  95 |         )
14508 |  96 | 
14509 |  97 |         # only set the data check if it can be waited on
14510 |  98 |         if delta <= (86400 * 40):  # 40 days
14511 |  99 |             self._have_data.set()
14512 | 100 | 
14513 | 101 |         # check if this timer is earlier than our currently run timer
14514 | 102 |         if self._current_timer and when < self._current_timer.expires:
14515 | 103 |             # cancel the task and re-run it
14516 | 104 |             self._task.cancel()
14517 | 105 |             self._task = self.bot.loop.create_task(self.dispatch_timers())
14518 | 106 | 
14519 | 107 |         return timer
14520 | 108 | 
14521 | 109 | 
14522 | 110 | async def setup(bot: Quotient):
14523 | 111 |     await bot.add_cog(Reminders(bot))
14524 | 112 | 
14525 | 
14526 | 
14527 | --------------------------------------------------------------------------------
14528 | /cogs/utility/__init__.py:
14529 | --------------------------------------------------------------------------------
14530 |   1 | from __future__ import annotations
14531 |   2 | 
14532 |   3 | import typing
14533 |   4 | 
14534 |   5 | from discord.utils import escape_markdown, escape_mentions
14535 |   6 | 
14536 |   7 | from cogs.utility.events import AutoPurgeEvents, ReminderEvents
14537 |   8 | 
14538 |   9 | if typing.TYPE_CHECKING:
14539 |  10 |     from core import Quotient
14540 |  11 | 
14541 |  12 | from ast import literal_eval as leval
14542 |  13 | from contextlib import suppress
14543 |  14 | from datetime import timedelta
14544 |  15 | from io import BytesIO
14545 |  16 | 
14546 |  17 | import discord
14547 |  18 | from discord.ext import commands
14548 |  19 | from humanize import precisedelta
14549 |  20 | 
14550 |  21 | from core import Cog, Context, embeds
14551 |  22 | from models import ArrayAppend, ArrayRemove, AutoPurge, Autorole, Snipe, Tag
14552 |  23 | from utils import (
14553 |  24 |     QuoCategory,
14554 |  25 |     QuoMember,
14555 |  26 |     QuoPaginator,
14556 |  27 |     QuoRole,
14557 |  28 |     QuoTextChannel,
14558 |  29 |     TimeText,
14559 |  30 |     checks,
14560 |  31 |     discord_timestamp,
14561 |  32 |     plural,
14562 |  33 |     simple_convert,
14563 |  34 |     strtime,
14564 |  35 |     truncate_string,
14565 |  36 | )
14566 |  37 | 
14567 |  38 | from .functions import TagConverter, TagName, guild_tag_stats, increment_usage, is_valid_name, member_tag_stats
14568 |  39 | from .views import *
14569 |  40 | 
14570 |  41 | 
14571 |  42 | class Utility(Cog, name="utility"):
14572 |  43 |     def __init__(self, bot: Quotient):
14573 |  44 |         self.bot = bot
14574 |  45 | 
14575 |  46 |     @commands.group(aliases=("timer", "remind"), invoke_without_command=True)
14576 |  47 |     async def reminder(self, ctx: Context, *, when: TimeText(commands.clean_content)):  # noqa: F722
14577 |  48 |         """Reminds you of something after a certain amount of time.
14578 |  49 | 
14579 |  50 |         The input can be any direct date (e.g. YYYY-MM-DD) or a human
14580 |  51 |         readable offset. Examples:
14581 |  52 | 
14582 |  53 |         - "next thursday at 3pm do something funny"
14583 |  54 |         - "do the dishes tomorrow"
14584 |  55 |         - "in 3 days do the thing"
14585 |  56 |         - "2d unmute someone"
14586 |  57 | 
14587 |  58 |         """
14588 |  59 |         expire = when.dt
14589 |  60 | 
14590 |  61 |         if not expire:
14591 |  62 |             return await ctx.error(
14592 |  63 |                 "I couldn't find time in your input. \n\nTry it like: `qremind me at 9pm to get laid.`"
14593 |  64 |             )
14594 |  65 | 
14595 |  66 |         await self.bot.reminders.create_timer(
14596 |  67 |             expire,
14597 |  68 |             "reminder",
14598 |  69 |             ctx.author.id,
14599 |  70 |             ctx.channel.id,
14600 |  71 |             when.arg,
14601 |  72 |             message_id=ctx.message.id,
14602 |  73 |         )
14603 |  74 | 
14604 |  75 |         await ctx.send(f"Alright **{ctx.author}**, I'll remind you {discord_timestamp(expire)}: {when.arg}")
14605 |  76 | 
14606 |  77 |     @reminder.command(name="all", ignore_extra=False)
14607 |  78 |     async def reminder_list(self, ctx: Context):
14608 |  79 |         """Shows the 10 latest currently running reminders."""
14609 |  80 |         query = """SELECT id, expires, extra #>> '{args,2}'
14610 |  81 |                    FROM timer
14611 |  82 |                    WHERE event = 'reminder'
14612 |  83 |                    AND extra #>> '{args,0}' = $1
14613 |  84 |                    ORDER BY expires;
14614 |  85 |                 """
14615 |  86 | 
14616 |  87 |         records = await ctx.db.fetch(query, str(ctx.author.id))
14617 |  88 | 
14618 |  89 |         if not records:
14619 |  90 |             return await ctx.error("No currently running reminders.")
14620 |  91 | 
14621 |  92 |         paginator = QuoPaginator(ctx, title=f"Total Reminders: {len(records)}", per_page=10)
14622 |  93 | 
14623 |  94 |         for _id, expires, message in records:
14624 |  95 |             paginator.add_line(f"`{_id}`: {truncate_string(message,40)}({discord_timestamp(expires)})")
14625 |  96 | 
14626 |  97 |         await paginator.start()
14627 |  98 | 
14628 |  99 |     @commands.group(invoke_without_command=True)
14629 | 100 |     @checks.is_mod()
14630 | 101 |     async def autorole(self, ctx: Context, off: typing.Optional[str]):
14631 | 102 |         """
14632 | 103 |         Manage Quotient's autoroles.
14633 | 104 |         """
14634 | 105 |         if not off or off.lower() != "off":
14635 | 106 |             return await ctx.send_help(ctx.command)
14636 | 107 | 
14637 | 108 |         record = await Autorole.get_or_none(guild_id=ctx.guild.id)
14638 | 109 | 
14639 | 110 |         if not record:
14640 | 111 |             return await ctx.send(
14641 | 112 |                 f"You have not set any autorole yet.\n\nDo it like: `{ctx.prefix}autorole humans @role`"
14642 | 113 |             )
14643 | 114 | 
14644 | 115 |         if not any([len(record.humans), len(record.bots)]):
14645 | 116 |             return await ctx.error("Autoroles already OFF!")
14646 | 117 |         prompt = await ctx.prompt("Are you sure you want to turn off autorole?")
14647 | 118 |         if prompt:
14648 | 119 |             # await Autorole.filter(guild_id=ctx.guild.id).update(humans=list, bots=list)
14649 | 120 |             await ctx.db.execute("UPDATE autoroles SET humans = '{}' , bots = '{}' WHERE guild_id = $1", ctx.guild.id)
14650 | 121 |             await ctx.success("Autoroles turned OFF!")
14651 | 122 |         else:
14652 | 123 |             await ctx.success("OK!")
14653 | 124 | 
14654 | 125 |     @autorole.command(name="humans")
14655 | 126 |     @checks.is_mod()
14656 | 127 |     @commands.bot_has_guild_permissions(manage_roles=True)
14657 | 128 |     async def autorole_humans(self, ctx: Context, *, role: QuoRole):
14658 | 129 |         """
14659 | 130 |         Add/ Remove a role to human autoroles.
14660 | 131 |         """
14661 | 132 |         record = await Autorole.get_or_none(pk=ctx.guild.id)
14662 | 133 |         if record is None:
14663 | 134 |             await Autorole.create(guild_id=ctx.guild.id, humans=[role.id])
14664 | 135 |             text = f"Added {role.mention} to human autoroles."
14665 | 136 | 
14666 | 137 |         else:
14667 | 138 |             func = (ArrayAppend, ArrayRemove)[role.id in record.humans]
14668 | 139 |             await Autorole.filter(guild_id=ctx.guild.id).update(humans=func("humans", role.id))
14669 | 140 |             text = (
14670 | 141 |                 f"Added {role.mention} to human autoroles."
14671 | 142 |                 if func == ArrayAppend
14672 | 143 |                 else f"Removed {role.mention} from human autoroles."
14673 | 144 |             )
14674 | 145 | 
14675 | 146 |         await ctx.success(text)
14676 | 147 | 
14677 | 148 |     @autorole.command(name="bots")
14678 | 149 |     @checks.is_mod()
14679 | 150 |     @commands.bot_has_guild_permissions(manage_roles=True)
14680 | 151 |     async def autorole_bots(self, ctx: Context, *, role: QuoRole):
14681 | 152 |         """
14682 | 153 |         Add/ Remove a role to bot autoroles.
14683 | 154 |         """
14684 | 155 |         record = await Autorole.get_or_none(pk=ctx.guild.id)
14685 | 156 |         if record is None:
14686 | 157 |             await Autorole.create(guild_id=ctx.guild.id, bots=[role.id])
14687 | 158 |             text = f"Added {role.mention} to bot autoroles."
14688 | 159 | 
14689 | 160 |         else:
14690 | 161 |             func = (ArrayAppend, ArrayRemove)[role.id in record.bots]
14691 | 162 |             await Autorole.filter(guild_id=ctx.guild.id).update(bots=func("bots", role.id))
14692 | 163 |             text = (
14693 | 164 |                 f"Added {role.mention} to bot autoroles."
14694 | 165 |                 if func == ArrayAppend
14695 | 166 |                 else f"Removed {role.mention} from bot autoroles."
14696 | 167 |             )
14697 | 168 | 
14698 | 169 |         await ctx.success(text)
14699 | 170 | 
14700 | 171 |     @autorole.command(name="config")
14701 | 172 |     @checks.is_mod()
14702 | 173 |     @commands.bot_has_guild_permissions(manage_roles=True)
14703 | 174 |     async def autorole_config(self, ctx: Context):
14704 | 175 |         """
14705 | 176 |         Get autorole config
14706 | 177 |         """
14707 | 178 |         record = await Autorole.get_or_none(pk=ctx.guild.id)
14708 | 179 |         if not record:
14709 | 180 |             return await ctx.send(
14710 | 181 |                 f"You have not set any autorole yet.\n\nDo it like: `{ctx.prefix}autorole humans @role`"
14711 | 182 |             )
14712 | 183 | 
14713 | 184 |         humans = ", ".join(record.human_roles) if list(record.human_roles) else "Not Set!"
14714 | 185 |         bots = ", ".join(record.bot_roles) if list(record.bot_roles) else "Not Set!"
14715 | 186 | 
14716 | 187 |         embed = self.bot.embed(ctx, title="Autorole Config")
14717 | 188 |         embed.add_field(name="Humans", value=humans, inline=False)
14718 | 189 |         embed.add_field(name="Bots", value=bots, inline=False)
14719 | 190 |         await ctx.send(embed=embed)
14720 | 191 | 
14721 | 192 |     @commands.hybrid_command(name="embed")
14722 | 193 |     @commands.has_permissions(manage_messages=True)
14723 | 194 |     async def embed_send(self, ctx: Context, channel: discord.TextChannel):
14724 | 195 |         """
14725 | 196 |         Generate and send embed to specified channel.
14726 | 197 |         """
14727 | 198 |         if not channel.permissions_for(ctx.me).embed_links:
14728 | 199 |             return await ctx.error(f"I need `embed_links` permission in {channel.mention}")
14729 | 200 | 
14730 | 201 |         view = embeds.EmbedBuilder(ctx, items=[EmbedSend(channel), EmbedCancel()])
14731 | 202 |         await view.rendor()
14732 | 203 | 
14733 | 204 |     @commands.command(name="quickembed", aliases=["qe"])
14734 | 205 |     @commands.has_permissions(manage_messages=True, embed_links=True)
14735 | 206 |     @commands.bot_has_permissions(manage_messages=True, embed_links=True)
14736 | 207 |     async def quick_embed_command(self, ctx: Context, *, text: str):
14737 | 208 |         """
14738 | 209 |         Generates quick embeds.
14739 | 210 |         Tip: You can send hyperlinks too. Example: `[anytext](any link)`
14740 | 211 |         """
14741 | 212 |         embed = self.bot.embed(ctx, description=text)
14742 | 213 |         if ctx.message.attachments and "image" in ctx.message.attachments[0].content_type:
14743 | 214 |             embed.set_image(url=ctx.message.attachments[0].proxy_url)
14744 | 215 |         await ctx.send(embed=embed)
14745 | 216 |         await ctx.message.delete()
14746 | 217 | 
14747 | 218 |     @commands.command()
14748 | 219 |     @commands.bot_has_permissions(embed_links=True)
14749 | 220 |     async def snipe(self, ctx: Context, *, channel: typing.Optional[QuoTextChannel]):
14750 | 221 |         """Snipe last deleted message of a channel."""
14751 | 222 | 
14752 | 223 |         channel = channel or ctx.channel
14753 | 224 | 
14754 | 225 |         snipe = await Snipe.get_or_none(channel_id=channel.id)
14755 | 226 |         if not snipe:
14756 | 227 |             return await ctx.error("There's nothing to snipe :c")
14757 | 228 | 
14758 | 229 |         elif snipe.nsfw and not ctx.channel.is_nsfw():
14759 | 230 |             return await ctx.error("The snipe is marked NSFW but the current channel isn't.")
14760 | 231 | 
14761 | 232 |         embed = self.bot.embed(ctx, timestamp=snipe.delete_time)
14762 | 233 |         embed.description = (
14763 | 234 |             f"Message sent by **{snipe.author}** was deleted in **{channel}** \n{discord_timestamp(snipe.delete_time)}\n"
14764 | 235 |             f"\n**__Message Content__**\n{snipe.content}"
14765 | 236 |         )
14766 | 237 | 
14767 | 238 |         embed.set_footer(text="Deleted")
14768 | 239 |         await ctx.send(embed=embed)
14769 | 240 | 
14770 | 241 |     @commands.group(invoke_without_command=True)
14771 | 242 |     async def tag(self, ctx: Context, *, name: typing.Optional[TagConverter]):
14772 | 243 |         """Call a tag with its name or id"""
14773 | 244 |         if name is None:
14774 | 245 |             return await ctx.send_help(ctx.command)
14775 | 246 | 
14776 | 247 |         if name.is_nsfw and not ctx.channel.is_nsfw():
14777 | 248 |             return await ctx.error("This tag can only be used in NSFW channels.")
14778 | 249 | 
14779 | 250 |         if name.is_embed is True:
14780 | 251 |             _dict = leval(name.content)
14781 | 252 |             await ctx.send(embed=discord.Embed.from_dict(_dict), reference=ctx.replied_reference)
14782 | 253 | 
14783 | 254 |         if not name.content:
14784 | 255 |             return await ctx.error("Tag doesn't have any content")
14785 | 256 |         await ctx.send(name.content, reference=ctx.replied_reference)
14786 | 257 |         await increment_usage(ctx, name.name)
14787 | 258 | 
14788 | 259 |     @tag.command(name="raw")
14789 | 260 |     @commands.bot_has_permissions(attach_files=True)
14790 | 261 |     async def raw_tag_content(self, ctx: Context, *, name: TagConverter):
14791 | 262 |         """Get the raw content of the tag"""
14792 | 263 |         if name.is_nsfw and not ctx.channel.is_nsfw():
14793 | 264 |             return await ctx.error("This tag can only be used in NSFW channels.")
14794 | 265 |         if not name.content:
14795 | 266 |             return await ctx.error("Tag does not have any content")
14796 | 267 |         temp = escape_markdown(name.content).replace("<", "\\<")  # why not!?
14797 | 268 |         main = escape_mentions(temp)
14798 | 269 |         if len(main) > 1990:  # for some reason exact `2000` do not work...
14799 | 270 |             file_obj = BytesIO(main.encode())
14800 | 271 |             return await ctx.send(file=discord.File(file_obj, filename="message_too_long.txt"))
14801 | 272 |         await ctx.send(main, allowed_mentions=discord.AllowedMentions.none())
14802 | 273 | 
14803 | 274 |     @tag.command(name="all", aliases=("list",))
14804 | 275 |     async def all_tags(self, ctx: Context, *, member: typing.Optional[QuoMember]):
14805 | 276 |         """Get all tags owned by the server or a member"""
14806 | 277 |         if not member:
14807 | 278 |             tags = await Tag.filter(guild_id=ctx.guild.id)
14808 | 279 | 
14809 | 280 |             if not tags:
14810 | 281 |                 return await ctx.error("This server doesn't have any tags.")
14811 | 282 | 
14812 | 283 |         else:
14813 | 284 |             tags = await Tag.filter(guild_id=ctx.guild.id, owner_id=member.id)
14814 | 285 |             if not tags:
14815 | 286 |                 return await ctx.error(f"{member} doesn't own any tag.")
14816 | 287 | 
14817 | 288 |         paginator = QuoPaginator(ctx, title=f"Total Tags: {len(tags)}", per_page=12)
14818 | 289 | 
14819 | 290 |         for idx, tag in enumerate(tags, start=1):
14820 | 291 |             paginator.add_line(f"`{idx:02}` {escape_markdown(tag.name)} (ID: {tag.id})")
14821 | 292 | 
14822 | 293 |         await paginator.start()
14823 | 294 | 
14824 | 295 |     @tag.command(name="info")
14825 | 296 |     async def tag_info(self, ctx: Context, *, tag: TagConverter):
14826 | 297 |         """Information about a tag"""
14827 | 298 |         embed = self.bot.embed(ctx, title=f"Stats for tag {tag.name}")
14828 | 299 | 
14829 | 300 |         user = self.bot.get_user(tag.owner_id) or await self.bot.fetch_user(tag.owner_id)
14830 | 301 | 
14831 | 302 |         embed.set_author(name=str(user), icon_url=user.display_avatar.url)
14832 | 303 | 
14833 | 304 |         embed.add_field(name="Owner", value=getattr(user, "mention", "Invalid User!"))
14834 | 305 |         embed.add_field(name="ID:", value=tag.id)
14835 | 306 |         embed.add_field(name="Uses", value=tag.usage)
14836 | 307 |         embed.add_field(name="NSFW", value="Yes" if tag.is_nsfw else "No")
14837 | 308 |         embed.add_field(name="Embed", value="Yes" if tag.is_embed else "No")
14838 | 309 |         embed.set_footer(text=f"Created At: {strtime(tag.created_at)}")
14839 | 310 |         await ctx.send(embed=embed)
14840 | 311 | 
14841 | 312 |     @tag.command(name="claim")
14842 | 313 |     async def claim_tag(self, ctx: Context, *, tag: TagConverter):
14843 | 314 |         """Claims a tag if the original owner left the server."""
14844 | 315 |         member = await self.bot.get_or_fetch_member(ctx.guild, tag.owner_id)
14845 | 316 | 
14846 | 317 |         if member is not None:
14847 | 318 |             return await ctx.send(f"The owner of this tag ({tag.owner}) is still in the server.")
14848 | 319 | 
14849 | 320 |         await Tag.filter(name=tag.name, guild_id=ctx.guild.id).update(owner_id=ctx.author.id)
14850 | 321 |         await ctx.success("Transfered tag ownership to you.")
14851 | 322 | 
14852 | 323 |     @tag.command(name="create")
14853 | 324 |     async def create_tag_command(self, ctx: Context, name: TagName, *, content: typing.Optional[str] = ""):
14854 | 325 |         """Create a new tag"""
14855 | 326 |         if content == "" and not ctx.message.attachments:
14856 | 327 |             return await ctx.error("Cannot make an empty tag.")
14857 | 328 | 
14858 | 329 |         if ctx.message.attachments:
14859 | 330 |             content += f"\n{ctx.message.attachments[0].proxy_url}"
14860 | 331 | 
14861 | 332 |         if len(content) > 1990:
14862 | 333 |             return await ctx.error("Tag content cannot contain more than 1990 characters.")
14863 | 334 | 
14864 | 335 |         if len(name) > 99:
14865 | 336 |             return await ctx.error("Tag Name cannot contain more that 99 characters.")
14866 | 337 | 
14867 | 338 |         if await is_valid_name(ctx, name):
14868 | 339 |             tag = await Tag.create(name=name, content=content, guild_id=ctx.guild.id, owner_id=ctx.author.id)
14869 | 340 | 
14870 | 341 |             await ctx.success(f"Created Tag (ID: `{tag.id}`)")
14871 | 342 | 
14872 | 343 |         else:
14873 | 344 |             await ctx.error("Tag Name is already taken.")
14874 | 345 | 
14875 | 346 |     @tag.command(name="delete", aliases=["del"])
14876 | 347 |     async def delete_tag(self, ctx: Context, *, tag: TagConverter):
14877 | 348 |         """Delete a tag"""
14878 | 349 |         tag = tag
14879 | 350 |         if tag.owner_id != ctx.author.id and not ctx.author.guild_permissions.manage_guild:
14880 | 351 |             return await ctx.error("This tag doesn't belong to you.")
14881 | 352 | 
14882 | 353 |         await Tag.filter(guild_id=ctx.guild.id, name=tag.name, owner_id=tag.owner_id).delete()
14883 | 354 |         await ctx.success(f"Deleted {tag.name}")
14884 | 355 | 
14885 | 356 |     @tag.command(name="transfer")
14886 | 357 |     async def transfer_tag(self, ctx: Context, member: QuoMember, *, tag: TagConverter):
14887 | 358 |         """Transfer the ownership of a tag."""
14888 | 359 |         if tag.owner_id != ctx.author.id:
14889 | 360 |             return await ctx.error("This tag doesn't belong to you.")
14890 | 361 | 
14891 | 362 |         await Tag.filter(id=tag.id).update(owner_id=member.id)
14892 | 363 |         await ctx.success("Transfer successful.")
14893 | 364 | 
14894 | 365 |     @tag.command("nsfw")
14895 | 366 |     async def nsfw_status_toggle(self, ctx: Context, *, tag: TagConverter):
14896 | 367 |         """Toggle NSFW for a tag."""
14897 | 368 |         if tag.owner_id != ctx.author.id and not ctx.author.guild_permissions.manage_guild:
14898 | 369 |             return await ctx.error("This tag doesn't belong to you.")
14899 | 370 | 
14900 | 371 |         await Tag.filter(id=tag.id).update(is_nsfw=not tag.is_nsfw)
14901 | 372 |         await ctx.success(f"Tag NSFW toggled {'ON' if not tag.is_nsfw else 'OFF'}!")
14902 | 373 | 
14903 | 374 |     @tag.command("mine")
14904 | 375 |     async def get_all_tags(self, ctx: Context):
14905 | 376 |         """Get a list of all tags owned by you."""
14906 | 377 |         tags = await Tag.filter(guild_id=ctx.guild.id, owner_id=ctx.author.id)
14907 | 378 | 
14908 | 379 |         if not tags:
14909 | 380 |             return await ctx.error("You do not own any tag.")
14910 | 381 | 
14911 | 382 |         paginator = QuoPaginator(ctx, title=f"Tags you own: {len(tags)}", per_page=12)
14912 | 383 | 
14913 | 384 |         for idx, tag in enumerate(tags, start=1):
14914 | 385 |             paginator.add_line(f"`{idx:02}` {escape_markdown(tag.name)} (ID: {tag.id})")
14915 | 386 | 
14916 | 387 |         await paginator.start()
14917 | 388 | 
14918 | 389 |     @tag.command(name="purge")
14919 | 390 |     @commands.has_guild_permissions(manage_guild=True)
14920 | 391 |     async def purge_tags(self, ctx: Context, *, member: QuoMember):
14921 | 392 |         """Delete all the tags of a member"""
14922 | 393 |         count = await Tag.filter(owner_id=member.id, guild_id=ctx.guild.id).count()
14923 | 394 |         if not count:
14924 | 395 |             return await ctx.error(f"{member} doesn't own any tag.")
14925 | 396 | 
14926 | 397 |         await Tag.filter(owner_id=member.id, guild_id=ctx.guild.id).delete()
14927 | 398 |         await ctx.success(f"Deleted {plural(count): tag|tags} of **{member}**.")
14928 | 399 | 
14929 | 400 |     @tag.command(name="edit")
14930 | 401 |     async def edit_tag(self, ctx: Context, name: TagName, *, content: typing.Optional[str] = ""):
14931 | 402 |         """Edit a tag"""
14932 | 403 |         tag = await Tag.get_or_none(name=name, guild_id=ctx.guild.id)
14933 | 404 |         if not tag:
14934 | 405 |             return await ctx.error("Tag name is invalid.")
14935 | 406 | 
14936 | 407 |         if tag.owner_id != ctx.author.id and not ctx.author.guild_permissions.manage_guild:
14937 | 408 |             return await ctx.error("This tag doesn't belong to you.")
14938 | 409 | 
14939 | 410 |         if len(content) > 1990:
14940 | 411 |             return await ctx.error("Tag content cannot exceed 1990 characters.")
14941 | 412 | 
14942 | 413 |         if content == "" and not ctx.message.attachments:
14943 | 414 |             return await ctx.error("Cannot edit tag.")
14944 | 415 | 
14945 | 416 |         if ctx.message.attachments:
14946 | 417 |             content += f"\n{ctx.message.attachments[0].proxy_url}"
14947 | 418 | 
14948 | 419 |         await Tag.filter(id=tag.id).update(content=content)
14949 | 420 |         await ctx.success("Tag updated.")
14950 | 421 | 
14951 | 422 |     # @tag.command(name="make")
14952 | 423 |     # async def tag_make(self, ctx: Context):
14953 | 424 |     #     """Make tags interactively."""
14954 | 425 | 
14955 | 426 |     #     def check(message: discord.Message):
14956 | 427 |     #         if message.content.strip().lower() == "cancel":
14957 | 428 |     #             raise commands.BadArgument("Alright, reverting all process.")
14958 | 429 | 
14959 | 430 |     #         return message.author == ctx.author and ctx.channel == message.channel
14960 | 431 | 
14961 | 432 |     #     msg = await ctx.simple("What do you want the tag name to be?")
14962 | 433 |     #     name = await inputs.string_input(ctx, check, delete_after=True)
14963 | 434 |     #     await inputs.safe_delete(msg)
14964 | 435 | 
14965 | 436 |     #     embed = await ctx.simple(
14966 | 437 |     #         f"What do you want the content to be?\n\n{keycap_digit(1)} | Simple Text\n{keycap_digit(2)} | Embed"
14967 | 438 |     #     )
14968 | 439 |     #     reactions = [keycap_digit(1), keycap_digit(2)]
14969 | 440 |     #     for reaction in reactions:
14970 | 441 |     #         await embed.add_reaction(reaction)
14971 | 442 | 
14972 | 443 |     @tag.command(name="search")
14973 | 444 |     async def search_tag(self, ctx: Context, *, name: str):
14974 | 445 |         """Search in all your tags."""
14975 | 446 |         tags = await Tag.filter(guild_id=ctx.guild.id, name__icontains=name)
14976 | 447 | 
14977 | 448 |         if not tags:
14978 | 449 |             return await ctx.error("No tags found.")
14979 | 450 | 
14980 | 451 |         paginator = QuoPaginator(ctx, title=f"Matching Tags: {len(tags)}", per_page=10)
14981 | 452 |         for idx, tag in enumerate(tags, start=1):
14982 | 453 |             paginator.add_line(f"`{idx:02}` {tag.name} (ID: {tag.id})")
14983 | 454 | 
14984 | 455 |         await paginator.start()
14985 | 456 | 
14986 | 457 |     @tag.command(name="stats")
14987 | 458 |     async def tag_stats(self, ctx: Context, *, member: typing.Optional[QuoMember]):
14988 | 459 |         """Tag statistics of the server or a member."""
14989 | 460 |         if member:
14990 | 461 |             await member_tag_stats(ctx, member)
14991 | 462 |         else:
14992 | 463 |             await guild_tag_stats(ctx)
14993 | 464 | 
14994 | 465 |     @commands.group(invoke_without_command=True)
14995 | 466 |     async def category(self, ctx: Context):
14996 | 467 |         """hide , delete , unhide or even nuke a category"""
14997 | 468 |         await ctx.send_help(ctx.command)
14998 | 469 | 
14999 | 470 |     @category.command(name="delete")
15000 | 471 |     @commands.has_permissions(manage_channels=True, manage_guild=True)
15001 | 472 |     @commands.bot_has_permissions(manage_channels=True)
15002 | 473 |     async def category_delete(self, ctx: Context, *, category: QuoCategory):
15003 | 474 |         """Delete a category and all the channels under it."""
15004 | 475 |         if not category.channels:
15005 | 476 |             return await ctx.error(f"**{category}** doesn't have any channels.")
15006 | 477 | 
15007 | 478 |         prompt = await ctx.prompt(
15008 | 479 |             message=f"All channels under the category `{category}` will be deleted.\nAre you sure you want to continue?"
15009 | 480 |         )
15010 | 481 |         if prompt:
15011 | 482 |             failed, success = 0, 0
15012 | 483 | 
15013 | 484 |             for channel in category.channels:
15014 | 485 |                 try:
15015 | 486 |                     await channel.delete()
15016 | 487 |                     success += 1
15017 | 488 |                 except discord.HTTPException:
15018 | 489 |                     failed += 1
15019 | 490 |                     continue
15020 | 491 | 
15021 | 492 |             await category.delete()
15022 | 493 | 
15023 | 494 |             with suppress(
15024 | 495 |                 discord.Forbidden, commands.ChannelNotFound, discord.NotFound, commands.CommandInvokeError
15025 | 496 |             ):  # yes all these will be raised if the channel is from ones we deleted earlier.
15026 | 497 |                 await ctx.success(f"Successfully deleted **{category}**. (Deleted: `{success}`, Failed: `{failed}`)")
15027 | 498 | 
15028 | 499 |         else:
15029 | 500 |             await ctx.simple("Ok Aborting.")
15030 | 501 | 
15031 | 502 |     @category.command(name="hide")
15032 | 503 |     @commands.has_permissions(manage_channels=True, manage_guild=True)
15033 | 504 |     @commands.bot_has_permissions(manage_channels=True)
15034 | 505 |     async def category_hide(self, ctx: Context, *, category: QuoCategory):
15035 | 506 |         """Hide a category and all its channels"""
15036 | 507 |         if not category.channels:
15037 | 508 |             return await ctx.error(f"**{category}** doesn't have any channels.")
15038 | 509 | 
15039 | 510 |         prompt = await ctx.prompt(
15040 | 511 |             message=f"All channels under the category `{category}` will be hidden.\nAre you sure you want to continue?"
15041 | 512 |         )
15042 | 513 |         if prompt:
15043 | 514 |             failed, success = 0, 0
15044 | 515 | 
15045 | 516 |             for channel in category.channels:
15046 | 517 |                 try:
15047 | 518 |                     perms = channel.overwrites_for(ctx.guild.default_role)
15048 | 519 |                     perms.read_messages = False
15049 | 520 |                     await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
15050 | 521 |                     success += 1
15051 | 522 |                 except discord.HTTPException:
15052 | 523 |                     failed += 1
15053 | 524 |                     continue
15054 | 525 | 
15055 | 526 |             await ctx.success(f"Successfully hidden category. (Hidden: `{success}`, Failed: `{failed}`)")
15056 | 527 | 
15057 | 528 |         else:
15058 | 529 |             await ctx.simple("Ok Aborting.")
15059 | 530 | 
15060 | 531 |     @category.command(name="unhide")
15061 | 532 |     @commands.has_permissions(manage_channels=True, manage_guild=True)
15062 | 533 |     @commands.bot_has_permissions(manage_channels=True)
15063 | 534 |     async def category_unhide(self, ctx: Context, *, category: QuoCategory):
15064 | 535 |         """Unhide a hidden category and all its channels."""
15065 | 536 |         if not category.channels:
15066 | 537 |             return await ctx.error(f"**{category}** doesn't have any channels.")
15067 | 538 | 
15068 | 539 |         prompt = await ctx.prompt(
15069 | 540 |             message=f"All channels under the category `{category}` will be unhidden.\nAre you sure you want to continue?"
15070 | 541 |         )
15071 | 542 |         if prompt:
15072 | 543 |             failed, success = 0, 0
15073 | 544 | 
15074 | 545 |             for channel in category.channels:
15075 | 546 |                 try:
15076 | 547 |                     perms = channel.overwrites_for(ctx.guild.default_role)
15077 | 548 |                     perms.read_messages = True
15078 | 549 |                     await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
15079 | 550 |                     success += 1
15080 | 551 |                 except discord.HTTPException:
15081 | 552 |                     failed += 1
15082 | 553 |                     continue
15083 | 554 | 
15084 | 555 |             await ctx.success(f"Successfully unhidden **{category}**. (Unhidden: `{success}`, Failed: `{failed}`)")
15085 | 556 | 
15086 | 557 |         else:
15087 | 558 |             await ctx.simple("Ok Aborting.")
15088 | 559 | 
15089 | 560 |     @category.command(name="nuke")
15090 | 561 |     @commands.has_permissions(manage_channels=True, manage_guild=True)
15091 | 562 |     @commands.bot_has_permissions(manage_channels=True)
15092 | 563 |     async def category_nuke(self, ctx: Context, *, category: QuoCategory):
15093 | 564 |         """
15094 | 565 |         Delete a category completely and create a new one
15095 | 566 |         This will delete all the channels under the category and will make a new one with same perms and channels.
15096 | 567 |         """
15097 | 568 |         if not category.channels:
15098 | 569 |             return await ctx.error(f"**{category}** doesn't have any channels.")
15099 | 570 | 
15100 | 571 |         prompt = await ctx.prompt(
15101 | 572 |             message=f"All channels under the category `{category}` will be cloned and deleted.\nAre you sure you want to continue?"
15102 | 573 |         )
15103 | 574 |         if prompt:
15104 | 575 |             failed, success = 0, 0
15105 | 576 |             for channel in category.channels:
15106 | 577 |                 if channel.permissions_for(ctx.me).manage_channels:
15107 | 578 |                     try:
15108 | 579 |                         position = channel.position
15109 | 580 |                         clone = await channel.clone(reason=f"Action done by {ctx.author}")
15110 | 581 |                         await channel.delete()
15111 | 582 |                         await clone.edit(position=position)
15112 | 583 |                         success += 1
15113 | 584 |                     except discord.HTTPException:
15114 | 585 |                         failed += 1
15115 | 586 |                         continue
15116 | 587 | 
15117 | 588 |             await ctx.success(f"Successfully nuked **{category}**. (Cloned: `{success}`, Failed: `{failed}`)")
15118 | 589 | 
15119 | 590 |         else:
15120 | 591 |             await ctx.simple("Ok Aborting.")
15121 | 592 | 
15122 | 593 |     @commands.group(invoke_without_command=True)
15123 | 594 |     async def autopurge(self, ctx: Context):
15124 | 595 |         """
15125 | 596 |         Set Quotient to delete every new message in a channel after  a specific interval.
15126 | 597 |         """
15127 | 598 |         await ctx.send_help(ctx.command)
15128 | 599 | 
15129 | 600 |     @autopurge.command(name="set")
15130 | 601 |     @commands.has_permissions(manage_messages=True)
15131 | 602 |     async def autopurge_set(self, ctx: Context, channel: QuoTextChannel, delete_after: str):
15132 | 603 |         """
15133 | 604 |         Set the autopurge for a channel
15134 | 605 |         `delete_after` should be in this format: s|m|h|d
15135 | 606 |         """
15136 | 607 |         if not channel.permissions_for(ctx.me).manage_messages:
15137 | 608 |             return await ctx.error("I don't have `manage messages` permission in {0}".format(channel.mention))
15138 | 609 | 
15139 | 610 |         seconds = simple_convert(delete_after)
15140 | 611 | 
15141 | 612 |         if seconds <= 5 or seconds > 604800:
15142 | 613 |             return await ctx.error("Delete Time must be more than 5s and less than 7d.")
15143 | 614 | 
15144 | 615 |         if (count := await AutoPurge.filter(guild_id=ctx.guild.id).count()) >= 1 and not await ctx.is_premium_guild():
15145 | 616 |             return await ctx.error(
15146 | 617 |                 "You cannot set autopurge in more than 1 channel in free tier."
15147 | 618 |                 f"\nHowever [Quotient Premium]({ctx.bot.prime_link}) allows you to set autopurge in unlimited channels."
15148 | 619 |             )
15149 | 620 | 
15150 | 621 |         if channel.id in self.bot.cache.autopurge_channels:
15151 | 622 |             return await ctx.error(f"**{channel}** is already an autopurge channel.")
15152 | 623 | 
15153 | 624 |         await AutoPurge.create(guild_id=ctx.guild.id, channel_id=channel.id, delete_after=seconds)
15154 | 625 |         self.bot.cache.autopurge_channels.add(channel.id)
15155 | 626 |         await ctx.success(f"**{channel}** added to autopurge channels.")
15156 | 627 | 
15157 | 628 |     @autopurge.command(name="list")
15158 | 629 |     @commands.has_permissions(manage_messages=True)
15159 | 630 |     async def autopurge_config(self, ctx: Context):
15160 | 631 |         """Get a list of all autopurge channels"""
15161 | 632 |         records = await AutoPurge.filter(guild_id=ctx.guild.id)
15162 | 633 |         if not records:
15163 | 634 |             return await ctx.error("This server doesn't have any autopurge channels.")
15164 | 635 | 
15165 | 636 |         text = "".join(
15166 | 637 |             f"`{idx:02}` | {getattr(record.channel, 'mention', 'Deleted Channel')} ({precisedelta(timedelta(seconds=record.delete_after))})\n"
15167 | 638 |             for idx, record in enumerate(records, start=1)
15168 | 639 |         )
15169 | 640 |         await ctx.send(embed=self.bot.embed(ctx, description=text, title="AutoPurge List"), embed_perms=True)
15170 | 641 | 
15171 | 642 |     @autopurge.command(name="remove")
15172 | 643 |     @commands.has_permissions(manage_messages=True)
15173 | 644 |     async def autopurge_remove(self, ctx: Context, *, channel: QuoTextChannel):
15174 | 645 |         """Remove a channel from autopurge"""
15175 | 646 |         if channel.id not in self.bot.cache.autopurge_channels:
15176 | 647 |             return await ctx.error(f"{channel} is not an autopurge channel.")
15177 | 648 | 
15178 | 649 |         self.bot.cache.autopurge_channels.discard(channel.id)
15179 | 650 |         await AutoPurge.filter(channel_id=channel.id, guild_id=ctx.guild.id).delete()
15180 | 651 |         await ctx.success(f"**{channel}** removed from autopurge channels.")
15181 | 652 | 
15182 | 653 | 
15183 | 654 | async def setup(bot: Quotient) -> None:
15184 | 655 |     await bot.add_cog(Utility(bot))
15185 | 656 |     await bot.add_cog(AutoPurgeEvents(bot))
15186 | 657 |     await bot.add_cog(ReminderEvents(bot))
15187 | 658 | 
15188 | 
15189 | 
15190 | --------------------------------------------------------------------------------
15191 | /cogs/utility/events/__init__.py:
15192 | --------------------------------------------------------------------------------
15193 | 1 | from .autopurge import AutoPurgeEvents
15194 | 2 | from .reminder import ReminderEvents
15195 | 3 | 
15196 | 
15197 | 
15198 | --------------------------------------------------------------------------------
15199 | /cogs/utility/events/autopurge.py:
15200 | --------------------------------------------------------------------------------
15201 |  1 | from __future__ import annotations
15202 |  2 | 
15203 |  3 | import typing
15204 |  4 | 
15205 |  5 | if typing.TYPE_CHECKING:
15206 |  6 |     from core import Quotient
15207 |  7 | 
15208 |  8 | from contextlib import suppress
15209 |  9 | from datetime import datetime, timedelta
15210 | 10 | 
15211 | 11 | import discord
15212 | 12 | 
15213 | 13 | from constants import IST
15214 | 14 | from core import Cog
15215 | 15 | from models import AutoPurge, Snipe, Timer
15216 | 16 | 
15217 | 17 | 
15218 | 18 | class AutoPurgeEvents(Cog):
15219 | 19 |     def __init__(self, bot: Quotient):
15220 | 20 |         self.bot = bot
15221 | 21 |         self.bot.loop.create_task(self.delete_older_snipes())
15222 | 22 | 
15223 | 23 |     async def delete_older_snipes(self):  # we delete snipes that are older than 10 days
15224 | 24 |         await self.bot.wait_until_ready()
15225 | 25 |         await Snipe.filter(delete_time__lte=(datetime.now(tz=IST) - timedelta(days=10))).delete()
15226 | 26 | 
15227 | 27 |     @Cog.listener()
15228 | 28 |     async def on_message_delete(self, message: discord.Message):
15229 | 29 |         if not message.guild or message.author.bot:
15230 | 30 |             return
15231 | 31 | 
15232 | 32 |         channel = message.channel
15233 | 33 |         content = message.content if message.content else "*[Content Unavailable]*"
15234 | 34 | 
15235 | 35 |         if not channel.type in (
15236 | 36 |             discord.ChannelType.text,
15237 | 37 |             discord.ChannelType.private_thread,
15238 | 38 |             discord.ChannelType.public_thread,
15239 | 39 |         ):
15240 | 40 |             return
15241 | 41 | 
15242 | 42 |         await Snipe.update_or_create(
15243 | 43 |             channel_id=channel.id,
15244 | 44 |             defaults={
15245 | 45 |                 "author_id": message.author.id,
15246 | 46 |                 "content": content,
15247 | 47 |                 "nsfw": channel.is_nsfw(),
15248 | 48 |             },
15249 | 49 |         )
15250 | 50 | 
15251 | 51 |     @Cog.listener()
15252 | 52 |     async def on_message(self, message: discord.Message):
15253 | 53 |         if not message.guild or not message.channel.id in self.bot.cache.autopurge_channels:
15254 | 54 |             return
15255 | 55 | 
15256 | 56 |         record = await AutoPurge.get_or_none(channel_id=message.channel.id)
15257 | 57 |         if not record:
15258 | 58 |             return self.bot.cache.autopurge_channels.discard(message.channel.id)
15259 | 59 | 
15260 | 60 |         await self.bot.reminders.create_timer(
15261 | 61 |             datetime.now(tz=IST) + timedelta(seconds=record.delete_after),
15262 | 62 |             "autopurge",
15263 | 63 |             message_id=message.id,
15264 | 64 |             channel_id=message.channel.id,
15265 | 65 |         )
15266 | 66 | 
15267 | 67 |     @Cog.listener()
15268 | 68 |     async def on_autopurge_timer_complete(self, timer: Timer):
15269 | 69 |         message_id, channel_id = timer.kwargs["message_id"], timer.kwargs["channel_id"]
15270 | 70 | 
15271 | 71 |         check = await AutoPurge.get_or_none(channel_id=channel_id)
15272 | 72 |         if not check:
15273 | 73 |             return
15274 | 74 | 
15275 | 75 |         channel = check.channel
15276 | 76 |         if not channel:
15277 | 77 |             return
15278 | 78 | 
15279 | 79 |         message = channel.get_partial_message(message_id)
15280 | 80 |         with suppress(discord.NotFound, discord.Forbidden, discord.HTTPException):
15281 | 81 |             msg = await message.fetch()
15282 | 82 |             if not msg.pinned:
15283 | 83 |                 await msg.delete()
15284 | 84 | 
15285 | 85 |     @Cog.listener()
15286 | 86 |     async def on_guild_channel_delete(self, channel: discord.TextChannel):
15287 | 87 |         if channel.id in self.bot.cache.autopurge_channels:
15288 | 88 |             await AutoPurge.filter(channel_id=channel.id).delete()
15289 | 89 |             self.bot.cache.autopurge_channels.discard(channel.id)
15290 | 90 | 
15291 | 
15292 | 
15293 | --------------------------------------------------------------------------------
15294 | /cogs/utility/events/reminder.py:
15295 | --------------------------------------------------------------------------------
15296 |  1 | from __future__ import annotations
15297 |  2 | 
15298 |  3 | import typing
15299 |  4 | 
15300 |  5 | if typing.TYPE_CHECKING:
15301 |  6 |     from core import Quotient
15302 |  7 | 
15303 |  8 | from contextlib import suppress
15304 |  9 | 
15305 | 10 | import discord
15306 | 11 | 
15307 | 12 | from core import Cog
15308 | 13 | from models import Timer
15309 | 14 | from utils import discord_timestamp
15310 | 15 | 
15311 | 16 | 
15312 | 17 | class ReminderEvents(Cog):
15313 | 18 |     def __init__(self, bot: Quotient):
15314 | 19 |         self.bot = bot
15315 | 20 | 
15316 | 21 |     @Cog.listener()
15317 | 22 |     async def on_reminder_timer_complete(self, timer: Timer):
15318 | 23 |         author_id, channel_id, message = timer.args
15319 | 24 | 
15320 | 25 |         try:
15321 | 26 |             channel = self.bot.get_channel(channel_id) or (await self.bot.fetch_channel(channel_id))
15322 | 27 |         except discord.HTTPException:
15323 | 28 |             return
15324 | 29 | 
15325 | 30 |         guild_id = channel.guild.id if isinstance(channel, (discord.TextChannel, discord.Thread)) else "@me"
15326 | 31 |         message_id = timer.kwargs["message_id"]
15327 | 32 |         msg = f"{discord_timestamp(timer.created)}: {message}"
15328 | 33 | 
15329 | 34 |         jump_url = f"https://discord.com/channels/{guild_id}/{channel.id}/{message_id}"
15330 | 35 | 
15331 | 36 |         v = discord.ui.View(timeout=None)
15332 | 37 |         v.add_item(discord.ui.Button(label="Jump to Original Message", url=jump_url, style=discord.ButtonStyle.link))
15333 | 38 | 
15334 | 39 |         embed = discord.Embed(
15335 | 40 |             color=self.bot.color,
15336 | 41 |             title=f"Reminder #{timer.id}",
15337 | 42 |             description=msg,
15338 | 43 |             url=jump_url,
15339 | 44 |             timestamp=self.bot.current_time,
15340 | 45 |         )
15341 | 46 | 
15342 | 47 |         with suppress(discord.HTTPException, discord.Forbidden, AttributeError):
15343 | 48 |             await channel.send(f"<@{author_id}>", embed=embed, view=v)
15344 | 49 | 
15345 | 
15346 | 
15347 | --------------------------------------------------------------------------------
15348 | /cogs/utility/functions.py:
15349 | --------------------------------------------------------------------------------
15350 |   1 | from discord.ext import commands
15351 |   2 | 
15352 |   3 | from core import Context
15353 |   4 | from models import Tag
15354 |   5 | from utils.converters import QuoMember
15355 |   6 | 
15356 |   7 | 
15357 |   8 | class TagName(commands.clean_content):
15358 |   9 |     def __init__(self, *, lower=False):
15359 |  10 |         self.lower = lower
15360 |  11 |         super().__init__()
15361 |  12 | 
15362 |  13 |     async def convert(self, ctx, argument):
15363 |  14 |         converted = await super().convert(ctx, argument)
15364 |  15 |         lower = converted.lower().strip()
15365 |  16 | 
15366 |  17 |         if not lower:
15367 |  18 |             raise commands.BadArgument("Missing tag name.")
15368 |  19 | 
15369 |  20 |         if len(lower) > 100:
15370 |  21 |             raise commands.BadArgument("Tag name is a maximum of 100 characters.")
15371 |  22 | 
15372 |  23 |         first_word, _, _ = lower.partition(" ")
15373 |  24 | 
15374 |  25 |         root = ctx.bot.get_command("tag")
15375 |  26 |         if first_word in root.all_commands:
15376 |  27 |             raise commands.BadArgument("This tag name starts with a reserved word.")
15377 |  28 | 
15378 |  29 |         return converted if not self.lower else lower
15379 |  30 | 
15380 |  31 | 
15381 |  32 | class TagConverter(commands.Converter):
15382 |  33 |     async def convert(self, ctx, argument: str):
15383 |  34 |         try:
15384 |  35 |             argument = int(argument)
15385 |  36 |             tag = await Tag.get_or_none(id=argument, guild_id=ctx.guild.id)
15386 |  37 | 
15387 |  38 |         except ValueError:
15388 |  39 |             tag = await Tag.get_or_none(guild_id=ctx.guild.id, name=argument)
15389 |  40 | 
15390 |  41 |         if not tag:
15391 |  42 |             search = await Tag.filter(guild_id=ctx.guild.id, name__icontains=argument).limit(3)
15392 |  43 |             text = f"**{argument}** is not a valid Tag Name or ID."
15393 |  44 |             if search:
15394 |  45 |                 tags = "\n".join((f"- {tag.name}" for tag in search))
15395 |  46 |                 text += f"\n\nMaybe you were looking for:\n{tags}"
15396 |  47 |             raise commands.BadArgument(text)
15397 |  48 | 
15398 |  49 |         return tag
15399 |  50 | 
15400 |  51 | 
15401 |  52 | async def is_valid_name(ctx: Context, name: str) -> bool:
15402 |  53 |     tag = await Tag.get_or_none(name=name, guild_id=ctx.guild.id)
15403 |  54 | 
15404 |  55 |     return not tag
15405 |  56 | 
15406 |  57 | 
15407 |  58 | async def increment_usage(ctx: Context, name) -> None:
15408 |  59 |     query = "UPDATE tags SET usage = usage + 1 WHERE guild_id = $1 AND name = $2"
15409 |  60 |     await ctx.db.execute(query, ctx.guild.id, name)
15410 |  61 | 
15411 |  62 | 
15412 |  63 | def emojize(seq):
15413 |  64 |     emoji = 129351
15414 |  65 |     for index, value in enumerate(seq):
15415 |  66 |         yield chr(emoji + index), value
15416 |  67 | 
15417 |  68 | 
15418 |  69 | async def guild_tag_stats(ctx: Context):
15419 |  70 |     e = ctx.bot.embed(ctx, title="Tag Stats")
15420 |  71 |     e.set_footer(text="These statistics are server-specific.")
15421 |  72 | 
15422 |  73 |     records = await Tag.filter(guild_id=ctx.guild.id).all().order_by("-usage").only("id", "name", "usage").limit(3)
15423 |  74 | 
15424 |  75 |     if not records:
15425 |  76 |         e.description = "No tag statistics here."
15426 |  77 | 
15427 |  78 |     else:
15428 |  79 |         e.description = f"{len(records)} tags, {sum(t.usage for t in records)} tag uses"
15429 |  80 | 
15430 |  81 |     value = "\n".join(f"{emoji}: {tag.name} ({tag.usage} uses)" for (emoji, (tag)) in emojize(records))
15431 |  82 | 
15432 |  83 |     e.add_field(name="Top Tags", value=value, inline=False)
15433 |  84 | 
15434 |  85 |     query = """SELECT
15435 |  86 |                     COUNT(*) AS tag_uses,
15436 |  87 |                     user_id
15437 |  88 |                    FROM commands
15438 |  89 |                    WHERE guild_id=$1 AND cmd='tag'
15439 |  90 |                    GROUP BY user_id
15440 |  91 |                    ORDER BY COUNT(*) DESC
15441 |  92 |                    LIMIT 3;
15442 |  93 |                 """
15443 |  94 | 
15444 |  95 |     records = await ctx.db.fetch(query, ctx.guild.id)
15445 |  96 | 
15446 |  97 |     if len(records) < 3:
15447 |  98 |         records.extend((None, None) for _ in range(3 - len(records)))
15448 |  99 | 
15449 | 100 |     value = "\n".join(
15450 | 101 |         f"{emoji}: <@{author_id}> ({uses} times)" if author_id else f"{emoji}: No one!"
15451 | 102 |         for (emoji, (uses, author_id)) in emojize(records)
15452 | 103 |     )
15453 | 104 | 
15454 | 105 |     e.add_field(name="Top Tag Users", value=value, inline=False)
15455 | 106 | 
15456 | 107 |     query = """SELECT
15457 | 108 |                        COUNT(*) AS "Tags",
15458 | 109 |                        owner_id
15459 | 110 |                    FROM tags
15460 | 111 |                    WHERE guild_id=$1
15461 | 112 |                    GROUP BY owner_id
15462 | 113 |                    ORDER BY COUNT(*) DESC
15463 | 114 |                    LIMIT 3;
15464 | 115 |                 """
15465 | 116 |     # I don't think they made group_by clause in tortoise
15466 | 117 |     records = await ctx.db.fetch(query, ctx.guild.id)
15467 | 118 |     if not records:
15468 | 119 |         text = "No statistics to show here."
15469 | 120 |     else:
15470 | 121 |         value = "\n".join(f"{emoji}: <@{owner_id}> ({count} tags)" for (emoji, (count, owner_id)) in emojize(records))
15471 | 122 | 
15472 | 123 |     e.add_field(name="Top Tag Creators", value=value, inline=False)
15473 | 124 |     await ctx.send(embed=e, embed_perms=True)
15474 | 125 | 
15475 | 126 | 
15476 | 127 | async def member_tag_stats(ctx: Context, member: QuoMember):
15477 | 128 |     e = ctx.bot.embed(ctx)
15478 | 129 |     e.set_author(name=str(member), icon_url=member.display_avatar.url)
15479 | 130 | 
15480 | 131 |     e.set_footer(text="These statistics are server-specific.")
15481 | 132 | 
15482 | 133 |     query = """SELECT COUNT(*)
15483 | 134 |                    FROM commands
15484 | 135 |                    WHERE guild_id=$1 AND cmd='tag' AND user_id=$2
15485 | 136 |                 """
15486 | 137 | 
15487 | 138 |     count = await ctx.db.fetchrow(query, ctx.guild.id, member.id)
15488 | 139 | 
15489 | 140 |     query = """SELECT
15490 | 141 |                     name,
15491 | 142 |                     usage,
15492 | 143 |                     COUNT(*) OVER() AS "Count",
15493 | 144 |                     SUM(usage) OVER () AS "Uses"
15494 | 145 |                 FROM tags
15495 | 146 |                 WHERE guild_id=$1 AND owner_id=$2
15496 | 147 |                 ORDER BY usage DESC
15497 | 148 |                 LIMIT 3;
15498 | 149 |                 """
15499 | 150 | 
15500 | 151 |     records = await ctx.db.fetch(query, ctx.guild.id, member.id)
15501 | 152 | 
15502 | 153 |     if len(records) > 1:
15503 | 154 |         owned = records[0]["Count"]
15504 | 155 |         uses = records[0]["Uses"]
15505 | 156 |     else:
15506 | 157 |         owned = "None"
15507 | 158 |         uses = 0
15508 | 159 | 
15509 | 160 |     e.add_field(name="Owned Tags", value=owned)
15510 | 161 |     e.add_field(name="Owned Tag Uses", value=uses)
15511 | 162 |     e.add_field(name="Tag Command Uses", value=count[0])
15512 | 163 | 
15513 | 164 |     if len(records) < 3:
15514 | 165 |         records.extend((None, None, None, None) for _ in range(3 - len(records)))
15515 | 166 | 
15516 | 167 |     emoji = 129351
15517 | 168 | 
15518 | 169 |     for offset, (name, uses, _, _) in enumerate(records):
15519 | 170 |         value = f"{name} ({uses} uses)" if name else "Nothing!"
15520 | 171 |         e.add_field(name=f"{chr(emoji + offset)} Owned Tag", value=value)
15521 | 172 | 
15522 | 173 |     await ctx.send(embed=e, embed_perms=True)
15523 | 174 | 
15524 | 
15525 | 
15526 | --------------------------------------------------------------------------------
15527 | /cogs/utility/views/__init__.py:
15528 | --------------------------------------------------------------------------------
15529 | 1 | from .embeds import *
15530 | 2 | 
15531 | 
15532 | 
15533 | --------------------------------------------------------------------------------
15534 | /cogs/utility/views/embeds.py:
15535 | --------------------------------------------------------------------------------
15536 |  1 | from __future__ import annotations
15537 |  2 | 
15538 |  3 | import typing as T
15539 |  4 | 
15540 |  5 | import discord
15541 |  6 | 
15542 |  7 | from core.embeds import EmbedBuilder
15543 |  8 | from utils import emote
15544 |  9 | 
15545 | 10 | __all__ = ("EmbedSend", "EmbedCancel")
15546 | 11 | 
15547 | 12 | 
15548 | 13 | class EmbedSend(discord.ui.Button):
15549 | 14 |     view: EmbedBuilder
15550 | 15 | 
15551 | 16 |     def __init__(self, channel: discord.TextChannel):
15552 | 17 |         self.channel = channel
15553 | 18 |         super().__init__(label="Send to #{0}".format(channel.name), style=discord.ButtonStyle.green)
15554 | 19 | 
15555 | 20 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
15556 | 21 |         user = interaction.user
15557 | 22 |         if not self.channel.permissions_for(user).send_messages:
15558 | 23 |             return await interaction.response.send_message(
15559 | 24 |                 f"You do not have the `send_messages` permission for the {self.channel.mention} channel."
15560 | 25 |             )
15561 | 26 | 
15562 | 27 |         try:
15563 | 28 |             m: T.Optional[discord.Message] = await self.channel.send(embed=self.view.embed)
15564 | 29 | 
15565 | 30 |         except Exception as e:
15566 | 31 |             await interaction.response.send_message(f"An error occured: {e}", ephemeral=True)
15567 | 32 | 
15568 | 33 |         else:
15569 | 34 |             await interaction.response.send_message(
15570 | 35 |                 f"{emote.check} | Embed was sent to {self.channel.mention} ([Jump URL](<{m.jump_url}>))", ephemeral=True
15571 | 36 |             )
15572 | 37 |             await self.view.on_timeout()
15573 | 38 | 
15574 | 39 | 
15575 | 40 | class EmbedCancel(discord.ui.Button):
15576 | 41 |     view: EmbedBuilder
15577 | 42 | 
15578 | 43 |     def __init__(self):
15579 | 44 |         super().__init__(label="Cancel", style=discord.ButtonStyle.red)
15580 | 45 | 
15581 | 46 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
15582 | 47 |         await interaction.response.send_message(f"{emote.xmark} | Embed sending cancelled.", ephemeral=True)
15583 | 48 |         await self.view.on_timeout()
15584 | 49 | 
15585 | 
15586 | 
15587 | --------------------------------------------------------------------------------
15588 | /config.py:
15589 | --------------------------------------------------------------------------------
15590 |  1 | # for tortoise-orm
15591 |  2 | 
15592 |  3 | TORTOISE = {}
15593 |  4 | 
15594 |  5 | 
15595 |  6 | POSTGRESQL = {}
15596 |  7 | 
15597 |  8 | EXTENSIONS = ()
15598 |  9 | 
15599 | 10 | DISCORD_TOKEN = ""
15600 | 11 | 
15601 | 12 | COLOR = 0x00FFB3
15602 | 13 | 
15603 | 14 | FOOTER = "quo is lub!"
15604 | 15 | 
15605 | 16 | PREFIX = "q"
15606 | 17 | 
15607 | 18 | SERVER_LINK = ""
15608 | 19 | 
15609 | 20 | BOT_INVITE = ""
15610 | 21 | 
15611 | 22 | WEBSITE = ""
15612 | 23 | 
15613 | 24 | REPOSITORY = ""
15614 | 25 | 
15615 | 26 | DEVS = ()
15616 | 27 | 
15617 | 28 | # LOGS
15618 | 29 | SHARD_LOG = ""
15619 | 30 | ERROR_LOG = ""
15620 | 31 | PUBLIC_LOG = ""
15621 | 32 | 
15622 | 
15623 | 
15624 | --------------------------------------------------------------------------------
15625 | /constants.py:
15626 | --------------------------------------------------------------------------------
15627 |   1 | import random
15628 |   2 | from contextlib import suppress
15629 |   3 | from datetime import datetime, timedelta
15630 |   4 | from enum import Enum
15631 |   5 | 
15632 |   6 | import discord
15633 |   7 | import pytz
15634 |   8 | 
15635 |   9 | import config
15636 |  10 | 
15637 |  11 | 
15638 |  12 | class _Sentinel:
15639 |  13 |     def __repr__(self):
15640 |  14 |         return "<MISSING>"
15641 |  15 | 
15642 |  16 | 
15643 |  17 | class Day(Enum):
15644 |  18 |     monday = "monday"
15645 |  19 |     tuesday = "tuesday"
15646 |  20 |     wednesday = "wednesday"
15647 |  21 |     thursday = "thursday"
15648 |  22 |     friday = "friday"
15649 |  23 |     saturday = "saturday"
15650 |  24 |     sunday = "sunday"
15651 |  25 | 
15652 |  26 | 
15653 |  27 | class PremiumPurchase(Enum):
15654 |  28 |     GIFT = "gift"
15655 |  29 |     PARTNERSHIP = "partner"
15656 |  30 |     SHOP = "shop"
15657 |  31 |     REGULAR = "regular"
15658 |  32 | 
15659 |  33 | 
15660 |  34 | class PartnerRequest(Enum):
15661 |  35 |     pending = "1"
15662 |  36 |     approved = "2"
15663 |  37 |     denied = "3"
15664 |  38 | 
15665 |  39 | 
15666 |  40 | class EsportsType(Enum):
15667 |  41 |     tourney = "tourney"
15668 |  42 |     scrim = "scrim"
15669 |  43 | 
15670 |  44 | 
15671 |  45 | class AutocleanType(Enum):
15672 |  46 |     channel = "channel"
15673 |  47 |     role = "role"
15674 |  48 | 
15675 |  49 | 
15676 |  50 | class SSType(Enum):
15677 |  51 |     yt = "youtube"
15678 |  52 |     insta = "instagram"
15679 |  53 |     rooter = "rooter"
15680 |  54 |     loco = "loco"
15681 |  55 |     anyss = "Any SS"
15682 |  56 |     custom = "custom"
15683 |  57 | 
15684 |  58 | 
15685 |  59 | class EsportsLog(Enum):
15686 |  60 |     open = "open"
15687 |  61 |     closed = "closed"
15688 |  62 |     success = "reg_success"
15689 |  63 | 
15690 |  64 | 
15691 |  65 | class EsportsRole(Enum):
15692 |  66 |     ping = "ping_role"
15693 |  67 |     open = "open_role"
15694 |  68 | 
15695 |  69 | 
15696 |  70 | class RegDeny(Enum):
15697 |  71 |     botmention = "mentioned bots"
15698 |  72 |     nomention = "insufficient mentions"
15699 |  73 |     banned = "banned"
15700 |  74 |     multiregister = "multiregister"
15701 |  75 |     noteamname = "no_team_name"
15702 |  76 |     reqperms = "lack_permissions"
15703 |  77 |     duplicate = "duplicate_name"
15704 |  78 |     bannedteammate = "banned_teammate"
15705 |  79 |     nolines = "no_lines"
15706 |  80 |     faketag = "fake_tag"
15707 |  81 | 
15708 |  82 | 
15709 |  83 | class RegMsg(Enum):
15710 |  84 |     sopen = "Scrim Registration Open"
15711 |  85 |     sclose = "Scrim Registration Close"
15712 |  86 |     topen = "Tourney Registration Open"
15713 |  87 |     tclose = "Tourney Registration Close"
15714 |  88 | 
15715 |  89 | 
15716 |  90 | class LockType(Enum):
15717 |  91 |     channel = "channel"
15718 |  92 |     guild = "guild"
15719 |  93 |     category = "category"
15720 |  94 |     maintenance = "maintenance"
15721 |  95 | 
15722 |  96 | 
15723 |  97 | class ScrimBanType(Enum):
15724 |  98 |     ban = "banned"
15725 |  99 |     unban = "unbanned"
15726 | 100 | 
15727 | 101 | 
15728 | 102 | bot_colors = {
15729 | 103 |     746348747918934096: 0x00FFB3,
15730 | 104 |     744990850064580660: 0xF3B82B,
15731 | 105 |     846339012607082506: 0x87EA5C,
15732 | 106 |     902856923311919104: 0xFF4E4A,
15733 | 107 |     902857046574129172: 0x5F6FFA,
15734 | 108 |     902857418390765569: 0xFFFFFF,
15735 | 109 | }
15736 | 110 | 
15737 | 111 | perks = {
15738 | 112 |     "Premium Role": ["❌", "✅"],
15739 | 113 |     "Scrims": ["3", "Unlimited"],
15740 | 114 |     "Tourneys": ["2", "Unlimited"],
15741 | 115 |     "TagCheck": ["1", "Unlimited"],
15742 | 116 |     "EasyTags": ["1", "Unlimited"],
15743 | 117 |     "Autorole": ["1", "Unlimited"],
15744 | 118 |     "Custom Footer": ["❌", "✅"],
15745 | 119 |     "Custom Color": ["❌", "✅"],
15746 | 120 |     "Giveaway": ["5", "Unlimited"],
15747 | 121 |     "Edit Ptable Watermark": ["❌", "✅"],
15748 | 122 |     "Autopurge": ["1", "Unlimited"],
15749 | 123 | }
15750 | 124 | 
15751 | 125 | 
15752 | 126 | def random_greeting():
15753 | 127 |     greetings = [
15754 | 128 |         "Hello, sunshine!",
15755 | 129 |         "Peek-a-boo!",
15756 | 130 |         "Howdy-doody!",
15757 | 131 |         "Ahoy, matey!",
15758 | 132 |         "Hiya!",
15759 | 133 |         "What’s crackin’?",
15760 | 134 |         "Howdy, howdy ,howdy!",
15761 | 135 |         "Yo!",
15762 | 136 |         "I like your face.",
15763 | 137 |         "Bonjour!",
15764 | 138 |         "Yo! You know who this is.",
15765 | 139 |     ]
15766 | 140 |     return random.choice(greetings)
15767 | 141 | 
15768 | 142 | 
15769 | 143 | def random_thanks():
15770 | 144 |     msges = (
15771 | 145 |         "https://cdn.discordapp.com/attachments/877888851241238548/877890130478784532/unknown.png",
15772 | 146 |         "https://cdn.discordapp.com/attachments/877888851241238548/877890377426821140/unknown.png",
15773 | 147 |         "https://cdn.discordapp.com/attachments/877888851241238548/877890550399918122/unknown.png",
15774 | 148 |         "https://cdn.discordapp.com/attachments/877888851241238548/877891011349725194/unknown.png",
15775 | 149 |         "https://cdn.discordapp.com/attachments/877888851241238548/877891209421549628/unknown.png",
15776 | 150 |         "https://cdn.discordapp.com/attachments/877888851241238548/877891348869550100/unknown.png",
15777 | 151 |         "https://cdn.discordapp.com/attachments/877888851241238548/877891767058444359/unknown.png",
15778 | 152 |         "https://cdn.discordapp.com/attachments/877888851241238548/877891874671706162/unknown.png",
15779 | 153 |         "https://cdn.discordapp.com/attachments/877888851241238548/877892011720572988/unknown.png",
15780 | 154 |         "https://cdn.discordapp.com/attachments/829953427336593429/878898567509573652/unknown.png",
15781 | 155 |         "https://cdn.discordapp.com/attachments/877888851241238548/881575840578695178/unknown.png",
15782 | 156 |         "https://cdn.discordapp.com/attachments/877888851241238548/881576005498732625/unknown.png",
15783 | 157 |         "https://cdn.discordapp.com/attachments/877888851241238548/881576299137761350/unknown.png",
15784 | 158 |         "https://cdn.discordapp.com/attachments/851846932593770496/886275684304044142/unknown.png",
15785 | 159 |     )
15786 | 160 |     return random.choice(msges)
15787 | 161 | 
15788 | 162 | 
15789 | 163 | tips = (
15790 | 164 |     "We have an awesome support server:\ndiscord.gg/aBM5xz6",
15791 | 165 |     "You can set custom reactions for tourneys & scrims with Quotient Pro.",
15792 | 166 |     "I like your face : )",  # I really do
15793 | 167 |     "You can add a role to multiple users with `role @role @user @user2...` command.",
15794 | 168 |     "Quotient can detect and verify youtube/insta/loco,etc. screenshots (`ssverify` cmd).",
15795 | 169 |     "You can buy Quotient Pro for 29INR only at <https://quotientbot.xyz/premium>",
15796 | 170 |     "You can send customized embeds with `/embed` command.",
15797 | 171 |     "Scrims Slot Cancel-Claim is available for free with `slotm` command.",
15798 | 172 |     "You can create tourney groups with `tourney` command.",
15799 | 173 |     "Scrims Open & Close messages can be designed with `sm` command.",
15800 | 174 |     "With Quotient Pro you can set custom DM message.",
15801 | 175 |     "We also make custom bots, checkout: https://discord.gg/7bKA8kZd44 ",
15802 | 176 | )
15803 | 177 | 
15804 | 178 | 
15805 | 179 | async def show_tip(ctx):
15806 | 180 |     if ctx.author.id in config.DEVS:
15807 | 181 |         return
15808 | 182 | 
15809 | 183 |     if random.randint(45, 69) == 69:
15810 | 184 |         with suppress(discord.HTTPException, discord.Forbidden):
15811 | 185 |             await ctx.send(f"**Did You Know?:** {random.choice(tips)}")
15812 | 186 | 
15813 | 187 | 
15814 | 188 | async def remind_premium(ctx):
15815 | 189 |     if random.randint(1, 3) != 1:
15816 | 190 |         return
15817 | 191 | 
15818 | 192 |     from cogs.premium.views import PremiumPurchaseBtn
15819 | 193 |     from models import Guild
15820 | 194 |     from utils import discord_timestamp
15821 | 195 | 
15822 | 196 |     guild = await Guild.get_or_none(
15823 | 197 |         pk=ctx.guild.id, is_premium=True, premium_end_time__lte=ctx.bot.current_time + timedelta(days=5)
15824 | 198 |     )
15825 | 199 |     if not guild:
15826 | 200 |         return
15827 | 201 | 
15828 | 202 |     if guild.premium_end_time < ctx.bot.current_time:
15829 | 203 |         return
15830 | 204 | 
15831 | 205 |     _e = discord.Embed(color=discord.Color.red(), title="Premium Ending Soon....")
15832 | 206 |     _e.description = (
15833 | 207 |         f"Your Quotient Premium subscription is ending {discord_timestamp(guild.premium_end_time)}\n\n"
15834 | 208 |         "*Click the button to renew your subscription.*"
15835 | 209 |     )
15836 | 210 |     v = discord.ui.View(timeout=None)
15837 | 211 |     v.add_item(PremiumPurchaseBtn(label="Renew Premium"))
15838 | 212 | 
15839 | 213 |     try:
15840 | 214 |         await ctx.reply(embed=_e, view=v)
15841 | 215 |     except discord.HTTPException:
15842 | 216 |         return
15843 | 217 | 
15844 | 218 | 
15845 | 219 | class HelpGIF(Enum):
15846 | 220 |     pass
15847 | 221 | 
15848 | 222 | 
15849 | 223 | MISSING = _Sentinel()
15850 | 224 | IST = pytz.timezone("Asia/Kolkata")
15851 | 225 | 
15852 | 
15853 | 
15854 | --------------------------------------------------------------------------------
15855 | /core/Bot.py:
15856 | --------------------------------------------------------------------------------
15857 |   1 | from __future__ import annotations
15858 |   2 | 
15859 |   3 | from typing import TYPE_CHECKING, Any, AsyncGenerator, Callable, Coroutine, Dict, Iterable, List, Optional, Union
15860 |   4 | 
15861 |   5 | if TYPE_CHECKING:
15862 |   6 |     from ..cogs.reminder import Reminders
15863 |   7 | 
15864 |   8 | import asyncio
15865 |   9 | import itertools
15866 |  10 | import os
15867 |  11 | import time
15868 |  12 | from datetime import datetime, timedelta
15869 |  13 | 
15870 |  14 | import aiohttp
15871 |  15 | import discord
15872 |  16 | from aiocache import cached
15873 |  17 | from discord import AllowedMentions, Intents
15874 |  18 | from discord.ext import commands
15875 |  19 | from lru import LRU
15876 |  20 | from tortoise import Tortoise
15877 |  21 | 
15878 |  22 | import config as cfg
15879 |  23 | import constants as csts
15880 |  24 | from models import Guild, Timer
15881 |  25 | 
15882 |  26 | from .cache import CacheManager
15883 |  27 | from .Context import Context
15884 |  28 | from .Help import HelpCommand
15885 |  29 | 
15886 |  30 | intents = Intents.default()
15887 |  31 | intents.members = True
15888 |  32 | intents.message_content = True
15889 |  33 | 
15890 |  34 | 
15891 |  35 | os.environ["JISHAKU_HIDE"] = "True"
15892 |  36 | os.environ["JISHAKU_NO_UNDERSCORE"] = "True"
15893 |  37 | os.environ["JISHAKU_NO_DM_TRACEBACK"] = "True"
15894 |  38 | os.environ["OMP_THREAD_LIMIT"] = "1"
15895 |  39 | 
15896 |  40 | __all__ = ("Quotient", "bot")
15897 |  41 | 
15898 |  42 | 
15899 |  43 | on_startup: List[Callable[["Quotient"], Coroutine]] = []
15900 |  44 | 
15901 |  45 | 
15902 |  46 | class Quotient(commands.AutoShardedBot):
15903 |  47 |     def __init__(self, **kwargs: Any) -> None:
15904 |  48 |         super().__init__(
15905 |  49 |             command_prefix=self.get_prefix,
15906 |  50 |             intents=intents,
15907 |  51 |             max_messages=1000,
15908 |  52 |             strip_after_prefix=True,
15909 |  53 |             case_insensitive=True,
15910 |  54 |             help_command=HelpCommand(),
15911 |  55 |             chunk_guilds_at_startup=False,
15912 |  56 |             allowed_mentions=AllowedMentions(everyone=False, roles=False, replied_user=True, users=True),
15913 |  57 |             activity=discord.Activity(type=discord.ActivityType.listening, name="qsetup | qhelp"),
15914 |  58 |             proxy=getattr(cfg, "PROXY_URI", None),
15915 |  59 |             **kwargs,
15916 |  60 |         )
15917 |  61 | 
15918 |  62 |         self.loop = asyncio.get_event_loop()
15919 |  63 |         self.start_time = datetime.now(tz=csts.IST)
15920 |  64 |         self.cmd_invokes = 0
15921 |  65 |         self.seen_messages = 0
15922 |  66 | 
15923 |  67 |         self.persistent_views_added = False
15924 |  68 |         self.sio = None
15925 |  69 | 
15926 |  70 |         self.lockdown: bool = False
15927 |  71 |         self.lockdown_msg: Optional[str] = None
15928 |  72 |         self._BotBase__cogs = commands.core._CaseInsensitiveDict()
15929 |  73 | 
15930 |  74 |         self.message_cache: Dict[int, Any] = LRU(1024)  # type: ignore
15931 |  75 | 
15932 |  76 |     @on_startup.append
15933 |  77 |     async def __load_extensions(self):
15934 |  78 |         for ext in self.config.EXTENSIONS:
15935 |  79 |             await self.load_extension(ext)
15936 |  80 |             print(f"Loaded extension: {ext}")
15937 |  81 | 
15938 |  82 |     @on_startup.append
15939 |  83 |     async def __load_presistent_views(self):
15940 |  84 |         from cogs.esports.views import GroupRefresh, ScrimsSlotmPublicView, SlotlistEditButton, TourneySlotManager
15941 |  85 |         from models import Scrim, ScrimsSlotManager, TGroupList, Tourney
15942 |  86 | 
15943 |  87 |         # Persistent views
15944 |  88 |         async for record in ScrimsSlotManager.all():
15945 |  89 |             self.add_view(ScrimsSlotmPublicView(record), message_id=record.message_id)
15946 |  90 | 
15947 |  91 |         async for tourney in Tourney.filter(slotm_message_id__isnull=False):
15948 |  92 |             self.add_view(
15949 |  93 |                 TourneySlotManager(self, tourney=tourney),
15950 |  94 |                 message_id=tourney.slotm_message_id,
15951 |  95 |             )
15952 |  96 | 
15953 |  97 |         async for scrim in Scrim.filter(slotlist_message_id__isnull=False):
15954 |  98 |             self.add_view(SlotlistEditButton(self, scrim), message_id=scrim.slotlist_message_id)
15955 |  99 | 
15956 | 100 |         async for record in TGroupList.all():
15957 | 101 |             self.add_view(GroupRefresh(), message_id=record.message_id)
15958 | 102 | 
15959 | 103 |         print("Persistent views: Loaded them too ")
15960 | 104 | 
15961 | 105 |     @on_startup.append
15962 | 106 |     async def __chunk_prime_guilds(self):
15963 | 107 |         from models import Guild
15964 | 108 | 
15965 | 109 |         async for g in Guild.filter(is_premium=True):
15966 | 110 |             if (_guild := self.get_guild(g.pk)) and not _guild.chunked:
15967 | 111 |                 self.loop.create_task(_guild.chunk())
15968 | 112 | 
15969 | 113 |     @property
15970 | 114 |     def config(self) -> cfg:
15971 | 115 |         """import and return config.py"""
15972 | 116 |         return __import__("config")
15973 | 117 | 
15974 | 118 |     @property
15975 | 119 |     def db(self):
15976 | 120 |         """to execute raw queries"""
15977 | 121 |         return Tortoise.get_connection("default")._pool
15978 | 122 | 
15979 | 123 |     @property
15980 | 124 |     def prime_link(self):
15981 | 125 |         return "https://quotientbot.xyz/premium"
15982 | 126 | 
15983 | 127 |     @property
15984 | 128 |     def color(self):
15985 | 129 |         return self.config.COLOR
15986 | 130 | 
15987 | 131 |     def reboot(self):
15988 | 132 |         return os.system("pm2 reload quotient")
15989 | 133 | 
15990 | 134 |     async def init_quo(self):
15991 | 135 |         """Instantiating aiohttps ClientSession and telling tortoise to create relations"""
15992 | 136 |         self.session = aiohttp.ClientSession(loop=self.loop)
15993 | 137 |         await Tortoise.init(cfg.TORTOISE)
15994 | 138 |         await Tortoise.generate_schemas(safe=True)
15995 | 139 | 
15996 | 140 |         self.cache = CacheManager(self)
15997 | 141 |         await self.cache.fill_temp_cache()
15998 | 142 | 
15999 | 143 |         # Initializing Models (Assigning Bot attribute to all models)
16000 | 144 |         for mname, model in Tortoise.apps.get("models").items():
16001 | 145 |             model.bot = self
16002 | 146 | 
16003 | 147 |     async def setup_hook(self) -> None:
16004 | 148 |         await self.init_quo()
16005 | 149 |         for coro_func in on_startup:
16006 | 150 |             self.loop.create_task(coro_func(self))
16007 | 151 | 
16008 | 152 |     async def get_prefix(self, message: discord.Message) -> Union[str, Callable, List[str]]:
16009 | 153 |         """Get a guild's prefix"""
16010 | 154 |         if not message.guild:
16011 | 155 |             return commands.when_mentioned_or("q")(self, message)
16012 | 156 | 
16013 | 157 |         prefix = None
16014 | 158 |         guild = self.cache.guild_data.get(message.guild.id)
16015 | 159 |         if guild:
16016 | 160 |             prefix = guild.get("prefix")
16017 | 161 | 
16018 | 162 |         else:
16019 | 163 |             self.cache.guild_data[message.guild.id] = {
16020 | 164 |                 "prefix": "q",
16021 | 165 |                 "color": self.color,
16022 | 166 |                 "footer": cfg.FOOTER,
16023 | 167 |             }
16024 | 168 | 
16025 | 169 |         prefix = prefix or "q"
16026 | 170 | 
16027 | 171 |         return commands.when_mentioned_or(
16028 | 172 |             *tuple("".join(chars) for chars in itertools.product(*zip(prefix.lower(), prefix.upper())))
16029 | 173 |         )(self, message)
16030 | 174 | 
16031 | 175 |     async def close(self) -> None:
16032 | 176 |         await super().close()
16033 | 177 | 
16034 | 178 |         if hasattr(self, "session"):
16035 | 179 |             await self.session.close()
16036 | 180 | 
16037 | 181 |         await Tortoise.close_connections()
16038 | 182 | 
16039 | 183 |     def get_message(self, message_id: int) -> Optional[discord.Message]:
16040 | 184 |         """Gets the message from the cache"""
16041 | 185 |         return self._connection._get_message(message_id)
16042 | 186 | 
16043 | 187 |     async def process_commands(self, message: discord.Message):
16044 | 188 |         if message.content and message.guild is not None:
16045 | 189 |             ctx = await self.get_context(message, cls=Context)
16046 | 190 | 
16047 | 191 |             if ctx.command is None:
16048 | 192 |                 return
16049 | 193 | 
16050 | 194 |             await self.invoke(ctx)
16051 | 195 | 
16052 | 196 |     async def on_message(self, message: discord.Message):
16053 | 197 |         self.seen_messages += 1
16054 | 198 | 
16055 | 199 |         if message.guild is None or message.author.bot:
16056 | 200 |             return
16057 | 201 | 
16058 | 202 |         await self.process_commands(message)
16059 | 203 | 
16060 | 204 |     async def on_command(self, ctx: Context):
16061 | 205 |         self.cmd_invokes += 1
16062 | 206 |         await csts.show_tip(ctx)
16063 | 207 |         await csts.remind_premium(ctx)
16064 | 208 |         await self.db.execute(
16065 | 209 |             "INSERT INTO user_data (user_id) VALUES ($1) ON CONFLICT DO NOTHING",
16066 | 210 |             ctx.author.id,
16067 | 211 |         )
16068 | 212 | 
16069 | 213 |     async def on_ready(self):
16070 | 214 |         print(f"[Quotient] Logged in as {self.user.name}({self.user.id})")
16071 | 215 | 
16072 | 216 |     async def wait_and_delete(self, message: discord.Message, delay: int = 10):
16073 | 217 |         """Waits for `delay` seconds and deletes the message"""
16074 | 218 |         return await self.reminders.create_timer(
16075 | 219 |             self.current_time + timedelta(seconds=delay),
16076 | 220 |             "msg_delete",
16077 | 221 |             message_id=message.id,
16078 | 222 |             channel_id=message.channel.id,
16079 | 223 |         )
16080 | 224 | 
16081 | 225 |     async def on_msg_delete_timer_complete(self, timer: Timer):
16082 | 226 |         """Deletes the message"""
16083 | 227 |         channel_id, message_id = timer.kwargs["channel_id"], timer.kwargs["message_id"]
16084 | 228 | 
16085 | 229 |         channel: discord.TextChannel = await self.getch(self.get_channel, self.fetch_channel, channel_id)
16086 | 230 |         if channel is None:
16087 | 231 |             return
16088 | 232 | 
16089 | 233 |         message = channel.get_partial_message(message_id)
16090 | 234 |         await message.delete(delay=0)
16091 | 235 | 
16092 | 236 |     def embed(self, ctx: Context, **kwargs: Any) -> discord.Embed:
16093 | 237 |         """This is how we deliver features like custom footer and custom color :)"""
16094 | 238 |         embed_color = self.cache.guild_data[ctx.guild.id]["color"]
16095 | 239 |         embed_footer = self.cache.guild_data[ctx.guild.id]["footer"]
16096 | 240 | 
16097 | 241 |         if embed_footer.strip().lower() == "none":
16098 | 242 |             embed_footer = None
16099 | 243 | 
16100 | 244 |         embed = discord.Embed(**kwargs, color=embed_color).set_footer(text=embed_footer)
16101 | 245 |         return embed
16102 | 246 | 
16103 | 247 |     async def is_owner(self, user: Union[discord.Member, discord.User]) -> bool:
16104 | 248 |         if await super().is_owner(user):
16105 | 249 |             return True
16106 | 250 | 
16107 | 251 |         return user.id in cfg.DEVS
16108 | 252 | 
16109 | 253 |     async def get_or_fetch_member(self, guild: discord.Guild, member_id: int) -> Optional[discord.Member]:
16110 | 254 |         """Looks up a member in cache or fetches if not found."""
16111 | 255 |         member = guild.get_member(member_id)
16112 | 256 |         if member is not None:
16113 | 257 |             return member
16114 | 258 | 
16115 | 259 |         shard = self.get_shard(guild.shard_id)
16116 | 260 | 
16117 | 261 |         if shard.is_ws_ratelimited():
16118 | 262 |             try:
16119 | 263 |                 member = await guild.fetch_member(member_id)
16120 | 264 |             except discord.HTTPException:
16121 | 265 |                 return None
16122 | 266 |             else:
16123 | 267 |                 return member
16124 | 268 | 
16125 | 269 |         members = await guild.query_members(limit=1, user_ids=[member_id], cache=True)
16126 | 270 | 
16127 | 271 |         if len(members) > 0:
16128 | 272 |             return members[0]
16129 | 273 | 
16130 | 274 |         return None
16131 | 275 | 
16132 | 276 |     async def resolve_member_ids(
16133 | 277 |         self, guild: discord.Guild, member_ids: Iterable[int]
16134 | 278 |     ) -> AsyncGenerator[discord.Member, None]:
16135 | 279 |         """Bulk resolves member IDs to member instances, if possible."""
16136 | 280 | 
16137 | 281 |         needs_resolution = []
16138 | 282 |         for member_id in member_ids:
16139 | 283 |             member = guild.get_member(member_id)
16140 | 284 |             if member is not None:
16141 | 285 |                 yield member
16142 | 286 |             else:
16143 | 287 |                 needs_resolution.append(member_id)
16144 | 288 | 
16145 | 289 |         if not needs_resolution:
16146 | 290 |             return
16147 | 291 | 
16148 | 292 |         total_need_resolution = len(needs_resolution)
16149 | 293 |         if total_need_resolution == 1:
16150 | 294 |             shard: discord.ShardInfo = self.get_shard(guild.shard_id)  # type: ignore  # will never be None
16151 | 295 |             if shard.is_ws_ratelimited():
16152 | 296 |                 try:
16153 | 297 |                     member = await guild.fetch_member(needs_resolution[0])
16154 | 298 |                 except discord.HTTPException:
16155 | 299 |                     pass
16156 | 300 |                 else:
16157 | 301 |                     yield member
16158 | 302 |             else:
16159 | 303 |                 members = await guild.query_members(limit=1, user_ids=needs_resolution, cache=True)
16160 | 304 |                 if members:
16161 | 305 |                     yield members[0]
16162 | 306 |         elif total_need_resolution <= 100:
16163 | 307 |             # Only a single resolution call needed here
16164 | 308 |             resolved = await guild.query_members(limit=100, user_ids=needs_resolution, cache=True)
16165 | 309 |             for member in resolved:
16166 | 310 |                 yield member
16167 | 311 |         else:
16168 | 312 |             # We need to chunk these in bits of 100...
16169 | 313 |             for index in range(0, total_need_resolution, 100):
16170 | 314 |                 to_resolve = needs_resolution[index : index + 100]
16171 | 315 |                 members = await guild.query_members(limit=100, user_ids=to_resolve, cache=True)
16172 | 316 |                 for member in members:
16173 | 317 |                     yield member
16174 | 318 | 
16175 | 319 |     @staticmethod
16176 | 320 |     @cached(ttl=60)
16177 | 321 |     async def is_premium_guild(guild_id: int) -> bool:
16178 | 322 |         return await Guild.filter(pk=guild_id, is_premium=True).exists()
16179 | 323 | 
16180 | 324 |     @property
16181 | 325 |     def server(self) -> Optional[discord.Guild]:
16182 | 326 |         return self.get_guild(746337818388987967)
16183 | 327 | 
16184 | 328 |     @property
16185 | 329 |     def invite_url(self) -> str:
16186 | 330 |         return discord.utils.oauth_url(
16187 | 331 |             self.user.id,
16188 | 332 |             permissions=discord.Permissions(536737213566),
16189 | 333 |             scopes=("bot", "applications.commands"),
16190 | 334 |             disable_guild_select=False,
16191 | 335 |         )
16192 | 336 | 
16193 | 337 |     @property
16194 | 338 |     def reminders(self) -> Reminders:  # since we use it a lot
16195 | 339 |         return self.get_cog("Reminders")
16196 | 340 | 
16197 | 341 |     @property
16198 | 342 |     def current_time(self):
16199 | 343 |         return datetime.now(tz=csts.IST)
16200 | 344 | 
16201 | 345 |     @property
16202 | 346 |     async def db_latency(self):
16203 | 347 |         t1 = time.perf_counter()
16204 | 348 |         await self.db.fetchval("SELECT 1;")
16205 | 349 |         t2 = time.perf_counter() - t1
16206 | 350 |         return f"{t2*1000:.2f} ms"
16207 | 351 | 
16208 | 352 |     @staticmethod
16209 | 353 |     async def getch(get_method: Callable, fetch_method: Callable, _id: int) -> Any:  # why does c have all the fun?
16210 | 354 |         try:
16211 | 355 |             _result = get_method(_id) or await fetch_method(_id)
16212 | 356 |         except (discord.HTTPException, discord.NotFound):
16213 | 357 |             return None
16214 | 358 |         else:
16215 | 359 |             return _result
16216 | 360 | 
16217 | 361 |     async def get_or_fetch_message(
16218 | 362 |         self,
16219 | 363 |         channel: discord.TextChannel,
16220 | 364 |         message_id: int,
16221 | 365 |         *,
16222 | 366 |         cache: bool = True,
16223 | 367 |         fetch: bool = True,
16224 | 368 |     ) -> Optional[discord.Message]:
16225 | 369 |         # caching cause, due to rate limiting 50/1
16226 | 370 |         if cache and (msg := self.get_message(message_id)):
16227 | 371 |             return msg
16228 | 372 |         try:
16229 | 373 |             return self.message_cache[message_id]
16230 | 374 |             # scripting is always faster than `.get()`
16231 | 375 |         except KeyError:
16232 | 376 |             pass
16233 | 377 |         before = discord.Object(message_id + 1)
16234 | 378 |         after = discord.Object(message_id - 1)
16235 | 379 |         if fetch:
16236 | 380 |             async for msg in channel.history(limit=1, before=before, after=after):
16237 | 381 |                 self.message_cache[msg.id] = msg
16238 | 382 |                 return msg
16239 | 383 | 
16240 | 384 |         return None
16241 | 385 | 
16242 | 386 |     async def send_message(self, channel_id: discord.abc.Snowflake, content, **kwargs: Any):
16243 | 387 |         await self.http.send_message(channel_id, content, **kwargs)
16244 | 388 | 
16245 | 389 |     async def convey_important_message(
16246 | 390 |         self,
16247 | 391 |         guild: discord.Guild,
16248 | 392 |         text: str,
16249 | 393 |         *,
16250 | 394 |         view=None,
16251 | 395 |         title="\N{WARNING SIGN}__**IMPORTANT**__\N{WARNING SIGN}",
16252 | 396 |     ):
16253 | 397 |         _e = discord.Embed(title=title, description=text)
16254 | 398 | 
16255 | 399 |         from models import Guild
16256 | 400 | 
16257 | 401 |         _g = await Guild.get(pk=guild.id)
16258 | 402 |         if (_c := _g.private_ch) and _c.permissions_for(guild.me).embed_links:
16259 | 403 |             _roles = [
16260 | 404 |                 role.mention
16261 | 405 |                 for role in guild.roles
16262 | 406 |                 if all((role.permissions.administrator, not role.managed, role.members))
16263 | 407 |             ]
16264 | 408 |             await _c.send(
16265 | 409 |                 embed=_e,
16266 | 410 |                 content=", ".join(_roles[:2]) if _roles else getattr(guild.owner, "mention"),
16267 | 411 |                 allowed_mentions=AllowedMentions(roles=True),
16268 | 412 |                 view=view,
16269 | 413 |             )
16270 | 414 | 
16271 | 415 |         if guild.owner is not None:  # there is very little chance that `guild.owner` is None
16272 | 416 |             try:
16273 | 417 |                 await guild.owner.send(embed=_e, view=view)
16274 | 418 |             except discord.Forbidden:
16275 | 419 |                 return
16276 | 420 | 
16277 | 421 | 
16278 | 422 | bot = Quotient()
16279 | 423 | 
16280 | 424 | 
16281 | 425 | @bot.before_invoke
16282 | 426 | async def bot_before_invoke(ctx: Context):
16283 | 427 |     if ctx.guild is not None and not ctx.guild.chunked:
16284 | 428 |         bot.loop.create_task(ctx.guild.chunk())
16285 | 429 | 
16286 | 
16287 | 
16288 | --------------------------------------------------------------------------------
16289 | /core/Cog.py:
16290 | --------------------------------------------------------------------------------
16291 |  1 | from discord.ext import commands
16292 |  2 | 
16293 |  3 | __all__ = ("Cog",)
16294 |  4 | 
16295 |  5 | 
16296 |  6 | class Cog(commands.Cog):
16297 |  7 |     """A custom implementation of commands.Cog class."""
16298 |  8 | 
16299 |  9 |     def __init__(self, *args, **kwargs):
16300 | 10 |         super().__init__(*args, **kwargs)
16301 | 11 | 
16302 | 12 |     def __str__(self):
16303 | 13 |         return "{0.__class__.__name__}".format(self)
16304 | 14 | 
16305 | 
16306 | 
16307 | --------------------------------------------------------------------------------
16308 | /core/Context.py:
16309 | --------------------------------------------------------------------------------
16310 |   1 | from __future__ import annotations
16311 |   2 | 
16312 |   3 | import asyncio
16313 |   4 | import io
16314 |   5 | from contextlib import suppress
16315 |   6 | from typing import TYPE_CHECKING, Any, Callable, Generic, Optional, TypeVar, Union
16316 |   7 | 
16317 |   8 | import aiohttp
16318 |   9 | import discord
16319 |  10 | from discord.ext import commands
16320 |  11 | 
16321 |  12 | import config as cfg
16322 |  13 | import utils
16323 |  14 | 
16324 |  15 | BotT = TypeVar("BotT", bound=commands.Bot)
16325 |  16 | 
16326 |  17 | 
16327 |  18 | __all__ = ("Context",)
16328 |  19 | 
16329 |  20 | 
16330 |  21 | class Context(commands.Context["commands.Bot"], Generic[BotT]):
16331 |  22 |     if TYPE_CHECKING:
16332 |  23 |         from .Bot import Quotient
16333 |  24 | 
16334 |  25 |     bot: Quotient
16335 |  26 | 
16336 |  27 |     def __init__(self, *args: Any, **kwargs: Any) -> None:
16337 |  28 |         super().__init__(*args, **kwargs)
16338 |  29 | 
16339 |  30 |     @property
16340 |  31 |     def db(self):
16341 |  32 |         return self.bot.db
16342 |  33 | 
16343 |  34 |     @property
16344 |  35 |     def session(self) -> aiohttp.ClientSession:
16345 |  36 |         return self.bot.session
16346 |  37 | 
16347 |  38 |     @property
16348 |  39 |     def guild_color(self):
16349 |  40 |         return self.bot.cache.guild_color(self.guild.id)
16350 |  41 | 
16351 |  42 |     @property
16352 |  43 |     def config(self) -> cfg:
16353 |  44 |         return self.bot.config
16354 |  45 | 
16355 |  46 |     @property
16356 |  47 |     async def banlog_channel(self):
16357 |  48 |         from models import BanLog
16358 |  49 | 
16359 |  50 |         record = await BanLog.get_or_none(guild_id=self.guild.id)
16360 |  51 |         if record:
16361 |  52 |             return record.channel
16362 |  53 | 
16363 |  54 |     @discord.utils.cached_property
16364 |  55 |     def replied_reference(self) -> Optional[discord.MessageReference]:
16365 |  56 |         ref = self.message.reference
16366 |  57 |         if ref and isinstance(ref.resolved, discord.Message):
16367 |  58 |             return ref.resolved.to_reference()
16368 |  59 |         return None
16369 |  60 | 
16370 |  61 |     async def prompt(self, message: str, title: Optional[str] = None, delete_after=True):
16371 |  62 |         """
16372 |  63 |         An interactive reaction confirmation dialog.
16373 |  64 |         """
16374 |  65 | 
16375 |  66 |         embed = discord.Embed(description=message, color=self.bot.color)
16376 |  67 |         if title is not None:
16377 |  68 |             embed.title = title
16378 |  69 | 
16379 |  70 |         view = utils.Prompt(self.author.id)
16380 |  71 |         msg: Optional[discord.Message] = await self.send(embed=embed, view=view)
16381 |  72 |         await view.wait()
16382 |  73 | 
16383 |  74 |         try:
16384 |  75 |             if delete_after and msg is not None:
16385 |  76 |                 await msg.delete(delay=0)
16386 |  77 |         finally:
16387 |  78 |             return view.value
16388 |  79 | 
16389 |  80 |     async def error(self, message: str, delete_after: bool = None, **kwargs: Any) -> Optional[discord.Message]:
16390 |  81 |         with suppress(discord.HTTPException):
16391 |  82 |             msg: Optional[discord.Message] = await self.reply(
16392 |  83 |                 embed=discord.Embed(description=message, color=discord.Color.red()),
16393 |  84 |                 delete_after=delete_after,
16394 |  85 |                 **kwargs,
16395 |  86 |             )
16396 |  87 |             try:
16397 |  88 |                 await self.bot.wait_for("message_delete", check=lambda m: m.id == self.message.id, timeout=30)
16398 |  89 |             except asyncio.TimeoutError:
16399 |  90 |                 pass
16400 |  91 |             else:
16401 |  92 |                 if msg is not None:
16402 |  93 |                     await msg.delete(delay=0)
16403 |  94 |             finally:
16404 |  95 |                 return msg
16405 |  96 | 
16406 |  97 |         return None
16407 |  98 | 
16408 |  99 |     async def safe_delete(self, msg: discord.Message, sleep_for: Union[int, float] = 0) -> None:
16409 | 100 |         if sleep_for:
16410 | 101 |             await asyncio.sleep(sleep_for)
16411 | 102 | 
16412 | 103 |         await msg.delete(delay=0)
16413 | 104 | 
16414 | 105 |     async def success(
16415 | 106 |         self, message: str, delete_after: Union[int, float] = None, **kwargs: Any
16416 | 107 |     ) -> Optional[discord.Message]:
16417 | 108 |         with suppress(discord.HTTPException):
16418 | 109 |             return await self.reply(
16419 | 110 |                 embed=discord.Embed(
16420 | 111 |                     description=f"{utils.check} | {message}",
16421 | 112 |                     color=self.bot.color,
16422 | 113 |                 ),
16423 | 114 |                 delete_after=delete_after,
16424 | 115 |                 **kwargs,
16425 | 116 |             )
16426 | 117 |         return None
16427 | 118 | 
16428 | 119 |     async def simple(
16429 | 120 |         self, message: str, delete_after: Union[int, float] = None, **kwargs: Any
16430 | 121 |     ) -> Optional[discord.Message]:
16431 | 122 |         with suppress(discord.HTTPException):
16432 | 123 |             image = kwargs.pop("image", None)
16433 | 124 |             footer = kwargs.pop("footer", None)
16434 | 125 | 
16435 | 126 |             embed = discord.Embed(description=message, color=self.bot.color)
16436 | 127 |             if image:
16437 | 128 |                 embed.set_image(url=image)
16438 | 129 |             if footer:
16439 | 130 |                 embed.set_footer(text=footer)
16440 | 131 | 
16441 | 132 |             return await self.reply(
16442 | 133 |                 embed=embed,
16443 | 134 |                 delete_after=delete_after,
16444 | 135 |                 **kwargs,
16445 | 136 |             )
16446 | 137 |         return None
16447 | 138 | 
16448 | 139 |     async def is_premium_guild(self) -> bool:
16449 | 140 |         from models import Guild
16450 | 141 | 
16451 | 142 |         with suppress(AttributeError):
16452 | 143 |             return (await Guild.get(guild_id=self.guild.id)).is_premium
16453 | 144 | 
16454 | 145 |         return False
16455 | 146 | 
16456 | 147 |     async def send_file(
16457 | 148 |         self,
16458 | 149 |         content: str,
16459 | 150 |         *,
16460 | 151 |         name: str = "Message.txt",
16461 | 152 |         escape_mentions: bool = True,
16462 | 153 |         **kwargs: Any,
16463 | 154 |     ) -> Optional[discord.Message]:
16464 | 155 |         """sends the file containg content"""
16465 | 156 |         if escape_mentions:
16466 | 157 |             content = discord.utils.escape_mentions(content)
16467 | 158 | 
16468 | 159 |         fp = io.BytesIO(content.encode())
16469 | 160 |         kwargs.pop("file", None)
16470 | 161 | 
16471 | 162 |         return await self.send(file=discord.File(fp, filename=name), **kwargs)
16472 | 163 | 
16473 | 164 |     async def maybe_delete(self, message: Optional[discord.Message] = None):
16474 | 165 |         if message is not None:
16475 | 166 |             await message.delete(delay=0)
16476 | 167 | 
16477 | 168 |     async def send(self, content: Any = None, **kwargs: Any) -> Optional[discord.Message]:
16478 | 169 |         if not (_perms := self.channel.permissions_for(self.me)).send_messages:
16479 | 170 |             try:
16480 | 171 |                 await self.author.send(
16481 | 172 |                     "I can't send any messages in that channel. \nPlease give me sufficient permissions to do so.",
16482 | 173 |                     view=self.get_dm_view(f"Sent from #{self.channel.name} in {self.guild.name}"),
16483 | 174 |                 )
16484 | 175 |             except discord.Forbidden:
16485 | 176 |                 pass
16486 | 177 |             return None
16487 | 178 | 
16488 | 179 |         require_embed_perms = kwargs.pop("embed_perms", False)
16489 | 180 |         if require_embed_perms and not _perms.embed_links:
16490 | 181 |             kwargs = {}
16491 | 182 |             content = (
16492 | 183 |                 "Oops! I need **Embed Links** permission to work properly. \n"
16493 | 184 |                 "Please tell a server admin to grant me that permission."
16494 | 185 |             )
16495 | 186 |         if isinstance(content, discord.Embed):
16496 | 187 |             kwargs["embed"] = content
16497 | 188 |             content = None
16498 | 189 |         if isinstance(content, discord.File):
16499 | 190 |             kwargs["file"] = content
16500 | 191 |             content = None
16501 | 192 | 
16502 | 193 |         return await super().send(content, **kwargs)
16503 | 194 | 
16504 | 195 |     async def wait_and_purge(
16505 | 196 |         self,
16506 | 197 |         channel: Union[discord.TextChannel, discord.Thread],
16507 | 198 |         *,
16508 | 199 |         limit: int = 100,
16509 | 200 |         wait_for: Union[int, float] = 10,
16510 | 201 |         check: Callable = lambda m: True,
16511 | 202 |     ):
16512 | 203 |         await asyncio.sleep(wait_for)
16513 | 204 | 
16514 | 205 |         with suppress(discord.HTTPException):
16515 | 206 |             await channel.purge(limit=limit, check=check)
16516 | 207 | 
16517 | 208 |     async def premium_mango(self, msg: str = "This feature requires Quotient Premium.") -> Optional[discord.Message]:
16518 | 209 |         from cogs.premium.views import PremiumView
16519 | 210 | 
16520 | 211 |         _view = PremiumView(msg)
16521 | 212 |         return await self.send(embed=_view.premium_embed, view=_view, embed_perms=True)
16522 | 213 | 
16523 | 214 |     @staticmethod
16524 | 215 |     def get_dm_view(msg: str) -> discord.ui.View:
16525 | 216 |         from .views import QuoDMView
16526 | 217 | 
16527 | 218 |         return QuoDMView(label=msg)
16528 | 219 | 
16529 | 
16530 | 
16531 | --------------------------------------------------------------------------------
16532 | /core/Help.py:
16533 | --------------------------------------------------------------------------------
16534 |   1 | from __future__ import annotations
16535 |   2 | 
16536 |   3 | from difflib import get_close_matches
16537 |   4 | from typing import List, Mapping
16538 |   5 | 
16539 |   6 | import discord
16540 |   7 | from discord.ext import commands
16541 |   8 | 
16542 |   9 | import config
16543 |  10 | from models import Guild
16544 |  11 | from utils import LinkButton, LinkType, QuoPaginator, discord_timestamp, truncate_string
16545 |  12 | 
16546 |  13 | from .Cog import Cog
16547 |  14 | 
16548 |  15 | 
16549 |  16 | class HelpCommand(commands.HelpCommand):
16550 |  17 |     def __init__(self) -> None:
16551 |  18 |         super().__init__(
16552 |  19 |             verify_checks=False,
16553 |  20 |             command_attrs={
16554 |  21 |                 "cooldown": commands.CooldownMapping.from_cooldown(1, 8.0, commands.BucketType.member),
16555 |  22 |                 "help": "Shows help about the bot, a command, or a category",
16556 |  23 |             },
16557 |  24 |         )
16558 |  25 | 
16559 |  26 |     @property
16560 |  27 |     def color(self):
16561 |  28 |         return self.context.bot.color
16562 |  29 | 
16563 |  30 |     async def send_bot_help(self, mapping: Mapping[Cog, List[commands.Command]]):
16564 |  31 |         ctx = self.context
16565 |  32 | 
16566 |  33 |         hidden = ("HelpCog", "Dev")
16567 |  34 | 
16568 |  35 |         embed = discord.Embed(color=self.color)
16569 |  36 | 
16570 |  37 |         server = f"[Support Server]({config.SERVER_LINK})"
16571 |  38 |         invite = f"[Invite Me]({config.BOT_INVITE})"
16572 |  39 |         dashboard = f"[Privacy Policy](https://github.com/quotientbot/Quotient-Bot/wiki/privacy-policy)"
16573 |  40 | 
16574 |  41 |         embed.description = f"{server} **|** {invite} **|** {dashboard}\n\n"
16575 |  42 | 
16576 |  43 |         guild = await Guild.get_or_none(pk=ctx.guild.id)
16577 |  44 |         if guild and guild.is_premium:
16578 |  45 |             embed.description += f"<a:top_user:807911932299837460> [__Server Premium ending:__]({config.SERVER_LINK}) {discord_timestamp(guild.premium_end_time)}"
16579 |  46 | 
16580 |  47 |         for cog, cmds in mapping.items():
16581 |  48 |             if cog and cog.qualified_name not in hidden and await self.filter_commands(cmds, sort=True):
16582 |  49 |                 embed.add_field(
16583 |  50 |                     inline=False,
16584 |  51 |                     name=cog.qualified_name.title(),
16585 |  52 |                     value=", ".join(map(lambda x: f"`{x}`", cog.get_commands())),
16586 |  53 |                 )
16587 |  54 | 
16588 |  55 |         slash_cmds = await ctx.bot.tree.fetch_commands()
16589 |  56 |         slash_cmds = [f"{i.mention}" for i in slash_cmds]
16590 |  57 |         embed.add_field(name="Slash Commands", value=", ".join(slash_cmds), inline=False)
16591 |  58 | 
16592 |  59 |         links = [
16593 |  60 |             LinkType("Support Server", config.SERVER_LINK),
16594 |  61 |             LinkType("Invite Me", config.BOT_INVITE),
16595 |  62 |         ]
16596 |  63 |         await ctx.send(embed=embed, embed_perms=True, view=LinkButton(links))
16597 |  64 | 
16598 |  65 |     async def send_group_help(self, group: commands.Group):
16599 |  66 |         prefix = self.context.prefix
16600 |  67 | 
16601 |  68 |         if not group.commands:
16602 |  69 |             return await self.send_command_help(group)
16603 |  70 | 
16604 |  71 |         embed = discord.Embed(color=discord.Color(self.color))
16605 |  72 | 
16606 |  73 |         embed.title = f"{group.qualified_name} {group.signature}"
16607 |  74 |         _help = group.help or "No description provided..."
16608 |  75 | 
16609 |  76 |         _cmds = "\n".join(f"`{prefix}{c.qualified_name}` : {truncate_string(c.short_doc,60)}" for c in group.commands)
16610 |  77 | 
16611 |  78 |         embed.description = f"> {_help}\n\n**Subcommands**\n{_cmds}"
16612 |  79 | 
16613 |  80 |         embed.set_footer(text=f'Use "{prefix}help <command>" for more information.')
16614 |  81 | 
16615 |  82 |         if group.aliases:
16616 |  83 |             embed.add_field(
16617 |  84 |                 name="Aliases",
16618 |  85 |                 value=", ".join(f"`{aliases}`" for aliases in group.aliases),
16619 |  86 |                 inline=False,
16620 |  87 |             )
16621 |  88 | 
16622 |  89 |         examples = []
16623 |  90 |         if group.extras:
16624 |  91 |             if _gif := group.extras.get("gif"):
16625 |  92 |                 embed.set_image(url=_gif)
16626 |  93 | 
16627 |  94 |             if _ex := group.extras.get("examples"):
16628 |  95 |                 examples = [f"{self.context.prefix}{i}" for i in _ex]
16629 |  96 | 
16630 |  97 |         if examples:
16631 |  98 |             examples: str = "\n".join(examples)  # type: ignore
16632 |  99 |             embed.add_field(name="Examples", value=f"```{examples}```")
16633 | 100 | 
16634 | 101 |         await self.context.send(embed=embed, embed_perms=True)
16635 | 102 | 
16636 | 103 |     async def send_cog_help(self, cog: Cog):
16637 | 104 |         paginator = QuoPaginator(self.context, per_page=14)
16638 | 105 |         c = 0
16639 | 106 |         for cmd in cog.get_commands():
16640 | 107 |             if not cmd.hidden:
16641 | 108 |                 _brief = "No Information..." if not cmd.short_doc else truncate_string(cmd.short_doc, 60)
16642 | 109 |                 paginator.add_line(f"`{cmd.qualified_name}` : {_brief}")
16643 | 110 |                 c += 1
16644 | 111 | 
16645 | 112 |         paginator.title = f"{cog.qualified_name.title()} ({c})"
16646 | 113 |         await paginator.start()
16647 | 114 | 
16648 | 115 |     async def send_command_help(self, cmd: commands.Command):
16649 | 116 |         embed = discord.Embed(color=self.color)
16650 | 117 |         embed.title = "Command: " + cmd.qualified_name
16651 | 118 | 
16652 | 119 |         examples = []
16653 | 120 | 
16654 | 121 |         alias = ",".join((f"`{alias}`" for alias in cmd.aliases)) if cmd.aliases else "No aliases"
16655 | 122 |         _text = (
16656 | 123 |             f"**Description:** {cmd.help or 'No help found...'}\n"
16657 | 124 |             f"**Usage:** `{self.get_command_signature(cmd)}`\n"
16658 | 125 |             f"**Aliases:** {alias}\n"
16659 | 126 |             f"**Examples:**"
16660 | 127 |         )
16661 | 128 | 
16662 | 129 |         if cmd.extras:
16663 | 130 |             if _gif := cmd.extras.get("gif"):
16664 | 131 |                 embed.set_image(url=_gif)
16665 | 132 | 
16666 | 133 |             if _ex := cmd.extras.get("examples"):
16667 | 134 |                 examples = [f"{self.context.prefix}{i}" for i in _ex]
16668 | 135 | 
16669 | 136 |         examples: str = "\n".join(examples) if examples else "Command has no examples"  # type: ignore
16670 | 137 | 
16671 | 138 |         _text += f"```{examples}```"
16672 | 139 | 
16673 | 140 |         embed.description = _text
16674 | 141 | 
16675 | 142 |         await self.context.send(embed=embed, embed_perms=True)
16676 | 143 | 
16677 | 144 |     async def command_not_found(self, string: str):
16678 | 145 |         message = f"Could not find the `{string}` command. "
16679 | 146 |         commands_list = (str(cmd) for cmd in self.context.bot.walk_commands())
16680 | 147 | 
16681 | 148 |         if dym := "\n".join(get_close_matches(string, commands_list)):
16682 | 149 |             message += f"Did you mean...\n{dym}"
16683 | 150 | 
16684 | 151 |         return message
16685 | 152 | 
16686 | 
16687 | 
16688 | --------------------------------------------------------------------------------
16689 | /core/__init__.py:
16690 | --------------------------------------------------------------------------------
16691 | 1 | from .Bot import Quotient, bot
16692 | 2 | from .Cog import Cog
16693 | 3 | from .Context import Context
16694 | 4 | from .cooldown import *
16695 | 5 | from .decorators import *
16696 | 6 | from .views import *
16697 | 7 | 
16698 | 
16699 | 
16700 | --------------------------------------------------------------------------------
16701 | /core/__pycache__/Bot.cpython-312.pyc:
16702 | --------------------------------------------------------------------------------
16703 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/core/__pycache__/Bot.cpython-312.pyc
16704 | 
16705 | 
16706 | --------------------------------------------------------------------------------
16707 | /core/__pycache__/Cog.cpython-312.pyc:
16708 | --------------------------------------------------------------------------------
16709 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/core/__pycache__/Cog.cpython-312.pyc
16710 | 
16711 | 
16712 | --------------------------------------------------------------------------------
16713 | /core/__pycache__/Context.cpython-312.pyc:
16714 | --------------------------------------------------------------------------------
16715 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/core/__pycache__/Context.cpython-312.pyc
16716 | 
16717 | 
16718 | --------------------------------------------------------------------------------
16719 | /core/__pycache__/Help.cpython-312.pyc:
16720 | --------------------------------------------------------------------------------
16721 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/core/__pycache__/Help.cpython-312.pyc
16722 | 
16723 | 
16724 | --------------------------------------------------------------------------------
16725 | /core/__pycache__/__init__.cpython-312.pyc:
16726 | --------------------------------------------------------------------------------
16727 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/core/__pycache__/__init__.cpython-312.pyc
16728 | 
16729 | 
16730 | --------------------------------------------------------------------------------
16731 | /core/__pycache__/cache.cpython-312.pyc:
16732 | --------------------------------------------------------------------------------
16733 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/core/__pycache__/cache.cpython-312.pyc
16734 | 
16735 | 
16736 | --------------------------------------------------------------------------------
16737 | /core/__pycache__/cooldown.cpython-312.pyc:
16738 | --------------------------------------------------------------------------------
16739 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/core/__pycache__/cooldown.cpython-312.pyc
16740 | 
16741 | 
16742 | --------------------------------------------------------------------------------
16743 | /core/__pycache__/decorators.cpython-312.pyc:
16744 | --------------------------------------------------------------------------------
16745 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/core/__pycache__/decorators.cpython-312.pyc
16746 | 
16747 | 
16748 | --------------------------------------------------------------------------------
16749 | /core/__pycache__/views.cpython-312.pyc:
16750 | --------------------------------------------------------------------------------
16751 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/core/__pycache__/views.cpython-312.pyc
16752 | 
16753 | 
16754 | --------------------------------------------------------------------------------
16755 | /core/_pages.py:
16756 | --------------------------------------------------------------------------------
16757 |   1 | from __future__ import annotations
16758 |   2 | 
16759 |   3 | import asyncio
16760 |   4 | import typing as T
16761 |   5 | 
16762 |   6 | import discord
16763 |   7 | 
16764 |   8 | from utils.default import split_list
16765 |   9 | 
16766 |  10 | from .Context import Context
16767 |  11 | from .views import QuotientView
16768 |  12 | 
16769 |  13 | 
16770 |  14 | class PageLine(T.NamedTuple):
16771 |  15 |     line: T.Optional[str] = None
16772 |  16 |     image: T.Optional[str] = None
16773 |  17 |     # embed: T.Optional[discord.Embed] = None
16774 |  18 | 
16775 |  19 | 
16776 |  20 | class QuoPages:
16777 |  21 |     def __init__(
16778 |  22 |         self,
16779 |  23 |         ctx: Context,
16780 |  24 |         *,
16781 |  25 |         per_page=10,
16782 |  26 |         timeout=60.0,
16783 |  27 |         title=None,
16784 |  28 |         show_page_count=True,
16785 |  29 |         embed_color=0x00FFB3,
16786 |  30 |         compact=False,
16787 |  31 |     ):
16788 |  32 |         self.ctx = ctx
16789 |  33 | 
16790 |  34 |         self.per_page = per_page
16791 |  35 |         self.timeout = timeout
16792 |  36 |         self.title = title or None
16793 |  37 |         self.show_page_count = show_page_count
16794 |  38 | 
16795 |  39 |         self.enteries: T.List[PageLine] = []
16796 |  40 | 
16797 |  41 |         self.items: T.List[discord.ui.Item] = []
16798 |  42 |         self.embed_color = embed_color
16799 |  43 | 
16800 |  44 |         self.compact = compact
16801 |  45 | 
16802 |  46 |         self.pages: T.List[PageLine] = []
16803 |  47 | 
16804 |  48 |         self.cur_page = 1
16805 |  49 | 
16806 |  50 |     def add_line(self, line: PageLine):
16807 |  51 |         self.enteries.append(line)
16808 |  52 | 
16809 |  53 |     @property
16810 |  54 |     def embed(self) -> discord.Embed:
16811 |  55 |         _p = self.pages[self.cur_page - 1]
16812 |  56 | 
16813 |  57 |         _e = discord.Embed(color=self.embed_color, title=self.title)
16814 |  58 |         _e.description = _p.line
16815 |  59 |         if _p.image:
16816 |  60 |             _e.set_image(url=_p.image)
16817 |  61 | 
16818 |  62 |         if self.show_page_count:
16819 |  63 |             _e.set_footer(text=f"Page {self.pages.index(_p) + 1} of {len(self.pages)}")
16820 |  64 |         return _e
16821 |  65 | 
16822 |  66 |     @property
16823 |  67 |     def current_page(self):
16824 |  68 |         ...
16825 |  69 | 
16826 |  70 |     async def paginate(self):
16827 |  71 |         if self.per_page <= 1:
16828 |  72 |             self.pages = self.enteries
16829 |  73 | 
16830 |  74 |         else:
16831 |  75 |             for _ in split_list(self.enteries, self.per_page):
16832 |  76 |                 _: T.List[PageLine]
16833 |  77 |                 self.pages.append(PageLine("".join(ent.line for ent in _), _[0].image))
16834 |  78 | 
16835 |  79 |         view = QuoPageView(
16836 |  80 |             self.ctx,
16837 |  81 |             pages=self.pages,
16838 |  82 |             items=self.items,
16839 |  83 |             embed=self.embed,
16840 |  84 |             show_count=self.show_page_count,
16841 |  85 |             need_skip=self.compact,
16842 |  86 |         )
16843 |  87 |         if len(self.pages) <= 1:
16844 |  88 |             view.message = await self.ctx.send(embed=self.embed)
16845 |  89 |             return
16846 |  90 | 
16847 |  91 |         view.message = await self.ctx.send(embed=self.embed, view=view)
16848 |  92 | 
16849 |  93 | 
16850 |  94 | class QuoPageView(QuotientView):
16851 |  95 |     def __init__(
16852 |  96 |         self,
16853 |  97 |         ctx: Context,
16854 |  98 |         *,
16855 |  99 |         pages: T.List[PageLine],
16856 | 100 |         items: T.Optional[T.List[discord.ui.Item]] = None,
16857 | 101 |         embed: discord.Embed,
16858 | 102 |         show_count: bool,
16859 | 103 |         need_skip: bool,
16860 | 104 |     ):
16861 | 105 |         super().__init__(ctx, timeout=40)
16862 | 106 | 
16863 | 107 |         self.pages = pages
16864 | 108 |         self.items = items
16865 | 109 |         self.current_page = 1
16866 | 110 |         self.embed = embed
16867 | 111 |         self.show_count = show_count
16868 | 112 |         self.need_skip = need_skip
16869 | 113 | 
16870 | 114 |         self.__input_lock = asyncio.Lock()
16871 | 115 | 
16872 | 116 |         self.clear_items()
16873 | 117 |         self.fill_items()
16874 | 118 | 
16875 | 119 |     def fill_items(self) -> None:
16876 | 120 |         for item in self.items:  # Not sure about these item's positions
16877 | 121 |             self.add_item(item)
16878 | 122 | 
16879 | 123 |         self.add_item(self.first_page)
16880 | 124 |         self.add_item(self.previous_page)
16881 | 125 | 
16882 | 126 |         if self.need_skip:
16883 | 127 |             self.add_item(self.skip_page)
16884 | 128 | 
16885 | 129 |         self.add_item(self.next_page)
16886 | 130 |         self.add_item(self.last_page)
16887 | 131 | 
16888 | 132 |     def update_embed(self):
16889 | 133 |         if self.show_count:
16890 | 134 |             self.embed.set_footer(text=f"Page {self.current_page} of {len(self.pages)}")
16891 | 135 | 
16892 | 136 |         self.embed.description = self.pages[self.current_page - 1].line
16893 | 137 | 
16894 | 138 |         if self.pages[self.current_page - 1].image:
16895 | 139 |             self.embed.set_image(url=self.pages[self.current_page - 1].image)
16896 | 140 | 
16897 | 141 |     @discord.ui.button(
16898 | 142 |         style=discord.ButtonStyle.green,
16899 | 143 |         custom_id="first",
16900 | 144 |         emoji="<:double_left:878668594530099220>",
16901 | 145 |     )
16902 | 146 |     async def first_page(self, interaction: discord.Interaction, button: discord.Button):
16903 | 147 |         self.current_page = 1
16904 | 148 |         self.update_embed()
16905 | 149 | 
16906 | 150 |         await interaction.response.edit_message(embed=self.embed, view=self)
16907 | 151 | 
16908 | 152 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="previous", emoji="<:left:878668491660623872>")
16909 | 153 |     async def previous_page(self, interaction: discord.Interaction, button: discord.Button):
16910 | 154 |         if self.current_page == 1:
16911 | 155 |             return
16912 | 156 | 
16913 | 157 |         self.current_page -= 1
16914 | 158 |         self.update_embed()
16915 | 159 | 
16916 | 160 |         await interaction.response.edit_message(embed=self.embed, view=self)
16917 | 161 | 
16918 | 162 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="skipto", label="Skip to page ...")
16919 | 163 |     async def skip_page(self, interaction: discord.Interaction, button: discord.Button):
16920 | 164 |         if self.__input_lock.locked():
16921 | 165 |             return await interaction.response.send_message("Already waiting for your response...", ephemeral=True)
16922 | 166 | 
16923 | 167 |         if self.message is None:
16924 | 168 |             return
16925 | 169 | 
16926 | 170 |         async with self.__input_lock:
16927 | 171 |             channel = self.message.channel
16928 | 172 |             author_id = interaction.user and interaction.user.id
16929 | 173 |             await interaction.response.send_message("Please enter the page number you want to skip to.", ephemeral=True)
16930 | 174 | 
16931 | 175 |             def _msg_check(m: discord.Message) -> bool:
16932 | 176 |                 return m.author.id == author_id and channel == m.channel and m.content.isdigit()
16933 | 177 | 
16934 | 178 |             try:
16935 | 179 |                 msg = await self.ctx.bot.wait_for("message", check=_msg_check, timeout=30.0)
16936 | 180 |             except asyncio.TimeoutError:
16937 | 181 |                 await interaction.followup.send("Took too long.", ephemeral=True)
16938 | 182 |                 await asyncio.sleep(5)
16939 | 183 |             else:
16940 | 184 |                 page = int(msg.content)
16941 | 185 |                 await msg.delete()
16942 | 186 | 
16943 | 187 |                 if page > len(self.pages):
16944 | 188 |                     await interaction.followup.send("Page number too high.", ephemeral=True)
16945 | 189 |                     return
16946 | 190 | 
16947 | 191 |                 self.current_page = page
16948 | 192 |                 self.update_embed()
16949 | 193 | 
16950 | 194 |                 if interaction.response.is_done():
16951 | 195 |                     if self.message:
16952 | 196 |                         await self.message.edit(embed=self.embed, view=self)
16953 | 197 |                 else:
16954 | 198 |                     await interaction.response.edit_message(embed=self.embed, view=self)
16955 | 199 | 
16956 | 200 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="next", emoji="<:right:878668370331983913>")
16957 | 201 |     async def next_page(self, interaction: discord.Interaction, button: discord.Button):
16958 | 202 |         if self.current_page == len(self.pages):
16959 | 203 |             return
16960 | 204 | 
16961 | 205 |         self.current_page += 1
16962 | 206 |         self.update_embed()
16963 | 207 | 
16964 | 208 |         await interaction.response.edit_message(embed=self.embed, view=self)
16965 | 209 | 
16966 | 210 |     @discord.ui.button(
16967 | 211 |         style=discord.ButtonStyle.green,
16968 | 212 |         custom_id="last",
16969 | 213 |         emoji="<:double_right:878668437193359392>",
16970 | 214 |     )
16971 | 215 |     async def last_page(self, interaction: discord.Interaction, button: discord.Button):
16972 | 216 |         self.current_page = len(self.pages)
16973 | 217 |         self.update_embed()
16974 | 218 | 
16975 | 219 |         await interaction.response.edit_message(embed=self.embed, view=self)
16976 | 220 | 
16977 | 
16978 | 
16979 | --------------------------------------------------------------------------------
16980 | /core/cache.py:
16981 | --------------------------------------------------------------------------------
16982 |  1 | from __future__ import annotations
16983 |  2 | 
16984 |  3 | from datetime import datetime
16985 |  4 | from typing import TYPE_CHECKING
16986 |  5 | 
16987 |  6 | import config
16988 |  7 | from constants import IST
16989 |  8 | from models import AutoPurge, BlockList, EasyTag, Guild, Scrim, SSVerify, TagCheck, Tourney
16990 |  9 | 
16991 | 10 | 
16992 | 11 | class CacheManager:
16993 | 12 |     def __init__(self, bot):
16994 | 13 |         if TYPE_CHECKING:
16995 | 14 |             from .Bot import Quotient
16996 | 15 | 
16997 | 16 |         self.bot: Quotient = bot
16998 | 17 | 
16999 | 18 |         self.guild_data = {}
17000 | 19 |         self.eztagchannels = set()
17001 | 20 |         self.tagcheck = set()
17002 | 21 |         self.scrim_channels = set()
17003 | 22 |         self.tourney_channels = set()
17004 | 23 |         self.autopurge_channels = set()
17005 | 24 |         self.media_partner_channels = set()
17006 | 25 |         self.ssverify_channels = set()
17007 | 26 | 
17008 | 27 |         self.blocked_ids = set()
17009 | 28 | 
17010 | 29 |     async def fill_temp_cache(self):
17011 | 30 |         async for record in Guild.all():
17012 | 31 |             self.guild_data[record.guild_id] = {
17013 | 32 |                 "prefix": record.prefix,
17014 | 33 |                 "color": record.embed_color or config.COLOR,
17015 | 34 |                 "footer": record.embed_footer or config.FOOTER,
17016 | 35 |             }
17017 | 36 | 
17018 | 37 |         async for record in EasyTag.all():
17019 | 38 |             self.eztagchannels.add(record.channel_id)
17020 | 39 | 
17021 | 40 |         async for record in TagCheck.all():
17022 | 41 |             self.tagcheck.add(record.channel_id)
17023 | 42 | 
17024 | 43 |         async for record in Scrim.filter(opened_at__lte=datetime.now(tz=IST)).all():
17025 | 44 |             self.scrim_channels.add(record.registration_channel_id)
17026 | 45 | 
17027 | 46 |         async for record in Tourney.filter(started_at__not_isnull=True):
17028 | 47 |             self.tourney_channels.add(record.registration_channel_id)
17029 | 48 | 
17030 | 49 |         async for record in AutoPurge.all():
17031 | 50 |             self.autopurge_channels.add(record.channel_id)
17032 | 51 | 
17033 | 52 |         async for record in Tourney.all():
17034 | 53 |             async for partner in record.media_partners.all():
17035 | 54 |                 self.media_partner_channels.add(partner.channel_id)
17036 | 55 | 
17037 | 56 |         async for record in SSVerify.all():
17038 | 57 |             self.ssverify_channels.add(record.channel_id)
17039 | 58 | 
17040 | 59 |         async for record in BlockList.all():
17041 | 60 |             self.blocked_ids.add(record.block_id)
17042 | 61 | 
17043 | 62 |     def guild_color(self, guild_id: int):
17044 | 63 |         return self.guild_data.get(guild_id, {}).get("color", config.COLOR)
17045 | 64 | 
17046 | 65 |     def guild_footer(self, guild_id: int):
17047 | 66 |         return self.guild_data.get(guild_id, {}).get("footer", config.FOOTER)
17048 | 67 | 
17049 | 68 |     async def update_guild_cache(self, guild_id: int, *, set_default=False) -> None:
17050 | 69 |         if set_default:
17051 | 70 |             await Guild.get(pk=guild_id).update(
17052 | 71 |                 prefix=config.PREFIX, embed_color=config.COLOR, embed_footer=config.FOOTER
17053 | 72 |             )
17054 | 73 | 
17055 | 74 |         _g = await Guild.get(pk=guild_id)
17056 | 75 |         self.guild_data[guild_id] = {
17057 | 76 |             "prefix": _g.prefix,
17058 | 77 |             "color": _g.embed_color or config.COLOR,
17059 | 78 |             "footer": _g.embed_footer or config.FOOTER,
17060 | 79 |         }
17061 | 80 | 
17062 | 81 |     # @staticmethod
17063 | 82 |     # @cached(ttl=10, serializer=JsonSerializer())
17064 | 83 |     # async def match_bot_guild(guild_id: int, bot_id: int) -> bool:
17065 | 84 |     #     return await Guild.filter(pk=guild_id, bot_id=bot_id).exists()
17066 | 85 | 
17067 | 
17068 | 
17069 | --------------------------------------------------------------------------------
17070 | /core/cooldown.py:
17071 | --------------------------------------------------------------------------------
17072 |  1 | from __future__ import annotations
17073 |  2 | 
17074 |  3 | import typing as T
17075 |  4 | from collections import defaultdict
17076 |  5 | 
17077 |  6 | import discord
17078 |  7 | from discord.ext import commands
17079 |  8 | 
17080 |  9 | __all__ = ("QuotientRatelimiter",)
17081 | 10 | 
17082 | 11 | 
17083 | 12 | class CooldownByMember(commands.CooldownMapping):
17084 | 13 |     def _bucket_key(self, member: discord.Member):
17085 | 14 |         return member.id
17086 | 15 | 
17087 | 16 | 
17088 | 17 | class CooldownByGuild(commands.CooldownMapping):
17089 | 18 |     def _bucket_key(self, member: discord.Guild):
17090 | 19 |         return member.id
17091 | 20 | 
17092 | 21 | 
17093 | 22 | class QuotientRatelimiter:
17094 | 23 |     def __init__(self, rate: float, per: float):
17095 | 24 |         self.by_member = CooldownByMember.from_cooldown(rate, per, commands.BucketType.member)
17096 | 25 |         self.by_guild = CooldownByGuild.from_cooldown(rate, per, commands.BucketType.guild)
17097 | 26 | 
17098 | 27 |     def is_ratelimited(self, obj: T.Union[discord.Guild, discord.Member]) -> bool:
17099 | 28 |         if isinstance(obj, discord.Guild):
17100 | 29 |             return self.by_guild.get_bucket(obj).update_rate_limit()
17101 | 30 | 
17102 | 31 |         return self.by_member.get_bucket(obj).update_rate_limit()
17103 | 32 | 
17104 | 
17105 | 
17106 | --------------------------------------------------------------------------------
17107 | /core/decorators.py:
17108 | --------------------------------------------------------------------------------
17109 |  1 | from __future__ import annotations
17110 |  2 | 
17111 |  3 | from contextlib import suppress
17112 |  4 | from functools import wraps
17113 |  5 | from typing import TYPE_CHECKING, Any, Callable
17114 |  6 | 
17115 |  7 | import discord
17116 |  8 | 
17117 |  9 | from core.Context import Context
17118 | 10 | 
17119 | 11 | from .cache import CacheManager
17120 | 12 | from .Cog import Cog
17121 | 13 | 
17122 | 14 | __all__ = ("right_bot_check", "event_bot_check", "role_command_check")
17123 | 15 | 
17124 | 16 | 
17125 | 17 | class right_bot_check:
17126 | 18 |     def __call__(self, fn: Callable) -> Callable:
17127 | 19 |         @wraps(fn)
17128 | 20 |         async def wrapper(*args: Any, **kwargs: Any):
17129 | 21 |             if TYPE_CHECKING:
17130 | 22 |                 from .Bot import Quotient
17131 | 23 | 
17132 | 24 |             if isinstance(args[0], Cog):
17133 | 25 |                 bot: Quotient = args[0].bot
17134 | 26 | 
17135 | 27 |             else:
17136 | 28 |                 bot: Quotient = args[0]  # type: ignore
17137 | 29 | 
17138 | 30 |             with suppress(AttributeError):
17139 | 31 |                 for arg in args:
17140 | 32 |                     # check for both guild and guild_id
17141 | 33 |                     if hasattr(arg, "guild"):
17142 | 34 |                         guild_id = arg.guild.id
17143 | 35 |                         break
17144 | 36 |                     elif hasattr(arg, "guild_id"):
17145 | 37 |                         guild_id = arg.guild_id
17146 | 38 |                         break
17147 | 39 |                 else:
17148 | 40 |                     _obj = kwargs.get("guild") or kwargs.get("guild_id")
17149 | 41 |                     # guild id can be none here
17150 | 42 |                     guild_id = _obj.id if isinstance(_obj, discord.Guild) else _obj
17151 | 43 | 
17152 | 44 |                 if guild_id is not None and not await CacheManager.match_bot_guild(guild_id, bot.user.id):
17153 | 45 |                     return
17154 | 46 | 
17155 | 47 |             return await fn(*args, **kwargs)
17156 | 48 | 
17157 | 49 |         return wrapper
17158 | 50 | 
17159 | 51 | 
17160 | 52 | class event_bot_check:
17161 | 53 |     def __init__(self, bot_id: int):
17162 | 54 |         self.bot_id = bot_id
17163 | 55 | 
17164 | 56 |     def __call__(self, fn: Callable) -> Callable:
17165 | 57 |         @wraps(fn)
17166 | 58 |         async def wrapper(*args: Any, **kwargs: Any):
17167 | 59 |             bot_id: int = args[0].bot.user.id
17168 | 60 |             return await fn(*args, **kwargs) if bot_id == self.bot_id else None
17169 | 61 | 
17170 | 62 |         return wrapper
17171 | 63 | 
17172 | 64 | 
17173 | 65 | class role_command_check:
17174 | 66 |     def __call__(self, fn: Callable) -> Callable:
17175 | 67 |         @wraps(fn)
17176 | 68 |         async def wrapper(*args: Any, **kwargs: Any):
17177 | 69 |             _, ctx, *role = args
17178 | 70 | 
17179 | 71 |             role: discord.Role = role[0] if isinstance(role, list) else role  # type: ignore
17180 | 72 |             ctx: Context  # type: ignore
17181 | 73 | 
17182 | 74 |             if role.managed:
17183 | 75 |                 return await ctx.error(f"Role is an integrated role and cannot be added manually.")
17184 | 76 | 
17185 | 77 |             if ctx.me.top_role.position <= role.position:
17186 | 78 |                 return await ctx.error(f"The position of {role.mention} is above my toprole ({ctx.me.top_role.mention})")
17187 | 79 | 
17188 | 80 |             if not ctx.author == ctx.guild.owner and ctx.author.top_role.position <= role.position:
17189 | 81 |                 return await ctx.error(
17190 | 82 |                     f"The position of {role.mention} is above your top role ({ctx.author.top_role.mention})"
17191 | 83 |                 )
17192 | 84 | 
17193 | 85 |             if role.permissions > ctx.author.guild_permissions:
17194 | 86 |                 return await ctx.error(f"{role.mention} has higher permissions than you.")
17195 | 87 | 
17196 | 88 |             if role.permissions.administrator:
17197 | 89 |                 return await ctx.error(f"{role.mention} has administrator permissions.")
17198 | 90 | 
17199 | 91 |             return await fn(*args, **kwargs)
17200 | 92 | 
17201 | 93 |         return wrapper
17202 | 94 | 
17203 | 
17204 | 
17205 | --------------------------------------------------------------------------------
17206 | /core/embeds.py:
17207 | --------------------------------------------------------------------------------
17208 |   1 | from __future__ import annotations
17209 |   2 | 
17210 |   3 | import typing as T
17211 |   4 | from contextlib import suppress
17212 |   5 | 
17213 |   6 | import discord
17214 |   7 | 
17215 |   8 | if T.TYPE_CHECKING:
17216 |   9 |     from core import Context
17217 |  10 | 
17218 |  11 | from .views import QuoInput, QuotientView
17219 |  12 | 
17220 |  13 | 
17221 |  14 | class EmbedOptions(discord.ui.Select):
17222 |  15 |     view: EmbedBuilder
17223 |  16 | 
17224 |  17 |     def __init__(self, ctx: Context):
17225 |  18 |         self.ctx = ctx
17226 |  19 |         super().__init__(
17227 |  20 |             placeholder="Select an option to design the message.",
17228 |  21 |             options=[
17229 |  22 |                 # discord.SelectOption(
17230 |  23 |                 #     label="Normal Text",
17231 |  24 |                 #     description="This is displayed above the embed.",
17232 |  25 |                 #     emoji="<:c_:972805722276524092>",
17233 |  26 |                 #     value="content",
17234 |  27 |                 # ),
17235 |  28 |                 discord.SelectOption(
17236 |  29 |                     label="Edit Message (Title, Description, Footer)",
17237 |  30 |                     emoji="<:add:844825523003850772>",
17238 |  31 |                     value="main",
17239 |  32 |                     description="Edit your embed title, description, and footer.",
17240 |  33 |                 ),
17241 |  34 |                 discord.SelectOption(
17242 |  35 |                     label="Edit Thumbnail Image",
17243 |  36 |                     description="Small Image on the right side of embed",
17244 |  37 |                     emoji="🖼️",
17245 |  38 |                     value="thumb",
17246 |  39 |                 ),
17247 |  40 |                 discord.SelectOption(
17248 |  41 |                     label="Edit Main Image",
17249 |  42 |                     description="Edit your embed Image",
17250 |  43 |                     emoji="🖼️",
17251 |  44 |                     value="image",
17252 |  45 |                 ),
17253 |  46 |                 discord.SelectOption(
17254 |  47 |                     label="Edit Footer Icon",
17255 |  48 |                     description="Small icon near footer message",
17256 |  49 |                     emoji="🖌️",
17257 |  50 |                     value="footer_icon",
17258 |  51 |                 ),
17259 |  52 |                 discord.SelectOption(
17260 |  53 |                     label="Edit Embed Color",
17261 |  54 |                     description="Change the color of the embed",
17262 |  55 |                     emoji="<:plant:1253293916724264981>",
17263 |  56 |                     value="color",
17264 |  57 |                 ),
17265 |  58 |             ],
17266 |  59 |         )
17267 |  60 | 
17268 |  61 |     async def callback(self, interaction: discord.Interaction):
17269 |  62 |         assert self.view is not None
17270 |  63 | 
17271 |  64 |         if (selected := self.values[0]) == "content":
17272 |  65 |             modal = Content()
17273 |  66 |             await interaction.response.send_modal(modal)
17274 |  67 |             await modal.wait()
17275 |  68 |             self.view.content = modal._content.value or ""
17276 |  69 | 
17277 |  70 |             await self.view.refresh_view()
17278 |  71 | 
17279 |  72 |         elif selected == "main":
17280 |  73 |             modal = QuoInput("Set Embed Message")
17281 |  74 |             modal.add_item(
17282 |  75 |                 discord.ui.TextInput(
17283 |  76 |                     label="Title",
17284 |  77 |                     placeholder="Enter text for title of embed here...",
17285 |  78 |                     max_length=256,
17286 |  79 |                     required=False,
17287 |  80 |                     style=discord.TextStyle.short,
17288 |  81 |                     default=self.view.embed.title,
17289 |  82 |                 )
17290 |  83 |             )
17291 |  84 |             modal.add_item(
17292 |  85 |                 discord.ui.TextInput(
17293 |  86 |                     label="Description",
17294 |  87 |                     placeholder="Enter text for description of embed here...",
17295 |  88 |                     max_length=4000,
17296 |  89 |                     required=False,
17297 |  90 |                     style=discord.TextStyle.long,
17298 |  91 |                     default=self.view.embed.description,
17299 |  92 |                 )
17300 |  93 |             )
17301 |  94 |             modal.add_item(
17302 |  95 |                 discord.ui.TextInput(
17303 |  96 |                     label="Footer Text",
17304 |  97 |                     placeholder="Enter text for footer of embed here...",
17305 |  98 |                     style=discord.TextStyle.long,
17306 |  99 |                     max_length=2048,
17307 | 100 |                     required=False,
17308 | 101 |                     default=self.view.embed.footer.text,
17309 | 102 |                 )
17310 | 103 |             )
17311 | 104 |             await interaction.response.send_modal(modal)
17312 | 105 |             await modal.wait()
17313 | 106 | 
17314 | 107 |             t, d, f = str(modal.children[0]), str(modal.children[1]), str(modal.children[2])
17315 | 108 | 
17316 | 109 |             self.view.embed.title = t or None
17317 | 110 |             self.view.embed.description = d or None
17318 | 111 |             self.view.embed.set_footer(text=f or None, icon_url=self.view.embed.footer.icon_url)
17319 | 112 | 
17320 | 113 |             await self.view.refresh_view()
17321 | 114 | 
17322 | 115 |         elif selected == "thumb":
17323 | 116 |             modal = QuoInput("Edit Thumbnail Image")
17324 | 117 |             modal.add_item(
17325 | 118 |                 discord.ui.TextInput(
17326 | 119 |                     label="Enter Image URL (Optional)",
17327 | 120 |                     placeholder="Leave empty to remove Image.",
17328 | 121 |                     required=False,
17329 | 122 |                     default=getattr(self.view.embed.thumbnail, "url", None),
17330 | 123 |                 )
17331 | 124 |             )
17332 | 125 |             await interaction.response.send_modal(modal)
17333 | 126 |             await modal.wait()
17334 | 127 |             url = str(modal.children[0]) or None
17335 | 128 | 
17336 | 129 |             if not url or not url.startswith("https"):
17337 | 130 |                 self.view.embed.set_thumbnail(url=None)
17338 | 131 | 
17339 | 132 |             else:
17340 | 133 |                 self.view.embed.set_thumbnail(url=url)
17341 | 134 |             await self.view.refresh_view()
17342 | 135 | 
17343 | 136 |         elif selected == "image":
17344 | 137 |             modal = QuoInput("Edit Main Image")
17345 | 138 |             modal.add_item(
17346 | 139 |                 discord.ui.TextInput(
17347 | 140 |                     label="Enter Image URL (Optional)",
17348 | 141 |                     placeholder="Leave empty to remove Image.",
17349 | 142 |                     required=False,
17350 | 143 |                     default=getattr(self.view.embed.image, "url", None),
17351 | 144 |                 )
17352 | 145 |             )
17353 | 146 |             await interaction.response.send_modal(modal)
17354 | 147 |             await modal.wait()
17355 | 148 |             url = str(modal.children[0]) or None
17356 | 149 | 
17357 | 150 |             if not url or not url.startswith("https"):
17358 | 151 |                 self.view.embed.set_image(url=None)
17359 | 152 | 
17360 | 153 |             else:
17361 | 154 |                 self.view.embed.set_image(url=url)
17362 | 155 | 
17363 | 156 |             await self.view.refresh_view()
17364 | 157 | 
17365 | 158 |         elif selected == "footer_icon":
17366 | 159 |             modal = QuoInput("Edit Footer Icon")
17367 | 160 |             modal.add_item(
17368 | 161 |                 discord.ui.TextInput(
17369 | 162 |                     label="Enter Image URL (Optional)",
17370 | 163 |                     placeholder="Leave empty to remove Icon.",
17371 | 164 |                     required=False,
17372 | 165 |                     default=getattr(self.view.embed.footer, "icon_url", None),
17373 | 166 |                 )
17374 | 167 |             )
17375 | 168 |             await interaction.response.send_modal(modal)
17376 | 169 |             await modal.wait()
17377 | 170 |             url = str(modal.children[0]) or None
17378 | 171 | 
17379 | 172 |             if not url or not url.startswith("https"):
17380 | 173 |                 self.view.embed.set_footer(icon_url=None, text=self.view.embed.footer.text)
17381 | 174 | 
17382 | 175 |             else:
17383 | 176 |                 self.view.embed.set_footer(icon_url=url, text=self.view.embed.footer.text)
17384 | 177 | 
17385 | 178 |             await self.view.refresh_view()
17386 | 179 | 
17387 | 180 |         elif selected == "color":
17388 | 181 |             from utils import QuoColor
17389 | 182 | 
17390 | 183 |             modal = QuoInput("Set Embed Color")
17391 | 184 |             modal.add_item(
17392 | 185 |                 discord.ui.TextInput(
17393 | 186 |                     label="Enter a valid Color",
17394 | 187 |                     placeholder="Examples: red, yellow, #00ffb3, etc.",
17395 | 188 |                     required=False,
17396 | 189 |                     max_length=7,
17397 | 190 |                 )
17398 | 191 |             )
17399 | 192 |             await interaction.response.send_modal(modal)
17400 | 193 |             await modal.wait()
17401 | 194 | 
17402 | 195 |             color = 0x36393E
17403 | 196 | 
17404 | 197 |             with suppress(ValueError):
17405 | 198 |                 if c := str(modal.children[0]):
17406 | 199 |                     color = int(str(await QuoColor.convert(self.ctx, c)).replace("#", ""), 16)
17407 | 200 | 
17408 | 201 |             self.view.embed.color = color
17409 | 202 | 
17410 | 203 |             await self.view.refresh_view()
17411 | 204 | 
17412 | 205 | 
17413 | 206 | class EmbedBuilder(QuotientView):
17414 | 207 |     def __init__(self, ctx: Context, **kwargs: T.Any):
17415 | 208 |         super().__init__(ctx, timeout=100)
17416 | 209 | 
17417 | 210 |         self.ctx = ctx
17418 | 211 |         self.add_item(EmbedOptions(self.ctx))
17419 | 212 | 
17420 | 213 |         for _ in kwargs.get("items", []):  # to add extra buttons and handle this view externally
17421 | 214 |             self.add_item(_)
17422 | 215 | 
17423 | 216 |     @property
17424 | 217 |     def formatted(self):
17425 | 218 |         return self.embed.to_dict()
17426 | 219 | 
17427 | 220 |     async def refresh_view(self, to_del: T.Optional[discord.Message] = None):
17428 | 221 |         if to_del is not None:
17429 | 222 |             await self.ctx.safe_delete(to_del)
17430 | 223 | 
17431 | 224 |         with suppress(discord.HTTPException):
17432 | 225 |             self.message = await self.message.edit(content=self.content, embed=self.embed, view=self)
17433 | 226 | 
17434 | 227 |     async def rendor(self, **kwargs: T.Any):
17435 | 228 |         self.message: discord.Message = await self.ctx.send(
17436 | 229 |             kwargs.get("content", ""),
17437 | 230 |             embed=kwargs.get("embed", self.help_embed),
17438 | 231 |             view=self,
17439 | 232 |         )
17440 | 233 | 
17441 | 234 |         self.content = self.message.content
17442 | 235 |         self.embed = self.message.embeds[0]
17443 | 236 | 
17444 | 237 |     @property
17445 | 238 |     def help_embed(self):
17446 | 239 |         return (
17447 | 240 |             discord.Embed(color=self.bot.color, title="Title", description="Description")
17448 | 241 |             .set_thumbnail(url="https://cdn.discordapp.com/attachments/853174868551532564/860464565338898472/embed_thumbnail.png")
17449 | 242 |             .set_image(url="https://cdn.discordapp.com/attachments/853174868551532564/860462053063393280/embed_image.png")
17450 | 243 |             .set_footer(
17451 | 244 |                 text="Footer Message",
17452 | 245 |                 icon_url="https://media.discordapp.net/attachments/853174868551532564/860464989164535828/embed_footer.png",
17453 | 246 |             )
17454 | 247 |         )
17455 | 248 | 
17456 | 249 | 
17457 | 250 | class Content(discord.ui.Modal, title="Edit Message Content"):
17458 | 251 |     _content: discord.ui.TextInput = discord.ui.TextInput(
17459 | 252 |         label="Content",
17460 | 253 |         placeholder="This text will be displayed over the embed",
17461 | 254 |         required=False,
17462 | 255 |         max_length=2000,
17463 | 256 |         style=discord.TextStyle.long,
17464 | 257 |     )
17465 | 258 | 
17466 | 259 |     async def on_submit(self, interaction: discord.Interaction) -> None:
17467 | 260 |         await interaction.response.defer()
17468 | 261 | 
17469 | 
17470 | 
17471 | --------------------------------------------------------------------------------
17472 | /core/views.py:
17473 | --------------------------------------------------------------------------------
17474 |  1 | from __future__ import annotations
17475 |  2 | 
17476 |  3 | from contextlib import suppress
17477 |  4 | from typing import TYPE_CHECKING, Optional
17478 |  5 | 
17479 |  6 | import discord
17480 |  7 | 
17481 |  8 | import config
17482 |  9 | from utils import emote
17483 | 10 | 
17484 | 11 | if TYPE_CHECKING:
17485 | 12 |     from .Context import Context
17486 | 13 | 
17487 | 14 | __all__ = ("QuotientView", "QuoInput", "QuoDMView")
17488 | 15 | 
17489 | 16 | 
17490 | 17 | class QuotientView(discord.ui.View):
17491 | 18 |     message: discord.Message
17492 | 19 |     custom_id = None
17493 | 20 | 
17494 | 21 |     def __init__(self, ctx: Context, *, timeout: Optional[float] = 30):
17495 | 22 |         super().__init__(timeout=timeout)
17496 | 23 |         self.ctx = ctx
17497 | 24 |         self.bot = ctx.bot
17498 | 25 | 
17499 | 26 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
17500 | 27 |         if interaction.user.id != self.ctx.author.id:
17501 | 28 |             await interaction.response.send_message(
17502 | 29 |                 "Sorry, you can't use this interaction as it is not started by you.",
17503 | 30 |                 ephemeral=True,
17504 | 31 |             )
17505 | 32 |             return False
17506 | 33 |         return True
17507 | 34 | 
17508 | 35 |     async def on_timeout(self) -> None:
17509 | 36 |         if hasattr(self, "message"):
17510 | 37 |             for b in self.children:
17511 | 38 |                 if isinstance(b, discord.ui.Button) and not b.style == discord.ButtonStyle.link:
17512 | 39 |                     b.style, b.disabled = discord.ButtonStyle.grey, True
17513 | 40 | 
17514 | 41 |                 elif isinstance(b, discord.ui.Select):
17515 | 42 |                     b.disabled = True
17516 | 43 | 
17517 | 44 |             with suppress(discord.HTTPException):
17518 | 45 |                 await self.message.edit(view=self)
17519 | 46 |                 return
17520 | 47 | 
17521 | 48 |     async def on_error(self, interaction: discord.Interaction, error: Exception, item) -> None:
17522 | 49 |         print("Quotient View Error:", error)
17523 | 50 |         self.ctx.bot.dispatch("command_error", self.ctx, error)
17524 | 51 | 
17525 | 52 |     @staticmethod
17526 | 53 |     def tricky_invite_button():  # yes lmao
17527 | 54 |         return discord.ui.Button(emoji=emote.info, url=config.SERVER_LINK)
17528 | 55 | 
17529 | 56 | 
17530 | 57 | class QuoInput(discord.ui.Modal):
17531 | 58 |     def __init__(self, title: str):
17532 | 59 |         super().__init__(title=title)
17533 | 60 | 
17534 | 61 |     async def on_submit(self, interaction: discord.Interaction) -> None:
17535 | 62 |         with suppress(discord.NotFound):
17536 | 63 |             await interaction.response.defer()
17537 | 64 | 
17538 | 65 | 
17539 | 66 | class QuoDMView(discord.ui.View):
17540 | 67 |     def __init__(self, *, timeout: float = 180, label: Optional[str] = None):
17541 | 68 |         super().__init__(timeout=timeout)
17542 | 69 | 
17543 | 70 |         self.add_item(
17544 | 71 |             discord.ui.Button(
17545 | 72 |                 style=discord.ButtonStyle.blurple,
17546 | 73 |                 label=label,
17547 | 74 |                 disabled=True,
17548 | 75 |             )
17549 | 76 |         )
17550 | 77 | 
17551 | 
17552 | 
17553 | --------------------------------------------------------------------------------
17554 | /data/font/Ubuntu-Regular.ttf:
17555 | --------------------------------------------------------------------------------
17556 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/font/Ubuntu-Regular.ttf
17557 | 
17558 | 
17559 | --------------------------------------------------------------------------------
17560 | /data/font/robo-bold.ttf:
17561 | --------------------------------------------------------------------------------
17562 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/font/robo-bold.ttf
17563 | 
17564 | 
17565 | --------------------------------------------------------------------------------
17566 | /data/font/robo-italic.ttf:
17567 | --------------------------------------------------------------------------------
17568 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/font/robo-italic.ttf
17569 | 
17570 | 
17571 | --------------------------------------------------------------------------------
17572 | /data/img/ptable1.jpg:
17573 | --------------------------------------------------------------------------------
17574 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable1.jpg
17575 | 
17576 | 
17577 | --------------------------------------------------------------------------------
17578 | /data/img/ptable10.jpg:
17579 | --------------------------------------------------------------------------------
17580 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable10.jpg
17581 | 
17582 | 
17583 | --------------------------------------------------------------------------------
17584 | /data/img/ptable11.jpg:
17585 | --------------------------------------------------------------------------------
17586 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable11.jpg
17587 | 
17588 | 
17589 | --------------------------------------------------------------------------------
17590 | /data/img/ptable12.jpg:
17591 | --------------------------------------------------------------------------------
17592 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable12.jpg
17593 | 
17594 | 
17595 | --------------------------------------------------------------------------------
17596 | /data/img/ptable13.jpg:
17597 | --------------------------------------------------------------------------------
17598 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable13.jpg
17599 | 
17600 | 
17601 | --------------------------------------------------------------------------------
17602 | /data/img/ptable14.jpg:
17603 | --------------------------------------------------------------------------------
17604 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable14.jpg
17605 | 
17606 | 
17607 | --------------------------------------------------------------------------------
17608 | /data/img/ptable15.jpg:
17609 | --------------------------------------------------------------------------------
17610 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable15.jpg
17611 | 
17612 | 
17613 | --------------------------------------------------------------------------------
17614 | /data/img/ptable16.jpg:
17615 | --------------------------------------------------------------------------------
17616 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable16.jpg
17617 | 
17618 | 
17619 | --------------------------------------------------------------------------------
17620 | /data/img/ptable17.jpg:
17621 | --------------------------------------------------------------------------------
17622 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable17.jpg
17623 | 
17624 | 
17625 | --------------------------------------------------------------------------------
17626 | /data/img/ptable18.jpg:
17627 | --------------------------------------------------------------------------------
17628 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable18.jpg
17629 | 
17630 | 
17631 | --------------------------------------------------------------------------------
17632 | /data/img/ptable19.jpg:
17633 | --------------------------------------------------------------------------------
17634 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable19.jpg
17635 | 
17636 | 
17637 | --------------------------------------------------------------------------------
17638 | /data/img/ptable2.jpg:
17639 | --------------------------------------------------------------------------------
17640 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable2.jpg
17641 | 
17642 | 
17643 | --------------------------------------------------------------------------------
17644 | /data/img/ptable20.jpg:
17645 | --------------------------------------------------------------------------------
17646 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable20.jpg
17647 | 
17648 | 
17649 | --------------------------------------------------------------------------------
17650 | /data/img/ptable3.jpg:
17651 | --------------------------------------------------------------------------------
17652 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable3.jpg
17653 | 
17654 | 
17655 | --------------------------------------------------------------------------------
17656 | /data/img/ptable4.jpg:
17657 | --------------------------------------------------------------------------------
17658 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable4.jpg
17659 | 
17660 | 
17661 | --------------------------------------------------------------------------------
17662 | /data/img/ptable5.jpg:
17663 | --------------------------------------------------------------------------------
17664 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable5.jpg
17665 | 
17666 | 
17667 | --------------------------------------------------------------------------------
17668 | /data/img/ptable6.jpg:
17669 | --------------------------------------------------------------------------------
17670 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable6.jpg
17671 | 
17672 | 
17673 | --------------------------------------------------------------------------------
17674 | /data/img/ptable7.jpg:
17675 | --------------------------------------------------------------------------------
17676 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable7.jpg
17677 | 
17678 | 
17679 | --------------------------------------------------------------------------------
17680 | /data/img/ptable8.jpg:
17681 | --------------------------------------------------------------------------------
17682 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable8.jpg
17683 | 
17684 | 
17685 | --------------------------------------------------------------------------------
17686 | /data/img/ptable9.jpg:
17687 | --------------------------------------------------------------------------------
17688 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/ptable9.jpg
17689 | 
17690 | 
17691 | --------------------------------------------------------------------------------
17692 | /data/img/rect2.png:
17693 | --------------------------------------------------------------------------------
17694 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/rect2.png
17695 | 
17696 | 
17697 | --------------------------------------------------------------------------------
17698 | /data/img/rect3.png:
17699 | --------------------------------------------------------------------------------
17700 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/rect3.png
17701 | 
17702 | 
17703 | --------------------------------------------------------------------------------
17704 | /data/img/rectangle.png:
17705 | --------------------------------------------------------------------------------
17706 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/data/img/rectangle.png
17707 | 
17708 | 
17709 | --------------------------------------------------------------------------------
17710 | /example_config.py:
17711 | --------------------------------------------------------------------------------
17712 |  1 | # for tortoise-orm
17713 |  2 | 
17714 |  3 | TORTOISE = {}
17715 |  4 | 
17716 |  5 | 
17717 |  6 | POSTGRESQL = {}
17718 |  7 | 
17719 |  8 | EXTENSIONS = ()
17720 |  9 | 
17721 | 10 | DISCORD_TOKEN = ""
17722 | 11 | 
17723 | 12 | COLOR = 0x00FFB3
17724 | 13 | 
17725 | 14 | FOOTER = "quo is lub!"
17726 | 15 | 
17727 | 16 | PREFIX = "q"
17728 | 17 | 
17729 | 18 | SERVER_LINK = ""
17730 | 19 | 
17731 | 20 | BOT_INVITE = ""
17732 | 21 | 
17733 | 22 | WEBSITE = ""
17734 | 23 | 
17735 | 24 | REPOSITORY = ""
17736 | 25 | 
17737 | 26 | DEVS = ()
17738 | 27 | 
17739 | 28 | # LOGS
17740 | 29 | SHARD_LOG = ""
17741 | 30 | ERROR_LOG = ""
17742 | 31 | PUBLIC_LOG = ""
17743 | 32 | 
17744 | 
17745 | 
17746 | --------------------------------------------------------------------------------
17747 | /models/__init__.py:
17748 | --------------------------------------------------------------------------------
17749 |  1 | from __future__ import annotations
17750 |  2 | 
17751 |  3 | import typing
17752 |  4 | 
17753 |  5 | if typing.TYPE_CHECKING:
17754 |  6 |     from core import Quotient
17755 |  7 | 
17756 |  8 | from tortoise import models
17757 |  9 | 
17758 | 10 | 
17759 | 11 | class BaseDbModel(models.Model):
17760 | 12 |     """Base Model for all tortoise models"""
17761 | 13 | 
17762 | 14 |     class Meta:
17763 | 15 |         abstract = True
17764 | 16 | 
17765 | 17 |     bot: Quotient
17766 | 18 | 
17767 | 19 | 
17768 | 20 | from .esports import *
17769 | 21 | from .helpers import *
17770 | 22 | from .misc import *
17771 | 23 | 
17772 | 
17773 | 
17774 | --------------------------------------------------------------------------------
17775 | /models/__pycache__/__init__.cpython-312.pyc:
17776 | --------------------------------------------------------------------------------
17777 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/__pycache__/__init__.cpython-312.pyc
17778 | 
17779 | 
17780 | --------------------------------------------------------------------------------
17781 | /models/esports/__init__.py:
17782 | --------------------------------------------------------------------------------
17783 | 1 | from .scrims import *
17784 | 2 | from .slotm import *
17785 | 3 | from .ssverify import *
17786 | 4 | from .tagcheck import *
17787 | 5 | from .tourney import *
17788 | 6 | 
17789 | 
17790 | 
17791 | --------------------------------------------------------------------------------
17792 | /models/esports/__pycache__/__init__.cpython-312.pyc:
17793 | --------------------------------------------------------------------------------
17794 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/esports/__pycache__/__init__.cpython-312.pyc
17795 | 
17796 | 
17797 | --------------------------------------------------------------------------------
17798 | /models/esports/__pycache__/scrims.cpython-312.pyc:
17799 | --------------------------------------------------------------------------------
17800 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/esports/__pycache__/scrims.cpython-312.pyc
17801 | 
17802 | 
17803 | --------------------------------------------------------------------------------
17804 | /models/esports/__pycache__/slotm.cpython-312.pyc:
17805 | --------------------------------------------------------------------------------
17806 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/esports/__pycache__/slotm.cpython-312.pyc
17807 | 
17808 | 
17809 | --------------------------------------------------------------------------------
17810 | /models/esports/__pycache__/ssverify.cpython-312.pyc:
17811 | --------------------------------------------------------------------------------
17812 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/esports/__pycache__/ssverify.cpython-312.pyc
17813 | 
17814 | 
17815 | --------------------------------------------------------------------------------
17816 | /models/esports/__pycache__/tagcheck.cpython-312.pyc:
17817 | --------------------------------------------------------------------------------
17818 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/esports/__pycache__/tagcheck.cpython-312.pyc
17819 | 
17820 | 
17821 | --------------------------------------------------------------------------------
17822 | /models/esports/__pycache__/tourney.cpython-312.pyc:
17823 | --------------------------------------------------------------------------------
17824 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/esports/__pycache__/tourney.cpython-312.pyc
17825 | 
17826 | 
17827 | --------------------------------------------------------------------------------
17828 | /models/esports/ptable.py:
17829 | --------------------------------------------------------------------------------
17830 |  1 | from tortoise import fields, models
17831 |  2 | 
17832 |  3 | from models.helpers import *
17833 |  4 | 
17834 |  5 | 
17835 |  6 | class PtableTourney(models.Model):
17836 |  7 |     class Meta:
17837 |  8 |         table = "ptable_tourney"
17838 |  9 | 
17839 | 10 |     id = fields.IntField(pk=True)
17840 | 11 |     guild_id = fields.BigIntField()
17841 | 12 |     associative_id = fields.CharField(max_length=10)
17842 | 13 |     title = fields.CharField(max_length=100)
17843 | 14 |     secondary_title = fields.CharField(max_length=100)
17844 | 15 |     footer = fields.CharField(max_length=100)
17845 | 16 | 
17846 | 17 |     per_kill = fields.IntField(default=0)
17847 | 18 |     postion_pts = fields.JSONField(default=dict)
17848 | 19 | 
17849 | 20 |     background_image = fields.CharField(max_length=200)
17850 | 21 |     colors = fields.JSONField(default=dict)
17851 | 22 | 
17852 | 23 |     created_at = fields.DatetimeField(auto_now_add=True)
17853 | 24 |     teams: fields.ManyToManyRelation["PtableTeam"] = fields.ManyToManyField("models.PtableTeam")
17854 | 25 |     matches: fields.ManyToManyRelation["PtableMatch"] = fields.ManyToManyField("models.PtableMatch")
17855 | 26 | 
17856 | 27 | 
17857 | 28 | class PtableTeam(models.Model):
17858 | 29 |     class Meta:
17859 | 30 |         table = "ptable_teams"
17860 | 31 | 
17861 | 32 |     id = fields.IntField(pk=True)
17862 | 33 |     team_name = fields.CharField(max_length=100)
17863 | 34 |     email = fields.CharField(max_length=100, null=True)
17864 | 35 |     phone = fields.CharField(max_length=10, null=True)
17865 | 36 |     logo = fields.CharField(max_length=200, null=True)
17866 | 37 |     added_by = fields.BigIntField()
17867 | 38 |     team_owner = fields.BigIntField()
17868 | 39 |     players = ArrayField(fields.BigIntField(default=list))
17869 | 40 |     last_used = fields.DatetimeField(auto_now=True)
17870 | 41 | 
17871 | 42 | 
17872 | 43 | class PtableMatch(models.Model):
17873 | 44 |     class Meta:
17874 | 45 |         table = "ptable_match"
17875 | 46 | 
17876 | 47 |     id = fields.IntField(pk=True)
17877 | 48 |     name = fields.CharField(max_length=100)
17878 | 49 |     created_at = fields.DatetimeField(auto_now=True)
17879 | 50 |     created_by = fields.BigIntField()
17880 | 51 |     results = fields.JSONField()
17881 | 52 | 
17882 | 
17883 | 
17884 | --------------------------------------------------------------------------------
17885 | /models/esports/reserve.py:
17886 | --------------------------------------------------------------------------------
17887 |  1 | from tortoise import fields, models
17888 |  2 | 
17889 |  3 | from models.helpers import *
17890 |  4 | 
17891 |  5 | 
17892 |  6 | class Subscriptions(models.Model):
17893 |  7 |     class Meta:
17894 |  8 |         table = "subscriptions"
17895 |  9 | 
17896 | 10 |     guild_id = fields.BigIntField(pk=True)
17897 | 11 |     log_channel_id = fields.BigIntField()
17898 | 12 |     slug = fields.CharField(max_length=20)
17899 | 13 |     balance = fields.IntField(default=0)
17900 | 14 |     upi_id = fields.CharField(max_length=25)
17901 | 15 | 
17902 | 16 |     plans: fields.ManyToManyRelation["SubPlan"] = fields.ManyToManyField("models.SubPlan")
17903 | 17 |     logs: fields.ManyToManyRelation["SubLog"] = fields.ManyToManyField("models.SubLog")
17904 | 18 | 
17905 | 19 | 
17906 | 20 | class SubPlan(models.Model):
17907 | 21 |     class Meta:
17908 | 22 |         table = "subscription_plans"
17909 | 23 | 
17910 | 24 |     id = fields.IntField(pk=True)
17911 | 25 |     name = fields.CharField(max_length=30)
17912 | 26 |     theme_color = fields.CharField(max_length=7)
17913 | 27 |     days = fields.IntField(default=1)
17914 | 28 |     slots = fields.IntField(default=1)
17915 | 29 |     perks = ArrayField(fields.CharField(max_length=100))
17916 | 30 |     price = fields.IntField()
17917 | 31 | 
17918 | 32 | 
17919 | 33 | class SubLog(models.Model):
17920 | 34 |     class Meta:
17921 | 35 |         table = "subscription_logs"
17922 | 36 | 
17923 | 37 |     id = fields.IntField(pk=True)
17924 | 38 | 
17925 | 
17926 | 
17927 | --------------------------------------------------------------------------------
17928 | /models/esports/scrims.py:
17929 | --------------------------------------------------------------------------------
17930 |   1 | import asyncio
17931 |   2 | import io
17932 |   3 | from ast import literal_eval as leval
17933 |   4 | from contextlib import suppress
17934 |   5 | from datetime import timedelta
17935 |   6 | from pathlib import Path
17936 |   7 | from typing import List, Optional
17937 |   8 | 
17938 |   9 | import discord
17939 |  10 | import humanize
17940 |  11 | from aiocache import cached
17941 |  12 | from PIL import Image, ImageDraw, ImageFont
17942 |  13 | from tortoise import fields, models
17943 |  14 | 
17944 |  15 | import utils
17945 |  16 | from constants import AutocleanType, Day, EsportsLog, EsportsRole
17946 |  17 | from core import Context
17947 |  18 | from models import BaseDbModel
17948 |  19 | from models.helpers import *
17949 |  20 | from utils import discord_timestamp, plural, truncate_string
17950 |  21 | 
17951 |  22 | 
17952 |  23 | class Scrim(BaseDbModel):
17953 |  24 |     class Meta:
17954 |  25 |         table = "sm.scrims"
17955 |  26 | 
17956 |  27 |     id = fields.BigIntField(pk=True, index=True)
17957 |  28 |     guild_id = fields.BigIntField()
17958 |  29 |     name = fields.TextField(default="Quotient-Scrims")
17959 |  30 |     registration_channel_id = fields.BigIntField(index=True)
17960 |  31 |     slotlist_channel_id = fields.BigIntField()
17961 |  32 |     slotlist_message_id = fields.BigIntField(null=True)
17962 |  33 |     role_id = fields.BigIntField(null=True)
17963 |  34 |     required_mentions = fields.IntField(default=4)
17964 |  35 |     start_from = fields.IntField(default=1)
17965 |  36 |     available_slots = ArrayField(fields.IntField(), default=list)
17966 |  37 |     total_slots = fields.IntField()
17967 |  38 |     host_id = fields.BigIntField()
17968 |  39 |     open_time = fields.DatetimeField()
17969 |  40 |     opened_at = fields.DatetimeField(null=True)
17970 |  41 |     closed_at = fields.DatetimeField(null=True)
17971 |  42 | 
17972 |  43 |     autoclean = ArrayField(fields.CharEnumField(AutocleanType), default=lambda: list(AutocleanType))
17973 |  44 |     autoclean_done = fields.BooleanField(default=False)
17974 |  45 |     autoclean_time = fields.DatetimeField(null=True)
17975 |  46 | 
17976 |  47 |     autoslotlist = fields.BooleanField(default=True)
17977 |  48 |     ping_role_id = fields.BigIntField(null=True)
17978 |  49 |     multiregister = fields.BooleanField(default=False)
17979 |  50 |     stoggle = fields.BooleanField(default=True)
17980 |  51 |     open_role_id = fields.BigIntField(null=True)
17981 |  52 |     autodelete_rejects = fields.BooleanField(default=False)
17982 |  53 |     autodelete_extras = fields.BooleanField(default=True)
17983 |  54 |     teamname_compulsion = fields.BooleanField(default=False)
17984 |  55 | 
17985 |  56 |     time_elapsed = fields.CharField(null=True, max_length=100)
17986 |  57 |     show_time_elapsed = fields.BooleanField(default=True)
17987 |  58 | 
17988 |  59 |     open_days = ArrayField(fields.CharEnumField(Day), default=lambda: list(Day))
17989 |  60 |     slotlist_format = fields.JSONField(default=dict)  #!str > jsonb
17990 |  61 | 
17991 |  62 |     no_duplicate_name = fields.BooleanField(default=False)
17992 |  63 | 
17993 |  64 |     open_message = fields.JSONField(default=dict)
17994 |  65 |     close_message = fields.JSONField(default=dict)
17995 |  66 |     banlog_channel_id = fields.BigIntField(null=True)
17996 |  67 | 
17997 |  68 |     match_time = fields.DatetimeField(null=True)
17998 |  69 | 
17999 |  70 |     emojis = fields.JSONField(default=dict)  #!new
18000 |  71 |     cdn = fields.JSONField(default={"status": False, "countdown": 3, "msg": {}})  #!new
18001 |  72 | 
18002 |  73 |     required_lines = fields.SmallIntField(default=0)
18003 |  74 |     allow_duplicate_tags = fields.BooleanField(default=True)
18004 |  75 |     # require_drop_location = fields.BooleanField(default=False)
18005 |  76 | 
18006 |  77 |     assigned_slots: fields.ManyToManyRelation["AssignedSlot"] = fields.ManyToManyField("models.AssignedSlot")
18007 |  78 |     reserved_slots: fields.ManyToManyRelation["ReservedSlot"] = fields.ManyToManyField("models.ReservedSlot")
18008 |  79 |     banned_teams: fields.ManyToManyRelation["BannedTeam"] = fields.ManyToManyField("models.BannedTeam")
18009 |  80 |     slot_reminders: fields.ManyToManyRelation["ScrimsSlotReminder"] = fields.ManyToManyField("models.ScrimsSlotReminder")
18010 |  81 | 
18011 |  82 |     def __str__(self):
18012 |  83 |         return f"{getattr(self.registration_channel,'mention','deleted-channel')} (ID: {self.id})"
18013 |  84 | 
18014 |  85 |     @staticmethod
18015 |  86 |     def is_ignorable(member: discord.Member) -> bool:
18016 |  87 |         return "scrims-mod" in (role.name.lower() for role in member.roles)
18017 |  88 | 
18018 |  89 |     @property
18019 |  90 |     def guild(self) -> Optional[discord.Guild]:
18020 |  91 |         return self.bot.get_guild(self.guild_id)
18021 |  92 | 
18022 |  93 |     @property
18023 |  94 |     def role(self):
18024 |  95 |         if self.guild is not None:
18025 |  96 |             return self.guild.get_role(self.role_id)
18026 |  97 | 
18027 |  98 |     @property
18028 |  99 |     def logschan(self):
18029 | 100 |         if self.guild is not None:
18030 | 101 |             return discord.utils.get(self.guild.text_channels, name="quotient-scrims-logs")
18031 | 102 | 
18032 | 103 |     @property
18033 | 104 |     def modrole(self):
18034 | 105 |         if self.guild is not None:
18035 | 106 |             return discord.utils.get(self.guild.roles, name="scrims-mod")
18036 | 107 | 
18037 | 108 |     @property
18038 | 109 |     def registration_channel(self):
18039 | 110 |         return self.bot.get_channel(self.registration_channel_id)
18040 | 111 | 
18041 | 112 |     @property
18042 | 113 |     def banlog_channel(self):
18043 | 114 |         return self.bot.get_channel(self.banlog_channel_id)
18044 | 115 | 
18045 | 116 |     @property
18046 | 117 |     def slotlist_channel(self):
18047 | 118 |         return self.bot.get_channel(self.slotlist_channel_id)
18048 | 119 | 
18049 | 120 |     @property
18050 | 121 |     def host(self):
18051 | 122 |         if self.guild is not None:
18052 | 123 |             return self.guild.get_member(self.host_id)
18053 | 124 | 
18054 | 125 |         return self.bot.get_user(self.host_id)
18055 | 126 | 
18056 | 127 |     @property
18057 | 128 |     def check_emoji(self):
18058 | 129 |         return self.emojis.get("tick", "✅")
18059 | 130 | 
18060 | 131 |     @property
18061 | 132 |     def cross_emoji(self):
18062 | 133 |         return self.emojis.get("cross", "❌")
18063 | 134 | 
18064 | 135 |     @property
18065 | 136 |     def available_to_reserve(self):
18066 | 137 |         """
18067 | 138 |         gives a range obj of available slots to reserve.
18068 | 139 |         this isn't true because some slots might be already reserved , we will sort them later
18069 | 140 |         """
18070 | 141 |         return range(self.start_from, self.total_slots + self.start_from)
18071 | 142 | 
18072 | 143 |     @property
18073 | 144 |     def opened(self):
18074 | 145 |         if self.opened_at is None:
18075 | 146 |             return False
18076 | 147 | 
18077 | 148 |         if self.closed_at is not None:
18078 | 149 |             return self.closed_at < self.opened_at
18079 | 150 | 
18080 | 151 |         return True
18081 | 152 | 
18082 | 153 |     @property
18083 | 154 |     def closed(self):
18084 | 155 |         return not self.opened
18085 | 156 | 
18086 | 157 |     @property
18087 | 158 |     def ping_role(self):
18088 | 159 |         if self.guild is not None:
18089 | 160 |             return self.guild.get_role(self.ping_role_id)
18090 | 161 | 
18091 | 162 |     @property
18092 | 163 |     def open_role(self):
18093 | 164 |         if self.guild is not None:
18094 | 165 |             if self.open_role_id is not None:
18095 | 166 |                 return self.guild.get_role(self.open_role_id)
18096 | 167 |             return self.guild.default_role
18097 | 168 | 
18098 | 169 |     @property  # what? you think its useless , i know :)
18099 | 170 |     def toggle(self):
18100 | 171 |         return self.stoggle
18101 | 172 | 
18102 | 173 |     @property
18103 | 174 |     def teams_registered(self):  # This should be awaited
18104 | 175 |         return self.assigned_slots.order_by("num")
18105 | 176 | 
18106 | 177 |     async def reserved_user_ids(self):
18107 | 178 |         return (i.user_id for i in await self.reserved_slots.all())
18108 | 179 | 
18109 | 180 |     async def banned_user_ids(self):
18110 | 181 |         return (i.user_id for i in await self.banned_teams.all())
18111 | 182 | 
18112 | 183 |     async def cleaned_slots(self) -> List["AssignedSlot"]:
18113 | 184 |         slots = await self.assigned_slots.order_by("num")
18114 | 185 | 
18115 | 186 |         _list = []
18116 | 187 |         for _ in {slot.num for slot in slots}:
18117 | 188 |             _list.append(next(i for i in slots if i.num == _))
18118 | 189 | 
18119 | 190 |         return _list
18120 | 191 | 
18121 | 192 |     async def add_tick(self, msg: discord.Message):
18122 | 193 |         with suppress(discord.HTTPException):
18123 | 194 |             await msg.add_reaction(self.check_emoji)
18124 | 195 |             await msg.author.add_roles(self.role)
18125 | 196 | 
18126 | 197 |     @staticmethod
18127 | 198 |     def default_slotlist_format():
18128 | 199 |         return discord.Embed(color=0x00FFB3, title=f"<<name>> Slotlist", description="```\n<<slots>>\n```").set_footer(
18129 | 200 |             text=f"Registration took: <<time_taken>>"
18130 | 201 |         )
18131 | 202 | 
18132 | 203 |     async def create_slotlist(self):
18133 | 204 |         _slots = await self.cleaned_slots()
18134 | 205 | 
18135 | 206 |         desc = "\n".join(f"Slot {slot.num:02}  ->  {slot.team_name}" for slot in _slots)
18136 | 207 | 
18137 | 208 |         if len(self.slotlist_format) <= 1:
18138 | 209 |             text = str(self.default_slotlist_format().to_dict())
18139 | 210 |         else:
18140 | 211 |             text = str(self.slotlist_format)
18141 | 212 | 
18142 | 213 |         changes = [
18143 | 214 |             ("<<name>>", self.name),
18144 | 215 |             ("<<time_taken>>", self.time_elapsed or "N/A"),
18145 | 216 |             ("<<open_time>>", discord_timestamp(self.open_time)),
18146 | 217 |         ]
18147 | 218 | 
18148 | 219 |         for _ in changes:
18149 | 220 |             text = text.replace(*_)
18150 | 221 | 
18151 | 222 |         embed = discord.Embed.from_dict(leval(text))
18152 | 223 |         if embed.color == None:
18153 | 224 |             embed.color = 0x2F3136
18154 | 225 | 
18155 | 226 |         embed.description = embed.description.replace("<<slots>>", desc)
18156 | 227 | 
18157 | 228 |         return embed, self.slotlist_channel
18158 | 229 | 
18159 | 230 |     async def refresh_slotlist_message(self, msg: discord.Message = None):
18160 | 231 |         embed, channel = await self.create_slotlist()
18161 | 232 | 
18162 | 233 |         with suppress(discord.HTTPException, AttributeError):
18163 | 234 |             if not msg:
18164 | 235 |                 msg = await self.bot.get_or_fetch_message(channel, self.slotlist_message_id)
18165 | 236 |                 # msg = await channel.fetch_message(self.slotlist_message_id)
18166 | 237 | 
18167 | 238 |             await msg.edit(embed=embed)
18168 | 239 | 
18169 | 240 |     async def send_slotlist(self, channel: discord.TextChannel = None) -> discord.Message:
18170 | 241 |         from cogs.esports.views.smslotlist.button import SlotlistEditButton
18171 | 242 | 
18172 | 243 |         channel = channel or self.slotlist_channel
18173 | 244 | 
18174 | 245 |         _v = SlotlistEditButton(self.bot, self)
18175 | 246 |         embed, schannel = await self.create_slotlist()
18176 | 247 |         _v.message = await channel.send(embed=embed, view=_v)
18177 | 248 | 
18178 | 249 |         if channel == schannel:
18179 | 250 |             await self.make_changes(slotlist_message_id=_v.message.id)
18180 | 251 | 
18181 | 252 |         return _v.message
18182 | 253 | 
18183 | 254 |     async def dispatch_reminders(self, channel: discord.TextChannel, link: str):
18184 | 255 |         reminders = await self.slot_reminders.all().order_by("created_at")
18185 | 256 | 
18186 | 257 |         if not reminders:
18187 | 258 |             return
18188 | 259 | 
18189 | 260 |         _e = discord.Embed(color=0x00FFB3, title=f"Slot Available to Claim - {channel.guild.name}", url=link)
18190 | 261 |         _e.description = f"A slot of {self} is available to claim in {channel.mention}!\nClaim it before anyone else do."
18191 | 262 | 
18192 | 263 |         async for user in self.bot.resolve_member_ids(self.guild, [i.user_id for i in reminders]):
18193 | 264 |             with suppress(discord.HTTPException):
18194 | 265 |                 await user.send(embed=_e)
18195 | 266 | 
18196 | 267 |         await ScrimsSlotReminder.filter(pk__in=(i.pk for i in reminders)).delete()
18197 | 268 | 
18198 | 269 |     async def ensure_match_timer(self):
18199 | 270 |         from models import Timer
18200 | 271 | 
18201 | 272 |         from .slotm import ScrimsSlotManager
18202 | 273 | 
18203 | 274 |         if not self.match_time:
18204 | 275 |             self.match_time = self.bot.current_time.replace(hour=0, minute=0, microsecond=0, second=0)
18205 | 276 | 
18206 | 277 |         _time = self.match_time
18207 | 278 |         while _time < self.bot.current_time:
18208 | 279 |             _time = _time + timedelta(hours=24)
18209 | 280 | 
18210 | 281 |         if self.match_time != _time:
18211 | 282 |             await Scrim.filter(pk=self.pk).update(match_time=_time)
18212 | 283 | 
18213 | 284 |         check = await Timer.filter(event="scrim_match", expires=_time, extra={"args": [], "kwargs": {"scrim_id": self.pk}}).exists()
18214 | 285 |         if not check:
18215 | 286 |             await self.bot.reminders.create_timer(_time, "scrim_match", scrim_id=self.pk)
18216 | 287 | 
18217 | 288 |         await ScrimsSlotManager.refresh_guild_message(self.guild_id, self.pk)
18218 | 289 | 
18219 | 290 |     async def make_changes(self, **kwargs):
18220 | 291 |         await Scrim.filter(pk=self.pk).update(**kwargs)
18221 | 292 |         return await self.refresh_from_db()
18222 | 293 | 
18223 | 294 |     async def get_text_slotlist(self):
18224 | 295 |         _text = f"{self} Slot details:\n\n"
18225 | 296 |         _slots = await self.cleaned_slots()
18226 | 297 | 
18227 | 298 |         for _ in _slots:
18228 | 299 |             _text += f"{_.num}. {_.team_name} <@{_.user_id}>\n"
18229 | 300 | 
18230 | 301 |         return _text
18231 | 302 | 
18232 | 303 |     async def ban_slot(self, slot: "AssignedSlot", *, reason, mod: discord.Member, ban_type: str):
18233 | 304 |         to_ban, scrims = [slot.user_id], [self]
18234 | 305 | 
18235 | 306 |         if ban_type == "2":
18236 | 307 |             to_ban = [_ for _ in slot.members]
18237 | 308 | 
18238 | 309 |         elif ban_type == "3":
18239 | 310 |             scrims = await Scrim.filter(guild_id=self.guild_id).order_by("open_time")
18240 | 311 | 
18241 | 312 |         elif ban_type == "4":
18242 | 313 |             to_ban = [_ for _ in slot.members]
18243 | 314 |             scrims = await Scrim.filter(guild_id=self.guild_id).order_by("open_time")
18244 | 315 | 
18245 | 316 |         for _ in to_ban:
18246 | 317 |             for scrim in scrims:
18247 | 318 |                 if _ in await scrim.banned_user_ids():
18248 | 319 |                     continue
18249 | 320 | 
18250 | 321 |                 b = await BannedTeam.create(user_id=_, expires=reason.dt, reason=reason.arg)
18251 | 322 |                 await scrim.banned_teams.add(b)
18252 | 323 | 
18253 | 324 |             if banlog := await BanLog.get_or_none(guild_id=self.guild_id):
18254 | 325 |                 await banlog.log_ban(_, mod, scrims, reason.arg, reason.dt)
18255 | 326 | 
18256 | 327 |             if reason.dt:
18257 | 328 |                 await self.bot.reminders.create_timer(
18258 | 329 |                     reason.dt,
18259 | 330 |                     "scrim_ban",
18260 | 331 |                     scrims=[scrim.id for scrim in scrims],
18261 | 332 |                     user_id=_,
18262 | 333 |                     mod=mod.id,
18263 | 334 |                     reason=reason.arg,
18264 | 335 |                 )
18265 | 336 | 
18266 | 337 |         return f"Banned {utils.plural(to_ban):player|players} from {utils.plural(scrims):scrim|scrims}."
18267 | 338 | 
18268 | 339 |     async def create_slotlist_img(self):
18269 | 340 |         """
18270 | 341 |         This is done! Now do whatever you can : )
18271 | 342 |         """
18272 | 343 |         slots = await self.teams_registered
18273 | 344 | 
18274 | 345 |         def wrapper():
18275 | 346 |             font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "Ubuntu-Regular.ttf"), 16)
18276 | 347 |             rects = []
18277 | 348 | 
18278 | 349 |             for slot in slots:
18279 | 350 |                 image = Image.new("RGBA", (290, 30), "#2e2e2e")
18280 | 351 |                 draw = ImageDraw.Draw(image)
18281 | 352 |                 draw.text((10, 5), f"Slot {slot.num:02}  |  {slot.team_name}", font=font, fill="white")
18282 | 353 |                 rects.append(image)
18283 | 354 | 
18284 | 355 |             # We will add 10 slots in a image.
18285 | 356 |             images = []
18286 | 357 |             for group in utils.split_list(rects, 10):
18287 | 358 |                 size = (
18288 | 359 |                     290,
18289 | 360 |                     len(group) * 40,
18290 | 361 |                 )
18291 | 362 |                 image = Image.new("RGBA", size)
18292 | 363 |                 x = 0
18293 | 364 |                 y = 0
18294 | 365 | 
18295 | 366 |                 for rect in group:
18296 | 367 |                     image.paste(rect, (x, y))
18297 | 368 |                     y += rect.size[1] + 10
18298 | 369 | 
18299 | 370 |                 img_bytes = io.BytesIO()
18300 | 371 |                 image.save(img_bytes, "PNG")
18301 | 372 |                 img_bytes.seek(0)
18302 | 373 |                 images.append(discord.File(img_bytes, "slotlist.png"))
18303 | 374 | 
18304 | 375 |             return images
18305 | 376 | 
18306 | 377 |         return await asyncio.get_event_loop().run_in_executor(
18307 | 378 |             None, wrapper
18308 | 379 |         )  # As pillow is blocking, we will process image in executor
18309 | 380 | 
18310 | 381 |     async def reg_open_msg(self):
18311 | 382 |         reserved_count = await self.reserved_slots.all().count()
18312 | 383 | 
18313 | 384 |         if len(self.open_message) <= 1:
18314 | 385 |             return discord.Embed(
18315 | 386 |                 color=self.bot.color,
18316 | 387 |                 title="Registration is now open!",
18317 | 388 |                 description=f"📣 **`{self.required_mentions}`** mentions required.\n"
18318 | 389 |                 f"📣 Total slots: **`{self.total_slots}`** [`{reserved_count}` slots reserved]",
18319 | 390 |             )
18320 | 391 | 
18321 | 392 |         changes = [
18322 | 393 |             ("<<mentions>>", str(self.required_mentions)),
18323 | 394 |             ("<<slots>>", str(self.total_slots)),
18324 | 395 |             ("<<reserved>>", str(reserved_count)),
18325 | 396 |             ("<<slotlist>>", getattr(self.slotlist_channel, "mention", "Not Found")),
18326 | 397 |             ("<<multireg>>", "Enabled" if self.multiregister else "Not Enabled"),
18327 | 398 |             ("<<teamname>>", "Yes" if self.teamname_compulsion else "No"),
18328 | 399 |             (
18329 | 400 |                 "<<mention_banned>>",
18330 | 401 |                 ", ".join(map(lambda x: getattr(x, "mention", "Left"), map(self.guild.get_member, await self.banned_user_ids()))),
18331 | 402 |             ),
18332 | 403 |             (
18333 | 404 |                 "<<mention_reserved>>",
18334 | 405 |                 ", ".join(
18335 | 406 |                     map(
18336 | 407 |                         lambda x: getattr(x, "mention", "Left"),
18337 | 408 |                         map(self.guild.get_member, await self.reserved_user_ids()),
18338 | 409 |                     )
18339 | 410 |                 ),
18340 | 411 |             ),
18341 | 412 |         ]
18342 | 413 | 
18343 | 414 |         text = str(self.open_message)
18344 | 415 |         for _ in changes:
18345 | 416 |             text = text.replace(*_)
18346 | 417 | 
18347 | 418 |         return discord.Embed.from_dict(leval(text))
18348 | 419 | 
18349 | 420 |     def reg_close_msg(self):
18350 | 421 |         if len(self.close_message) <= 1:
18351 | 422 |             return discord.Embed(color=self.bot.config.COLOR, description="**Registration is now Closed!**")
18352 | 423 | 
18353 | 424 |         changes = [
18354 | 425 |             ("<<slots>>", str(self.total_slots)),
18355 | 426 |             ("<<filled>>", str(self.total_slots - len(self.available_slots))),
18356 | 427 |             ("<<time_taken>>", self.time_elapsed or "N/A"),
18357 | 428 |             ("<<open_time>>", discord_timestamp(self.open_time)),
18358 | 429 |         ]
18359 | 430 | 
18360 | 431 |         text = str(self.close_message)
18361 | 432 |         for _ in changes:
18362 | 433 |             text = text.replace(*_)
18363 | 434 | 
18364 | 435 |         return discord.Embed.from_dict(leval(text))
18365 | 436 | 
18366 | 437 |     async def setup_logs(self):
18367 | 438 |         _reason = "Created for scrims management."
18368 | 439 | 
18369 | 440 |         guild = self.guild
18370 | 441 | 
18371 | 442 |         if not (scrims_mod := self.modrole):
18372 | 443 |             scrims_mod = await guild.create_role(name="scrims-mod", color=self.bot.color, reason=_reason)
18373 | 444 | 
18374 | 445 |         overwrite = self.registration_channel.overwrites_for(guild.default_role)
18375 | 446 |         overwrite.update(read_messages=True, send_messages=True, read_message_history=True)
18376 | 447 |         await self.registration_channel.set_permissions(scrims_mod, overwrite=overwrite)
18377 | 448 | 
18378 | 449 |         if (scrims_log_channel := self.logschan) is None:
18379 | 450 |             overwrites = {
18380 | 451 |                 guild.default_role: discord.PermissionOverwrite(read_messages=False),
18381 | 452 |                 guild.me: discord.PermissionOverwrite(read_messages=True),
18382 | 453 |                 scrims_mod: discord.PermissionOverwrite(read_messages=True),
18383 | 454 |             }
18384 | 455 |             scrims_log_channel = await guild.create_text_channel(
18385 | 456 |                 name="quotient-scrims-logs",
18386 | 457 |                 overwrites=overwrites,
18387 | 458 |                 reason=_reason,
18388 | 459 |                 topic="**DO NOT RENAME THIS CHANNEL**",
18389 | 460 |             )
18390 | 461 | 
18391 | 462 |             note = await scrims_log_channel.send(
18392 | 463 |                 embed=discord.Embed(
18393 | 464 |                     description=f"If events related to scrims i.e opening registrations or adding roles, "
18394 | 465 |                     f"etc are triggered, then they will be logged in this channel. "
18395 | 466 |                     f"Also I have created {scrims_mod.mention}, you can give that role to your "
18396 | 467 |                     f"scrims-moderators. User with {scrims_mod.mention} can also send messages in "
18397 | 468 |                     f"registration channels and they won't be considered as scrims-registration.\n\n"
18398 | 469 |                     f"`Note`: **Do not rename this channel.**",
18399 | 470 |                     color=0x00FFB3,
18400 | 471 |                 )
18401 | 472 |             )
18402 | 473 |             await note.pin()
18403 | 474 | 
18404 | 475 |     async def full_delete(self):
18405 | 476 |         from .slotm import ScrimsSlotManager
18406 | 477 | 
18407 | 478 |         _id = self.pk
18408 | 479 |         self.bot.cache.scrim_channels.discard(self.registration_channel_id)
18409 | 480 | 
18410 | 481 |         slotm = await ScrimsSlotManager.filter(guild_id=self.guild_id, scrim_ids__contains=self.pk)
18411 | 482 |         await ScrimsSlotManager.filter(pk__in=[_.pk for _ in slotm]).update(scrim_ids=ArrayRemove("scrim_ids", _id))
18412 | 483 | 
18413 | 484 |         _d = await self.assigned_slots.all()
18414 | 485 |         await AssignedSlot.filter(pk__in=[_.pk for _ in _d]).delete()
18415 | 486 |         _r = await self.slot_reminders.all()
18416 | 487 |         await ScrimsSlotReminder.filter(pk__in=[_.pk for _ in _r]).delete()
18417 | 488 |         _re = await self.reserved_slots.all()
18418 | 489 |         await ReservedSlot.filter(pk__in=[_.pk for _ in _re]).delete()
18419 | 490 |         await self.delete()
18420 | 491 | 
18421 | 492 |     async def confirm_all_scrims(self, ctx: Context, **kwargs):
18422 | 493 |         if not await Scrim.scrim_count(ctx.guild.id) > 1:
18423 | 494 |             return
18424 | 495 | 
18425 | 496 |         prompt = await ctx.prompt("Do you want to apply these changes to all scrims in this server?")
18426 | 497 |         if not prompt:
18427 | 498 |             return await ctx.simple("Alright, this scrim only.", 4)
18428 | 499 | 
18429 | 500 |         await Scrim.filter(guild_id=ctx.guild.id).update(**kwargs)
18430 | 501 |         await ctx.simple("This change was applied to all your scrims.", 4)
18431 | 502 | 
18432 | 503 |     async def close_registration(self):
18433 | 504 |         from cogs.esports.helpers.utils import toggle_channel, wait_and_purge
18434 | 505 | 
18435 | 506 |         from .slotm import ScrimsSlotManager
18436 | 507 | 
18437 | 508 |         closed_at = self.bot.current_time
18438 | 509 |         registration_channel = self.registration_channel
18439 | 510 |         open_role = self.open_role
18440 | 511 | 
18441 | 512 |         self.time_elapsed = humanize.precisedelta(closed_at - self.opened_at)
18442 | 513 |         await self.make_changes(opened_at=None, time_elapsed=self.time_elapsed, closed_at=closed_at)
18443 | 514 | 
18444 | 515 |         channel_update = await toggle_channel(registration_channel, open_role, False)
18445 | 516 |         _e = self.reg_close_msg()
18446 | 517 |         await registration_channel.send(embed=_e)
18447 | 518 | 
18448 | 519 |         self.bot.dispatch("scrim_log", EsportsLog.closed, self, permission_updated=channel_update)
18449 | 520 | 
18450 | 521 |         registered = await self.teams_registered
18451 | 522 | 
18452 | 523 |         if self.autoslotlist and registered:
18453 | 524 |             await self.send_slotlist()
18454 | 525 | 
18455 | 526 |         if self.autodelete_extras:
18456 | 527 |             msg_ids = (i.message_id for i in registered)
18457 | 528 | 
18458 | 529 |             check = lambda x: all((not x.pinned, not x.reactions, not x.embeds, not x.author == self.bot.user, not x.id in msg_ids))
18459 | 530 |             self.bot.loop.create_task(wait_and_purge(registration_channel, check=check, wait_for=60))
18460 | 531 | 
18461 | 532 |         slotm = await ScrimsSlotManager.get_or_none(guild_id=self.guild_id, scrim_ids__contains=self.id)
18462 | 533 |         if slotm:
18463 | 534 |             await slotm.refresh_public_message()
18464 | 535 | 
18465 | 536 |     async def __add_role_to_reserved_users(self, member_ids: set[int]):
18466 | 537 |         role = discord.Object(id=self.role_id)
18467 | 538 |         async for member in self.bot.resolve_member_ids(self.guild, member_ids):
18468 | 539 |             try:
18469 | 540 |                 if not member._roles.has(role.id):
18470 | 541 |                     await member.add_roles(role, reason=f"Reserved Slot [{self.pk}]")
18471 | 542 |                     await asyncio.sleep(0.2)
18472 | 543 |             except discord.HTTPException:
18473 | 544 |                 continue
18474 | 545 | 
18475 | 546 |     async def start_registration(self):
18476 | 547 |         from cogs.esports.helpers.utils import (
18477 | 548 |             available_to_reserve,
18478 | 549 |             scrim_work_role,
18479 | 550 |             toggle_channel,
18480 | 551 |         )
18481 | 552 | 
18482 | 553 |         oldslots = await self.assigned_slots
18483 | 554 |         await AssignedSlot.filter(id__in=(slot.id for slot in oldslots)).delete()
18484 | 555 |         await self.assigned_slots.clear()
18485 | 556 | 
18486 | 557 |         # here we insert a list of slots we can give for the registration.
18487 | 558 |         await self.bot.db.execute(
18488 | 559 |             """
18489 | 560 |             UPDATE public."sm.scrims" SET available_slots = $1 WHERE id = $2
18490 | 561 |             """,
18491 | 562 |             await available_to_reserve(self),
18492 | 563 |             self.id,
18493 | 564 |         )
18494 | 565 | 
18495 | 566 |         reserved_slots = await self.reserved_slots.all().order_by("num")
18496 | 567 |         reserved_user_ids = {slot.user_id for slot in reserved_slots if slot.user_id is not None}
18497 | 568 | 
18498 | 569 |         for slot in reserved_slots:
18499 | 570 |             assinged_slot = await AssignedSlot.create(
18500 | 571 |                 num=slot.num,
18501 | 572 |                 user_id=slot.user_id,
18502 | 573 |                 team_name=slot.team_name,
18503 | 574 |                 jump_url=None,
18504 | 575 |             )
18505 | 576 | 
18506 | 577 |             await self.assigned_slots.add(assinged_slot)
18507 | 578 | 
18508 | 579 |         self.bot.loop.create_task(self.__add_role_to_reserved_users(reserved_user_ids))
18509 | 580 | 
18510 | 581 |         await Scrim.filter(pk=self.id).update(
18511 | 582 |             opened_at=self.bot.current_time,
18512 | 583 |             closed_at=None,
18513 | 584 |             slotlist_message_id=None,
18514 | 585 |         )
18515 | 586 |         self.bot.loop.create_task(self.ensure_match_timer())
18516 | 587 |         await asyncio.sleep(0.2)
18517 | 588 | 
18518 | 589 |         # Opening Channel for Normal Janta
18519 | 590 |         registration_channel = self.registration_channel
18520 | 591 |         open_role = self.open_role
18521 | 592 | 
18522 | 593 |         # check if countdown is on
18523 | 594 | 
18524 | 595 |         # if self.cdn.get("status", False):
18525 | 596 |         #     ...
18526 | 597 | 
18527 | 598 |         _e = await self.reg_open_msg()
18528 | 599 | 
18529 | 600 |         await registration_channel.send(
18530 | 601 |             content=scrim_work_role(self, EsportsRole.ping),
18531 | 602 |             embed=_e,
18532 | 603 |             allowed_mentions=discord.AllowedMentions(roles=True, everyone=True),
18533 | 604 |         )
18534 | 605 | 
18535 | 606 |         self.bot.cache.scrim_channels.add(registration_channel.id)
18536 | 607 | 
18537 | 608 |         await toggle_channel(registration_channel, open_role, True)
18538 | 609 |         self.bot.dispatch("scrim_log", EsportsLog.open, self)
18539 | 610 | 
18540 | 611 |     @staticmethod
18541 | 612 |     async def show_selector(*args, **kwargs):
18542 | 613 |         """
18543 | 614 |         :param: ctx: Context
18544 | 615 |         :param: scrims: List[Scrim]
18545 | 616 |         :param: placeholder:str
18546 | 617 |         :param: multi:bool=True
18547 | 618 |         """
18548 | 619 |         from cogs.esports.views.scrims.selector import prompt_selector
18549 | 620 | 
18550 | 621 |         return await prompt_selector(*args, **kwargs)
18551 | 622 | 
18552 | 623 |     async def scrim_posi(self):
18553 | 624 |         from cogs.esports.views.scrims.selector import scrim_position
18554 | 625 | 
18555 | 626 |         return await scrim_position(self.pk, self.guild_id)
18556 | 627 | 
18557 | 628 |     @staticmethod
18558 | 629 |     @cached(ttl=60 * 2)
18559 | 630 |     async def scrim_count(guild_id: int):
18560 | 631 |         return await Scrim.filter(guild_id=guild_id).count()
18561 | 632 | 
18562 | 633 |     async def check_fake_tags(self, message: discord.Message):
18563 | 634 |         query = """
18564 | 635 |         SELECT *
18565 | 636 |             FROM PUBLIC."sm.scrims_sm.assigned_slots" AS ASSIGNED_SLOT
18566 | 637 |             INNER JOIN PUBLIC."sm.assigned_slots" AS SLOTS ON SLOTS.ID = ASSIGNED_SLOT.ASSIGNEDSLOT_ID
18567 | 638 |         WHERE ASSIGNED_SLOT."sm.scrims_id" = $1
18568 | 639 |         AND $2 && SLOTS.MEMBERS;
18569 | 640 | 
18570 | 641 |         """
18571 | 642 |         return await self.bot.db.fetch(query, self.id, [i.id for i in message.mentions])
18572 | 643 | 
18573 | 644 | 
18574 | 645 | class BaseSlot(models.Model):
18575 | 646 |     class Meta:
18576 | 647 |         abstract = True
18577 | 648 | 
18578 | 649 |     id = fields.IntField(pk=True)
18579 | 650 |     num = fields.IntField(null=True)  # this will never be null but there are already records in the table so
18580 | 651 |     user_id = fields.BigIntField(null=True)
18581 | 652 |     team_name = fields.TextField(null=True)
18582 | 653 |     # drop_location = fields.CharField(max_length=30, null=True)
18583 | 654 |     members = ArrayField(fields.BigIntField(), default=list)
18584 | 655 | 
18585 | 656 | 
18586 | 657 | class AssignedSlot(BaseSlot):
18587 | 658 |     class Meta:
18588 | 659 |         table = "sm.assigned_slots"
18589 | 660 | 
18590 | 661 |     message_id = fields.BigIntField(null=True)
18591 | 662 |     jump_url = fields.TextField(null=True)
18592 | 663 | 
18593 | 664 |     @property
18594 | 665 |     def owner(self) -> discord.User:
18595 | 666 |         return self.bot.get_user(self.user_id)
18596 | 667 | 
18597 | 668 | 
18598 | 669 | class ReservedSlot(BaseSlot):
18599 | 670 |     class Meta:
18600 | 671 |         table = "sm.reserved_slots"
18601 | 672 | 
18602 | 673 |     expires = fields.DatetimeField(null=True)
18603 | 674 | 
18604 | 675 |     @property
18605 | 676 |     def leader(self):
18606 | 677 |         return self.bot.get_user(self.user_id)
18607 | 678 | 
18608 | 679 | 
18609 | 680 | class BannedTeam(BaseSlot):
18610 | 681 |     class Meta:
18611 | 682 |         table = "sm.banned_teams"
18612 | 683 | 
18613 | 684 |     reason = fields.CharField(max_length=200, null=True)
18614 | 685 |     expires = fields.DatetimeField(null=True)
18615 | 686 | 
18616 | 687 | 
18617 | 688 | class BanLog(BaseDbModel):
18618 | 689 |     class Meta:
18619 | 690 |         table = "esports_bans"
18620 | 691 | 
18621 | 692 |     id = fields.IntField(pk=True)
18622 | 693 |     guild_id = fields.BigIntField()
18623 | 694 |     channel_id = fields.BigIntField()
18624 | 695 | 
18625 | 696 |     @property
18626 | 697 |     def channel(self):
18627 | 698 |         return self.bot.get_channel(self.channel_id)
18628 | 699 | 
18629 | 700 |     def __format_scrims(self, scrims: List[Scrim]):
18630 | 701 |         _scrims = []
18631 | 702 |         for idx, _ in enumerate(scrims, start=1):
18632 | 703 |             if idx < 4:
18633 | 704 |                 _scrims.append(getattr(_.registration_channel, "mention", "`deleted-channel`"))
18634 | 705 | 
18635 | 706 |             elif idx == 4:
18636 | 707 |                 _scrims.append(f"**...{len(scrims) -  3} more**")
18637 | 708 | 
18638 | 709 |         return ", ".join(_scrims)
18639 | 710 | 
18640 | 711 |     async def log_ban(self, user_id: int, mod: discord.Member, scrims: List[Scrim], reason: str = None, dt: str = None):
18641 | 712 |         user: discord.User = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, user_id)
18642 | 713 | 
18643 | 714 |         _e = discord.Embed(color=discord.Color.red(), title=f"🔨 Banned from {plural(scrims):scrim|scrims}")
18644 | 715 |         _e.add_field(name="User", value=f"{user} ({getattr(user, 'mention','unknown-user')})")
18645 | 716 |         _e.add_field(name="Moderator", value=mod)
18646 | 717 |         _e.add_field(name="Effected Scrims", value=self.__format_scrims(scrims), inline=False)
18647 | 718 |         _e.add_field(name="Reason", value=f"```{truncate_string(reason,100) if reason else 'No reason given'}```")
18648 | 719 | 
18649 | 720 |         _e.set_footer(text=f"Expiring: {'Never' if not dt else ''}")
18650 | 721 |         if dt:
18651 | 722 |             _e.timestamp = dt
18652 | 723 | 
18653 | 724 |         if user:
18654 | 725 |             _e.set_thumbnail(url=getattr(user.display_avatar, "url", "https://cdn.discordapp.com/embed/avatars/0.png"))
18655 | 726 | 
18656 | 727 |         with suppress(discord.HTTPException, AttributeError):
18657 | 728 |             await self.channel.send(getattr(user, "mention", ""), embed=_e)
18658 | 729 | 
18659 | 730 |     async def log_unban(self, user_id: int, mod: discord.Member, scrims: List[Scrim], reason: str = None):
18660 | 731 |         user = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, user_id)
18661 | 732 |         _e = discord.Embed(color=discord.Color.green(), title=f"🍃 Unbanned from {plural(scrims):Scrim|Scrims}")
18662 | 733 |         _e.add_field(name="User", value=f"{user} ({getattr(user, 'mention','unknown-user')})")
18663 | 734 |         _e.add_field(name="Moderator", value=mod)
18664 | 735 |         _e.add_field(name="Effected Scrims", value=self.__format_scrims(scrims), inline=False)
18665 | 736 |         _e.add_field(name="Reason", value=reason or "```No Reason given..```", inline=False)
18666 | 737 |         _e.timestamp = self.bot.current_time
18667 | 738 | 
18668 | 739 |         if user:
18669 | 740 |             _e.set_thumbnail(url=getattr(user.display_avatar, "url", "https://cdn.discordapp.com/embed/avatars/0.png"))
18670 | 741 | 
18671 | 742 |         with suppress(discord.HTTPException, AttributeError):
18672 | 743 |             await self.channel.send(getattr(user, "mention", ""), embed=_e)
18673 | 744 | 
18674 | 745 | 
18675 | 746 | class ScrimsSlotReminder(BaseDbModel):
18676 | 747 |     class Meta:
18677 | 748 |         table = "scrims_slot_reminders"
18678 | 749 | 
18679 | 750 |     id = fields.IntField(pk=True)
18680 | 751 |     user_id = fields.BigIntField()
18681 | 752 |     created_at = fields.DatetimeField(auto_now=True)
18682 | 753 | 
18683 | 
18684 | 
18685 | --------------------------------------------------------------------------------
18686 | /models/esports/slotm.py:
18687 | --------------------------------------------------------------------------------
18688 |   1 | from contextlib import suppress
18689 |   2 | from typing import Any, List, Optional, Tuple
18690 |   3 | 
18691 |   4 | import discord
18692 |   5 | from tortoise import fields
18693 |   6 | 
18694 |   7 | from models import BaseDbModel
18695 |   8 | from models.helpers import ArrayField
18696 |   9 | from utils import aenumerate, plural
18697 |  10 | 
18698 |  11 | from .scrims import Scrim
18699 |  12 | 
18700 |  13 | __all__ = ("ScrimsSlotManager",)
18701 |  14 | 
18702 |  15 | 
18703 |  16 | class ScrimsSlotManager(BaseDbModel):
18704 |  17 |     class Meta:
18705 |  18 |         table = "slot_manager"
18706 |  19 | 
18707 |  20 |     id = fields.IntField(pk=True)
18708 |  21 |     guild_id = fields.BigIntField()
18709 |  22 |     main_channel_id = fields.BigIntField()
18710 |  23 | 
18711 |  24 |     message_id = fields.BigIntField()
18712 |  25 | 
18713 |  26 |     toggle = fields.BooleanField(default=True)
18714 |  27 |     allow_reminders = fields.BooleanField(default=True)
18715 |  28 |     multiple_slots = fields.BooleanField(default=False)
18716 |  29 | 
18717 |  30 |     scrim_ids = ArrayField(fields.BigIntField(), default=list)
18718 |  31 | 
18719 |  32 |     def __str__(self):
18720 |  33 |         return f"{getattr(self.main_channel,'mention','not-found')} - ({plural(self.scrim_ids):scrim|scrims})"
18721 |  34 | 
18722 |  35 |     @property
18723 |  36 |     def guild(self):
18724 |  37 |         return self.bot.get_guild(self.guild_id)
18725 |  38 | 
18726 |  39 |     async def scrims(self) -> List[Scrim]:
18727 |  40 |         return await Scrim.filter(pk__in=self.scrim_ids)
18728 |  41 | 
18729 |  42 |     @property
18730 |  43 |     def main_channel(self):
18731 |  44 |         return self.bot.get_channel(self.main_channel_id)
18732 |  45 | 
18733 |  46 |     @property
18734 |  47 |     def logschan(self):
18735 |  48 |         if (g := self.guild) is not None:
18736 |  49 |             return discord.utils.get(g.text_channels, name="quotient-scrims-logs")
18737 |  50 | 
18738 |  51 |     async def message(self):
18739 |  52 |         channel = await self.bot.getch(self.bot.get_channel, self.bot.fetch_channel, self.main_channel_id)
18740 |  53 |         if channel:
18741 |  54 |             _m = None
18742 |  55 |             with suppress(discord.HTTPException):
18743 |  56 |                 _m = await self.bot.get_or_fetch_message(channel, self.message_id)
18744 |  57 | 
18745 |  58 |             return _m
18746 |  59 | 
18747 |  60 |     @staticmethod
18748 |  61 |     async def from_guild(guild: discord.Guild):
18749 |  62 |         return await ScrimsSlotManager.filter(guild_id=guild.id)
18750 |  63 | 
18751 |  64 |     @staticmethod
18752 |  65 |     async def unavailable_scrims(guild: discord.Guild) -> List[int]:
18753 |  66 |         return [scrim for record in await ScrimsSlotManager.filter(guild_id=guild.id) for scrim in record.scrim_ids]
18754 |  67 | 
18755 |  68 |     @staticmethod
18756 |  69 |     async def available_scrims(guild: discord.Guild) -> List[Scrim]:
18757 |  70 |         return await Scrim.filter(pk__not_in=await ScrimsSlotManager.unavailable_scrims(guild), guild_id=guild.id)
18758 |  71 | 
18759 |  72 |     async def full_delete(self):
18760 |  73 |         """
18761 |  74 |         Delete a slotm record.
18762 |  75 |         """
18763 |  76 |         message = await self.message()
18764 |  77 | 
18765 |  78 |         if message:
18766 |  79 |             _embed, _view = await self.public_message()
18767 |  80 |             for b in _view.children:
18768 |  81 |                 if isinstance(b, discord.ui.Button):
18769 |  82 |                     b.disabled = True
18770 |  83 | 
18771 |  84 |             await message.edit(embed=_embed, view=_view)
18772 |  85 | 
18773 |  86 |         await self.delete()
18774 |  87 | 
18775 |  88 |     @property
18776 |  89 |     def claimable_slots(self):
18777 |  90 |         return (
18778 |  91 |             Scrim.filter(
18779 |  92 |                 pk__in=self.scrim_ids,
18780 |  93 |                 closed_at__gt=self.bot.current_time.replace(hour=0, minute=0, second=0, microsecond=0),
18781 |  94 |                 available_slots__not=[],
18782 |  95 |                 match_time__gt=self.bot.current_time,
18783 |  96 |                 opened_at__isnull=True,
18784 |  97 |             )
18785 |  98 |             .order_by("open_time")
18786 |  99 |             .limit(25)
18787 | 100 |         )
18788 | 101 | 
18789 | 102 |     async def _formatted_claimable(self) -> List[str]:
18790 | 103 |         """
18791 | 104 |         Returns a list of slots that can be claimed
18792 | 105 |         """
18793 | 106 |         _list = []
18794 | 107 | 
18795 | 108 |         async for idx, _ in aenumerate(self.claimable_slots, start=1):
18796 | 109 |             _list.append(
18797 | 110 |                 f"`{idx}` {getattr(_.registration_channel,'mention','deleted-channel')}  ─  {plural(_.available_slots):Slot|Slots}"
18798 | 111 |             )
18799 | 112 | 
18800 | 113 |         return _list
18801 | 114 | 
18802 | 115 |     async def public_message(self) -> Tuple[discord.Embed, discord.ui.View]:
18803 | 116 |         """
18804 | 117 |         Generate public message & view for slot manager.
18805 | 118 |         """
18806 | 119 | 
18807 | 120 |         from cogs.esports.views.slotm import ScrimsSlotmPublicView
18808 | 121 | 
18809 | 122 |         _claimable = await self._formatted_claimable()
18810 | 123 | 
18811 | 124 |         _claimable_slots = (
18812 | 125 |             ("\n" + "\n".join(_claimable))
18813 | 126 |             if _claimable
18814 | 127 |             else ("```No Slots Available at the time.\nPress 🔔 to set a reminder. ``` \n")
18815 | 128 |         )
18816 | 129 | 
18817 | 130 |         _e = discord.Embed(color=0x00FFB3, title="Scrims Slot Management", url=self.bot.config.SERVER_LINK)
18818 | 131 |         _e.description = (
18819 | 132 |             f"● Press `cancel-slot` to cancel your slot.\n"
18820 | 133 |             f"● Note that Id-Pass role can only be transferred to your teammates.\n\n"
18821 | 134 |             f"● Available Slots: {_claimable_slots}"
18822 | 135 |         )
18823 | 136 | 
18824 | 137 |         view = ScrimsSlotmPublicView(self)
18825 | 138 | 
18826 | 139 |         if not _claimable:
18827 | 140 |             view.children[1].disabled = True
18828 | 141 | 
18829 | 142 |         if not self.allow_reminders:
18830 | 143 |             view.children[2].disabled = True
18831 | 144 | 
18832 | 145 |         if not self.toggle:
18833 | 146 |             for _ in view.children:
18834 | 147 |                 _.disabled = True
18835 | 148 | 
18836 | 149 |         return _e, view
18837 | 150 | 
18838 | 151 |     async def refresh_public_message(self) -> Optional[discord.Message]:
18839 | 152 |         """
18840 | 153 |         Edit public slotm message to reflect current state.
18841 | 154 |         """
18842 | 155 |         m = await self.message()
18843 | 156 |         if not m:
18844 | 157 |             return await self.full_delete()
18845 | 158 | 
18846 | 159 |         _embed, _view = await self.public_message()
18847 | 160 | 
18848 | 161 |         with suppress(discord.HTTPException):
18849 | 162 |             return await m.edit(embed=_embed, view=_view)
18850 | 163 | 
18851 | 164 |     @staticmethod
18852 | 165 |     async def refresh_guild_message(guild_id: int, scrim_id: int) -> Optional[discord.Message]:
18853 | 166 |         slotm = await ScrimsSlotManager.get_or_none(guild_id=guild_id, scrim_ids__contains=scrim_id)
18854 | 167 |         if slotm:
18855 | 168 |             return await slotm.refresh_public_message()
18856 | 169 | 
18857 | 170 |     async def setup(self, guild: discord.Guild, user: discord.Member):
18858 | 171 |         """
18859 | 172 |         Creates a new channel and setup slot-m.
18860 | 173 |         """
18861 | 174 | 
18862 | 175 |         reason = f"Created for Scrims Slot Management by {user}"
18863 | 176 | 
18864 | 177 |         overwrites = {
18865 | 178 |             guild.default_role: discord.PermissionOverwrite(
18866 | 179 |                 read_messages=True, send_messages=False, read_message_history=True
18867 | 180 |             ),
18868 | 181 |             guild.me: discord.PermissionOverwrite(
18869 | 182 |                 read_messages=True,
18870 | 183 |                 send_messages=True,
18871 | 184 |                 manage_channels=True,
18872 | 185 |                 manage_messages=True,
18873 | 186 |                 read_message_history=True,
18874 | 187 |                 embed_links=True,
18875 | 188 |             ),
18876 | 189 |         }
18877 | 190 | 
18878 | 191 |         __channel = await guild.create_text_channel(name="cancel-claim-slot", overwrites=overwrites, reason=reason)
18879 | 192 | 
18880 | 193 |         self.main_channel_id = __channel.id
18881 | 194 | 
18882 | 195 |         _embed, _view = await self.public_message()
18883 | 196 |         m = await __channel.send(embed=_embed, view=_view)
18884 | 197 | 
18885 | 198 |         self.message_id = m.id
18886 | 199 |         await self.save()
18887 | 200 |         return self
18888 | 201 | 
18889 | 202 |     async def user_slots(self, user_id: int) -> List[Any]:
18890 | 203 |         query = """
18891 | 204 |         (SELECT *
18892 | 205 | 		    FROM
18893 | 206 | 			(SELECT SCRIMS.ID AS SCRIM_ID,
18894 | 207 | 					*
18895 | 208 | 				FROM PUBLIC."sm.scrims" AS SCRIMS
18896 | 209 | 				FULL OUTER JOIN
18897 | 210 | 					(SELECT ID AS ASSIGNED_SLOT_ID,
18898 | 211 | 							*
18899 | 212 | 						FROM PUBLIC."sm.scrims_sm.assigned_slots" AS SCRIM_SLOT
18900 | 213 | 						INNER JOIN PUBLIC."sm.assigned_slots" AS SLOTS ON SLOTS.ID = SCRIM_SLOT.ASSIGNEDSLOT_ID) AS SCRIM_SLOT ON SCRIMS.ID = SCRIM_SLOT."sm.scrims_id"
18901 | 214 | 				WHERE (SCRIMS.ID = ANY ($1)
18902 | 215 | 											AND MATCH_TIME > NOW()
18903 | 216 | 											AND OPENED_AT IS NULL = TRUE
18904 | 217 | 											AND CLOSED_AT > CURRENT_DATE + interval '1 minute'
18905 | 218 | 											AND SCRIM_SLOT."sm.scrims_id" IS NOT NULL)) AS SM
18906 | 219 | 		WHERE USER_ID = $2)        
18907 | 220 |         """
18908 | 221 | 
18909 | 222 |         return await self.bot.db.fetch(query, self.scrim_ids, user_id)
18910 | 223 | 
18911 | 
18912 | 
18913 | --------------------------------------------------------------------------------
18914 | /models/esports/ssverify.py:
18915 | --------------------------------------------------------------------------------
18916 |   1 | from typing import Tuple
18917 |   2 | 
18918 |   3 | import imagehash
18919 |   4 | from pydantic import BaseModel, HttpUrl
18920 |   5 | from tortoise import fields
18921 |   6 | 
18922 |   7 | import config
18923 |   8 | from constants import SSType
18924 |   9 | from core import Context
18925 |  10 | from models import BaseDbModel
18926 |  11 | from models.helpers import *
18927 |  12 | from utils import emote
18928 |  13 | 
18929 |  14 | 
18930 |  15 | class ImageResponse(BaseModel):
18931 |  16 |     url: HttpUrl
18932 |  17 |     dhash: str
18933 |  18 |     phash: str
18934 |  19 |     text: str
18935 |  20 | 
18936 |  21 |     @property
18937 |  22 |     def lower_text(self):
18938 |  23 |         return self.text.lower().replace(" ", "").replace("\n", "")
18939 |  24 | 
18940 |  25 | 
18941 |  26 | class SSData(BaseDbModel):
18942 |  27 |     class Meta:
18943 |  28 |         table = "ss_data"
18944 |  29 | 
18945 |  30 |     id = fields.IntField(pk=True)
18946 |  31 |     author_id = fields.BigIntField()
18947 |  32 |     channel_id = fields.BigIntField()
18948 |  33 |     message_id = fields.BigIntField()
18949 |  34 |     dhash = fields.CharField(max_length=1024, null=True)
18950 |  35 |     phash = fields.CharField(max_length=1024, null=True)
18951 |  36 |     submitted_at = fields.DatetimeField(auto_now=True)
18952 |  37 | 
18953 |  38 |     @property
18954 |  39 |     def author(self):
18955 |  40 |         return self.bot.get_user(self.author_id)
18956 |  41 | 
18957 |  42 |     @property
18958 |  43 |     def jump_url(self):
18959 |  44 |         return "https://discord.com/channels/{}/" + f"{self.channel_id}/{self.message_id}"
18960 |  45 | 
18961 |  46 | 
18962 |  47 | class SSVerify(BaseDbModel):
18963 |  48 |     class Meta:
18964 |  49 |         table = "ss_info"
18965 |  50 | 
18966 |  51 |     id = fields.IntField(pk=True)
18967 |  52 |     channel_id = fields.BigIntField(index=True)
18968 |  53 |     guild_id = fields.BigIntField()
18969 |  54 |     role_id = fields.BigIntField()
18970 |  55 |     required_ss = fields.IntField(default=4)
18971 |  56 |     channel_name = fields.CharField(max_length=50)
18972 |  57 |     channel_link = fields.CharField(max_length=150, default=config.SERVER_LINK)
18973 |  58 | 
18974 |  59 |     keywords = ArrayField(fields.CharField(max_length=50), default=list)
18975 |  60 |     allow_same = fields.BooleanField(default=False)
18976 |  61 | 
18977 |  62 |     ss_type = fields.CharEnumField(SSType)
18978 |  63 | 
18979 |  64 |     success_message = fields.CharField(null=True, max_length=500)
18980 |  65 | 
18981 |  66 |     data: fields.ManyToManyRelation["SSData"] = fields.ManyToManyField("models.SSData", index=True)
18982 |  67 | 
18983 |  68 |     @property
18984 |  69 |     def _guild(self):
18985 |  70 |         return self.bot.get_guild(self.guild_id)
18986 |  71 | 
18987 |  72 |     @property
18988 |  73 |     def channel(self):
18989 |  74 |         return self.bot.get_channel(self.channel_id)
18990 |  75 | 
18991 |  76 |     @property
18992 |  77 |     def role(self):
18993 |  78 |         if g := self._guild:
18994 |  79 |             return g.get_role(self.role_id)
18995 |  80 | 
18996 |  81 |     def emoji(self, _bool: bool = False):
18997 |  82 |         return emote.check if _bool else "⚠️"
18998 |  83 | 
18999 |  84 |     def __str__(self):
19000 |  85 |         _f = self.ss_type.value.title()
19001 |  86 |         if self.ss_type == SSType.custom:
19002 |  87 |             _f += f"(`{self.keywords[0]}`)"
19003 |  88 | 
19004 |  89 |         return f"{getattr(self.channel,'mention','deleted-channel')} - {_f}"
19005 |  90 | 
19006 |  91 |     async def is_user_verified(self, user_id: int):
19007 |  92 |         return await self.data.filter(author_id=user_id).count() >= self.required_ss
19008 |  93 | 
19009 |  94 |     async def required_by_user(self, user_id: int):
19010 |  95 |         diff = self.required_ss - await self.data.filter(author_id=user_id).count()
19011 |  96 |         return 0 if diff <= 0 else diff
19012 |  97 | 
19013 |  98 |     async def full_delete(self):
19014 |  99 |         self.bot.cache.ssverify_channels.discard(self.channel_id)
19015 | 100 |         data = await self.data.all()
19016 | 101 | 
19017 | 102 |         await SSData.filter(pk__in=[d.id for d in data]).delete()
19018 | 103 |         await self.delete()
19019 | 104 | 
19020 | 105 |     @property
19021 | 106 |     def filtered_keywords(self):
19022 | 107 |         _l = [self.channel_name.lower().replace(" ", "")]
19023 | 108 |         for _ in self.keywords:
19024 | 109 |             _l.append(_.lower().replace(" ", ""))
19025 | 110 | 
19026 | 111 |         return _l
19027 | 112 | 
19028 | 113 |     async def _add_to_data(self, ctx: Context, img: ImageResponse):
19029 | 114 |         data = await SSData.create(
19030 | 115 |             author_id=ctx.author.id,
19031 | 116 |             channel_id=ctx.channel.id,
19032 | 117 |             message_id=ctx.message.id,
19033 | 118 |             dhash=img.dhash,
19034 | 119 |             phash=img.phash,
19035 | 120 |         )
19036 | 121 |         await self.data.add(data)
19037 | 122 | 
19038 | 123 |     async def _match_for_duplicate(self, dhash: str, phash: str, author_id: int) -> Tuple[bool, str]:
19039 | 124 |         _dhash = imagehash.hex_to_hash(dhash)
19040 | 125 |         async for record in self.data.filter(author_id=author_id).order_by("submitted_at"):
19041 | 126 |             if _dhash - imagehash.hex_to_hash(record.dhash) <= 7:
19042 | 127 |                 return (
19043 | 128 |                     True,
19044 | 129 |                     f"{self.emoji(False)} | You've already submitted this screenshot [here]({record.jump_url.format(self.guild_id)}).\n",
19045 | 130 |                 )
19046 | 131 | 
19047 | 132 |         if r := await self.data.filter(dhash=dhash, phash=phash).first():
19048 | 133 |             return (
19049 | 134 |                 True,
19050 | 135 |                 f"{self.emoji(False)} | <@{r.author_id}>, already submitted the [same ss]({r.jump_url.format(self.guild_id)}).\n",
19051 | 136 |             )
19052 | 137 | 
19053 | 138 |         return False, False
19054 | 139 | 
19055 | 140 |     async def verify_yt(self, ctx: Context, image: ImageResponse):
19056 | 141 |         if not any(_ in image.lower_text for _ in ("subscribe", "videos")):
19057 | 142 |             return f"{self.emoji()} | This is not a valid youtube ss.\n"
19058 | 143 | 
19059 | 144 |         elif not self.channel_name.lower().replace(" ", "") in image.lower_text:
19060 | 145 |             return f"{self.emoji()} | Screenshot must belong to [`{self.channel_name}`]({self.channel_link}) channel.\n"
19061 | 146 | 
19062 | 147 |         elif "SUBSCRIBE " in image.text.replace("\n", " "):
19063 | 148 |             return f"{self.emoji()} | You must subscribe [`{self.channel_name}`]({self.channel_link}) to get verified.\n"
19064 | 149 | 
19065 | 150 |         await self._add_to_data(ctx, image)
19066 | 151 |         return f"{self.emoji(True)} | Verified successfully.\n"
19067 | 152 | 
19068 | 153 |     async def verify_insta(self, ctx: Context, image: ImageResponse):
19069 | 154 |         if not "followers" in image.lower_text:
19070 | 155 |             return f"{self.emoji()} | This is not a valid instagram ss.\n"
19071 | 156 | 
19072 | 157 |         elif not self.channel_name.lower().replace(" ", "") in image.lower_text:
19073 | 158 |             return f"{self.emoji()} | Screenshot must belong to [`{self.channel_name}`]({self.channel_link}) page.\n"
19074 | 159 | 
19075 | 160 |         elif "FOLLOW " in image.text.replace("\n", " "):
19076 | 161 |             return f"{self.emoji()} | You must follow [`{self.channel_name}`]({self.channel_link}) to get verified.\n"
19077 | 162 | 
19078 | 163 |         await self._add_to_data(ctx, image)
19079 | 164 |         return f"{self.emoji(True)} | Verified successfully.\n"
19080 | 165 | 
19081 | 166 |     async def verify_loco(self, ctx: Context, image: ImageResponse):
19082 | 167 |         if not self.channel_name.lower().replace(" ", "") in image.lower_text:
19083 | 168 |             return f"{self.emoji()} | Screenshot must belong to [`{self.channel_name}`]({self.channel_link}) channel.\n"
19084 | 169 | 
19085 | 170 |         elif "FOLLOW" in image.text and not "FOLLOWING" in image.text:
19086 | 171 |             return f"{self.emoji()} | You must follow [`{self.channel_name}`]({self.channel_link}) to get verified.\n"
19087 | 172 | 
19088 | 173 |         await self._add_to_data(ctx, image)
19089 | 174 |         return f"{self.emoji(True)} | Verified successfully.\n"
19090 | 175 | 
19091 | 176 |     async def verify_rooter(self, ctx: Context, image: ImageResponse):
19092 | 177 |         if not self.channel_name.lower().replace(" ", "") in image.lower_text:
19093 | 178 |             return f"{self.emoji()} | Screenshot must belong to [`{self.channel_name}`]({self.channel_link}) channel.\n"
19094 | 179 | 
19095 | 180 |         elif "FOLLOW" in image.text and not "FOLLOWING" in image.text:
19096 | 181 |             return f"{self.emoji()} | You must follow [`{self.channel_name}`]({self.channel_link}) to get verified.\n"
19097 | 182 | 
19098 | 183 |         await self._add_to_data(ctx, image)
19099 | 184 |         return f"{self.emoji(True)} | Verified successfully.\n"
19100 | 185 | 
19101 | 186 |     async def verify_custom(self, ctx: Context, image: ImageResponse):
19102 | 187 |         if not any(_ in image.lower_text for _ in self.filtered_keywords):
19103 | 188 |             return f"{self.emoji()} | This is not a valid {self.keywords[0]} ss.\n"
19104 | 189 | 
19105 | 190 |         await self._add_to_data(ctx, image)
19106 | 191 |         return f"{self.emoji(True)} | Verified successfully.\n"
19107 | 192 | 
19108 | 
19109 | 
19110 | --------------------------------------------------------------------------------
19111 | /models/esports/tagcheck.py:
19112 | --------------------------------------------------------------------------------
19113 |  1 | from typing import Optional
19114 |  2 | 
19115 |  3 | import discord
19116 |  4 | from tortoise import fields
19117 |  5 | 
19118 |  6 | from models import BaseDbModel
19119 |  7 | from models.helpers import *
19120 |  8 | 
19121 |  9 | 
19122 | 10 | class TagCheck(BaseDbModel):
19123 | 11 |     class Meta:
19124 | 12 |         table = "tagcheck"
19125 | 13 | 
19126 | 14 |     id = fields.BigIntField(pk=True)
19127 | 15 |     guild_id = fields.BigIntField()
19128 | 16 |     channel_id = fields.BigIntField()
19129 | 17 |     required_mentions = fields.IntField(default=0)
19130 | 18 |     delete_after = fields.BooleanField(default=False)
19131 | 19 | 
19132 | 20 |     @property
19133 | 21 |     def _guild(self) -> Optional[discord.Guild]:
19134 | 22 |         return self.bot.get_guild(self.guild_id)
19135 | 23 | 
19136 | 24 |     @property
19137 | 25 |     def channel(self) -> Optional[discord.TextChannel]:
19138 | 26 |         return self.bot.get_channel(self.channel_id)
19139 | 27 | 
19140 | 28 |     @property
19141 | 29 |     def ignorerole(self) -> Optional[discord.Role]:
19142 | 30 |         if not self._guild is None:
19143 | 31 |             return discord.utils.get(self._guild.roles, name="quotient-tag-ignore")
19144 | 32 | 
19145 | 33 |     def __str__(self):
19146 | 34 |         return f"{getattr(self.channel,'mention','channel-not-found')} (Mentions: `{self.required_mentions}`)"
19147 | 35 | 
19148 | 36 | 
19149 | 37 | class EasyTag(BaseDbModel):
19150 | 38 |     class Meta:
19151 | 39 |         table = "easytags"
19152 | 40 | 
19153 | 41 |     id = fields.BigIntField(pk=True)
19154 | 42 |     guild_id = fields.BigIntField()
19155 | 43 |     channel_id = fields.BigIntField(index=True)
19156 | 44 |     delete_after = fields.BooleanField(default=False)
19157 | 45 | 
19158 | 46 |     @property
19159 | 47 |     def _guild(self) -> Optional[discord.Guild]:
19160 | 48 |         return self.bot.get_guild(self.guild_id)
19161 | 49 | 
19162 | 50 |     @property
19163 | 51 |     def channel(self) -> Optional[discord.TextChannel]:
19164 | 52 |         return self.bot.get_channel(self.channel_id)
19165 | 53 | 
19166 | 54 |     @property
19167 | 55 |     def ignorerole(self) -> Optional[discord.Role]:
19168 | 56 |         if not self._guild is None:
19169 | 57 |             return discord.utils.get(self._guild.roles, name="quotient-tag-ignore")
19170 | 58 | 
19171 | 
19172 | 
19173 | --------------------------------------------------------------------------------
19174 | /models/esports/tourney.py:
19175 | --------------------------------------------------------------------------------
19176 |   1 | import io
19177 |   2 | from contextlib import suppress
19178 |   3 | from typing import List, Optional, Union
19179 |   4 | 
19180 |   5 | import discord
19181 |   6 | from discord.ext.commands import BadArgument
19182 |   7 | from tortoise import exceptions, fields
19183 |   8 | 
19184 |   9 | from models import BaseDbModel
19185 |  10 | from models.helpers import *  # noqa: F401, F403
19186 |  11 | from utils import split_list
19187 |  12 | 
19188 |  13 | _dict = {
19189 |  14 |     "tick": "\N{WHITE HEAVY CHECK MARK}",
19190 |  15 |     "cross": "\N{CROSS MARK}",
19191 |  16 | }
19192 |  17 | 
19193 |  18 | from constants import EsportsLog
19194 |  19 | from core import Context
19195 |  20 | 
19196 |  21 | 
19197 |  22 | class Tourney(BaseDbModel):
19198 |  23 |     class Meta:
19199 |  24 |         table = "tm.tourney"
19200 |  25 | 
19201 |  26 |     id = fields.BigIntField(pk=True, index=True)
19202 |  27 |     guild_id = fields.BigIntField()
19203 |  28 |     name = fields.CharField(max_length=30, default="Quotient-Tourney")
19204 |  29 |     registration_channel_id = fields.BigIntField(index=True)
19205 |  30 |     confirm_channel_id = fields.BigIntField()
19206 |  31 |     role_id = fields.BigIntField()
19207 |  32 |     required_mentions = fields.SmallIntField(default=4, validators=[ValueRangeValidator(range(0, 11))])
19208 |  33 |     total_slots = fields.SmallIntField()
19209 |  34 |     banned_users = ArrayField(fields.BigIntField(), default=list)
19210 |  35 |     host_id = fields.BigIntField()
19211 |  36 |     multiregister = fields.BooleanField(default=False)
19212 |  37 |     started_at = fields.DatetimeField(null=True)
19213 |  38 |     closed_at = fields.DatetimeField(null=True)
19214 |  39 |     open_role_id = fields.BigIntField(null=True)
19215 |  40 |     teamname_compulsion = fields.BooleanField(default=False)
19216 |  41 | 
19217 |  42 |     ping_role_id = fields.BigIntField(null=True)
19218 |  43 |     no_duplicate_name = fields.BooleanField(default=True)
19219 |  44 |     autodelete_rejected = fields.BooleanField(default=False)
19220 |  45 | 
19221 |  46 |     slotlist_start = fields.SmallIntField(default=2)
19222 |  47 |     group_size = fields.SmallIntField(null=True)
19223 |  48 |     success_message = fields.CharField(max_length=500, null=True)
19224 |  49 | 
19225 |  50 |     emojis = fields.JSONField(default=_dict)
19226 |  51 | 
19227 |  52 |     slotm_channel_id = fields.BigIntField(null=True)
19228 |  53 |     slotm_message_id = fields.BigIntField(null=True)
19229 |  54 | 
19230 |  55 |     required_lines = fields.SmallIntField(default=0)
19231 |  56 |     allow_duplicate_tags = fields.BooleanField(default=True)
19232 |  57 | 
19233 |  58 |     assigned_slots: fields.ManyToManyRelation["TMSlot"] = fields.ManyToManyField("models.TMSlot")
19234 |  59 |     media_partners: fields.ManyToManyRelation["MediaPartner"] = fields.ManyToManyField("models.MediaPartner")
19235 |  60 | 
19236 |  61 |     def __str__(self):
19237 |  62 |         return f"{getattr(self.registration_channel,'mention','deleted-channel')} [ID: `{self.id}`]"
19238 |  63 | 
19239 |  64 |     @classmethod
19240 |  65 |     async def convert(cls, ctx, argument: str):
19241 |  66 |         try:
19242 |  67 |             argument = int(argument)
19243 |  68 |         except ValueError:
19244 |  69 |             pass
19245 |  70 |         else:
19246 |  71 |             try:
19247 |  72 |                 return await cls.get(pk=argument, guild_id=ctx.guild.id)
19248 |  73 |             except exceptions.DoesNotExist:
19249 |  74 |                 pass
19250 |  75 | 
19251 |  76 |         raise BadArgument(f"This is not a valid Tourney ID.\n\nGet a valid ID with `{ctx.prefix}tourney config`")
19252 |  77 | 
19253 |  78 |     @property
19254 |  79 |     def guild(self) -> Optional[discord.Guild]:
19255 |  80 |         return self.bot.get_guild(self.guild_id)
19256 |  81 | 
19257 |  82 |     @property
19258 |  83 |     def logschan(self) -> Optional[discord.TextChannel]:
19259 |  84 |         if (g := self.guild) is not None:
19260 |  85 |             return discord.utils.get(g.text_channels, name="quotient-tourney-logs")
19261 |  86 | 
19262 |  87 |     @property
19263 |  88 |     def registration_channel(self) -> Optional[discord.TextChannel]:
19264 |  89 |         if (g := self.guild) is not None:
19265 |  90 |             return g.get_channel(self.registration_channel_id)
19266 |  91 | 
19267 |  92 |     @property
19268 |  93 |     def confirm_channel(self) -> Optional[discord.TextChannel]:
19269 |  94 |         if (g := self.guild) is not None:
19270 |  95 |             return g.get_channel(self.confirm_channel_id)
19271 |  96 | 
19272 |  97 |     @property
19273 |  98 |     def slotm_channel(self) -> Optional[discord.TextChannel]:
19274 |  99 |         if (g := self.guild) is not None:
19275 | 100 |             return g.get_channel(self.slotm_channel_id)
19276 | 101 | 
19277 | 102 |     @property
19278 | 103 |     def closed(self):
19279 | 104 |         return bool(self.closed_at)
19280 | 105 | 
19281 | 106 |     @property
19282 | 107 |     def role(self) -> Optional[discord.Role]:
19283 | 108 |         if (g := self.guild) is not None:
19284 | 109 |             return g.get_role(self.role_id)
19285 | 110 | 
19286 | 111 |     @property
19287 | 112 |     def open_role(self):
19288 | 113 |         if (g := self.guild) is not None:
19289 | 114 |             if self.open_role_id is not None:
19290 | 115 |                 return g.get_role(self.open_role_id)
19291 | 116 |             return self.guild.default_role
19292 | 117 | 
19293 | 118 |     @property
19294 | 119 |     def ping_role(self):
19295 | 120 |         if (g := self.guild) is not None:
19296 | 121 |             if self.ping_role_id is not None:
19297 | 122 |                 return g.get_role(self.ping_role_id)
19298 | 123 |             return None
19299 | 124 | 
19300 | 125 |     @property
19301 | 126 |     def modrole(self):
19302 | 127 |         if (g := self.guild) is not None:
19303 | 128 |             return discord.utils.get(g.roles, name="tourney-mod")
19304 | 129 | 
19305 | 130 |     @property
19306 | 131 |     def check_emoji(self):
19307 | 132 |         return self.emojis.get("tick", "✅")
19308 | 133 | 
19309 | 134 |     @property
19310 | 135 |     def cross_emoji(self):
19311 | 136 |         return self.emojis.get("cross", "❌")
19312 | 137 | 
19313 | 138 |     @staticmethod
19314 | 139 |     def is_ignorable(member: discord.Member) -> bool:
19315 | 140 |         return "tourney-mod" in (role.name.lower() for role in member.roles)
19316 | 141 | 
19317 | 142 |     async def _get_groups(self) -> List[List["TMSlot"]]:
19318 | 143 |         return split_list(await self.assigned_slots.all().order_by("num"), self.group_size)
19319 | 144 | 
19320 | 145 |     async def get_group(self, num: int) -> List["TMSlot"]:
19321 | 146 |         _all = await self._get_groups()
19322 | 147 |         for group in _all:
19323 | 148 |             if _all.index(group) == num - 1:
19324 | 149 |                 return group
19325 | 150 | 
19326 | 151 |     async def add_assigned_slot(self, slot: "TMSlot", message: discord.Message):
19327 | 152 |         _e = discord.Embed(color=self.bot.color)
19328 | 153 |         _e.description = f"**{slot.num}) NAME: [{slot.team_name.upper()}]({slot.jump_url})**\n"
19329 | 154 | 
19330 | 155 |         if len(message.mentions) > 0:
19331 | 156 |             _e.description += f"Team: {', '.join([str(m) for m in message.mentions])}"
19332 | 157 | 
19333 | 158 |         if _chan := self.confirm_channel:
19334 | 159 |             m = await _chan.send(
19335 | 160 |                 content=message.author.mention, embed=_e, allowed_mentions=discord.AllowedMentions(users=True)
19336 | 161 |             )
19337 | 162 | 
19338 | 163 |             slot.confirm_jump_url = m.jump_url
19339 | 164 | 
19340 | 165 |             await slot.save()
19341 | 166 |             await self.assigned_slots.add(slot)
19342 | 167 | 
19343 | 168 |     async def finalize_slot(self, ctx: Context, slot: "TMSlot"):
19344 | 169 |         """
19345 | 170 |         Add role to user and reaction to the message
19346 | 171 |         """
19347 | 172 |         with suppress(discord.HTTPException):
19348 | 173 |             if not (_role := self.role) in ctx.author.roles:
19349 | 174 |                 await ctx.author.add_roles(_role)
19350 | 175 | 
19351 | 176 |             await ctx.message.add_reaction(self.check_emoji)
19352 | 177 | 
19353 | 178 |             if self.success_message:
19354 | 179 |                 embed = discord.Embed(color=self.bot.color, description=self.success_message)
19355 | 180 |                 embed.title = f"Message from {ctx.guild.name}"
19356 | 181 |                 embed.url = slot.jump_url
19357 | 182 | 
19358 | 183 |                 await ctx.author.send(embed=embed, view=ctx.get_dm_view(f"Sent from {ctx.guild.name}"))
19359 | 184 | 
19360 | 185 |     async def end_process(self):
19361 | 186 |         from cogs.esports.helpers.utils import toggle_channel
19362 | 187 | 
19363 | 188 |         closed_at = self.bot.current_time
19364 | 189 | 
19365 | 190 |         registration_channel = self.registration_channel
19366 | 191 |         open_role = self.open_role
19367 | 192 | 
19368 | 193 |         await Tourney.filter(pk=self.id).update(started_at=None, closed_at=closed_at)
19369 | 194 |         channel_update = await toggle_channel(registration_channel, open_role, False)
19370 | 195 |         await registration_channel.send(
19371 | 196 |             embed=discord.Embed(color=self.bot.color, description="**Registration is now closed!**")
19372 | 197 |         )
19373 | 198 | 
19374 | 199 |         self.bot.dispatch("tourney_log", EsportsLog.closed, self, permission_updated=channel_update)
19375 | 200 | 
19376 | 201 |     async def setup_slotm(self):
19377 | 202 |         from cogs.esports.views.tourney.slotm import TourneySlotManager
19378 | 203 | 
19379 | 204 |         _view = TourneySlotManager(self.bot, tourney=self)
19380 | 205 |         _category = self.registration_channel.category or self.registration_channel.guild
19381 | 206 |         overwrites = {
19382 | 207 |             self.guild.default_role: discord.PermissionOverwrite(
19383 | 208 |                 read_messages=True, send_messages=False, read_message_history=True
19384 | 209 |             ),
19385 | 210 |             self.guild.me: discord.PermissionOverwrite(manage_channels=True, manage_permissions=True),
19386 | 211 |         }
19387 | 212 | 
19388 | 213 |         slotm_channel = await _category.create_text_channel(name="tourney-slotmanager", overwrites=overwrites)
19389 | 214 |         return await slotm_channel.send(embed=TourneySlotManager.initial_embed(self), view=_view)
19390 | 215 | 
19391 | 216 |     async def get_csv(self):
19392 | 217 |         guild = self.guild
19393 | 218 |         member_ids = [_.id for _ in guild.members]
19394 | 219 | 
19395 | 220 |         _x = "Reg Posi,Team Name,Leader,Leader ID,Teammates,Teammates in Server,Jump URL\n"
19396 | 221 | 
19397 | 222 |         async for slot in self.assigned_slots.all().order_by("num"):
19398 | 223 |             _team = " | ".join((f"{str(guild.get_member(m))} ({m})" for m in slot.members))
19399 | 224 | 
19400 | 225 |             _x += (
19401 | 226 |                 f"{slot.num},{slot.team_name},{str(guild.get_member(slot.leader_id))},"
19402 | 227 |                 f"'{slot.leader_id}',{_team},{sum(1 for i in slot.members if i in member_ids)},{slot.jump_url}\n"
19403 | 228 |             )
19404 | 229 | 
19405 | 230 |         fp = io.BytesIO(_x.encode())
19406 | 231 | 
19407 | 232 |         return discord.File(fp, filename=f"tourney_data_{self.id}_{self.bot.current_time.timestamp()}.csv")
19408 | 233 | 
19409 | 234 |     async def full_delete(self, member: discord.Member = None) -> None:
19410 | 235 |         if self.logschan != None:
19411 | 236 |             member = member.mention if member else "Unknown"
19412 | 237 |             embed = discord.Embed(color=discord.Color.red())
19413 | 238 |             embed.title = f"A tournament was completely deleted."
19414 | 239 |             embed.description = f"Tourney name : {self.name} [{self.id}]" + f"\nDeleted by: {member}"
19415 | 240 |             await self.logschan.send(embed=embed, file=await self.get_csv())
19416 | 241 | 
19417 | 242 |         self.bot.cache.tourney_channels.discard(self.registration_channel_id)
19418 | 243 |         _data = await self.assigned_slots.all()
19419 | 244 |         await TMSlot.filter(pk__in=[_.id for _ in _data]).delete()
19420 | 245 |         await self.delete()
19421 | 246 | 
19422 | 247 |         if self.slotm_channel_id:
19423 | 248 |             with suppress(discord.HTTPException, AttributeError):
19424 | 249 |                 await self.slotm_channel.delete()
19425 | 250 | 
19426 | 251 |     @staticmethod
19427 | 252 |     async def prompt_selector(ctx: Context, *, tourneys: List["Tourney"] = None, placeholder: str = None):
19428 | 253 |         placeholder = placeholder or "Choose a tourney to contine..."
19429 | 254 | 
19430 | 255 |         from cogs.esports.views.tourney._select import QuotientView, TourneySelector
19431 | 256 | 
19432 | 257 |         tourneys = tourneys or await Tourney.filter(guild_id=ctx.guild.id).order_by("id").limit(25)
19433 | 258 | 
19434 | 259 |         if not tourneys:
19435 | 260 |             return None
19436 | 261 | 
19437 | 262 |         if len(tourneys) == 1:
19438 | 263 |             return tourneys[0]
19439 | 264 | 
19440 | 265 |         view = QuotientView(ctx)
19441 | 266 |         view.add_item(TourneySelector(placeholder, tourneys))
19442 | 267 | 
19443 | 268 |         view.message = await ctx.send("Choose a tourney from the dropdown below...", view=view)
19444 | 269 |         await view.wait()
19445 | 270 |         if view.custom_id:
19446 | 271 |             await view.message.delete()
19447 | 272 |             return await Tourney.get_or_none(id=view.custom_id)
19448 | 273 | 
19449 | 274 |     async def setup_logs(self):
19450 | 275 |         _reason = "Created for tournament management."
19451 | 276 |         _g = self.guild
19452 | 277 | 
19453 | 278 |         if not (tourney_mod := self.modrole):
19454 | 279 |             tourney_mod = await self.guild.create_role(name="tourney-mod", color=self.bot.color, reason=_reason)
19455 | 280 | 
19456 | 281 |         overwrite = self.registration_channel.overwrites_for(_g.default_role)
19457 | 282 |         overwrite.update(read_messages=True, send_messages=True, read_message_history=True)
19458 | 283 |         await self.registration_channel.set_permissions(tourney_mod, overwrite=overwrite)
19459 | 284 | 
19460 | 285 |         if (tourney_log_channel := self.logschan) is None:
19461 | 286 |             overwrites = {
19462 | 287 |                 _g.default_role: discord.PermissionOverwrite(read_messages=False),
19463 | 288 |                 _g.me: discord.PermissionOverwrite(read_messages=True),
19464 | 289 |                 tourney_mod: discord.PermissionOverwrite(read_messages=True),
19465 | 290 |             }
19466 | 291 |             tourney_log_channel = await _g.create_text_channel(
19467 | 292 |                 name="quotient-tourney-logs",
19468 | 293 |                 overwrites=overwrites,
19469 | 294 |                 reason=_reason,
19470 | 295 |                 topic="**DO NOT RENAME THIS CHANNEL**",
19471 | 296 |             )
19472 | 297 | 
19473 | 298 |             note = await tourney_log_channel.send(
19474 | 299 |                 embed=discord.Embed(
19475 | 300 |                     description=f"If events related to tournament i.e opening registrations or adding roles, "
19476 | 301 |                     f"etc are triggered, then they will be logged in this channel. "
19477 | 302 |                     f"Also I have created {tourney_mod.mention}, you can give that role to your "
19478 | 303 |                     f"tourney-moderators. User with {tourney_mod.mention} can also send messages in "
19479 | 304 |                     f"registration channels and they won't be considered as tourney-registration.\n\n"
19480 | 305 |                     f"`Note`: **Do not rename/delete this channel.**",
19481 | 306 |                     color=discord.Color(self.bot.color),
19482 | 307 |                 )
19483 | 308 |             )
19484 | 309 |             await tourney_log_channel.send(f"<@{self.host_id}> **Read This Message 👆**")
19485 | 310 |             await note.pin()
19486 | 311 | 
19487 | 312 |     async def toggle_registrations(self):
19488 | 313 |         channel, open_role = self.registration_channel, self.open_role
19489 | 314 |         if not channel:
19490 | 315 |             return False, f"I cannot find the registration channel. ({self.registration_channel_id})"
19491 | 316 | 
19492 | 317 |         if not channel.permissions_for(self.guild.me).manage_permissions:
19493 | 318 |             return False, f"I don't have permission to manage channel permissions. ({channel.id})"
19494 | 319 | 
19495 | 320 |         if not open_role:
19496 | 321 |             return False, f"I cannot find the open role. ({self.open_role_id})"
19497 | 322 | 
19498 | 323 |         if self.started_at:
19499 | 324 |             return await self.__stop_registrations()
19500 | 325 | 
19501 | 326 |         return await self.__start_registrations()
19502 | 327 | 
19503 | 328 |     async def __start_registrations(self):
19504 | 329 |         registration_channel = self.registration_channel
19505 | 330 | 
19506 | 331 |         if self.total_slots <= await self.assigned_slots.all().count():
19507 | 332 |             return False, "Slots are already full, Increase slots to start again."
19508 | 333 | 
19509 | 334 |         await Tourney.filter(pk=self.id).update(started_at=self.bot.current_time, closed_at=None)
19510 | 335 |         self.bot.cache.tourney_channels.add(self.registration_channel_id)
19511 | 336 | 
19512 | 337 |         _e = discord.Embed(color=self.bot.color)
19513 | 338 | 
19514 | 339 |         _e.description = (
19515 | 340 |             f"**Registration Open for {self.name}**\n"
19516 | 341 |             "```"
19517 | 342 |             f"📣 {self.required_mentions} mentions required.\n"
19518 | 343 |             f"📣 Total slots: {self.total_slots} [{self.total_slots - await self.assigned_slots.all().count()} slots left]"
19519 | 344 |             "```"
19520 | 345 |         )
19521 | 346 |         _e.set_thumbnail(url=getattr(self.guild.icon, "url", self.bot.user.avatar.url))
19522 | 347 |         _ping = None
19523 | 348 |         if p := self.ping_role:
19524 | 349 |             if p == self.guild.default_role:
19525 | 350 |                 _ping = "@everyone"
19526 | 351 | 
19527 | 352 |             else:
19528 | 353 |                 _ping = p.mention
19529 | 354 | 
19530 | 355 |         await registration_channel.send(
19531 | 356 |             _ping, embed=_e, allowed_mentions=discord.AllowedMentions(roles=True, everyone=True)
19532 | 357 |         )
19533 | 358 | 
19534 | 359 |         overwrite = registration_channel.overwrites_for(self.open_role)
19535 | 360 |         overwrite.update(send_messages=True)
19536 | 361 |         await registration_channel.set_permissions(
19537 | 362 |             self.open_role,
19538 | 363 |             overwrite=overwrite,
19539 | 364 |             reason="Open for Registrations!",
19540 | 365 |         )
19541 | 366 |         return True, True
19542 | 367 | 
19543 | 368 |     async def __stop_registrations(self):
19544 | 369 |         registration_channel = self.registration_channel
19545 | 370 | 
19546 | 371 |         overwrite = registration_channel.overwrites_for(self.open_role)
19547 | 372 |         overwrite.update(send_messages=False)
19548 | 373 |         await registration_channel.set_permissions(
19549 | 374 |             self.open_role,
19550 | 375 |             overwrite=overwrite,
19551 | 376 |             reason="Closed Registrations!",
19552 | 377 |         )
19553 | 378 | 
19554 | 379 |         await registration_channel.send(
19555 | 380 |             embed=discord.Embed(color=self.bot.color, description=f"**{self.name} registration paused.**")
19556 | 381 |         )
19557 | 382 |         await Tourney.filter(pk=self.id).update(started_at=None, closed_at=self.bot.current_time)
19558 | 383 |         return True, True
19559 | 384 | 
19560 | 385 |     async def ban_user(self, user: Union[discord.Member, discord.User]):
19561 | 386 |         await Tourney.filter(pk=self.id).update(banned_users=ArrayAppend("banned_users", user.id))
19562 | 387 | 
19563 | 388 |     async def unban_user(self, user: Union[discord.Member, discord.User]):
19564 | 389 |         await Tourney.filter(pk=self.id).update(banned_users=ArrayRemove("banned_users", user.id))
19565 | 390 | 
19566 | 391 |     async def remove_slot(self, slot: "TMSlot"):
19567 | 392 |         if slot.confirm_jump_url:
19568 | 393 |             self.bot.loop.create_task(self.update_confirmed_message(slot.confirm_jump_url))
19569 | 394 | 
19570 | 395 |         await slot.delete()
19571 | 396 | 
19572 | 397 |         if not await self.assigned_slots.filter(leader_id=slot.leader_id).exists():
19573 | 398 |             m = self.guild.get_member(slot.leader_id)
19574 | 399 |             if m:
19575 | 400 |                 await m.remove_roles(discord.Object(id=self.role_id))
19576 | 401 | 
19577 | 402 |     async def update_confirmed_message(self, link: str):
19578 | 403 |         _ids = [int(i) for i in link.split("/")[5:]]
19579 | 404 | 
19580 | 405 |         with suppress(discord.HTTPException, IndexError):
19581 | 406 |             message = await self.guild.get_channel(_ids[0]).fetch_message(_ids[1])
19582 | 407 | 
19583 | 408 |             if message:
19584 | 409 |                 e = message.embeds[0]
19585 | 410 | 
19586 | 411 |                 e.description = "~~" + e.description.strip() + "~~"
19587 | 412 |                 e.title = "Cancelled Slot"
19588 | 413 |                 e.color = discord.Color.red()
19589 | 414 | 
19590 | 415 |                 await message.edit(embed=e)
19591 | 416 | 
19592 | 417 |     async def make_changes(self, **kwargs):
19593 | 418 |         return await Tourney.filter(pk=self.id).update(**kwargs)
19594 | 419 | 
19595 | 420 |     async def refresh_slotlm(self):
19596 | 421 |         from cogs.esports.views.tourney import TourneySlotManager
19597 | 422 | 
19598 | 423 |         msg = await self.bot.get_or_fetch_message(self.slotm_channel, self.slotm_message_id)
19599 | 424 |         _view = TourneySlotManager(self.bot, tourney=self)
19600 | 425 |         _e = TourneySlotManager.initial_embed(self)
19601 | 426 | 
19602 | 427 |         try:
19603 | 428 |             await msg.edit(embed=_e, view=_view)
19604 | 429 |         except discord.HTTPException:
19605 | 430 |             msg = await self.slotm_channel.send(embed=_e, view=_view)
19606 | 431 |             await self.make_changes(slotm_message_id=msg.id)
19607 | 432 | 
19608 | 433 |         finally:
19609 | 434 |             return True
19610 | 435 | 
19611 | 436 |     async def check_fake_tags(self, message: discord.Message):
19612 | 437 |         query = """
19613 | 438 |         SELECT *
19614 | 439 |             FROM PUBLIC."tm.tourney_tm.register" AS ASSIGNED_SLOT
19615 | 440 |             INNER JOIN PUBLIC."tm.register" AS SLOTS ON SLOTS.ID = ASSIGNED_SLOT.TMSLOT_ID
19616 | 441 |         WHERE ASSIGNED_SLOT."tm.tourney_id" = $1
19617 | 442 |         AND $2 && SLOTS.MEMBERS;
19618 | 443 | 
19619 | 444 |         """
19620 | 445 |         return await self.bot.db.fetch(query, self.id, [i.id for i in message.mentions])
19621 | 446 | 
19622 | 447 | 
19623 | 448 | class TMSlot(BaseDbModel):
19624 | 449 |     class Meta:
19625 | 450 |         table = "tm.register"
19626 | 451 | 
19627 | 452 |     id = fields.BigIntField(pk=True)
19628 | 453 |     num = fields.IntField()
19629 | 454 |     team_name = fields.TextField()
19630 | 455 |     leader_id = fields.BigIntField()
19631 | 456 |     message_id = fields.BigIntField(null=True)
19632 | 457 |     members = ArrayField(fields.BigIntField(), default=list)
19633 | 458 |     confirm_jump_url = fields.CharField(max_length=300, null=True)
19634 | 459 |     jump_url = fields.TextField(null=True)
19635 | 460 | 
19636 | 461 | 
19637 | 462 | class MediaPartner(BaseDbModel):
19638 | 463 |     class Meta:
19639 | 464 |         table = "tm.media_partners"
19640 | 465 | 
19641 | 466 |     channel_id = fields.BigIntField(pk=True, generated=False)
19642 | 467 |     tourney_id = fields.IntField()
19643 | 468 |     slots: fields.ManyToManyRelation["PartnerSlot"] = fields.ManyToManyField("models.PartnerSlot")
19644 | 469 | 
19645 | 470 |     @property
19646 | 471 |     def channel(self) -> Optional[discord.TextChannel]:
19647 | 472 |         return self.bot.get_channel(self.channel_id)
19648 | 473 | 
19649 | 474 | 
19650 | 475 | class PartnerSlot(BaseDbModel):
19651 | 476 |     class Meta:
19652 | 477 |         table = "tm.media_partner_users"
19653 | 478 | 
19654 | 479 |     id = fields.IntField(pk=True)
19655 | 480 |     user_id = fields.BigIntField()
19656 | 481 |     message_id = fields.BigIntField()
19657 | 482 |     jump_url = fields.CharField(max_length=300, null=True)
19658 | 483 |     members = ArrayField(fields.BigIntField(), default=list)
19659 | 484 | 
19660 | 485 | 
19661 | 486 | class TGroupList(BaseDbModel):
19662 | 487 |     class Meta:
19663 | 488 |         table = "tourney_groups"
19664 | 489 | 
19665 | 490 |     message_id = fields.BigIntField(pk=True)
19666 | 491 |     tourney_id = fields.IntField()
19667 | 492 |     channel_id = fields.BigIntField()
19668 | 493 |     group_number = fields.SmallIntField()
19669 | 494 |     refresh_at = fields.DatetimeField(auto_now=True)
19670 | 495 | 
19671 | 496 |     @property
19672 | 497 |     def channel(self):
19673 | 498 |         return self.bot.get_channel(self.channel_id)
19674 | 499 | 
19675 | 500 |     @property
19676 | 501 |     def jump_url(self):
19677 | 502 |         if c := self.channel:
19678 | 503 |             return f"https://discord.com/channels/{c.guild.id}/{self.channel_id}/{self.pk}"
19679 | 504 | 
19680 | 
19681 | 
19682 | --------------------------------------------------------------------------------
19683 | /models/helpers/__init__.py:
19684 | --------------------------------------------------------------------------------
19685 | 1 | from .cfields import *  # noqa: F401, F403
19686 | 2 | from .functions import *  # noqa: F401, F403
19687 | 3 | from .validators import *  # noqa: F401, F403
19688 | 4 | 
19689 | 
19690 | 
19691 | --------------------------------------------------------------------------------
19692 | /models/helpers/__pycache__/__init__.cpython-312.pyc:
19693 | --------------------------------------------------------------------------------
19694 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/helpers/__pycache__/__init__.cpython-312.pyc
19695 | 
19696 | 
19697 | --------------------------------------------------------------------------------
19698 | /models/helpers/__pycache__/cfields.cpython-312.pyc:
19699 | --------------------------------------------------------------------------------
19700 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/helpers/__pycache__/cfields.cpython-312.pyc
19701 | 
19702 | 
19703 | --------------------------------------------------------------------------------
19704 | /models/helpers/__pycache__/functions.cpython-312.pyc:
19705 | --------------------------------------------------------------------------------
19706 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/helpers/__pycache__/functions.cpython-312.pyc
19707 | 
19708 | 
19709 | --------------------------------------------------------------------------------
19710 | /models/helpers/__pycache__/validators.cpython-312.pyc:
19711 | --------------------------------------------------------------------------------
19712 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/helpers/__pycache__/validators.cpython-312.pyc
19713 | 
19714 | 
19715 | --------------------------------------------------------------------------------
19716 | /models/helpers/cfields.py:
19717 | --------------------------------------------------------------------------------
19718 |  1 | from typing import Any
19719 |  2 | 
19720 |  3 | from tortoise.fields.base import Field
19721 |  4 | 
19722 |  5 | 
19723 |  6 | class ArrayField(Field, list):
19724 |  7 |     def __init__(self, field: Field, **kwargs) -> None:
19725 |  8 |         super().__init__(**kwargs)
19726 |  9 |         self.sub_field = field
19727 | 10 |         self.SQL_TYPE = "%s[]" % field.SQL_TYPE
19728 | 11 | 
19729 | 12 |     def to_python_value(self, value: Any) -> Any:
19730 | 13 |         return list(map(self.sub_field.to_python_value, value))
19731 | 14 | 
19732 | 15 |     def to_db_value(self, value: Any, instance: Any) -> Any:
19733 | 16 |         return [self.sub_field.to_db_value(val, instance) for val in value]
19734 | 17 | 
19735 | 
19736 | 
19737 | --------------------------------------------------------------------------------
19738 | /models/helpers/functions.py:
19739 | --------------------------------------------------------------------------------
19740 |  1 | import typing
19741 |  2 | from enum import Enum
19742 |  3 | 
19743 |  4 | from pypika.terms import Function
19744 |  5 | from tortoise.expressions import F
19745 |  6 | 
19746 |  7 | __all__ = (
19747 |  8 |     "ArrayAppend",
19748 |  9 |     "ArrayRemove",
19749 | 10 | )
19750 | 11 | 
19751 | 12 | 
19752 | 13 | class ArrayAppend(Function):
19753 | 14 |     def __init__(self, field: str, value: typing.Any) -> None:
19754 | 15 |         if isinstance(value, Enum):
19755 | 16 |             value = value.value
19756 | 17 | 
19757 | 18 |         super().__init__("ARRAY_APPEND", F(field), str(value))
19758 | 19 | 
19759 | 20 | 
19760 | 21 | class ArrayRemove(Function):
19761 | 22 |     def __init__(self, field: str, value: typing.Any) -> None:
19762 | 23 |         if isinstance(value, Enum):
19763 | 24 |             value = value.value
19764 | 25 | 
19765 | 26 |         super().__init__("ARRAY_REMOVE", F(field), str(value))
19766 | 27 | 
19767 | 
19768 | 
19769 | --------------------------------------------------------------------------------
19770 | /models/helpers/validators.py:
19771 | --------------------------------------------------------------------------------
19772 |  1 | from tortoise.exceptions import ValidationError
19773 |  2 | from tortoise.validators import Validator
19774 |  3 | 
19775 |  4 | 
19776 |  5 | class ValueRangeValidator(Validator):
19777 |  6 |     """
19778 |  7 |     A validator to validate whether the given value is in given range or not.
19779 |  8 |     """
19780 |  9 | 
19781 | 10 |     def __init__(self, _range: range):
19782 | 11 |         self._range = _range
19783 | 12 | 
19784 | 13 |     def __call__(self, value: int):
19785 | 14 |         if not value in self._range:
19786 | 15 |             raise ValidationError(f"The value must be a number between `{self._range.start}` and `{self._range.stop}`.")
19787 | 16 | 
19788 | 
19789 | 
19790 | --------------------------------------------------------------------------------
19791 | /models/misc/AutoPurge.py:
19792 | --------------------------------------------------------------------------------
19793 |  1 | from tortoise import fields, models
19794 |  2 | 
19795 |  3 | 
19796 |  4 | class AutoPurge(models.Model):
19797 |  5 |     class Meta:
19798 |  6 |         table = "autopurge"
19799 |  7 | 
19800 |  8 |     id = fields.BigIntField(pk=True)
19801 |  9 |     guild_id = fields.BigIntField()
19802 | 10 |     channel_id = fields.BigIntField()
19803 | 11 |     delete_after = fields.IntField(default=10)
19804 | 12 | 
19805 | 13 |     @property
19806 | 14 |     def channel(self):
19807 | 15 |         return self.bot.get_channel(self.channel_id)
19808 | 16 | 
19809 | 
19810 | 
19811 | --------------------------------------------------------------------------------
19812 | /models/misc/Autorole.py:
19813 | --------------------------------------------------------------------------------
19814 |  1 | from typing import Optional
19815 |  2 | 
19816 |  3 | import discord
19817 |  4 | from tortoise import fields, models
19818 |  5 | 
19819 |  6 | from models.helpers import ArrayField
19820 |  7 | 
19821 |  8 | 
19822 |  9 | class Autorole(models.Model):
19823 | 10 |     class Meta:
19824 | 11 |         table = "autoroles"
19825 | 12 | 
19826 | 13 |     guild_id = fields.BigIntField(pk=True, index=True)
19827 | 14 |     humans = ArrayField(fields.BigIntField(), default=list)
19828 | 15 |     bots = ArrayField(fields.BigIntField(), default=list)
19829 | 16 | 
19830 | 17 |     @property
19831 | 18 |     def _guild(self) -> Optional[discord.Guild]:
19832 | 19 |         return self.bot.get_guild(self.guild_id)
19833 | 20 | 
19834 | 21 |     @property
19835 | 22 |     def human_roles(self):
19836 | 23 |         if self._guild is not None:
19837 | 24 |             return tuple(map(lambda x: getattr(self._guild.get_role(x), "mention", "Deleted"), self.humans))
19838 | 25 | 
19839 | 26 |     @property
19840 | 27 |     def bot_roles(self):
19841 | 28 |         if self._guild is not None:
19842 | 29 |             return tuple(map(lambda x: getattr(self._guild.get_role(x), "mention", "Deleted"), self.bots))
19843 | 30 | 
19844 | 
19845 | 
19846 | --------------------------------------------------------------------------------
19847 | /models/misc/Commands.py:
19848 | --------------------------------------------------------------------------------
19849 |  1 | from tortoise import fields, models
19850 |  2 | 
19851 |  3 | 
19852 |  4 | class Commands(models.Model):
19853 |  5 |     class Meta:
19854 |  6 |         table = "commands"
19855 |  7 | 
19856 |  8 |     id = fields.BigIntField(pk=True)
19857 |  9 |     guild_id = fields.BigIntField(index=True)
19858 | 10 |     channel_id = fields.BigIntField()
19859 | 11 |     user_id = fields.BigIntField(index=True)
19860 | 12 |     cmd = fields.CharField(max_length=100, index=True)
19861 | 13 |     used_at = fields.DatetimeField(auto_now=True)
19862 | 14 |     prefix = fields.CharField(max_length=100)
19863 | 15 |     failed = fields.BooleanField(default=False)
19864 | 16 | 
19865 | 
19866 | 
19867 | --------------------------------------------------------------------------------
19868 | /models/misc/Lockdown.py:
19869 | --------------------------------------------------------------------------------
19870 |  1 | from tortoise import fields, models
19871 |  2 | 
19872 |  3 | import constants
19873 |  4 | from models.helpers import ArrayField
19874 |  5 | 
19875 |  6 | 
19876 |  7 | class Lockdown(models.Model):
19877 |  8 |     class Meta:
19878 |  9 |         table = "lockdown"
19879 | 10 | 
19880 | 11 |     id = fields.BigIntField(pk=True)
19881 | 12 |     guild_id = fields.BigIntField(index=True)
19882 | 13 |     type = fields.CharEnumField(constants.LockType, max_length=20)
19883 | 14 |     role_id = fields.BigIntField(null=True)
19884 | 15 |     channel_id = fields.BigIntField(null=True)
19885 | 16 |     channel_ids = ArrayField(fields.BigIntField(), default=list, index=True)
19886 | 17 |     expire_time = fields.DatetimeField(null=True)
19887 | 18 |     author_id = fields.BigIntField()
19888 | 19 | 
19889 | 20 |     @property
19890 | 21 |     def _guild(self):
19891 | 22 |         return self.bot.get_guild(self.guild_id)
19892 | 23 | 
19893 | 24 |     @property
19894 | 25 |     def roles(self):
19895 | 26 |         if self._guild is not None:
19896 | 27 |             return self._guild.get_role(self.role_id)
19897 | 28 | 
19898 | 29 |     @property
19899 | 30 |     def channels(self):
19900 | 31 |         return map(self.bot.get_channel, self.channel_ids)
19901 | 32 | 
19902 | 
19903 | 
19904 | --------------------------------------------------------------------------------
19905 | /models/misc/Snipe.py:
19906 | --------------------------------------------------------------------------------
19907 |  1 | from tortoise import fields, models
19908 |  2 | 
19909 |  3 | 
19910 |  4 | class Snipe(models.Model):
19911 |  5 |     class Meta:
19912 |  6 |         table = "snipes"
19913 |  7 | 
19914 |  8 |     channel_id = fields.BigIntField(pk=True)
19915 |  9 |     author_id = fields.BigIntField()
19916 | 10 |     content = fields.TextField()
19917 | 11 |     delete_time = fields.DatetimeField(auto_now=True)
19918 | 12 |     nsfw = fields.BooleanField(default=False)
19919 | 13 | 
19920 | 14 |     @property
19921 | 15 |     def author(self):
19922 | 16 |         return self.bot.get_user(self.author_id)
19923 | 17 | 
19924 | 
19925 | 
19926 | --------------------------------------------------------------------------------
19927 | /models/misc/Tag.py:
19928 | --------------------------------------------------------------------------------
19929 |  1 | from tortoise import fields, models
19930 |  2 | 
19931 |  3 | 
19932 |  4 | class Tag(models.Model):
19933 |  5 |     class Meta:
19934 |  6 |         table = "tags"
19935 |  7 | 
19936 |  8 |     id = fields.BigIntField(pk=True)
19937 |  9 |     guild_id = fields.BigIntField()
19938 | 10 |     name = fields.CharField(max_length=100)
19939 | 11 |     content = fields.TextField()
19940 | 12 |     is_embed = fields.BooleanField(default=False)
19941 | 13 |     is_nsfw = fields.BooleanField(default=False)
19942 | 14 |     owner_id = fields.BigIntField()
19943 | 15 |     created_at = fields.DatetimeField(auto_now=True)
19944 | 16 |     usage = fields.IntField(default=0)
19945 | 17 | 
19946 | 18 |     @property
19947 | 19 |     def owner(self):
19948 | 20 |         return self.bot.get_user(self.owner_id)
19949 | 21 | 
19950 | 
19951 | 
19952 | --------------------------------------------------------------------------------
19953 | /models/misc/Timer.py:
19954 | --------------------------------------------------------------------------------
19955 |  1 | from tortoise import fields, models
19956 |  2 | 
19957 |  3 | 
19958 |  4 | class Timer(models.Model):
19959 |  5 |     id = fields.BigIntField(pk=True)
19960 |  6 |     expires = fields.DatetimeField(index=True)
19961 |  7 |     created = fields.DatetimeField(auto_now=True)
19962 |  8 |     event = fields.TextField()
19963 |  9 |     extra = fields.JSONField(default=dict)
19964 | 10 | 
19965 | 11 |     @property
19966 | 12 |     def kwargs(self):
19967 | 13 |         return self.extra.get("kwargs", {})
19968 | 14 | 
19969 | 15 |     @property
19970 | 16 |     def args(self):
19971 | 17 |         return self.extra.get("args", ())
19972 | 18 | 
19973 | 
19974 | 
19975 | --------------------------------------------------------------------------------
19976 | /models/misc/User.py:
19977 | --------------------------------------------------------------------------------
19978 |  1 | from tortoise import fields, models
19979 |  2 | 
19980 |  3 | from models.helpers import ArrayField
19981 |  4 | 
19982 |  5 | 
19983 |  6 | # TODO: make manytomany field in user_data for redeem codes.
19984 |  7 | class User(models.Model):
19985 |  8 |     class Meta:
19986 |  9 |         table = "user_data"
19987 | 10 | 
19988 | 11 |     user_id = fields.BigIntField(pk=True, index=True)
19989 | 12 |     is_premium = fields.BooleanField(default=False, index=True)
19990 | 13 |     premium_expire_time = fields.DatetimeField(null=True)
19991 | 14 |     made_premium = ArrayField(fields.BigIntField(), default=list)  # a list of servers this user boosted
19992 | 15 |     premiums = fields.IntField(default=0)
19993 | 16 |     premium_notified = fields.BooleanField(default=False)
19994 | 17 |     public_profile = fields.BooleanField(default=True)
19995 | 18 |     # badges = CharVarArrayField(default=list)
19996 | 19 |     money = fields.IntField(default=0)
19997 | 20 | 
19998 | 
19999 | 
20000 | --------------------------------------------------------------------------------
20001 | /models/misc/Votes.py:
20002 | --------------------------------------------------------------------------------
20003 |  1 | from tortoise import fields, models
20004 |  2 | 
20005 |  3 | 
20006 |  4 | class Votes(models.Model):
20007 |  5 |     class Meta:
20008 |  6 |         table = "votes"
20009 |  7 | 
20010 |  8 |     user_id = fields.BigIntField(pk=True)
20011 |  9 |     is_voter = fields.BooleanField(default=False, index=True)
20012 | 10 |     expire_time = fields.DatetimeField(null=True)
20013 | 11 |     reminder = fields.BooleanField(default=False)
20014 | 12 |     notified = fields.BooleanField(default=False, index=True)
20015 | 13 |     public_profile = fields.BooleanField(default=True)
20016 | 14 |     total_votes = fields.IntField(default=0)
20017 | 15 | 
20018 | 
20019 | 
20020 | --------------------------------------------------------------------------------
20021 | /models/misc/__init__.py:
20022 | --------------------------------------------------------------------------------
20023 |  1 | from .alerts import *
20024 |  2 | from .AutoPurge import *
20025 |  3 | from .Autorole import *
20026 |  4 | from .block import *
20027 |  5 | from .Commands import *
20028 |  6 | from .guild import *  # noqa: F401, F403
20029 |  7 | from .Lockdown import *
20030 |  8 | from .premium import *
20031 |  9 | from .Snipe import *
20032 | 10 | from .Tag import *
20033 | 11 | from .Timer import *
20034 | 12 | from .User import *
20035 | 13 | from .Votes import *
20036 | 14 | 
20037 | 
20038 | 
20039 | --------------------------------------------------------------------------------
20040 | /models/misc/__pycache__/AutoPurge.cpython-312.pyc:
20041 | --------------------------------------------------------------------------------
20042 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/AutoPurge.cpython-312.pyc
20043 | 
20044 | 
20045 | --------------------------------------------------------------------------------
20046 | /models/misc/__pycache__/Autorole.cpython-312.pyc:
20047 | --------------------------------------------------------------------------------
20048 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/Autorole.cpython-312.pyc
20049 | 
20050 | 
20051 | --------------------------------------------------------------------------------
20052 | /models/misc/__pycache__/Commands.cpython-312.pyc:
20053 | --------------------------------------------------------------------------------
20054 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/Commands.cpython-312.pyc
20055 | 
20056 | 
20057 | --------------------------------------------------------------------------------
20058 | /models/misc/__pycache__/Lockdown.cpython-312.pyc:
20059 | --------------------------------------------------------------------------------
20060 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/Lockdown.cpython-312.pyc
20061 | 
20062 | 
20063 | --------------------------------------------------------------------------------
20064 | /models/misc/__pycache__/Snipe.cpython-312.pyc:
20065 | --------------------------------------------------------------------------------
20066 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/Snipe.cpython-312.pyc
20067 | 
20068 | 
20069 | --------------------------------------------------------------------------------
20070 | /models/misc/__pycache__/Tag.cpython-312.pyc:
20071 | --------------------------------------------------------------------------------
20072 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/Tag.cpython-312.pyc
20073 | 
20074 | 
20075 | --------------------------------------------------------------------------------
20076 | /models/misc/__pycache__/Timer.cpython-312.pyc:
20077 | --------------------------------------------------------------------------------
20078 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/Timer.cpython-312.pyc
20079 | 
20080 | 
20081 | --------------------------------------------------------------------------------
20082 | /models/misc/__pycache__/User.cpython-312.pyc:
20083 | --------------------------------------------------------------------------------
20084 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/User.cpython-312.pyc
20085 | 
20086 | 
20087 | --------------------------------------------------------------------------------
20088 | /models/misc/__pycache__/Votes.cpython-312.pyc:
20089 | --------------------------------------------------------------------------------
20090 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/Votes.cpython-312.pyc
20091 | 
20092 | 
20093 | --------------------------------------------------------------------------------
20094 | /models/misc/__pycache__/__init__.cpython-312.pyc:
20095 | --------------------------------------------------------------------------------
20096 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/__init__.cpython-312.pyc
20097 | 
20098 | 
20099 | --------------------------------------------------------------------------------
20100 | /models/misc/__pycache__/alerts.cpython-312.pyc:
20101 | --------------------------------------------------------------------------------
20102 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/alerts.cpython-312.pyc
20103 | 
20104 | 
20105 | --------------------------------------------------------------------------------
20106 | /models/misc/__pycache__/block.cpython-312.pyc:
20107 | --------------------------------------------------------------------------------
20108 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/block.cpython-312.pyc
20109 | 
20110 | 
20111 | --------------------------------------------------------------------------------
20112 | /models/misc/__pycache__/guild.cpython-312.pyc:
20113 | --------------------------------------------------------------------------------
20114 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/guild.cpython-312.pyc
20115 | 
20116 | 
20117 | --------------------------------------------------------------------------------
20118 | /models/misc/__pycache__/premium.cpython-312.pyc:
20119 | --------------------------------------------------------------------------------
20120 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/models/misc/__pycache__/premium.cpython-312.pyc
20121 | 
20122 | 
20123 | --------------------------------------------------------------------------------
20124 | /models/misc/alerts.py:
20125 | --------------------------------------------------------------------------------
20126 |  1 | from __future__ import annotations
20127 |  2 | 
20128 |  3 | from tortoise import fields
20129 |  4 | 
20130 |  5 | from models import BaseDbModel
20131 |  6 | from models.helpers import *
20132 |  7 | 
20133 |  8 | 
20134 |  9 | class Alert(BaseDbModel):
20135 | 10 |     class Meta:
20136 | 11 |         table = "alerts"
20137 | 12 | 
20138 | 13 |     id = fields.IntField(pk=True)
20139 | 14 |     author_id = fields.BigIntField()
20140 | 15 |     created_at = fields.DatetimeField(auto_now=True)
20141 | 16 |     active = fields.BooleanField(default=True)
20142 | 17 |     message = fields.JSONField(default=dict)
20143 | 18 |     conditions = ArrayField(fields.CharField(max_length=100), default=list)
20144 | 19 |     prompts: fields.ManyToManyRelation["Prompt"] = fields.ManyToManyField("models.Prompt")
20145 | 20 |     reads: fields.ManyToManyRelation["Read"] = fields.ManyToManyField("models.Read")
20146 | 21 | 
20147 | 22 | 
20148 | 23 | class Prompt(BaseDbModel):
20149 | 24 |     class Meta:
20150 | 25 |         table = "alert_prompts"
20151 | 26 | 
20152 | 27 |     id = fields.IntField(pk=True)
20153 | 28 |     user_id = fields.BigIntField()
20154 | 29 |     prompted_at = fields.DatetimeField(auto_now=True)
20155 | 30 | 
20156 | 31 | 
20157 | 32 | class Read(BaseDbModel):
20158 | 33 |     class Meta:
20159 | 34 |         table = "alert_reads"
20160 | 35 | 
20161 | 36 |     id = fields.IntField(pk=True)
20162 | 37 |     user_id = fields.BigIntField()
20163 | 38 |     read_at = fields.DatetimeField(auto_now=True)
20164 | 39 | 
20165 | 
20166 | 
20167 | --------------------------------------------------------------------------------
20168 | /models/misc/block.py:
20169 | --------------------------------------------------------------------------------
20170 |  1 | from enum import IntEnum
20171 |  2 | 
20172 |  3 | from tortoise import fields
20173 |  4 | 
20174 |  5 | from models import BaseDbModel
20175 |  6 | 
20176 |  7 | __all__ = ("BlockList", "BlockIdType")
20177 |  8 | 
20178 |  9 | 
20179 | 10 | class BlockIdType(IntEnum):
20180 | 11 |     USER = 1
20181 | 12 |     GUILD = 2
20182 | 13 | 
20183 | 14 | 
20184 | 15 | class BlockList(BaseDbModel):
20185 | 16 |     class Meta:
20186 | 17 |         table = "block_list"
20187 | 18 | 
20188 | 19 |     id = fields.IntField(pk=True)
20189 | 20 |     block_id = fields.BigIntField()
20190 | 21 |     block_id_type = fields.IntEnumField(BlockIdType)
20191 | 22 |     blocked_by = fields.BigIntField(null=True)
20192 | 23 |     reason = fields.CharField(max_length=250, null=True)
20193 | 24 |     timestamp = fields.DatetimeField(auto_now=True)
20194 | 25 | 
20195 | 
20196 | 
20197 | --------------------------------------------------------------------------------
20198 | /models/misc/guild.py:
20199 | --------------------------------------------------------------------------------
20200 |  1 | import discord
20201 |  2 | from tortoise import fields
20202 |  3 | 
20203 |  4 | import config
20204 |  5 | from models import BaseDbModel
20205 |  6 | from models.helpers import *
20206 |  7 | 
20207 |  8 | _dict = {"embed": [], "scrims": [], "tourney": [], "slotm": []}
20208 |  9 | 
20209 | 10 | 
20210 | 11 | class Guild(BaseDbModel):
20211 | 12 |     class Meta:
20212 | 13 |         table = "guild_data"
20213 | 14 | 
20214 | 15 |     guild_id = fields.BigIntField(pk=True, index=True)
20215 | 16 | 
20216 | 17 |     prefix = fields.CharField(default="q", max_length=5)
20217 | 18 |     embed_color = fields.IntField(default=65459, null=True)
20218 | 19 |     embed_footer = fields.TextField(default=config.FOOTER)
20219 | 20 | 
20220 | 21 |     tag_enabled_for_everyone = fields.BooleanField(default=True)  # ye naam maine ni rkha sachi
20221 | 22 | 
20222 | 23 |     is_premium = fields.BooleanField(default=False)
20223 | 24 |     made_premium_by = fields.BigIntField(null=True)
20224 | 25 |     premium_end_time = fields.DatetimeField(null=True)
20225 | 26 |     premium_notified = fields.BooleanField(default=False)
20226 | 27 | 
20227 | 28 |     public_profile = fields.BooleanField(default=True)  # whether to list the server on global leaderboards
20228 | 29 | 
20229 | 30 |     private_channel = fields.BigIntField(null=True)
20230 | 31 | 
20231 | 32 |     dashboard_access = fields.JSONField(default=_dict)
20232 | 33 | 
20233 | 34 |     @property
20234 | 35 |     def _guild(self) -> discord.Guild:
20235 | 36 |         return self.bot.get_guild(self.guild_id)
20236 | 37 | 
20237 | 38 |     @property
20238 | 39 |     def private_ch(self) -> discord.TextChannel:
20239 | 40 |         if (g := self._guild) is not None:
20240 | 41 |             return g.get_channel(self.private_channel)
20241 | 42 | 
20242 | 43 |     @property
20243 | 44 |     def booster(self):
20244 | 45 |         return self.bot.get_user(self.made_premium_by)
20245 | 46 | 
20246 | 
20247 | 
20248 | --------------------------------------------------------------------------------
20249 | /models/misc/premium.py:
20250 | --------------------------------------------------------------------------------
20251 |  1 | import os
20252 |  2 | from datetime import timedelta
20253 |  3 | 
20254 |  4 | from tortoise import fields
20255 |  5 | 
20256 |  6 | from models import BaseDbModel
20257 |  7 | 
20258 |  8 | __all__ = ("PremiumTxn", "PremiumPlan")
20259 |  9 | 
20260 | 10 | 
20261 | 11 | class PremiumPlan(BaseDbModel):
20262 | 12 |     class Meta:
20263 | 13 |         table = "premium_plans"
20264 | 14 | 
20265 | 15 |     id = fields.IntField(pk=True)
20266 | 16 |     name = fields.CharField(max_length=50)
20267 | 17 |     description = fields.CharField(max_length=250, null=True)
20268 | 18 |     price = fields.IntField()
20269 | 19 |     duration = fields.TimeDeltaField()
20270 | 20 | 
20271 | 21 |     @staticmethod
20272 | 22 |     async def insert_plans():
20273 | 23 |         await PremiumPlan.all().delete()
20274 | 24 |         await PremiumPlan.create(name="Trial (7d)", description="Duration: 7 days", price=29, duration=timedelta(days=7))
20275 | 25 |         await PremiumPlan.create(
20276 | 26 |             name="Basic (1m)", description="Duration: 28 days", price=79, duration=timedelta(days=28)
20277 | 27 |         )
20278 | 28 |         await PremiumPlan.create(
20279 | 29 |             name="Professional (3m)", description="Duration: 84 days", price=229, duration=timedelta(days=84)
20280 | 30 |         )
20281 | 31 |         await PremiumPlan.create(
20282 | 32 |             name="Enterprise (6m)", description="Duration: 168 days", price=469, duration=timedelta(days=168)
20283 | 33 |         )
20284 | 34 |         await PremiumPlan.create(
20285 | 35 |             name="GodLike (Lifetime)", description="Duration: 69 years", price=4999, duration=timedelta(days=25185)
20286 | 36 |         )
20287 | 37 | 
20288 | 38 | 
20289 | 39 | class PremiumTxn(BaseDbModel):
20290 | 40 |     class Meta:
20291 | 41 |         table = "premium_txns"
20292 | 42 | 
20293 | 43 |     id = fields.IntField(pk=True)
20294 | 44 |     txnid = fields.CharField(max_length=100)
20295 | 45 |     user_id = fields.BigIntField()
20296 | 46 |     guild_id = fields.BigIntField()
20297 | 47 |     plan_id = fields.IntField()
20298 | 48 | 
20299 | 49 |     created_at = fields.DatetimeField(auto_now=True)
20300 | 50 |     completed_at = fields.DatetimeField(null=True)
20301 | 51 |     raw_data = fields.JSONField(default=dict)
20302 | 52 | 
20303 | 53 |     @staticmethod
20304 | 54 |     async def gen_txnid() -> str:
20305 | 55 |         txnid = None
20306 | 56 | 
20307 | 57 |         while txnid == None:
20308 | 58 |             _id = "QP_" + os.urandom(16).hex()
20309 | 59 |             if not await PremiumTxn.filter(txnid=_id).exists():
20310 | 60 |                 txnid = _id
20311 | 61 | 
20312 | 62 |         return txnid
20313 | 63 | 
20314 | 
20315 | 
20316 | --------------------------------------------------------------------------------
20317 | /requirements.txt:
20318 | --------------------------------------------------------------------------------
20319 |  1 | git+https://github.com/Rapptz/discord.py.git
20320 |  2 | tortoise-orm
20321 |  3 | colorama
20322 |  4 | asyncpg
20323 |  5 | dateparser
20324 |  6 | aerich
20325 |  7 | parsedatetime
20326 |  8 | Pillow
20327 |  9 | mystbin.py
20328 | 10 | prettytable
20329 | 11 | psutil
20330 | 12 | PyNaCl
20331 | 13 | Quart
20332 | 14 | requests
20333 | 15 | dblpy
20334 | 16 | jishaku
20335 | 17 | humanize
20336 | 18 | pygit2
20337 | 19 | async-property
20338 | 20 | colour
20339 | 21 | imgkit
20340 | 22 | aiocache
20341 | 23 | ujson
20342 | 24 | ImageHash
20343 | 25 | pytesseract
20344 | 26 | python-socketio
20345 | 27 | aiohttp-asgi
20346 | 28 | fastapi
20347 | 29 | python-multipart
20348 | 30 | lru-dict
20349 | 31 | pypika
20350 | 32 | 
20351 | 
20352 | 
20353 | --------------------------------------------------------------------------------
20354 | /server/__init__.py:
20355 | --------------------------------------------------------------------------------
20356 |  1 | from __future__ import annotations
20357 |  2 | 
20358 |  3 | import typing as T
20359 |  4 | 
20360 |  5 | if T.TYPE_CHECKING:
20361 |  6 |     from core import Quotient
20362 |  7 | 
20363 |  8 | from aiohttp import web
20364 |  9 | from aiohttp_asgi import ASGIResource
20365 | 10 | from discord.ext.commands import Cog
20366 | 11 | 
20367 | 12 | import config
20368 | 13 | 
20369 | 14 | from .app import fastapi_app
20370 | 15 | 
20371 | 16 | 
20372 | 17 | class ApiServer(Cog):
20373 | 18 |     app: web.Application
20374 | 19 |     app_started: bool = False
20375 | 20 |     webserver: web.TCPSite
20376 | 21 | 
20377 | 22 |     def __init__(self, bot: Quotient):
20378 | 23 |         self.bot = bot
20379 | 24 | 
20380 | 25 |     async def cog_load(self) -> None:
20381 | 26 |         self.app, self.webserver = await self.init_application()
20382 | 27 |         self.app_started = True
20383 | 28 | 
20384 | 29 |     async def cog_unload(self) -> None:
20385 | 30 |         if self.app_started:
20386 | 31 |             print("[Server] Closing...")
20387 | 32 |             await self.webserver.stop()
20388 | 33 |             await self.app.shutdown()
20389 | 34 |             await self.app.cleanup()
20390 | 35 | 
20391 | 36 |     async def init_application(self) -> T.Tuple[web.Application, web.TCPSite]:
20392 | 37 |         aiohttp_app = web.Application()
20393 | 38 |         asgi_resource = ASGIResource(fastapi_app, root_path="")  # type: ignore
20394 | 39 |         aiohttp_app.router.register_resource(asgi_resource)
20395 | 40 | 
20396 | 41 |         runner = web.AppRunner(app=aiohttp_app)
20397 | 42 |         await runner.setup()
20398 | 43 |         webserver = web.TCPSite(runner, "0.0.0.0", config.SERVER_PORT)
20399 | 44 |         await webserver.start()
20400 | 45 |         print("[Server] Asgi server started")
20401 | 46 |         return aiohttp_app, webserver
20402 | 47 | 
20403 | 48 | 
20404 | 49 | async def setup(bot: Quotient):
20405 | 50 |     await bot.add_cog(ApiServer(bot))
20406 | 51 | 
20407 | 
20408 | 
20409 | --------------------------------------------------------------------------------
20410 | /server/app/__init__.py:
20411 | --------------------------------------------------------------------------------
20412 |  1 | from fastapi import FastAPI
20413 |  2 | 
20414 |  3 | fastapi_app = FastAPI()
20415 |  4 | 
20416 |  5 | 
20417 |  6 | @fastapi_app.get("/")
20418 |  7 | async def root():
20419 |  8 |     return {"ping": "pong"}
20420 |  9 | 
20421 | 10 | 
20422 | 11 | from .payment import router as payment_router
20423 | 12 | 
20424 | 13 | fastapi_app.include_router(payment_router)
20425 | 14 | 
20426 | 
20427 | 
20428 | --------------------------------------------------------------------------------
20429 | /server/app/payment.py:
20430 | --------------------------------------------------------------------------------
20431 |   1 | import hashlib
20432 |   2 | from datetime import datetime
20433 |   3 | 
20434 |   4 | from fastapi import APIRouter, Request
20435 |   5 | from fastapi.templating import Jinja2Templates
20436 |   6 | 
20437 |   7 | import config
20438 |   8 | import constants
20439 |   9 | from models import ArrayAppend, Guild, PremiumPlan, PremiumTxn, User
20440 |  10 | 
20441 |  11 | router = APIRouter()
20442 |  12 | template = Jinja2Templates(directory="src/server/templates")
20443 |  13 | 
20444 |  14 | 
20445 |  15 | def create_hash(txnId: str, amount: str, productInfo: str, firstName: str, email: str):
20446 |  16 |     # sha512(key|txnid|amount|productinfo|firstname|email|udf1|udf2|udf3|udf4|udf5||||||salt)
20447 |  17 | 
20448 |  18 |     return hashlib.sha512(
20449 |  19 |         f"{config.PAYU_KEY}|{txnId}|{amount}|{productInfo}|{firstName}|{email}|||||||||||{config.PAYU_SALT}".encode(
20450 |  20 |             "utf-8"
20451 |  21 |         )
20452 |  22 |     ).hexdigest()
20453 |  23 | 
20454 |  24 | 
20455 |  25 | @router.get("/getpremium")
20456 |  26 | async def get_premium(request: Request, txnId: str):
20457 |  27 |     record = await PremiumTxn.get_or_none(txnid=txnId)
20458 |  28 | 
20459 |  29 |     if not record:
20460 |  30 |         return {"error": "Invalid Transaction ID"}
20461 |  31 | 
20462 |  32 |     if record.completed_at:
20463 |  33 |         return {"error": "Transaction already completed"}
20464 |  34 | 
20465 |  35 |     plan = await PremiumPlan.get(pk=record.plan_id)
20466 |  36 | 
20467 |  37 |     payu_hash = create_hash(txnId, plan.price, "premium", record.user_id, "abcd@gmail.com")
20468 |  38 | 
20469 |  39 |     data = {
20470 |  40 |         "key": config.PAYU_KEY,
20471 |  41 |         "txnid": txnId,
20472 |  42 |         "amount": plan.price,
20473 |  43 |         "productinfo": "premium",
20474 |  44 |         "firstname": record.user_id,
20475 |  45 |         "email": "abcd@gmail.com",
20476 |  46 |         "surl": f"{config.SUCCESS_URL}{txnId}",
20477 |  47 |         "furl": f"{config.FAILED_URL}{txnId}",
20478 |  48 |         "phone": "9999999999",
20479 |  49 |         "action": config.PAYU_PAYMENT_LINK,
20480 |  50 |         "hash": payu_hash,
20481 |  51 |     }
20482 |  52 | 
20483 |  53 |     return template.TemplateResponse("payu.html", {"request": request, "posted": data})
20484 |  54 | 
20485 |  55 | 
20486 |  56 | @router.post("/premium_success")
20487 |  57 | async def premium_success(request: Request, txnId: str):
20488 |  58 |     from core import bot
20489 |  59 | 
20490 |  60 |     try:
20491 |  61 |         form = await request.form()
20492 |  62 |     except:
20493 |  63 |         return {"error": "Invalid Request."}
20494 |  64 | 
20495 |  65 |     if not "payu" in request.headers.get("origin"):
20496 |  66 |         return {"error": "Invalid Request Origin."}
20497 |  67 | 
20498 |  68 |     if not form.get("status") == "success":
20499 |  69 |         return {"error": f"Transaction Status: {form.get('status')}"}
20500 |  70 | 
20501 |  71 |     record = await PremiumTxn.get_or_none(txnid=txnId)
20502 |  72 |     if not record:
20503 |  73 |         return {"error": "Transaction Id is invalid."}
20504 |  74 | 
20505 |  75 |     if record.completed_at:
20506 |  76 |         return {"error": "Transaction is already complete."}
20507 |  77 | 
20508 |  78 |     await PremiumTxn.get(txnid=txnId).update(raw_data=dict(form), completed_at=datetime.now(constants.IST))
20509 |  79 |     u, b = await User.get_or_create(user_id=record.user_id)
20510 |  80 |     plan = await PremiumPlan.get(pk=record.plan_id)
20511 |  81 | 
20512 |  82 |     end_time = u.premium_expire_time + plan.duration if u.is_premium else datetime.now(constants.IST) + plan.duration
20513 |  83 | 
20514 |  84 |     await User.get(pk=u.pk).update(is_premium=True, premium_expire_time=end_time)
20515 |  85 |     await User.get(pk=u.user_id).update(made_premium=ArrayAppend("made_premium", u.user_id))
20516 |  86 | 
20517 |  87 |     bot.dispatch("premium_purchase", record.txnid)
20518 |  88 | 
20519 |  89 |     guild = await Guild.get(pk=record.guild_id)
20520 |  90 |     end_time = guild.premium_end_time + plan.duration if guild.is_premium else datetime.now(constants.IST) + plan.duration
20521 |  91 |     await Guild.get(pk=guild.pk).update(is_premium=True, premium_end_time=end_time, made_premium_by=u.user_id)
20522 |  92 | 
20523 |  93 |     return {"success": "Transaction was successful. Please return to discord App."}
20524 |  94 | 
20525 |  95 | 
20526 |  96 | @router.post("/premium_failed")
20527 |  97 | async def premium_failed(request: Request, txnId: str):
20528 |  98 |     try:
20529 |  99 |         form = await request.form()
20530 | 100 |     except:
20531 | 101 |         return {"error": "Invalid Request."}
20532 | 102 | 
20533 | 103 |     if not "payu" in request.headers.get("origin"):
20534 | 104 |         return {"error": "Invalid Request Origin."}
20535 | 105 | 
20536 | 106 |     await PremiumTxn.get(txnid=txnId).update(completed_at=datetime.now(constants.IST), raw_data=dict(form))
20537 | 107 | 
20538 | 108 |     return {"error": "Transaction Cancelled."}
20539 | 109 | 
20540 | 
20541 | 
20542 | --------------------------------------------------------------------------------
20543 | /server/templates/payu.html:
20544 | --------------------------------------------------------------------------------
20545 |  1 | <html>
20546 |  2 |     <head>
20547 |  3 |         <title>Loading...</title>
20548 |  4 |     </head>
20549 |  5 |   
20550 |  6 |     <body onload="document.payuForm.submit()">
20551 |  7 |         <form action={{ posted.action }} method="post" name="payuForm">
20552 |  8 |             <input type="hidden" name="key" value="{{posted.key}}" />
20553 |  9 |             <input type="hidden" name="hash" value="{{ posted.hash }}" />
20554 | 10 |             <input type="hidden" name="txnid" value="{{ posted.txnid }}" />
20555 | 11 | 
20556 | 12 |             <input type="hidden" name="productinfo" value="{{ posted.productinfo }}" />
20557 | 13 | 
20558 | 14 |             <input type="hidden" name="amount" value="{{ posted.amount }}" /></td>
20559 | 15 |             <input type="hidden" name="firstname" id="firstname" value="{{ posted.firstname }}" /></td>
20560 | 16 |             <input type="hidden" name="email" id="email" value="{{ posted.email}}" /></td>
20561 | 17 | 
20562 | 18 |             <input type="hidden" name="surl" value="{{ posted.surl }}" size="64" /></td>
20563 | 19 |             <input type="hidden" name="furl" value="{{ posted.furl }}" size="64" /></td>
20564 | 20 | 
20565 | 21 |         </form>
20566 | 22 |     </body>
20567 | 23 |     </html>
20568 | 
20569 | 
20570 | --------------------------------------------------------------------------------
20571 | /server/templates/response.html:
20572 | --------------------------------------------------------------------------------
20573 |  1 | <!DOCTYPE html>
20574 |  2 | <html lang="en">
20575 |  3 | 
20576 |  4 | <head>
20577 |  5 |     <meta charset="UTF-8">
20578 |  6 |     <meta name="viewport" content="width=device-width, initial-scale=1.0">
20579 |  7 |     <title>Payment Response</title>
20580 |  8 |     <style>
20581 |  9 |         body {
20582 | 10 |             font-family: Arial, sans-serif;
20583 | 11 |             display: flex;
20584 | 12 |             background-color: #222;
20585 | 13 |             justify-content: center;
20586 | 14 |             align-items: center;
20587 | 15 |             height: 100vh;
20588 | 16 |             margin: 0;
20589 | 17 |         }
20590 | 18 | 
20591 | 19 |         .container {
20592 | 20 |             background-color: black;
20593 | 21 |             padding: 20px;
20594 | 22 |             text-align: center;
20595 | 23 |             border-radius: 30px;
20596 | 24 |         }
20597 | 25 | 
20598 | 26 |         .success-message {
20599 | 27 |             color: #00ffb3;
20600 | 28 |         }
20601 | 29 | 
20602 | 30 |         .error-message {
20603 | 31 |             color: #e74c3c;
20604 | 32 |         }
20605 | 33 |         p{
20606 | 34 |             color: white    ;
20607 | 35 |         }
20608 | 36 |         img{
20609 | 37 |             height: 70px;
20610 | 38 |             width: 70px;
20611 | 39 |         }
20612 | 40 | 
20613 | 41 |     </style>
20614 | 42 | </head>
20615 | 43 | 
20616 | 44 | <body>
20617 | 45 |     <div class="container">
20618 | 46 |         {% if success %}
20619 | 47 |         <h1 class="success-message">Transaction was Successful!</h1>
20620 | 48 |         <img src="https://quotientbot.xyz/static/media/favicon.b181bf099887fa60b39b.png">
20621 | 49 |         <p>Please return to the Discord App.</p>
20622 | 50 |         {% else %}
20623 | 51 |         <h1 class="error-message">An Error occurred during the Transaction.</h1>
20624 | 52 |         <img src="https://quotientbot.xyz/static/media/favicon.b181bf099887fa60b39b.png">
20625 | 53 |         <p>Please try again later or contact support.</p>
20626 | 54 |         {% endif %}
20627 | 55 |     </div>
20628 | 56 | </body>
20629 | 57 | 
20630 | 58 | </html>
20631 | 59 | 
20632 | 
20633 | 
20634 | --------------------------------------------------------------------------------
20635 | /sockets/__init__.py:
20636 | --------------------------------------------------------------------------------
20637 |  1 | from __future__ import annotations
20638 |  2 | 
20639 |  3 | import typing
20640 |  4 | 
20641 |  5 | if typing.TYPE_CHECKING:
20642 |  6 |     from core import Quotient
20643 |  7 | 
20644 |  8 | from socketio import AsyncClient
20645 |  9 | 
20646 | 10 | from core import Cog
20647 | 11 | 
20648 | 12 | from .app import sio
20649 | 13 | from .events import DashboardGate, SocketScrims, SockGuild, SockPrime, SockSettings
20650 | 14 | 
20651 | 15 | 
20652 | 16 | class SocketConnection(Cog):
20653 | 17 |     connected: bool = False
20654 | 18 |     sio: AsyncClient
20655 | 19 | 
20656 | 20 |     def __init__(self, bot: Quotient):
20657 | 21 |         self.bot = bot
20658 | 22 |         self.task = self.bot.loop.create_task(self.__make_connection())
20659 | 23 | 
20660 | 24 |     def cog_unload(self) -> None:
20661 | 25 |         self.bot.loop.create_task(self.__close_connection())
20662 | 26 | 
20663 | 27 |     async def __make_connection(self):
20664 | 28 |         await sio.connect(self.bot.config.SOCKET_URL, auth={"token": self.bot.config.SOCKET_AUTH})
20665 | 29 | 
20666 | 30 |         sio.bot, self.bot.sio = self.bot, sio
20667 | 31 |         self.connected = True
20668 | 32 | 
20669 | 33 |     async def __close_connection(self):
20670 | 34 |         if self.connected:
20671 | 35 |             await sio.disconnect()
20672 | 36 |             self.connected = False
20673 | 37 | 
20674 | 38 | 
20675 | 39 | async def setup(bot: Quotient):
20676 | 40 |     await bot.add_cog(SocketConnection(bot))
20677 | 41 |     await bot.add_cog(DashboardGate(bot))
20678 | 42 |     await bot.add_cog(SocketScrims(bot))
20679 | 43 |     await bot.add_cog(SockSettings(bot))
20680 | 44 |     await bot.add_cog(SockPrime(bot))
20681 | 45 |     await bot.add_cog(SockGuild(bot))
20682 | 46 | 
20683 | 
20684 | 
20685 | --------------------------------------------------------------------------------
20686 | /sockets/app/__init__.py:
20687 | --------------------------------------------------------------------------------
20688 | 1 | from .app import sio
20689 | 2 | 
20690 | 
20691 | 
20692 | --------------------------------------------------------------------------------
20693 | /sockets/app/app.py:
20694 | --------------------------------------------------------------------------------
20695 |  1 | from __future__ import annotations
20696 |  2 | 
20697 |  3 | import typing
20698 |  4 | 
20699 |  5 | if typing.TYPE_CHECKING:
20700 |  6 |     from core import Quotient
20701 |  7 | 
20702 |  8 | import socketio
20703 |  9 | 
20704 | 10 | 
20705 | 11 | class QuoSocket(socketio.AsyncClient):
20706 | 12 |     bot: Quotient
20707 | 13 | 
20708 | 14 |     def __init__(self, **kwargs):
20709 | 15 |         super().__init__(**kwargs)
20710 | 16 | 
20711 | 17 |     async def emit(self, event, data=None, namespace=None, callback=None):
20712 | 18 |         return await super().emit("response__" + event, data=data, namespace=namespace, callback=callback)
20713 | 19 | 
20714 | 20 |     async def request(self, event, data=None, namespace=None, callback=None):
20715 | 21 |         return await super().emit(event, data=data, namespace=namespace, callback=callback)
20716 | 22 | 
20717 | 23 |     @staticmethod
20718 | 24 |     def int_parse(data):
20719 | 25 |         if not isinstance(data, dict):
20720 | 26 |             return data
20721 | 27 | 
20722 | 28 |         for x, y in data.items():
20723 | 29 |             if isinstance(y, str) and y.isdigit():
20724 | 30 |                 data[x] = int(y)
20725 | 31 | 
20726 | 32 |         return data
20727 | 33 | 
20728 | 34 | 
20729 | 35 | sio = QuoSocket(logger=True, engineio_logger=True)
20730 | 36 | ignored = ("update_total_votes", "update_votes_leaderboard")
20731 | 37 | 
20732 | 38 | 
20733 | 39 | @sio.on("*")
20734 | 40 | async def catch_all(event, data):
20735 | 41 |     if event in ignored:
20736 | 42 |         return
20737 | 43 | 
20738 | 44 |     data = QuoSocket.int_parse(data)
20739 | 45 | 
20740 | 46 |     r, e, u = event.split("__")
20741 | 47 |     data["user__id"] = u
20742 | 48 |     sio.bot.dispatch(r + "__" + e, u, data)
20743 | 49 | 
20744 | 
20745 | 
20746 | --------------------------------------------------------------------------------
20747 | /sockets/events/__init__.py:
20748 | --------------------------------------------------------------------------------
20749 | 1 | from .dashgate import *  # noqa: F401, F403
20750 | 2 | from .guilds import *  # noqa: F401, F403
20751 | 3 | from .premium import *  # noqa: F401, F403
20752 | 4 | from .scrims import *  # noqa: F401, F403
20753 | 5 | from .settings import *  # noqa: F401, F403
20754 | 6 | 
20755 | 
20756 | 
20757 | --------------------------------------------------------------------------------
20758 | /sockets/events/dashgate.py:
20759 | --------------------------------------------------------------------------------
20760 |  1 | from __future__ import annotations
20761 |  2 | 
20762 |  3 | from typing import TYPE_CHECKING
20763 |  4 | 
20764 |  5 | if TYPE_CHECKING:
20765 |  6 |     from core import Quotient
20766 |  7 | 
20767 |  8 | from core import Cog
20768 |  9 | from models import Guild
20769 | 10 | 
20770 | 11 | __all__ = ("DashboardGate",)
20771 | 12 | 
20772 | 13 | 
20773 | 14 | class DashboardGate(Cog):
20774 | 15 |     def __init__(self, bot: Quotient):
20775 | 16 |         self.bot = bot
20776 | 17 | 
20777 | 18 |     @Cog.listener()
20778 | 19 |     async def on_request__latency(self, u, data):
20779 | 20 |         return await self.bot.sio.emit("latency__{0}".format(u), {})
20780 | 21 | 
20781 | 22 |     @Cog.listener()
20782 | 23 |     async def on_request__guild_permissions(self, u, data):
20783 | 24 |         guild_ids = data["guild_ids"]
20784 | 25 |         user_id = data["user_id"]
20785 | 26 | 
20786 | 27 |         result = {}
20787 | 28 | 
20788 | 29 |         for guild_id in guild_ids:
20789 | 30 |             guild_id = int(guild_id)
20790 | 31 | 
20791 | 32 |             guild = self.bot.get_guild(guild_id)
20792 | 33 |             if not guild:
20793 | 34 |                 result[guild_id] = -1
20794 | 35 |                 continue
20795 | 36 | 
20796 | 37 |             if not guild.chunked:
20797 | 38 |                 self.bot.loop.create_task(guild.chunk())
20798 | 39 | 
20799 | 40 |             member = await self.bot.get_or_fetch_member(guild, user_id)
20800 | 41 |             if not member:
20801 | 42 |                 result[guild_id] = -1
20802 | 43 |                 continue
20803 | 44 | 
20804 | 45 |             perms = 1
20805 | 46 | 
20806 | 47 |             if member.guild_permissions.manage_guild:
20807 | 48 |                 result[guild_id] = 2
20808 | 49 |                 continue
20809 | 50 | 
20810 | 51 |             g_record = await Guild.get(pk=guild_id)
20811 | 52 |             _roles = [str(_.id) for _ in member.roles]
20812 | 53 | 
20813 | 54 |             if any(i in g_record.dashboard_access["embed"] for i in _roles):
20814 | 55 |                 perms *= 3
20815 | 56 | 
20816 | 57 |             if any(i in g_record.dashboard_access["scrims"] for i in _roles):
20817 | 58 |                 perms *= 5
20818 | 59 | 
20819 | 60 |             if any(i in g_record.dashboard_access["tourney"] for i in _roles):
20820 | 61 |                 perms *= 7
20821 | 62 | 
20822 | 63 |             if any(i in g_record.dashboard_access["slotm"] for i in _roles):
20823 | 64 |                 perms *= 11
20824 | 65 | 
20825 | 66 |             result[guild_id] = perms
20826 | 67 | 
20827 | 68 |         await self.bot.sio.emit(f"guild_permissions__{u}", result)
20828 | 69 | 
20829 | 
20830 | 
20831 | --------------------------------------------------------------------------------
20832 | /sockets/events/guilds.py:
20833 | --------------------------------------------------------------------------------
20834 |  1 | from __future__ import annotations
20835 |  2 | 
20836 |  3 | import typing as T
20837 |  4 | 
20838 |  5 | import discord
20839 |  6 | 
20840 |  7 | if T.TYPE_CHECKING:
20841 |  8 |     from core import Quotient
20842 |  9 | 
20843 | 10 | from core import Cog
20844 | 11 | from models import Guild
20845 | 12 | 
20846 | 13 | from ..schemas import QGuild
20847 | 14 | 
20848 | 15 | __all__ = ("SockGuild",)
20849 | 16 | 
20850 | 17 | 
20851 | 18 | class SockGuild(Cog):
20852 | 19 |     def __init__(self, bot: Quotient):
20853 | 20 |         self.bot = bot
20854 | 21 | 
20855 | 22 |     @Cog.listener()
20856 | 23 |     async def on_request__get_guilds(self, u, data: dict):
20857 | 24 |         guild_ids = data["guild_ids"]
20858 | 25 |         user_id = data["user_id"]
20859 | 26 | 
20860 | 27 |         results: T.Dict[str, T.List[QGuild]] = {}
20861 | 28 | 
20862 | 29 |         for _id in guild_ids:
20863 | 30 |             guild = self.bot.get_guild(int(_id))
20864 | 31 |             if not guild:
20865 | 32 |                 continue
20866 | 33 | 
20867 | 34 |             member = await self.bot.get_or_fetch_member(guild, user_id)
20868 | 35 |             if not member:
20869 | 36 |                 continue
20870 | 37 | 
20871 | 38 |             results[str(_id)] = (await QGuild.from_guild(guild, await self.__guild_permissions(guild, member))).dict()
20872 | 39 | 
20873 | 40 |         await self.bot.sio.emit("get_guilds__{0}".format(u), results)
20874 | 41 | 
20875 | 42 |     async def __guild_permissions(self, guild: discord.Guild, user: discord.Member):
20876 | 43 |         perms = 1
20877 | 44 | 
20878 | 45 |         if user.guild_permissions.manage_guild:
20879 | 46 |             return 2
20880 | 47 | 
20881 | 48 |         g = await Guild.get(pk=guild.id)
20882 | 49 |         _roles = [str(_.id) for _ in user.roles]
20883 | 50 | 
20884 | 51 |         if any(i in g.dashboard_access["embed"] for i in _roles):
20885 | 52 |             perms *= 3
20886 | 53 | 
20887 | 54 |         if any(i in g.dashboard_access["scrims"] for i in _roles):
20888 | 55 |             perms *= 5
20889 | 56 | 
20890 | 57 |         if any(i in g.dashboard_access["tourney"] for i in _roles):
20891 | 58 |             perms *= 7
20892 | 59 | 
20893 | 60 |         if any(i in g.dashboard_access["slotm"] for i in _roles):
20894 | 61 |             perms *= 11
20895 | 62 | 
20896 | 63 |         return perms
20897 | 64 | 
20898 | 
20899 | 
20900 | --------------------------------------------------------------------------------
20901 | /sockets/events/premium.py:
20902 | --------------------------------------------------------------------------------
20903 |   1 | from __future__ import annotations
20904 |   2 | 
20905 |   3 | import typing as T
20906 |   4 | from contextlib import suppress
20907 |   5 | 
20908 |   6 | if T.TYPE_CHECKING:
20909 |   7 |     from core import Quotient
20910 |   8 | 
20911 |   9 | import discord
20912 |  10 | 
20913 |  11 | from constants import random_greeting, random_thanks
20914 |  12 | from core import Cog
20915 |  13 | 
20916 |  14 | __all__ = ("SockPrime",)
20917 |  15 | 
20918 |  16 | 
20919 |  17 | class SockPrime(Cog):
20920 |  18 |     def __init__(self, bot: Quotient):
20921 |  19 |         self.bot = bot
20922 |  20 |         self.hook = discord.Webhook.from_url(self.bot.config.PUBLIC_LOG, session=self.bot.session)
20923 |  21 | 
20924 |  22 |     @Cog.listener()
20925 |  23 |     async def on_request__perks(self, u, data):
20926 |  24 |         return await self.bot.sio.emit(
20927 |  25 |             f"perks__{u}",
20928 |  26 |             [
20929 |  27 |                 "Unlimited Scrims (3 for free)",
20930 |  28 |                 "Unlimited tournaments (1 for free)",
20931 |  29 |                 "Remind Me & Transfer Id-Pass button in Scrims Slotm.",
20932 |  30 |                 "Unlimited tagcheck and easytag channels.",
20933 |  31 |                 "Custom reactions for tourney and scrims.",
20934 |  32 |                 "Unlimited media partner channels.",
20935 |  33 |                 "Unlimited ssverification channels.",
20936 |  34 |                 "Premium role in our server + several other benefits...",
20937 |  35 |             ],
20938 |  36 |         )
20939 |  37 | 
20940 |  38 |     @Cog.listener()
20941 |  39 |     async def on_request__new_premium(self, u, data: dict):
20942 |  40 |         await self.bot.sio.emit("new_premium__{0}".format(u), {})
20943 |  41 | 
20944 |  42 |         if not data.get("is_verified"):
20945 |  43 |             return await self.__transaction_failed(int(u))
20946 |  44 | 
20947 |  45 |         user_id = int(u)
20948 |  46 |         invoice = data["invoice_link"]
20949 |  47 | 
20950 |  48 |         prime = "https://discord.com/oauth2/authorize?client_id=902856923311919104&scope=applications.commands%20bot&permissions=536737213566"
20951 |  49 | 
20952 |  50 |         member = await self.bot.get_or_fetch_member(self.bot.server, user_id)
20953 |  51 |         if member is not None:
20954 |  52 |             await member.add_roles(discord.Object(id=self.bot.config.PREMIUM_ROLE), reason="They purchased premium.")
20955 |  53 | 
20956 |  54 |         else:
20957 |  55 |             member = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, user_id)
20958 |  56 | 
20959 |  57 |         _e = discord.Embed(color=self.bot.color)
20960 |  58 |         _e.description = (
20961 |  59 |             f"{random_greeting()} {member.mention},\n"
20962 |  60 |             "Thanks for purchasing Quotient Premium.\n\n"
20963 |  61 |             f"[Invite Quotient Pro]({prime}) | [Support Server]({self.bot.config.SERVER_LINK}) | [Download Invoice]({invoice})"
20964 |  62 |         )
20965 |  63 | 
20966 |  64 |         _e.set_image(url=random_thanks())
20967 |  65 | 
20968 |  66 |         try:
20969 |  67 |             await member.send(embed=_e)
20970 |  68 |         except discord.HTTPException:
20971 |  69 |             pass
20972 |  70 | 
20973 |  71 |         finally:
20974 |  72 |             _e = discord.Embed(
20975 |  73 |                 color=discord.Color.gold(), description=f"Thanks **{member}** for purchasing Quotient Premium."
20976 |  74 |             )
20977 |  75 |             _e.set_image(url=random_thanks())
20978 |  76 |             await self.hook.send(embed=_e, username="premium-logs", avatar_url=self.bot.config.PREMIUM_AVATAR)
20979 |  77 | 
20980 |  78 |             # if data["details"]["amount"] != "29.00":
20981 |  79 |             #     await self.give_rilp_premium(member)
20982 |  80 | 
20983 |  81 |     async def __transaction_failed(self, user_id: int) -> None:
20984 |  82 |         ...
20985 |  83 | 
20986 |  84 |     # async def give_rilp_premium(self, member: discord.Member | discord.User) -> None:
20987 |  85 | 
20988 |  86 |     #     async with self.bot.session.post(
20989 |  87 |     #         self.bot.config.RILP_PREMIUM,
20990 |  88 |     #         headers=self.bot.config.RILP_HEADERS,
20991 |  89 |     #         json={"userId": str(member.id), "subscriptionId": "Q_{}".format(self.bot.current_time.timestamp())},
20992 |  90 |     #     ) as res:
20993 |  91 |     #         if not res.status == 200:
20994 |  92 |     #             return
20995 |  93 | 
20996 |  94 |     #         res = await res.json()
20997 |  95 |     #         _f = discord.Embed(color=self.bot.color, title="Quotient x RILP BOT", url=self.bot.config.SERVER_LINK)
20998 |  96 |     #         _f.description = (
20999 |  97 |     #             "Quotient has partnered with Rilp Bot, a multipurpose bot that features Automoderation, "
21000 |  98 |     #             "Invite Tracking, Starboard, Welcome and Leave messages, Giveaways, Polls, Moderation, "
21001 |  99 |     #             "Captcha Security, and much more.\n\n"
21002 | 100 |     #             "With this Quotient Pro purchase, you have received **Rilp Bot Premium (30 days)**"
21003 | 101 |     #             "\n\n__Please follow these steps:__\n"
21004 | 102 |     #             "➜ Head over to dashboard <https://rilp-bot.tech>\n"
21005 | 103 |     #             "➜ Login with your discord account from which you bought Quotient Pro.\n"
21006 | 104 |     #             "➜ Click on the dropdown beside avatar and then head over to `Manage Subscription`\n"
21007 | 105 |     #             "➜ Click on 'Select Server' and choose your server to activate premium.\n\n"
21008 | 106 |     #             "To Invite RILP BOT - <https://rilp-bot.tech/invite>\n"
21009 | 107 |     #             "Dashboard - https://rilp-bot.tech\n"
21010 | 108 |     #             "Support Server - <https://rilp-bot.tech/support>\n"
21011 | 109 |     #         )
21012 | 110 | 
21013 | 111 |     #         _f.set_image(
21014 | 112 |     #             url="https://cdn.discordapp.com/attachments/1001770455016935536/1002246506981625947/rilpxquotient.jpg"
21015 | 113 |     #         )
21016 | 114 |     #         try:
21017 | 115 |     #             await member.send(embed=_f)
21018 | 116 | 
21019 | 117 |     #         except discord.Forbidden:
21020 | 118 |     #             return
21021 | 119 | 
21022 | 
21023 | 
21024 | --------------------------------------------------------------------------------
21025 | /sockets/events/scrims.py:
21026 | --------------------------------------------------------------------------------
21027 |  1 | from __future__ import annotations
21028 |  2 | 
21029 |  3 | import typing
21030 |  4 | 
21031 |  5 | if typing.TYPE_CHECKING:
21032 |  6 |     from core import Quotient
21033 |  7 | 
21034 |  8 | from core import Cog
21035 |  9 | from models import Scrim
21036 | 10 | 
21037 | 11 | from ..schemas import BaseScrim, SockResponse
21038 | 12 | 
21039 | 13 | __all__ = ("SocketScrims",)
21040 | 14 | 
21041 | 15 | 
21042 | 16 | class SocketScrims(Cog):
21043 | 17 |     def __init__(self, bot: Quotient):
21044 | 18 |         self.bot = bot
21045 | 19 | 
21046 | 20 |     @Cog.listener()
21047 | 21 |     async def on_request__bot_scrim_create(self, u: str, data: dict):
21048 | 22 |         data: BaseScrim = BaseScrim(**data)
21049 | 23 | 
21050 | 24 |         _v = await data.validate_perms(self.bot)
21051 | 25 | 
21052 | 26 |         if all(_v):
21053 | 27 |             _v = await data.create_scrim(self.bot)
21054 | 28 | 
21055 | 29 |         if not all(_v):
21056 | 30 |             return await self.bot.sio.emit("bot_scrim_create__{0}".format(u), SockResponse(ok=False, error=_v[1]).dict())
21057 | 31 | 
21058 | 32 |         await self.bot.sio.emit("bot_scrim_create__{0}".format(u), SockResponse(data={"id": _v[1].id}).dict())
21059 | 33 | 
21060 | 34 |     @Cog.listener()
21061 | 35 |     async def on_request__bot_scrim_edit(self, u: str, data: dict):
21062 | 36 |         data: BaseScrim = BaseScrim(**data)
21063 | 37 | 
21064 | 38 |         _v = await data.validate_perms(self.bot)
21065 | 39 | 
21066 | 40 |         if not all(_v):
21067 | 41 |             return await self.bot.sio.emit("bot_scrim_edit__{0}".format(u), SockResponse(ok=False, error=_v[1]).dict())
21068 | 42 | 
21069 | 43 |         await data.update_scrim(self.bot)
21070 | 44 |         await self.bot.sio.emit(f"bot_scrim_edit__{u}", SockResponse().dict())
21071 | 45 | 
21072 | 46 |     @Cog.listener()
21073 | 47 |     async def on_request__bot_scrim_delete(self, u: str, data: dict):
21074 | 48 |         guild_id, scrim_id = data["guild_id"], data["scrim_id"]
21075 | 49 |         if scrim_id:
21076 | 50 |             scrim = await Scrim.get_or_none(pk=scrim_id)
21077 | 51 |             if scrim:
21078 | 52 |                 await scrim.full_delete()
21079 | 53 | 
21080 | 54 |         else:
21081 | 55 |             scrims = await Scrim.filter(guild_id=guild_id)
21082 | 56 |             for scrim in scrims:
21083 | 57 |                 await scrim.full_delete()
21084 | 58 | 
21085 | 59 |         return await self.bot.sio.emit(f"bot_scrim_delete__{u}", SockResponse().dict())
21086 | 60 | 
21087 | 
21088 | 
21089 | --------------------------------------------------------------------------------
21090 | /sockets/events/settings.py:
21091 | --------------------------------------------------------------------------------
21092 |  1 | from __future__ import annotations
21093 |  2 | 
21094 |  3 | from typing import TYPE_CHECKING
21095 |  4 | 
21096 |  5 | if TYPE_CHECKING:
21097 |  6 |     from core import Quotient
21098 |  7 | 
21099 |  8 | from contextlib import suppress
21100 |  9 | 
21101 | 10 | import discord
21102 | 11 | 
21103 | 12 | import constants
21104 | 13 | from core import Cog
21105 | 14 | from models import Votes
21106 | 15 | 
21107 | 16 | from ..schemas import SockResponse
21108 | 17 | 
21109 | 18 | 
21110 | 19 | class SockSettings(Cog):
21111 | 20 |     def __init__(self, bot: Quotient):
21112 | 21 |         self.bot = bot
21113 | 22 |         self.hook = discord.Webhook.from_url(self.bot.config.PUBLIC_LOG, session=self.bot.session)
21114 | 23 | 
21115 | 24 |     @Cog.listener()
21116 | 25 |     async def on_request__prefix_change(self, u, data: dict):
21117 | 26 |         guild_id = data.get("guild_id")
21118 | 27 |         await self.bot.cache.update_guild_cache(int(guild_id))
21119 | 28 |         await self.bot.sio.emit("prefix_change__{0}".format(u), SockResponse().dict())
21120 | 29 | 
21121 | 30 |     @Cog.listener()
21122 | 31 |     async def on_request__new_vote(self, u, data: dict):
21123 | 32 |         user_id = int(data.get("user_id"))
21124 | 33 |         record = await Votes.get(pk=user_id)
21125 | 34 | 
21126 | 35 |         await self.bot.reminders.create_timer(record.expire_time, "vote", user_id=record.user_id)
21127 | 36 | 
21128 | 37 |         member = self.bot.server.get_member(record.user_id)
21129 | 38 |         if member is not None:
21130 | 39 |             await member.add_roles(discord.Object(id=self.bot.config.VOTER_ROLE), reason="They voted for me.")
21131 | 40 | 
21132 | 41 |         else:
21133 | 42 |             member = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, record.pk)
21134 | 43 | 
21135 | 44 |         with suppress(discord.HTTPException, AttributeError):
21136 | 45 |             embed = discord.Embed(color=discord.Color.green(), description=f"Thanks **{member}** for voting.")
21137 | 46 |             embed.set_image(url=constants.random_thanks())
21138 | 47 |             embed.set_footer(text=f"Your total votes: {record.total_votes}")
21139 | 48 |             await self.hook.send(embed=embed, username="vote-logs", avatar_url=self.bot.user.display_avatar.url)
21140 | 49 | 
21141 | 50 |     @Cog.listener()
21142 | 51 |     async def on_request__get_usernames(self, u, data: dict):
21143 | 52 |         _dict = {}
21144 | 53 |         for _ in data.get("users"):
21145 | 54 |             _dict[str(_)] = str(await self.bot.getch(self.bot.get_user, self.bot.fetch_user, int(_)))
21146 | 55 | 
21147 | 56 |         await self.bot.sio.emit("get_usernames__{0}".format(u), SockResponse(data=_dict).dict())
21148 | 57 | 
21149 | 
21150 | 
21151 | --------------------------------------------------------------------------------
21152 | /sockets/events/tourney.py:
21153 | --------------------------------------------------------------------------------
21154 |  1 | from __future__ import annotations
21155 |  2 | 
21156 |  3 | from typing import TYPE_CHECKING
21157 |  4 | 
21158 |  5 | if TYPE_CHECKING:
21159 |  6 |     from core import Quotient
21160 |  7 | 
21161 |  8 | from core import Cog
21162 |  9 | from models import Tourney
21163 | 10 | 
21164 | 11 | from ..schemas import SockTourney
21165 | 12 | 
21166 | 13 | __all__ = ("SockTourney",)
21167 | 14 | 
21168 | 15 | 
21169 | 16 | class SockTourney(Cog):
21170 | 17 |     def __init__(self, bot: Quotient):
21171 | 18 |         self.bot = bot
21172 | 19 | 
21173 | 20 |     @Cog.listener()
21174 | 21 |     async def on_request__bot_tourney_create(self, u: str, data: dict):
21175 | 22 |         data: SockTourney = SockTourney(**data)
21176 | 23 | 
21177 | 24 |     @Cog.listener()
21178 | 25 |     async def on_request__bot_tourney_edit(self, u: str, data: dict):
21179 | 26 |         data: SockTourney = SockTourney(**data)
21180 | 27 | 
21181 | 28 |     @Cog.listener()
21182 | 29 |     async def on_request__bot_tourney_delete(self, u: str, data: dict):
21183 | 30 |         guild_id, tourney_id = data["guild_id"], data["tourney_id"]
21184 | 31 |         if tourney_id:
21185 | 32 |             tourney = await Tourney.get_or_none(pk=tourney_id)
21186 | 33 |             if tourney:
21187 | 34 |                 await tourney.full_delete()
21188 | 35 | 
21189 | 36 |         else:
21190 | 37 |             tourneys = await Tourney.filter(guild_id=guild_id)
21191 | 38 |             for tourney in tourneys:
21192 | 39 |                 await tourney.full_delete()
21193 | 40 | 
21194 | 41 |         return await self.bot.sio.emit("bot_tourney_delete__{0}".format(u), SockTourney().dict())
21195 | 42 | 
21196 | 
21197 | 
21198 | --------------------------------------------------------------------------------
21199 | /sockets/schemas/__init__.py:
21200 | --------------------------------------------------------------------------------
21201 | 1 | from ._guild import *
21202 | 2 | from ._resp import *
21203 | 3 | from ._scrim import *
21204 | 4 | from ._tourney import *
21205 | 5 | 
21206 | 
21207 | 
21208 | --------------------------------------------------------------------------------
21209 | /sockets/schemas/_guild.py:
21210 | --------------------------------------------------------------------------------
21211 |  1 | import typing as T
21212 |  2 | 
21213 |  3 | import discord
21214 |  4 | from pydantic import BaseModel
21215 |  5 | 
21216 |  6 | from models import Guild
21217 |  7 | 
21218 |  8 | __all__ = ("QGuild",)
21219 |  9 | 
21220 | 10 | 
21221 | 11 | class QGuild(BaseModel):
21222 | 12 |     id: str
21223 | 13 |     name: str
21224 | 14 |     icon: str
21225 | 15 |     channels: T.List[dict]
21226 | 16 |     roles: T.List[dict]
21227 | 17 |     boosted_by: dict
21228 | 18 |     dashboard_access: int
21229 | 19 | 
21230 | 20 |     @staticmethod
21231 | 21 |     async def from_guild(guild: discord.Guild, perms: int):
21232 | 22 |         _d = {
21233 | 23 |             "id": str(guild.id),
21234 | 24 |             "name": guild.name,
21235 | 25 |             "dashboard_access": perms,
21236 | 26 |             "icon": getattr(guild.icon, "url", "https://cdn.discordapp.com/embed/avatars/0.png"),
21237 | 27 |         }
21238 | 28 | 
21239 | 29 |         _d["channels"] = [{"id": str(c.id), "name": c.name} for c in guild.text_channels]
21240 | 30 | 
21241 | 31 |         _d["roles"] = [
21242 | 32 |             {"id": str(r.id), "name": r.name, "color": int(r.color), "managed": r.managed} for r in guild.roles
21243 | 33 |         ]
21244 | 34 |         _d["boosted_by"] = {}
21245 | 35 | 
21246 | 36 |         record = await Guild.get(pk=guild.id)
21247 | 37 | 
21248 | 38 |         if record.is_premium:
21249 | 39 |             booster = await record.bot.get_or_fetch_member(guild, record.made_premium_by)
21250 | 40 |             _d["boosted_by"] = {
21251 | 41 |                 "id": str(getattr(booster, "id", 12345)),
21252 | 42 |                 "username": getattr(booster, "name", "Unknown User"),
21253 | 43 |                 "discriminator": getattr(booster, "discriminator", "#0000"),
21254 | 44 |                 "avatar": booster.display_avatar.url if booster else "https://cdn.discordapp.com/embed/avatars/0.png",
21255 | 45 |             }
21256 | 46 | 
21257 | 47 |         return QGuild(**_d)
21258 | 48 | 
21259 | 
21260 | 
21261 | --------------------------------------------------------------------------------
21262 | /sockets/schemas/_resp.py:
21263 | --------------------------------------------------------------------------------
21264 |  1 | from pydantic import BaseModel
21265 |  2 | 
21266 |  3 | __all__ = ("SockResponse",)
21267 |  4 | 
21268 |  5 | 
21269 |  6 | class SockResponse(BaseModel):
21270 |  7 |     ok: bool = True
21271 |  8 |     error: str = None
21272 |  9 |     data: dict = None
21273 | 10 | 
21274 | 
21275 | 
21276 | --------------------------------------------------------------------------------
21277 | /sockets/schemas/_scrim.py:
21278 | --------------------------------------------------------------------------------
21279 |   1 | from __future__ import annotations
21280 |   2 | 
21281 |   3 | from datetime import datetime
21282 |   4 | from typing import TYPE_CHECKING, List, Tuple, Union
21283 |   5 | 
21284 |   6 | from pydantic import BaseModel, validator
21285 |   7 | 
21286 |   8 | if TYPE_CHECKING:
21287 |   9 |     from core import Quotient
21288 |  10 | 
21289 |  11 | from datetime import datetime, timedelta
21290 |  12 | 
21291 |  13 | import dateparser
21292 |  14 | 
21293 |  15 | from constants import IST, AutocleanType, Day
21294 |  16 | from models import Guild, Scrim, Timer
21295 |  17 | 
21296 |  18 | __all__ = ("BaseScrim",)
21297 |  19 | 
21298 |  20 | 
21299 |  21 | def str_to_time(_t: str = None):
21300 |  22 |     if not _t:
21301 |  23 |         return datetime.now(IST).replace(hour=4, minute=0, second=0, microsecond=0) + timedelta(days=1)
21302 |  24 | 
21303 |  25 |     parsed = dateparser.parse(
21304 |  26 |         _t,
21305 |  27 |         settings={
21306 |  28 |             # "RELATIVE_BASE": datetime.now(tz=IST),
21307 |  29 |             "TIMEZONE": "Asia/Kolkata",
21308 |  30 |             "RETURN_AS_TIMEZONE_AWARE": True,
21309 |  31 |         },
21310 |  32 |     )
21311 |  33 |     if datetime.now(tz=IST) > parsed:
21312 |  34 |         parsed = parsed + timedelta(hours=24)
21313 |  35 | 
21314 |  36 |     return parsed
21315 |  37 | 
21316 |  38 | 
21317 |  39 | class BaseScrim(BaseModel):
21318 |  40 |     id: int = None
21319 |  41 |     guild_id: int
21320 |  42 |     name: str = "Quotient-Scrims"
21321 |  43 |     registration_channel_id: int
21322 |  44 |     slotlist_channel_id: int
21323 |  45 |     role_id: int
21324 |  46 |     required_mentions: int
21325 |  47 |     start_from: int = 1
21326 |  48 |     total_slots: int
21327 |  49 |     host_id: int
21328 |  50 |     open_time: datetime
21329 |  51 |     autoclean: List[AutocleanType] = list(AutocleanType)
21330 |  52 |     autoclean_time: datetime = datetime.now(IST).replace(hour=4, minute=0, second=0, microsecond=0) + timedelta(days=1)
21331 |  53 | 
21332 |  54 |     autoslotlist: bool = True
21333 |  55 |     ping_role_id: int = None
21334 |  56 |     multiregister: bool = False
21335 |  57 |     open_role_id: int = None
21336 |  58 | 
21337 |  59 |     autodelete_rejects: bool = False
21338 |  60 |     autodelete_extras: bool = True
21339 |  61 |     teamname_compulsion: bool = True
21340 |  62 | 
21341 |  63 |     show_time_elapsed: bool = True
21342 |  64 |     open_days: List[Day] = list(Day)
21343 |  65 |     no_duplicate_name: bool = False
21344 |  66 |     open_message: dict = {}
21345 |  67 |     close_message: dict = {}
21346 |  68 | 
21347 |  69 |     banlog_channel_id: int = None
21348 |  70 |     match_time: datetime = None
21349 |  71 | 
21350 |  72 |     # validators
21351 |  73 |     _open_time = validator("open_time", pre=True, allow_reuse=True)(str_to_time)
21352 |  74 |     _autoclean_time = validator("autoclean_time", pre=True, allow_reuse=True)(str_to_time)
21353 |  75 |     _match_time = validator("match_time", pre=True, allow_reuse=True)(str_to_time)
21354 |  76 | 
21355 |  77 |     async def validate_perms(self, bot: Quotient) -> Tuple[bool, Union[bool, str]]:
21356 |  78 |         v = await self.__check_bot_perms(bot)
21357 |  79 |         if not all(v):
21358 |  80 |             return v
21359 |  81 | 
21360 |  82 |         guild = bot.get_guild(self.guild_id)
21361 |  83 | 
21362 |  84 |         reg_channel = bot.get_channel(self.registration_channel_id)
21363 |  85 |         if not reg_channel:
21364 |  86 |             return False, "Quotient can't see your registration channel. Give Perms."
21365 |  87 | 
21366 |  88 |         _p = reg_channel.permissions_for(guild.me)
21367 |  89 |         if not all((_p.manage_channels, _p.manage_permissions, _p.manage_messages)):
21368 |  90 |             return False, "Quotient can't manage this registration channel. Give Perms."
21369 |  91 | 
21370 |  92 |         role = guild.get_role(self.role_id)
21371 |  93 |         if not role:
21372 |  94 |             return False, "Quotient couldn't find your sucess role."
21373 |  95 | 
21374 |  96 |         if role >= guild.me.top_role:
21375 |  97 |             return False, "Drag Quotent role above your success role."
21376 |  98 | 
21377 |  99 |         _p = role.permissions
21378 | 100 |         if any((_p.administrator, _p.manage_channels, _p.manage_roles, _p.kick_members, _p.ban_members)):
21379 | 101 |             return False, "Success role has dangerous permissions."
21380 | 102 | 
21381 | 103 |         return True, True
21382 | 104 | 
21383 | 105 |     async def create_scrim(self, bot: Quotient):
21384 | 106 |         if not await Guild.filter(guild_id=self.guild_id, is_premium=True).exists():
21385 | 107 |             if await Scrim.filter(guild_id=self.guild_id).count() >= 3:
21386 | 108 |                 return False, "Cannot create more than 3 scrims without Premium."
21387 | 109 | 
21388 | 110 |         if await Scrim.filter(registration_channel_id=self.registration_channel_id).exists():
21389 | 111 |             return False, "Another scrim is using this registration channel."
21390 | 112 | 
21391 | 113 |         _d = self.dict()
21392 | 114 |         del _d["id"]
21393 | 115 | 
21394 | 116 |         scrim = await Scrim.create(**_d)
21395 | 117 | 
21396 | 118 |         await bot.reminders.create_timer(scrim.open_time, "scrim_open", scrim_id=scrim.id)
21397 | 119 | 
21398 | 120 |         await bot.reminders.create_timer(scrim.autoclean_time, "autoclean", scrim_id=scrim.id)
21399 | 121 |         bot.loop.create_task(scrim.setup_logs())
21400 | 122 |         return True, scrim
21401 | 123 | 
21402 | 124 |     async def update_scrim(self, bot: Quotient):
21403 | 125 |         scrim = await Scrim.get_or_none(pk=self.id)
21404 | 126 |         if not scrim:
21405 | 127 |             return False, "Scrim not found."
21406 | 128 | 
21407 | 129 |         await Timer.filter(extra={"args": [], "kwargs": {"scrim_id": self.id}}, event="autoclean").delete()
21408 | 130 |         await Timer.filter(extra={"args": [], "kwargs": {"scrim_id": self.id}}, event="scrim_open").delete()
21409 | 131 |         await bot.reminders.create_timer(self.open_time, "scrim_open", scrim_id=self.id)
21410 | 132 | 
21411 | 133 |         await bot.reminders.create_timer(self.autoclean_time, "autoclean", scrim_id=self.id)
21412 | 134 | 
21413 | 135 |         _d = self.dict()
21414 | 136 |         del _d["id"]
21415 | 137 |         del _d["open_days"]
21416 | 138 |         del _d["autoclean"]
21417 | 139 | 
21418 | 140 |         await Scrim.filter(pk=self.id).update(**_d)
21419 | 141 | 
21420 | 142 |         _w = """UPDATE public."sm.scrims" SET autoclean = $1 , open_days = $2 WHERE id = $3"""
21421 | 143 |         await bot.db.execute(_w, [_.value for _ in self.autoclean], [_.value for _ in self.open_days], self.id)
21422 | 144 | 
21423 | 145 |         bot.loop.create_task(scrim.setup_logs())
21424 | 146 |         return True, True
21425 | 147 | 
21426 | 148 |     async def __check_bot_perms(self, bot: Quotient):
21427 | 149 |         g = await bot.getch(bot.get_guild, bot.fetch_guild, self.guild_id)
21428 | 150 | 
21429 | 151 |         if g:
21430 | 152 |             g_perms = g.me.guild_permissions
21431 | 153 | 
21432 | 154 |         if not g:
21433 | 155 |             return False, "Couldn't find your server. Try again in a few minutes."
21434 | 156 | 
21435 | 157 |         if not all((g_perms.manage_channels, g_perms.manage_roles, g_perms.manage_messages)):
21436 | 158 |             return False, "Quotient needs manage channels, manage roles permission."
21437 | 159 | 
21438 | 160 |         if not all((g_perms.add_reactions, g_perms.embed_links)):
21439 | 161 |             return False, "Quotient needs add reacions & embed links permission."
21440 | 162 | 
21441 | 163 |         return True, True
21442 | 164 | 
21443 | 
21444 | 
21445 | --------------------------------------------------------------------------------
21446 | /sockets/schemas/_tourney.py:
21447 | --------------------------------------------------------------------------------
21448 |  1 | from __future__ import annotations
21449 |  2 | 
21450 |  3 | from typing import List, Optional
21451 |  4 | 
21452 |  5 | from pydantic import BaseModel
21453 |  6 | 
21454 |  7 | 
21455 |  8 | class SockTourney(BaseModel):
21456 |  9 |     id: Optional[int] = None
21457 | 10 |     guild_id: int
21458 | 11 |     name: str = "Quotient-Tourney"
21459 | 12 |     registration_channel_id: int
21460 | 13 |     confirm_channel_id: int
21461 | 14 |     role_id: int
21462 | 15 |     required_mentions: int = 4
21463 | 16 |     total_slots: int
21464 | 17 |     banned_users: List[int]
21465 | 18 |     host_id: int
21466 | 19 |     multiregister: bool = False
21467 | 20 |     open_role_id: Optional[int] = None
21468 | 21 |     teamname_compulsion: bool = False
21469 | 22 |     ping_role_id: Optional[int] = None
21470 | 23 |     no_duplicate_name: bool = True
21471 | 24 |     autodelete_rejected: bool = True
21472 | 25 |     success_message: Optional[str] = None
21473 | 26 | 
21474 | 
21475 | 
21476 | --------------------------------------------------------------------------------
21477 | /utils/__init__.py:
21478 | --------------------------------------------------------------------------------
21479 | 1 | from .buttons import *
21480 | 2 | from .converters import *
21481 | 3 | from .default import *
21482 | 4 | from .emote import *
21483 | 5 | from .formats import *
21484 | 6 | from .inputs import *
21485 | 7 | from .paginator import *
21486 | 8 | from .time import *
21487 | 9 | 
21488 | 
21489 | 
21490 | --------------------------------------------------------------------------------
21491 | /utils/__pycache__/__init__.cpython-312.pyc:
21492 | --------------------------------------------------------------------------------
21493 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/utils/__pycache__/__init__.cpython-312.pyc
21494 | 
21495 | 
21496 | --------------------------------------------------------------------------------
21497 | /utils/__pycache__/buttons.cpython-312.pyc:
21498 | --------------------------------------------------------------------------------
21499 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/utils/__pycache__/buttons.cpython-312.pyc
21500 | 
21501 | 
21502 | --------------------------------------------------------------------------------
21503 | /utils/__pycache__/converters.cpython-312.pyc:
21504 | --------------------------------------------------------------------------------
21505 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/utils/__pycache__/converters.cpython-312.pyc
21506 | 
21507 | 
21508 | --------------------------------------------------------------------------------
21509 | /utils/__pycache__/default.cpython-312.pyc:
21510 | --------------------------------------------------------------------------------
21511 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/utils/__pycache__/default.cpython-312.pyc
21512 | 
21513 | 
21514 | --------------------------------------------------------------------------------
21515 | /utils/__pycache__/emote.cpython-312.pyc:
21516 | --------------------------------------------------------------------------------
21517 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/utils/__pycache__/emote.cpython-312.pyc
21518 | 
21519 | 
21520 | --------------------------------------------------------------------------------
21521 | /utils/__pycache__/exceptions.cpython-312.pyc:
21522 | --------------------------------------------------------------------------------
21523 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/utils/__pycache__/exceptions.cpython-312.pyc
21524 | 
21525 | 
21526 | --------------------------------------------------------------------------------
21527 | /utils/__pycache__/formats.cpython-312.pyc:
21528 | --------------------------------------------------------------------------------
21529 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/utils/__pycache__/formats.cpython-312.pyc
21530 | 
21531 | 
21532 | --------------------------------------------------------------------------------
21533 | /utils/__pycache__/inputs.cpython-312.pyc:
21534 | --------------------------------------------------------------------------------
21535 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/utils/__pycache__/inputs.cpython-312.pyc
21536 | 
21537 | 
21538 | --------------------------------------------------------------------------------
21539 | /utils/__pycache__/paginator.cpython-312.pyc:
21540 | --------------------------------------------------------------------------------
21541 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/utils/__pycache__/paginator.cpython-312.pyc
21542 | 
21543 | 
21544 | --------------------------------------------------------------------------------
21545 | /utils/__pycache__/regex.cpython-312.pyc:
21546 | --------------------------------------------------------------------------------
21547 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/utils/__pycache__/regex.cpython-312.pyc
21548 | 
21549 | 
21550 | --------------------------------------------------------------------------------
21551 | /utils/__pycache__/time.cpython-312.pyc:
21552 | --------------------------------------------------------------------------------
21553 | https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/6fc4ffd98a3222be331f63abaa56e16ad939700a/utils/__pycache__/time.cpython-312.pyc
21554 | 
21555 | 
21556 | --------------------------------------------------------------------------------
21557 | /utils/buttons.py:
21558 | --------------------------------------------------------------------------------
21559 |   1 | from __future__ import annotations
21560 |   2 | 
21561 |   3 | from typing import List, NamedTuple, Optional, Union
21562 |   4 | 
21563 |   5 | import discord
21564 |   6 | 
21565 |   7 | from .emote import TextChannel, VoiceChannel
21566 |   8 | 
21567 |   9 | 
21568 |  10 | class LinkType(NamedTuple):
21569 |  11 |     name: Optional[str] = None
21570 |  12 |     url: Optional[str] = None
21571 |  13 |     emoji: Optional[str] = None
21572 |  14 | 
21573 |  15 | 
21574 |  16 | class LinkButton(discord.ui.View):
21575 |  17 |     def __init__(self, links: Union[LinkType, List[LinkType]]):
21576 |  18 |         super().__init__()
21577 |  19 | 
21578 |  20 |         links = links if isinstance(links, list) else [links]
21579 |  21 | 
21580 |  22 |         for link in links:
21581 |  23 |             self.add_item(discord.ui.Button(label=link.name, url=link.url, emoji=link.emoji))
21582 |  24 | 
21583 |  25 | 
21584 |  26 | class Prompt(discord.ui.View):
21585 |  27 |     def __init__(self, user_id, timeout=30.0):
21586 |  28 |         super().__init__(timeout=timeout)
21587 |  29 |         self.user_id = user_id
21588 |  30 |         self.value = None
21589 |  31 | 
21590 |  32 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
21591 |  33 |         if interaction.user.id != self.user_id:
21592 |  34 |             await interaction.response.send_message(
21593 |  35 |                 "Sorry, you can't use this interaction as it is not started by you.", ephemeral=True
21594 |  36 |             )
21595 |  37 |             return False
21596 |  38 |         return True
21597 |  39 | 
21598 |  40 |     @discord.ui.button(label="Confirm", style=discord.ButtonStyle.green)
21599 |  41 |     async def confirm(self, interaction: discord.Interaction, _: discord.ui.Button):
21600 |  42 |         await interaction.response.defer()
21601 |  43 |         self.value = True
21602 |  44 |         self.stop()
21603 |  45 | 
21604 |  46 |     @discord.ui.button(label="Cancel", style=discord.ButtonStyle.grey)
21605 |  47 |     async def cancel(self, interaction: discord.Interaction, _: discord.ui.Button):
21606 |  48 |         await interaction.response.defer()
21607 |  49 |         self.value = False
21608 |  50 |         self.stop()
21609 |  51 | 
21610 |  52 | 
21611 |  53 | class BaseSelector(discord.ui.View):
21612 |  54 |     message: discord.Message
21613 |  55 | 
21614 |  56 |     def __init__(self, author_id, selector: discord.ui.Select, **kwargs):
21615 |  57 |         self.author_id = author_id
21616 |  58 |         self.custom_id = None
21617 |  59 |         super().__init__(timeout=30.0)
21618 |  60 | 
21619 |  61 |         self.add_item(selector(**kwargs))
21620 |  62 | 
21621 |  63 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
21622 |  64 |         if interaction.user.id != self.author_id:
21623 |  65 |             await interaction.response.send_message(
21624 |  66 |                 "Sorry, you can't use this interaction as it is not started by you.", ephemeral=True
21625 |  67 |             )
21626 |  68 |             return False
21627 |  69 |         return True
21628 |  70 | 
21629 |  71 |     async def on_timeout(self) -> None:
21630 |  72 |         if hasattr(self, "message"):
21631 |  73 |             await self.message.delete()
21632 |  74 | 
21633 |  75 | 
21634 |  76 | class ChannelSelector(discord.ui.Select):
21635 |  77 |     def __init__(self, placeholder: str, channels: List[Union[discord.TextChannel, discord.VoiceChannel]]):
21636 |  78 |         _options = []
21637 |  79 |         for channel in channels:
21638 |  80 |             _options.append(
21639 |  81 |                 discord.SelectOption(
21640 |  82 |                     label=channel.name,
21641 |  83 |                     value=channel.id,
21642 |  84 |                     description=f"{channel.name} ({channel.id})",
21643 |  85 |                     emoji=TextChannel if isinstance(channel, discord.TextChannel) else VoiceChannel,
21644 |  86 |                 )
21645 |  87 |             )
21646 |  88 | 
21647 |  89 |         super().__init__(placeholder=placeholder, options=_options)
21648 |  90 | 
21649 |  91 |     async def callback(self, interaction: discord.Interaction):
21650 |  92 |         await interaction.response.defer()
21651 |  93 |         self.view.custom_id = interaction.data["values"][0]
21652 |  94 |         self.view.stop()
21653 |  95 | 
21654 |  96 | 
21655 |  97 | class CustomSelector(discord.ui.Select):
21656 |  98 |     def __init__(self, placeholder: str, options: List[discord.SelectOption]):
21657 |  99 |         super().__init__(placeholder=placeholder, options=options)
21658 | 100 | 
21659 | 101 |     async def callback(self, interaction: discord.Interaction):
21660 | 102 |         await interaction.response.defer()
21661 | 103 |         self.view.custom_id = interaction.data["values"][0]
21662 | 104 |         self.view.stop()
21663 | 105 | 
21664 | 
21665 | 
21666 | --------------------------------------------------------------------------------
21667 | /utils/checks.py:
21668 | --------------------------------------------------------------------------------
21669 |   1 | from typing import Union
21670 |   2 | 
21671 |   3 | from discord.ext import commands
21672 |   4 | from discord.ext.commands import CheckFailure, Context, has_any_role
21673 |   5 | 
21674 |   6 | from models import Guild, User
21675 |   7 | 
21676 |   8 | from .exceptions import *
21677 |   9 | 
21678 |  10 | 
21679 |  11 | def has_done_setup():
21680 |  12 |     async def predicate(ctx: Context):
21681 |  13 |         check = await Guild.get_or_none(pk=ctx.guild.id)
21682 |  14 |         if not check.private_ch:
21683 |  15 |             raise NotSetup()
21684 |  16 | 
21685 |  17 |         else:
21686 |  18 |             return True
21687 |  19 | 
21688 |  20 |     return commands.check(predicate)
21689 |  21 | 
21690 |  22 | 
21691 |  23 | def is_premium_guild():
21692 |  24 |     async def predictate(ctx: Context):
21693 |  25 |         check = await Guild.get_or_none(guild_id=ctx.guild.id)
21694 |  26 |         if not check or check.is_premium is False:
21695 |  27 |             raise NotPremiumGuild()
21696 |  28 | 
21697 |  29 |         else:
21698 |  30 |             return True
21699 |  31 | 
21700 |  32 |     return commands.check(predictate)
21701 |  33 | 
21702 |  34 | 
21703 |  35 | def is_premium_user():
21704 |  36 |     async def predicate(ctx: Context):
21705 |  37 |         check = await User.get_or_none(user_id=ctx.author.id)
21706 |  38 |         if not check or check.is_premium is False:
21707 |  39 |             raise NotPremiumUser()
21708 |  40 | 
21709 |  41 |         else:
21710 |  42 |             return True
21711 |  43 | 
21712 |  44 |     return commands.check(predicate)
21713 |  45 | 
21714 |  46 | 
21715 |  47 | def can_use_sm():
21716 |  48 |     """
21717 |  49 |     Returns True if the user has manage roles or scrim-mod role in the server.
21718 |  50 |     """
21719 |  51 | 
21720 |  52 |     async def predicate(ctx: Context):
21721 |  53 |         if ctx.author.guild_permissions.manage_guild or "scrims-mod" in (role.name.lower() for role in ctx.author.roles):
21722 |  54 |             return True
21723 |  55 |         raise SMNotUsable()
21724 |  56 | 
21725 |  57 |     return commands.check(predicate)
21726 |  58 | 
21727 |  59 | 
21728 |  60 | def can_use_tm():
21729 |  61 |     """
21730 |  62 |     Returns True if the user has manage roles or scrim-mod role in the server.
21731 |  63 |     """
21732 |  64 | 
21733 |  65 |     async def predicate(ctx: Context):
21734 |  66 |         if ctx.author.guild_permissions.manage_guild or "tourney-mod" in (role.name.lower() for role in ctx.author.roles):
21735 |  67 |             return True
21736 |  68 |         raise TMNotUsable()
21737 |  69 | 
21738 |  70 |     return commands.check(predicate)
21739 |  71 | 
21740 |  72 | 
21741 |  73 | async def has_any_role_check(ctx: Context, *roles: Union[str, int]) -> bool:
21742 |  74 |     """
21743 |  75 |     Returns True if the context's author has any of the specified roles.
21744 |  76 |     `roles` are the names or IDs of the roles for which to check.
21745 |  77 |     False is always returns if the context is outside a guild.
21746 |  78 |     """
21747 |  79 |     try:
21748 |  80 |         return await has_any_role(*roles).predicate(ctx)
21749 |  81 |     except CheckFailure:
21750 |  82 |         return False
21751 |  83 | 
21752 |  84 | 
21753 |  85 | async def check_guild_permissions(ctx: Context, perms, *, check=all):
21754 |  86 |     is_owner = await ctx.bot.is_owner(ctx.author)
21755 |  87 |     if is_owner:
21756 |  88 |         return True
21757 |  89 | 
21758 |  90 |     if ctx.guild is None:
21759 |  91 |         return False
21760 |  92 | 
21761 |  93 |     resolved = ctx.author.guild_permissions
21762 |  94 |     return check(getattr(resolved, name, None) == value for name, value in perms.items())
21763 |  95 | 
21764 |  96 | 
21765 |  97 | def is_mod():
21766 |  98 |     async def pred(ctx):
21767 |  99 |         return await check_guild_permissions(ctx, {"manage_guild": True})
21768 | 100 | 
21769 | 101 |     return commands.check(pred)
21770 | 102 | 
21771 | 103 | 
21772 | 104 | def is_admin():
21773 | 105 |     async def pred(ctx):
21774 | 106 |         return await check_guild_permissions(ctx, {"administrator": True})
21775 | 107 | 
21776 | 108 |     return commands.check(pred)
21777 | 109 | 
21778 | 110 | 
21779 | 111 | async def check_permissions(ctx: Context, perms, *, check=all):
21780 | 112 |     is_owner = await ctx.bot.is_owner(ctx.author)
21781 | 113 |     if is_owner:
21782 | 114 |         return True
21783 | 115 | 
21784 | 116 |     resolved = ctx.channel.permissions_for(ctx.author)
21785 | 117 |     return check(getattr(resolved, name, None) == value for name, value in perms.items())
21786 | 118 | 
21787 | 119 | 
21788 | 120 | def has_permissions(*, check=all, **perms):
21789 | 121 |     async def pred(ctx):
21790 | 122 |         return await check_permissions(ctx, perms, check=check)
21791 | 123 | 
21792 | 124 |     return commands.check(pred)
21793 | 125 | 
21794 | 
21795 | 
21796 | --------------------------------------------------------------------------------
21797 | /utils/converters.py:
21798 | --------------------------------------------------------------------------------
21799 |   1 | import asyncio
21800 |   2 | import contextlib
21801 |   3 | import re
21802 |   4 | from concurrent.futures import ThreadPoolExecutor
21803 |   5 | from functools import partial, wraps
21804 |   6 | from typing import Optional
21805 |   7 | 
21806 |   8 | import discord
21807 |   9 | from discord.ext import commands
21808 |  10 | from PIL import ImageColor
21809 |  11 | 
21810 |  12 | __all__ = (
21811 |  13 |     "BannedMember",
21812 |  14 |     "ActionReason",
21813 |  15 |     "MemberID",
21814 |  16 |     "QuoRole",
21815 |  17 |     "QuoMember",
21816 |  18 |     "QuoUser",
21817 |  19 |     "QuoColor",
21818 |  20 |     "QuoCategory",
21819 |  21 |     "QuoTextChannel",
21820 |  22 |     "to_async",
21821 |  23 | )
21822 |  24 | 
21823 |  25 | 
21824 |  26 | class to_async:
21825 |  27 |     def __init__(self, *, executor: Optional[ThreadPoolExecutor] = None):
21826 |  28 |         self.executor = executor
21827 |  29 | 
21828 |  30 |     def __call__(self, blocking):
21829 |  31 |         @wraps(blocking)
21830 |  32 |         async def wrapper(*args, **kwargs):
21831 |  33 |             loop = asyncio.get_event_loop()
21832 |  34 |             if not self.executor:
21833 |  35 |                 self.executor = ThreadPoolExecutor()
21834 |  36 | 
21835 |  37 |             func = partial(blocking, *args, **kwargs)
21836 |  38 | 
21837 |  39 |             return await loop.run_in_executor(self.executor, func)
21838 |  40 | 
21839 |  41 |         return wrapper
21840 |  42 | 
21841 |  43 | 
21842 |  44 | class QuoColor:
21843 |  45 |     @classmethod
21844 |  46 |     async def convert(cls, ctx, arg):
21845 |  47 |         match, check = None, False
21846 |  48 |         with contextlib.suppress(AttributeError):
21847 |  49 |             match = re.match(r"\(?(\d+),?\s*(\d+),?\s*(\d+)\)?", arg)
21848 |  50 |             check = all(0 <= int(x) <= 255 for x in match.groups())
21849 |  51 | 
21850 |  52 |         if match and check:
21851 |  53 |             return discord.Color.from_rgb(*[int(i) for i in match.groups()])
21852 |  54 | 
21853 |  55 |         _converter = commands.ColorConverter()
21854 |  56 |         result = None
21855 |  57 | 
21856 |  58 |         try:
21857 |  59 |             result = await _converter.convert(ctx, arg)
21858 |  60 |         except commands.BadColorArgument:
21859 |  61 |             with contextlib.suppress(ValueError):
21860 |  62 |                 color = ImageColor.getrgb(arg)
21861 |  63 |                 result = discord.Color.from_rgb(*color)
21862 |  64 | 
21863 |  65 |         if result:
21864 |  66 |             return result
21865 |  67 | 
21866 |  68 |         return await ctx.error(f"`{arg}` isn't a valid color.", 4)
21867 |  69 | 
21868 |  70 | 
21869 |  71 | class BannedMember(commands.Converter):
21870 |  72 |     async def convert(self, ctx, argument):
21871 |  73 |         if argument.isdigit():
21872 |  74 |             member_id = int(argument, base=10)
21873 |  75 |             try:
21874 |  76 |                 return await ctx.guild.fetch_ban(discord.Object(id=member_id))
21875 |  77 |             except discord.NotFound:
21876 |  78 |                 raise commands.BadArgument("This member has not been banned before.") from None
21877 |  79 | 
21878 |  80 |         ban_list = await ctx.guild.bans()
21879 |  81 |         entity = discord.utils.find(lambda u: str(u.user) == argument, ban_list)
21880 |  82 | 
21881 |  83 |         if entity is None:
21882 |  84 |             raise commands.BadArgument("This member has not been banned before.")
21883 |  85 |         return entity
21884 |  86 | 
21885 |  87 | 
21886 |  88 | class ActionReason(commands.Converter):
21887 |  89 |     async def convert(self, ctx, argument):
21888 |  90 |         ret = f"{ctx.author} (ID: {ctx.author.id}): {argument}"
21889 |  91 | 
21890 |  92 |         if len(ret) > 512:
21891 |  93 |             reason_max = 512 - len(ret) + len(argument)
21892 |  94 |             raise commands.BadArgument(f"Reason is too long ({len(argument)}/{reason_max})")
21893 |  95 |         return ret
21894 |  96 | 
21895 |  97 | 
21896 |  98 | def can_execute_action(ctx, user, target):
21897 |  99 |     return user.id == ctx.bot.owner_id or user == ctx.guild.owner or user.top_role > target.top_role
21898 | 100 | 
21899 | 101 | 
21900 | 102 | class MemberID(commands.Converter):
21901 | 103 |     async def convert(self, ctx, argument):
21902 | 104 |         try:
21903 | 105 |             m = await QuoMember().convert(ctx, argument)
21904 | 106 |         except commands.BadArgument:
21905 | 107 |             try:
21906 | 108 |                 member_id = int(argument, base=10)
21907 | 109 |             except ValueError:
21908 | 110 |                 raise commands.BadArgument(f"{argument} is not a valid member or member ID.") from None
21909 | 111 |             else:
21910 | 112 |                 m = await ctx.bot.get_or_fetch_member(ctx.guild, member_id)
21911 | 113 |                 if m is None:
21912 | 114 |                     # hackban case
21913 | 115 |                     return type("_Hackban", (), {"id": member_id, "__str__": lambda s: f"Member ID {s.id}"})()
21914 | 116 | 
21915 | 117 |         if not can_execute_action(ctx, ctx.author, m):
21916 | 118 |             raise commands.BadArgument("You cannot do this action on this user due to role hierarchy.")
21917 | 119 | 
21918 | 120 |         elif not can_execute_action(ctx, ctx.me, m):
21919 | 121 |             raise commands.BadArgument("I cannot do this action on this user due to role hierarchy.")
21920 | 122 | 
21921 | 123 |         return m
21922 | 124 | 
21923 | 125 | 
21924 | 126 | class QuoRole(commands.Converter):
21925 | 127 |     async def convert(self, ctx, argument) -> Optional[discord.Role]:
21926 | 128 |         """
21927 | 129 |         Return Role, this works without taking case sensitivity into account.
21928 | 130 | 
21929 | 131 |         Raises commands.RoleNotFound if cannot find the role.
21930 | 132 |         """
21931 | 133 |         try:
21932 | 134 |             return await commands.RoleConverter().convert(ctx, argument)
21933 | 135 |         except commands.RoleNotFound:
21934 | 136 | 
21935 | 137 |             def check(role):
21936 | 138 |                 return role.name.lower() == argument.lower() or str(role).lower() == argument.lower()
21937 | 139 | 
21938 | 140 |             if found := discord.utils.find(check, ctx.guild.roles):
21939 | 141 |                 return found
21940 | 142 | 
21941 | 143 |             raise commands.RoleNotFound(argument)
21942 | 144 | 
21943 | 145 | 
21944 | 146 | class QuoMember(commands.Converter):
21945 | 147 |     async def convert(self, ctx, argument) -> Optional[discord.Member]:
21946 | 148 |         """
21947 | 149 |         Returns Member , it is better that commands.MemberConverter() because it finds member without
21948 | 150 |         taking case sensitivity into account.
21949 | 151 | 
21950 | 152 |         Raises commands.MemberNotFound
21951 | 153 |         """
21952 | 154 |         argument = argument.strip()
21953 | 155 |         try:
21954 | 156 |             return await commands.MemberConverter().convert(ctx, argument)
21955 | 157 |         except commands.MemberNotFound:
21956 | 158 | 
21957 | 159 |             def check(member):
21958 | 160 |                 return (
21959 | 161 |                     member.name.lower() == argument.lower()
21960 | 162 |                     or member.display_name.lower() == argument.lower()
21961 | 163 |                     or str(member).lower() == argument.lower()
21962 | 164 |                 )
21963 | 165 | 
21964 | 166 |             if found := discord.utils.find(check, ctx.guild.members):
21965 | 167 |                 return found
21966 | 168 | 
21967 | 169 |             raise commands.MemberNotFound(argument)
21968 | 170 | 
21969 | 171 | 
21970 | 172 | class QuoUser(commands.Converter):
21971 | 173 |     async def convert(self, ctx, argument):
21972 | 174 |         """
21973 | 175 |         This will return Member if member exists in the guild else will returns User.
21974 | 176 |         Raises commands.UserNotFound
21975 | 177 |         """
21976 | 178 |         argument = argument.strip()
21977 | 179 |         if ctx.guild:
21978 | 180 |             try:
21979 | 181 |                 return await QuoMember().convert(ctx, argument)
21980 | 182 | 
21981 | 183 |             except commands.MemberNotFound:
21982 | 184 |                 pass
21983 | 185 | 
21984 | 186 |         try:
21985 | 187 |             return await commands.UserConverter().convert(ctx, argument)
21986 | 188 | 
21987 | 189 |         except commands.UserNotFound:
21988 | 190 | 
21989 | 191 |             def check(user):
21990 | 192 |                 return (
21991 | 193 |                     user.name.lower() == argument.lower()
21992 | 194 |                     or str(user).lower() == argument.lower()
21993 | 195 |                     or user.id == str(argument)
21994 | 196 |                 )
21995 | 197 | 
21996 | 198 |             if found := discord.utils.find(check, ctx.bot.users):
21997 | 199 |                 return found
21998 | 200 |             raise commands.UserNotFound(argument)
21999 | 201 | 
22000 | 202 | 
22001 | 203 | class QuoCategory(commands.Converter):
22002 | 204 |     async def convert(self, ctx: commands.Context, argument):
22003 | 205 |         try:
22004 | 206 |             return await commands.CategoryChannelConverter().convert(ctx, argument)
22005 | 207 |         except commands.ChannelNotFound:
22006 | 208 | 
22007 | 209 |             def check(category):
22008 | 210 |                 return category.name.lower() == argument.lower()
22009 | 211 | 
22010 | 212 |             if found := discord.utils.find(check, ctx.guild.categories):
22011 | 213 |                 return found
22012 | 214 | 
22013 | 215 |             raise commands.ChannelNotFound(argument)
22014 | 216 | 
22015 | 217 | 
22016 | 218 | class QuoTextChannel(commands.Converter):
22017 | 219 |     async def convert(self, ctx: commands.Context, argument):
22018 | 220 |         try:
22019 | 221 |             return await commands.TextChannelConverter().convert(ctx, argument)
22020 | 222 |         except commands.ChannelNotFound:
22021 | 223 | 
22022 | 224 |             def check(channel: discord.TextChannel):
22023 | 225 |                 return channel.name.lower() == argument.lower()
22024 | 226 | 
22025 | 227 |             if found := discord.utils.find(check, ctx.guild.text_channels):
22026 | 228 |                 return found
22027 | 229 | 
22028 | 230 |             raise commands.ChannelNotFound(argument)
22029 | 231 | 
22030 | 
22031 | 
22032 | --------------------------------------------------------------------------------
22033 | /utils/default.py:
22034 | --------------------------------------------------------------------------------
22035 |  1 | from __future__ import annotations
22036 |  2 | 
22037 |  3 | import re
22038 |  4 | from datetime import datetime
22039 |  5 | from itertools import islice
22040 |  6 | from typing import Union
22041 |  7 | from unicodedata import normalize as nm
22042 |  8 | 
22043 |  9 | import discord
22044 | 10 | 
22045 | 11 | from constants import IST
22046 | 12 | 
22047 | 13 | 
22048 | 14 | def get_chunks(iterable, size: int):
22049 | 15 |     it = iter(iterable)
22050 | 16 |     return iter(lambda: tuple(islice(it, size)), ())
22051 | 17 | 
22052 | 18 | 
22053 | 19 | def split_list(data: list, per_list: int):
22054 | 20 |     data = list(data)
22055 | 21 | 
22056 | 22 |     new = []
22057 | 23 | 
22058 | 24 |     for i in range(0, len(data), per_list):
22059 | 25 |         new.append(data[i : i + per_list])
22060 | 26 | 
22061 | 27 |     return new
22062 | 28 | 
22063 | 29 | 
22064 | 30 | def find_team(message: discord.Message):
22065 | 31 |     """
22066 | 32 |     Finds team name from a message
22067 | 33 |     """
22068 | 34 |     author = message.author
22069 | 35 |     teamname = re.search(r"team.*", message.content)
22070 | 36 |     if teamname is None:
22071 | 37 |         return f"{author}'s team"
22072 | 38 | 
22073 | 39 |     # teamname = (re.sub(r"\b[0-9]+\b\s*|team|name|[^\w\s]", "", teamname.group())).strip()
22074 | 40 |     teamname: str = re.sub(r"<@*#*!*&*\d+>|team|name|[^\w\s]", "", teamname.group()).strip()
22075 | 41 | 
22076 | 42 |     teamname = f"Team {teamname.title()}" if teamname else f"{author}'s team"
22077 | 43 |     return teamname
22078 | 44 | 
22079 | 45 | 
22080 | 46 | def find_drop_location(message: discord.Message):
22081 | 47 |     """
22082 | 48 |     Find team's drop location from message, if provided.
22083 | 49 |     """
22084 | 50 |     drop_location = re.search(r"drop.*", message.content)
22085 | 51 |     if drop_location is None:
22086 | 52 |         return None
22087 | 53 | 
22088 | 54 |     drop_location = re.sub(r"<@*#*!*&*\d+>|drop|location|[^\w\s]", "", drop_location.group()).strip()
22089 | 55 | 
22090 | 56 |     return drop_location.title() if drop_location else None
22091 | 57 | 
22092 | 58 | 
22093 | 59 | def regional_indicator(c: str) -> str:
22094 | 60 |     """Returns a regional indicator emoji given a character."""
22095 | 61 |     return chr(0x1F1E6 - ord("A") + ord(c.upper()))
22096 | 62 | 
22097 | 63 | 
22098 | 64 | def keycap_digit(c: Union[int, str]) -> str:
22099 | 65 |     """Returns a keycap digit emoji given a character."""
22100 | 66 |     c = int(c)
22101 | 67 |     if 0 < c < 10:
22102 | 68 |         return str(c) + "\U0000FE0F\U000020E3"
22103 | 69 |     if c == 10:
22104 | 70 |         return "\U000FE83B"
22105 | 71 |     raise ValueError("Invalid keycap digit")
22106 | 72 | 
22107 | 73 | 
22108 | 74 | async def aenumerate(asequence, start=0):
22109 | 75 |     """Asynchronously enumerate an async iterator from a given start value"""
22110 | 76 |     n = start
22111 | 77 |     async for elem in asequence:
22112 | 78 |         yield n, elem
22113 | 79 |         n += 1
22114 | 80 | 
22115 | 81 | 
22116 | 82 | def get_ipm(bot):
22117 | 83 |     """Returns Quotient's cmds invoke rate per minute"""
22118 | 84 |     time = (datetime.now(tz=IST) - bot.start_time).total_seconds()
22119 | 85 |     per_second = bot.cmd_invokes / time
22120 | 86 |     per_minute = per_second * 60
22121 | 87 |     return per_minute
22122 | 88 | 
22123 | 
22124 | 
22125 | --------------------------------------------------------------------------------
22126 | /utils/emote.py:
22127 | --------------------------------------------------------------------------------
22128 |  1 | # never ask me to remove these :c
22129 |  2 | red = "<:red:775586906599456779>"
22130 |  3 | green = "<:green:775586905580240946>"
22131 |  4 | yellow = "<:yellow:775586904439128064>"
22132 |  5 | invisible = "<:invisible:775586907680931860>"
22133 |  6 | 
22134 |  7 | scrimscheck = "<:scrimscheck:839554647861755946>"
22135 |  8 | scrimsxmark = "<:scrimscross:839554689778712576>"
22136 |  9 | 
22137 | 10 | info = "<:info2:899020593188462693>"
22138 | 11 | trash = "<:trashcan:896382424529907742>"
22139 | 12 | exit = "<:exit:926048897548300339>"
22140 | 13 | 
22141 | 14 | 
22142 | 15 | add = "<:add:844825523003850772>"
22143 | 16 | remove = "<:remove:844825861295046661>"
22144 | 17 | edit = "<:edit:844826616735727616>"
22145 | 18 | 
22146 | 19 | diamond = "<a:diamond:899295009289949235>"
22147 | 20 | 
22148 | 21 | error = "❗"
22149 | 22 | 
22150 | 23 | server = "<:server:775586933396078612>"
22151 | 24 | privacy = "<:privacy:775586938659799060>"
22152 | 25 | 
22153 | 26 | one = "1️⃣"
22154 | 27 | two = "2️⃣"
22155 | 28 | three = "3️⃣"
22156 | 29 | four = "4️⃣"
22157 | 30 | five = "5️⃣"
22158 | 31 | 
22159 | 32 | 
22160 | 33 | rps = "<:rps:833993433415811083>"
22161 | 34 | 
22162 | 35 | 
22163 | 36 | bravery = "<:bravery:833991097222299678>"
22164 | 37 | brilliance = "<:brilliance:833991154839191573>"
22165 | 38 | balance = "<:balance:833991183087829012>"
22166 | 39 | 
22167 | 40 | supporter = "<:supporter:833991451872198696>"
22168 | 41 | staff = "<:staff:833991411313147915>"
22169 | 42 | partner = "<:partner:833991367130087464>"
22170 | 43 | hypesquad = "<:hypesquad:833991496545206282>"
22171 | 44 | hypesquad_events = "<:hypesquad_events:833991530418667540>"
22172 | 45 | bug_hunter = "<:bug_hunter:833991572613234718>"
22173 | 46 | BugHunterLvl2 = "<:bug_hunter2:833991610357514240>"
22174 | 47 | bot = "<:bot:833991659133992991>"
22175 | 48 | bot_devloper = "<:bot_devloper:833991714637217803>"
22176 | 49 | verified_bot = "<:verifiedbot1:833991773248290817><:verifiedbot2:833991793683070996>"
22177 | 50 | 
22178 | 51 | check = "<:check:807913701151342592>"
22179 | 52 | xmark = "<:xmark:807913737805234176>"
22180 | 53 | loading = "<a:loading:815826684262744124>"
22181 | 54 | VoiceChannel = "<:voice:815827186116198430>"
22182 | 55 | TextChannel = "<:text:815827264679706624>"
22183 | 56 | category = "<:category:815831557507776583>"
22184 | 57 | pain = "<:blobpain:831771526368985098>"
22185 | 58 | settings_yes = "<:settings_mark_off:815169498319159337><:settings_check_on:815169424566517791>"
22186 | 59 | settings_no = "<:set_no_on:815169465259786241><:set_yes_off:815169360393404436>"
22187 | 60 | 
22188 | 61 | 
22189 | 62 | pstop = "<:stop:829602188593856574>"
22190 | 63 | pprevious = "<:previous:829602188565151744>"
22191 | 64 | pnext = "<:next:829602188653101056>"
22192 | 65 | plast = "<:last:829602188435128331>"
22193 | 66 | pfirst = "<:first:829602188598312990>"
22194 | 67 | 
22195 | 68 | 
22196 | 69 | red1 = "<:red1:870909062227845122>"
22197 | 70 | red2 = "<:red2:870909062513061899>"
22198 | 71 | red3 = "<:red3:870909062877966376>"
22199 | 72 | red4 = "<:red4:870909062341099572>"
22200 | 73 | red5 = "<:red5:870909062437548072>"
22201 | 74 | 
22202 | 75 | 
22203 | 76 | green1 = "<:green1:870909061514792991>"
22204 | 77 | green2 = "<:green2:870909061225390131>"
22205 | 78 | green3 = "<:green3:870909061661605969>"
22206 | 79 | green4 = "<:green4:870909062320099329>"
22207 | 80 | green5 = "<:green5:870909062345281546>"
22208 | 81 | 
22209 | 82 | BADGES = {
22210 | 83 |     "creator": "<:creator:807911084069617674>",
22211 | 84 |     "dev": "<:dev:807911284040531999>",
22212 | 85 |     "donator": "<a:donator:807913325861142578>",
22213 | 86 |     "messenger": "<a:messenger:807912019130974242>",
22214 | 87 |     "premium": "<a:premium:807911675981201459>",
22215 | 88 |     "contributor": "<a:contributor:807911226432028704>",
22216 | 89 |     "staff": "<:staff:807911358549065738>",
22217 | 90 |     "top_user": "<a:top_user:807911932299837460>",
22218 | 91 |     "voter": "<:voter:807912082142003220>",
22219 | 92 | }
22220 | 93 | 
22221 | 94 | p = "\U0001f1f5"
22222 | 95 | e = "\U0001f1ea"
22223 | 96 | r = "\U0001f1f7"
22224 | 97 | eye = "👀"
22225 | 98 | 
22226 | 
22227 | 
22228 | --------------------------------------------------------------------------------
22229 | /utils/exceptions.py:
22230 | --------------------------------------------------------------------------------
22231 |  1 | from discord.ext import commands
22232 |  2 | 
22233 |  3 | 
22234 |  4 | class QuotientError(commands.CheckFailure):
22235 |  5 |     pass
22236 |  6 | 
22237 |  7 | 
22238 |  8 | class NotSetup(QuotientError):
22239 |  9 |     def __init__(self):
22240 | 10 |         super().__init__(
22241 | 11 |             "This command requires you to have Quotient's private channel.\nKindly run `{ctx.prefix}setup` and try again."
22242 | 12 |         )
22243 | 13 | 
22244 | 14 | 
22245 | 15 | class NotPremiumGuild(QuotientError):
22246 | 16 |     def __init__(self):
22247 | 17 |         super().__init__(
22248 | 18 |             "This command requires this server to be premium.\n\nCheckout Quotient Premium [here]({ctx.bot.prime_link})"
22249 | 19 |         )
22250 | 20 | 
22251 | 21 | 
22252 | 22 | class NotPremiumUser(QuotientError):
22253 | 23 |     def __init__(self):
22254 | 24 |         super().__init__(
22255 | 25 |             "This command requires you to be a premium user.\nCheckout Quotient Premium [here]({ctx.bot.prime_link})"
22256 | 26 |         )
22257 | 27 | 
22258 | 28 | 
22259 | 29 | class InputError(QuotientError):
22260 | 30 |     pass
22261 | 31 | 
22262 | 32 | 
22263 | 33 | class SMNotUsable(QuotientError):
22264 | 34 |     def __init__(self):
22265 | 35 |         super().__init__("You need either the `scrims-mod` role or `Manage Server` permissions to use this command.")
22266 | 36 | 
22267 | 37 | 
22268 | 38 | class TMNotUsable(QuotientError):
22269 | 39 |     def __init__(self):
22270 | 40 |         super().__init__("You need either the `tourney-mod` role or `Manage Server` permissions to use tourney manager.")
22271 | 41 | 
22272 | 42 | 
22273 | 43 | class PastTime(QuotientError):
22274 | 44 |     def __init__(self):
22275 | 45 |         super().__init__(
22276 | 46 |             f"The time you entered seems to be in past.\n\nKindly try again, use times like: `tomorrow` , `friday 9pm`"
22277 | 47 |         )
22278 | 48 | 
22279 | 49 | 
22280 | 50 | TimeInPast = PastTime
22281 | 51 | 
22282 | 52 | 
22283 | 53 | class InvalidTime(QuotientError):
22284 | 54 |     def __init__(self):
22285 | 55 |         super().__init__(f"The time you entered seems to be invalid.\n\nKindly try again.")
22286 | 56 | 
22287 | 
22288 | 
22289 | --------------------------------------------------------------------------------
22290 | /utils/formats.py:
22291 | --------------------------------------------------------------------------------
22292 |  1 | def truncate_string(value, max_length=128, suffix="..."):
22293 |  2 |     string_value = str(value)
22294 |  3 |     string_truncated = string_value[: min(len(string_value), (max_length - len(suffix)))]
22295 |  4 |     suffix = suffix if len(string_value) > max_length else ""
22296 |  5 |     return string_truncated + suffix
22297 |  6 | 
22298 |  7 | 
22299 |  8 | class plural:
22300 |  9 |     def __init__(self, value):
22301 | 10 |         self.value = value
22302 | 11 | 
22303 | 12 |         if isinstance(self.value, list):
22304 | 13 |             self.value = len(self.value)
22305 | 14 | 
22306 | 15 |     def __format__(self, format_spec):
22307 | 16 |         v = self.value
22308 | 17 |         singular, sep, plural = format_spec.partition("|")
22309 | 18 |         plural = plural or f"{singular}s"
22310 | 19 |         if abs(v) != 1:
22311 | 20 |             return f"{v} {plural}"
22312 | 21 |         return f"{v} {singular}"
22313 | 22 | 
22314 | 
22315 | 
22316 | --------------------------------------------------------------------------------
22317 | /utils/inputs.py:
22318 | --------------------------------------------------------------------------------
22319 |   1 | from __future__ import annotations
22320 |   2 | 
22321 |   3 | import asyncio
22322 |   4 | from contextlib import suppress
22323 |   5 | from datetime import datetime, timedelta
22324 |   6 | 
22325 |   7 | import aiohttp
22326 |   8 | import dateparser
22327 |   9 | import discord
22328 |  10 | from discord.ext.commands import Context
22329 |  11 | from discord.ext.commands.converter import MemberConverter, RoleConverter, TextChannelConverter
22330 |  12 | 
22331 |  13 | from constants import IST
22332 |  14 | from utils import keycap_digit
22333 |  15 | 
22334 |  16 | from .exceptions import InputError
22335 |  17 | 
22336 |  18 | 
22337 |  19 | async def safe_delete(message) -> bool:
22338 |  20 |     try:
22339 |  21 |         await message.delete()
22340 |  22 |     except (discord.Forbidden, discord.NotFound):
22341 |  23 |         return False
22342 |  24 |     else:
22343 |  25 |         return True
22344 |  26 | 
22345 |  27 | 
22346 |  28 | async def channel_input(ctx: Context, check=None, timeout=120, delete_after=False, check_perms=True):
22347 |  29 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
22348 |  30 |     try:
22349 |  31 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
22350 |  32 |     except asyncio.TimeoutError:
22351 |  33 |         raise InputError("You failed to select a channel in time. Try again!")
22352 |  34 | 
22353 |  35 |     else:
22354 |  36 |         channel = await TextChannelConverter().convert(ctx, message.content)
22355 |  37 | 
22356 |  38 |         perms = channel.permissions_for(ctx.me)
22357 |  39 | 
22358 |  40 |         if not all((perms.read_messages, perms.send_messages, perms.embed_links)):
22359 |  41 |             raise InputError(
22360 |  42 |                 f"Please make sure I have the following perms in {channel.mention}:\n"
22361 |  43 |                 "`read_messages`,`send_messages`,`embed_links`."
22362 |  44 |             )
22363 |  45 | 
22364 |  46 |         if check_perms:
22365 |  47 |             if not all(
22366 |  48 |                 (
22367 |  49 |                     perms.manage_channels,
22368 |  50 |                     perms.add_reactions,
22369 |  51 |                     perms.use_external_emojis,
22370 |  52 |                     perms.manage_permissions,
22371 |  53 |                     perms.manage_messages,
22372 |  54 |                 )
22373 |  55 |             ):
22374 |  56 |                 raise InputError(
22375 |  57 |                     f"Please make sure I have the following perms in {channel.mention}:\n"
22376 |  58 |                     "- `add reactions`\n- `use external emojis`\n- `manage channel`\n- `manage permissions`\n"
22377 |  59 |                     "- `manage messages`"
22378 |  60 |                 )
22379 |  61 |         if delete_after:
22380 |  62 |             await safe_delete(message)
22381 |  63 | 
22382 |  64 |         return channel
22383 |  65 | 
22384 |  66 | 
22385 |  67 | async def role_input(ctx: Context, check=None, timeout=120, hierarchy=True, check_perms=True, delete_after=False):
22386 |  68 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
22387 |  69 | 
22388 |  70 |     try:
22389 |  71 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
22390 |  72 |         role = await RoleConverter().convert(ctx, message.content)
22391 |  73 |     except asyncio.TimeoutError:
22392 |  74 |         raise InputError("You failed to select a role in time. Try again!")
22393 |  75 | 
22394 |  76 |     else:
22395 |  77 |         if role.managed:
22396 |  78 |             raise InputError(f"Role is an integrated role and cannot be added manually.")
22397 |  79 |         if hierarchy:
22398 |  80 |             if role > ctx.me.top_role:
22399 |  81 |                 raise InputError(
22400 |  82 |                     f"The position of {role.mention} is above my top role. So I can't give it to anyone.\nKindly move {ctx.me.top_role.mention} above {role.mention} in Server Settings."
22401 |  83 |                 )
22402 |  84 | 
22403 |  85 |             if ctx.author.id != ctx.guild.owner_id:
22404 |  86 |                 if role > ctx.author.top_role:
22405 |  87 |                     raise InputError(
22406 |  88 |                         f"The position of {role.mention} is above your top role {ctx.author.top_role.mention}."
22407 |  89 |                     )
22408 |  90 | 
22409 |  91 |         if check_perms:
22410 |  92 |             _perms = role.permissions
22411 |  93 |             if any(
22412 |  94 |                 (
22413 |  95 |                     _perms.administrator,
22414 |  96 |                     _perms.manage_channels,
22415 |  97 |                     _perms.manage_roles,
22416 |  98 |                     _perms.kick_members,
22417 |  99 |                     _perms.ban_members,
22418 | 100 |                 )
22419 | 101 |             ):
22420 | 102 |                 raise InputError(f"{role.mention} has dangerous permissions.")
22421 | 103 | 
22422 | 104 |         if delete_after:
22423 | 105 |             await safe_delete(message)
22424 | 106 | 
22425 | 107 |         return role
22426 | 108 | 
22427 | 109 | 
22428 | 110 | async def member_input(ctx: Context, check=None, timeout=120, delete_after=False):
22429 | 111 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
22430 | 112 | 
22431 | 113 |     try:
22432 | 114 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
22433 | 115 |         member = await MemberConverter().convert(ctx, message.content)
22434 | 116 | 
22435 | 117 |     except asyncio.TimeoutError:
22436 | 118 |         raise InputError("You failed to mention a member in time. Try again!")
22437 | 119 | 
22438 | 120 |     else:
22439 | 121 |         if delete_after:
22440 | 122 |             await safe_delete(message)
22441 | 123 | 
22442 | 124 |         return member
22443 | 125 | 
22444 | 126 | 
22445 | 127 | async def integer_input(ctx: Context, check=None, timeout=120, limits=(None, None), delete_after=False):
22446 | 128 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
22447 | 129 | 
22448 | 130 |     def new_check(message: discord.Message):
22449 | 131 |         if not check(message):
22450 | 132 |             return False
22451 | 133 | 
22452 | 134 |         try:
22453 | 135 |             if limits[1] is not None:
22454 | 136 |                 if len(message.content) > len(str(limits[1])):  # This is for safe side, memory errors u know :)
22455 | 137 |                     return False
22456 | 138 | 
22457 | 139 |             digit = int(message.content)
22458 | 140 | 
22459 | 141 |         except ValueError:
22460 | 142 |             return False
22461 | 143 |         else:
22462 | 144 |             if not any(limits):  # No Limits
22463 | 145 |                 return True
22464 | 146 | 
22465 | 147 |             low, high = limits
22466 | 148 | 
22467 | 149 |             if all(limits):
22468 | 150 |                 return low <= digit <= high
22469 | 151 |             if low is not None:
22470 | 152 |                 return low <= digit
22471 | 153 |             return high <= digit
22472 | 154 | 
22473 | 155 |     try:
22474 | 156 |         message: discord.Message = await ctx.bot.wait_for("message", check=new_check, timeout=timeout)
22475 | 157 |     except asyncio.TimeoutError:
22476 | 158 |         raise InputError("You failed to select a number in time. Try again!")
22477 | 159 |     else:
22478 | 160 |         if delete_after:
22479 | 161 |             await safe_delete(message)
22480 | 162 | 
22481 | 163 |         return int(message.content)
22482 | 164 | 
22483 | 165 | 
22484 | 166 | async def time_input(ctx: Context, check=None, timeout=120, delete_after=False):
22485 | 167 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
22486 | 168 | 
22487 | 169 |     try:
22488 | 170 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
22489 | 171 |     except asyncio.TimeoutError:
22490 | 172 |         raise InputError("Timeout, You have't responsed in time. Try again!")
22491 | 173 |     else:
22492 | 174 |         try:
22493 | 175 |             parsed = dateparser.parse(
22494 | 176 |                 message.content,
22495 | 177 |                 settings={
22496 | 178 |                     # "RELATIVE_BASE": datetime.now(tz=IST),
22497 | 179 |                     "TIMEZONE": "Asia/Kolkata",
22498 | 180 |                     "RETURN_AS_TIMEZONE_AWARE": True,
22499 | 181 |                 },
22500 | 182 |             )
22501 | 183 | 
22502 | 184 |             if delete_after:
22503 | 185 |                 await safe_delete(message)
22504 | 186 | 
22505 | 187 |             while datetime.now(tz=IST) > parsed:
22506 | 188 |                 parsed = parsed + timedelta(hours=24)
22507 | 189 | 
22508 | 190 |             return parsed
22509 | 191 | 
22510 | 192 |         except TypeError:
22511 | 193 |             raise InputError("This isn't valid time format.")
22512 | 194 | 
22513 | 195 | 
22514 | 196 | async def string_input(ctx: Context, check=None, timeout=120, delete_after=False):
22515 | 197 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
22516 | 198 | 
22517 | 199 |     try:
22518 | 200 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
22519 | 201 |     except asyncio.TimeoutError:
22520 | 202 |         raise InputError("Took too long. Good Bye.")  # This would sound cooler.
22521 | 203 |     else:
22522 | 204 |         if delete_after:
22523 | 205 |             await safe_delete(message)
22524 | 206 | 
22525 | 207 |         return message.content
22526 | 208 | 
22527 | 209 | 
22528 | 210 | async def image_input(ctx: Context, check, timeout=120, delete_after=False):
22529 | 211 |     try:
22530 | 212 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
22531 | 213 |     except asyncio.TimeoutError:
22532 | 214 |         raise InputError("Took too long. Good Bye.")
22533 | 215 | 
22534 | 216 |     else:
22535 | 217 |         if delete_after:
22536 | 218 |             await safe_delete(message)
22537 | 219 | 
22538 | 220 |         if message.content.strip().lower() == "none":
22539 | 221 |             return None
22540 | 222 | 
22541 | 223 |         _image_formats = ("image/png", "image/jpeg", "image/jpg", "image/gif")
22542 | 224 | 
22543 | 225 |         if message.attachments and message.attachments[0].content_type in _image_formats:
22544 | 226 |             return message.attachments[0].proxy_url
22545 | 227 | 
22546 | 228 |         result = None
22547 | 229 |         with suppress(aiohttp.InvalidURL):
22548 | 230 |             res = await ctx.bot.session.get(message.content)
22549 | 231 |             if res.headers["content-type"] in _image_formats:
22550 | 232 |                 result = message.content
22551 | 233 | 
22552 | 234 |         return result
22553 | 235 | 
22554 | 236 | 
22555 | 237 | async def text_or_embed(ctx: Context, check, timeout=120, delete_after=False):
22556 | 238 |     reactions = (keycap_digit(1), keycap_digit(2))
22557 | 239 | 
22558 | 240 |     def react_check(reaction, user):
22559 | 241 |         return user == ctx.author and str(reaction.emoji) in reactions
22560 | 242 | 
22561 | 243 |     msg = await ctx.simple(
22562 | 244 |         f"What do you want the content to be?\n\n{keycap_digit(1)} | Simple Text\n{keycap_digit(2)} | Embed"
22563 | 245 |     )
22564 | 246 | 
22565 | 247 |     for reaction in reactions:
22566 | 248 |         await msg.add_reaction(reaction)
22567 | 249 | 
22568 | 250 |     reaction, user = await ctx.bot.wait_for("reaction_add", timeout=15, check=react_check)
22569 | 251 | 
22570 | 252 |     if delete_after:
22571 | 253 |         await safe_delete(msg)
22572 | 254 | 
22573 | 255 |     if str(reaction.emoji) == keycap_digit(1):
22574 | 256 |         msg = await ctx.simple("Kindly enter the text now.")
22575 | 257 |         text = await string_input(ctx, check, delete_after=True)
22576 | 258 | 
22577 | 259 |         if delete_after:
22578 | 260 |             await safe_delete(msg)
22579 | 261 | 
22580 | 262 |         return text
22581 | 263 | 
22582 | 264 |     if str(reaction.emoji) == keycap_digit(2):
22583 | 265 |         msg = await ctx.simple(f"embed ki .......")
22584 | 266 | 
22585 | 
22586 | 
22587 | --------------------------------------------------------------------------------
22588 | /utils/paginator.py:
22589 | --------------------------------------------------------------------------------
22590 |   1 | from contextlib import suppress
22591 |   2 | from typing import NamedTuple, Optional
22592 |   3 | 
22593 |   4 | import discord
22594 |   5 | 
22595 |   6 | from .default import get_chunks
22596 |   7 | 
22597 |   8 | 
22598 |   9 | class Page(NamedTuple):
22599 |  10 |     index: int
22600 |  11 |     content: str
22601 |  12 | 
22602 |  13 | 
22603 |  14 | class Pages:
22604 |  15 |     def __init__(self, pages: list):
22605 |  16 |         self.pages = pages
22606 |  17 |         self.cur_page = 1
22607 |  18 | 
22608 |  19 |     @property
22609 |  20 |     def current_page(self) -> Page:
22610 |  21 |         return Page(self.cur_page, self.pages[self.cur_page - 1])
22611 |  22 | 
22612 |  23 |     @property
22613 |  24 |     def next_page(self) -> Optional[Page]:
22614 |  25 |         if self.cur_page == self.total:
22615 |  26 |             return None
22616 |  27 | 
22617 |  28 |         self.cur_page += 1
22618 |  29 |         return self.current_page
22619 |  30 | 
22620 |  31 |     @property
22621 |  32 |     def previous_page(self) -> Optional[Page]:
22622 |  33 |         if self.cur_page == 1:
22623 |  34 |             return None
22624 |  35 | 
22625 |  36 |         self.cur_page -= 1
22626 |  37 |         return self.current_page
22627 |  38 | 
22628 |  39 |     @property
22629 |  40 |     def first_page(self) -> Page:
22630 |  41 |         self.cur_page = 1
22631 |  42 |         return self.current_page
22632 |  43 | 
22633 |  44 |     @property
22634 |  45 |     def last_page(self) -> Page:
22635 |  46 |         self.cur_page = self.total
22636 |  47 |         return self.current_page
22637 |  48 | 
22638 |  49 |     @property
22639 |  50 |     def total(self):
22640 |  51 |         return len(self.pages)
22641 |  52 | 
22642 |  53 | 
22643 |  54 | class QuoPaginator:
22644 |  55 |     def __init__(self, ctx, *, per_page=10, timeout=60.0, title=None, show_page_count=True):
22645 |  56 |         self.ctx = ctx
22646 |  57 |         self.per_page = per_page
22647 |  58 |         self.timeout = timeout
22648 |  59 |         self.title = title
22649 |  60 |         self.show_page_count = show_page_count
22650 |  61 | 
22651 |  62 |         self.lines = []
22652 |  63 |         self.pages = None
22653 |  64 | 
22654 |  65 |     def add_line(self, line: str, sep="\n"):
22655 |  66 |         self.lines.append(f"{line}{sep}")
22656 |  67 | 
22657 |  68 |     @property
22658 |  69 |     def embed(self):
22659 |  70 |         page = self.pages.current_page
22660 |  71 | 
22661 |  72 |         e = discord.Embed(color=self.ctx.bot.color)
22662 |  73 |         if self.title:
22663 |  74 |             e.title = self.title
22664 |  75 | 
22665 |  76 |         e.description = page.content
22666 |  77 | 
22667 |  78 |         if self.show_page_count:
22668 |  79 |             e.set_footer(text=f"Page {page.index} of {self.pages.total}")
22669 |  80 | 
22670 |  81 |         return e
22671 |  82 | 
22672 |  83 |     async def start(self):
22673 |  84 |         _pages = []
22674 |  85 |         for page in get_chunks(self.lines, self.per_page):
22675 |  86 |             _pages.append("".join(page))
22676 |  87 | 
22677 |  88 |         self.pages = Pages(_pages)
22678 |  89 | 
22679 |  90 |         if not self.pages.total > 1:
22680 |  91 |             return await self.ctx.send(embed=self.embed)
22681 |  92 | 
22682 |  93 |         view = PaginatorView(
22683 |  94 |             self.ctx, pages=self.pages, embed=self.embed, timeout=self.timeout, show_page_count=self.show_page_count
22684 |  95 |         )
22685 |  96 |         view.message = await self.ctx.send(embed=self.embed, view=view)
22686 |  97 | 
22687 |  98 | 
22688 |  99 | class PaginatorView(discord.ui.View):
22689 | 100 |     message: discord.Message
22690 | 101 | 
22691 | 102 |     def __init__(self, ctx, pages: Pages, embed, timeout, show_page_count):
22692 | 103 |         super().__init__(timeout=timeout)
22693 | 104 | 
22694 | 105 |         self.ctx = ctx
22695 | 106 |         self.pages = pages
22696 | 107 |         self.embed: discord.Embed = embed
22697 | 108 |         self.show_page_count = show_page_count
22698 | 109 | 
22699 | 110 |         if self.pages.cur_page == 1:
22700 | 111 |             self.children[0].disabled = True
22701 | 112 |             self.children[1].disabled = True
22702 | 113 | 
22703 | 114 |     def lock_bro(self):
22704 | 115 |         if self.pages.cur_page == self.pages.total:
22705 | 116 |             self.children[0].disabled = False
22706 | 117 |             self.children[1].disabled = False
22707 | 118 | 
22708 | 119 |             self.children[2].disabled = True
22709 | 120 |             self.children[3].disabled = True
22710 | 121 | 
22711 | 122 |         elif self.pages.cur_page == 1:
22712 | 123 |             self.children[0].disabled = True
22713 | 124 |             self.children[1].disabled = True
22714 | 125 | 
22715 | 126 |             self.children[2].disabled = False
22716 | 127 |             self.children[3].disabled = False
22717 | 128 | 
22718 | 129 |         elif 1 < self.pages.cur_page < self.pages.total:
22719 | 130 |             for b in self.children:
22720 | 131 |                 b.disabled = False
22721 | 132 | 
22722 | 133 |     def update_embed(self, page: Page):
22723 | 134 |         if self.show_page_count:
22724 | 135 |             self.embed.set_footer(text=f"Page {page.index} of {self.pages.total}")
22725 | 136 | 
22726 | 137 |         self.embed.description = page.content
22727 | 138 | 
22728 | 139 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
22729 | 140 |         if interaction.user.id != self.ctx.author.id:
22730 | 141 |             await interaction.response.send_message(
22731 | 142 |                 "Sorry, you can't use this interaction as it is not started by you.", ephemeral=True
22732 | 143 |             )
22733 | 144 |             return False
22734 | 145 |         return True
22735 | 146 | 
22736 | 147 |     async def on_timeout(self) -> None:
22737 | 148 |         for b in self.children:
22738 | 149 |             b.style, b.disabled = discord.ButtonStyle.grey, True
22739 | 150 | 
22740 | 151 |         with suppress(discord.HTTPException):
22741 | 152 |             await self.message.edit(view=self)
22742 | 153 | 
22743 | 154 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="first", emoji="<:double_left:878668594530099220>")
22744 | 155 |     async def first(self, interaction: discord.Interaction, button: discord.ui.Button):
22745 | 156 |         await interaction.response.defer()
22746 | 157 |         page = self.pages.first_page
22747 | 158 | 
22748 | 159 |         self.update_embed(page)
22749 | 160 |         self.lock_bro()
22750 | 161 |         await interaction.message.edit(embed=self.embed, view=self)
22751 | 162 | 
22752 | 163 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="previous", emoji="<:left:878668491660623872>")
22753 | 164 |     async def previous(self, interaction: discord.Interaction, button: discord.ui.Button):
22754 | 165 |         await interaction.response.defer()
22755 | 166 |         page = self.pages.previous_page
22756 | 167 |         self.update_embed(page)
22757 | 168 |         self.lock_bro()
22758 | 169 |         await interaction.message.edit(embed=self.embed, view=self)
22759 | 170 | 
22760 | 171 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="next", emoji="<:right:878668370331983913>")
22761 | 172 |     async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
22762 | 173 |         await interaction.response.defer()
22763 | 174 |         page = self.pages.next_page
22764 | 175 |         self.update_embed(page)
22765 | 176 | 
22766 | 177 |         self.lock_bro()
22767 | 178 |         await interaction.message.edit(embed=self.embed, view=self)
22768 | 179 | 
22769 | 180 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="last", emoji="<:double_right:878668437193359392>")
22770 | 181 |     async def last(self, interaction: discord.Interaction, button: discord.ui.Button):
22771 | 182 |         await interaction.response.defer()
22772 | 183 |         page = self.pages.last_page
22773 | 184 | 
22774 | 185 |         self.update_embed(page)
22775 | 186 |         self.lock_bro()
22776 | 187 |         await interaction.message.edit(embed=self.embed, view=self)
22777 | 188 | 
22778 | 
22779 | 
22780 | --------------------------------------------------------------------------------
22781 | /utils/regex.py:
22782 | --------------------------------------------------------------------------------
22783 |  1 | import re
22784 |  2 | 
22785 |  3 | """
22786 |  4 | Regex compiled by pythondiscord.com
22787 |  5 | Helper regex for moderation
22788 |  6 | """
22789 |  7 | 
22790 |  8 | INVITE_RE = re.compile(
22791 |  9 |     r"(?:discord(?:[\.,]|dot)gg|"  # Could be discord.gg/
22792 | 10 |     r"discord(?:[\.,]|dot)com(?:\/|slash)invite|"  # or discord.com/invite/
22793 | 11 |     r"discordapp(?:[\.,]|dot)com(?:\/|slash)invite|"  # or discordapp.com/invite/
22794 | 12 |     r"discord(?:[\.,]|dot)me|"  # or discord.me
22795 | 13 |     r"discord(?:[\.,]|dot)io"  # or discord.io.
22796 | 14 |     r")(?:[\/]|slash)"  # / or 'slash'
22797 | 15 |     r"([a-zA-Z0-9\-]+)",  # the invite code itself
22798 | 16 |     flags=re.IGNORECASE,
22799 | 17 | )
22800 | 18 | 
22801 | 19 | 
22802 | 20 | TIME_REGEX = re.compile(r"(?:(\d{1,5})(h|s|m|d))+?")
22803 | 21 | 
22804 | 
22805 | 
22806 | --------------------------------------------------------------------------------
22807 | /utils/time.py:
22808 | --------------------------------------------------------------------------------
22809 |   1 | import datetime as dtm
22810 |   2 | import re
22811 |   3 | 
22812 |   4 | import dateparser
22813 |   5 | import parsedatetime as pdt
22814 |   6 | from dateutil.parser import ParserError, parse
22815 |   7 | from dateutil.relativedelta import relativedelta
22816 |   8 | from discord.ext import commands
22817 |   9 | 
22818 |  10 | from constants import IST
22819 |  11 | from core import Context
22820 |  12 | from utils import exceptions
22821 |  13 | 
22822 |  14 | from .formats import plural
22823 |  15 | from .regex import TIME_REGEX
22824 |  16 | 
22825 |  17 | units = pdt.pdtLocales["en_US"].units
22826 |  18 | 
22827 |  19 | 
22828 |  20 | class PastDate(commands.Converter):
22829 |  21 |     async def convert(self, ctx, argument):
22830 |  22 |         try:
22831 |  23 |             dt = parse(argument, ignoretz=True)
22832 |  24 |         except ParserError:
22833 |  25 |             raise commands.BadArgument(
22834 |  26 |                 "The date format you entered seems to be Invalid.\n\n"
22835 |  27 |                 "The day can be human readable date like `11 May` or maybe a more concrete one such as '4-05-2021'"
22836 |  28 |             )
22837 |  29 | 
22838 |  30 |         else:
22839 |  31 |             if dt.date() > dtm.datetime.now().date():
22840 |  32 |                 raise commands.BadArgument(
22841 |  33 |                     "This date seems to be in future, either write today's date or some date that is in past."
22842 |  34 |                 )
22843 |  35 | 
22844 |  36 |             return IST.localize(dt.replace(hour=0, minute=0, second=0, microsecond=0))
22845 |  37 | 
22846 |  38 | 
22847 |  39 | class ShortTime:
22848 |  40 |     compiled = re.compile(
22849 |  41 |         """(?:(?P<years>[0-9])(?:years?|y))?             # e.g. 2y
22850 |  42 |                              (?:(?P<months>[0-9]{1,2})(?:months?|mo))?     # e.g. 2months
22851 |  43 |                              (?:(?P<weeks>[0-9]{1,4})(?:weeks?|w))?        # e.g. 10w
22852 |  44 |                              (?:(?P<days>[0-9]{1,5})(?:days?|d))?          # e.g. 14d
22853 |  45 |                              (?:(?P<hours>[0-9]{1,5})(?:hours?|h))?        # e.g. 12h
22854 |  46 |                              (?:(?P<minutes>[0-9]{1,5})(?:minutes?|m))?    # e.g. 10m
22855 |  47 |                              (?:(?P<seconds>[0-9]{1,5})(?:seconds?|s))?    # e.g. 15s
22856 |  48 |                           """,
22857 |  49 |         re.VERBOSE,
22858 |  50 |     )
22859 |  51 | 
22860 |  52 |     def __init__(self, argument, *, now=None):
22861 |  53 |         match = self.compiled.fullmatch(argument)
22862 |  54 |         if match is None or not match.group(0):
22863 |  55 |             raise exceptions.InvalidTime()
22864 |  56 | 
22865 |  57 |         data = {k: int(v) for k, v in match.groupdict(default=0).items()}
22866 |  58 |         now = dtm.datetime.now(tz=IST)
22867 |  59 |         self.dt = now + relativedelta(**data)
22868 |  60 | 
22869 |  61 |     @classmethod
22870 |  62 |     async def convert(cls, ctx, argument):
22871 |  63 |         return cls(argument, now=dtm.datetime.now(tz=IST))
22872 |  64 | 
22873 |  65 | 
22874 |  66 | class HumanTime:
22875 |  67 |     calendar = pdt.Calendar(version=pdt.VERSION_CONTEXT_STYLE)
22876 |  68 | 
22877 |  69 |     def __init__(self, argument, *, now=None):
22878 |  70 |         now = now or dtm.datetime.now(tz=IST)
22879 |  71 |         dt, status = self.calendar.parseDT(argument, sourceTime=now)
22880 |  72 |         if not status.hasDateOrTime:
22881 |  73 |             raise exceptions.InvalidTime()
22882 |  74 | 
22883 |  75 |         dt = dt.replace(tzinfo=IST)
22884 |  76 | 
22885 |  77 |         if not status.hasTime:
22886 |  78 |             # replace it with the current time
22887 |  79 |             dt = dt.replace(hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
22888 |  80 | 
22889 |  81 |         self.dt = dt
22890 |  82 |         self._past = dt < now
22891 |  83 | 
22892 |  84 |     @classmethod
22893 |  85 |     async def convert(cls, ctx, argument):
22894 |  86 |         return cls(argument, now=ctx.message.created_at)
22895 |  87 | 
22896 |  88 | 
22897 |  89 | class Time(HumanTime):
22898 |  90 |     def __init__(self, argument, *, now=None):
22899 |  91 |         try:
22900 |  92 |             o = ShortTime(argument, now=now)
22901 |  93 |         except Exception as e:
22902 |  94 |             super().__init__(argument)
22903 |  95 |         else:
22904 |  96 |             self.dt = o.dt
22905 |  97 |             self._past = False
22906 |  98 | 
22907 |  99 | 
22908 | 100 | class FutureTime(Time):
22909 | 101 |     def __init__(self, argument, *, now=None):
22910 | 102 |         super().__init__(argument, now=dtm.datetime.now(tz=IST))
22911 | 103 | 
22912 | 104 |         if self._past:
22913 | 105 |             raise exceptions.PastTime()
22914 | 106 | 
22915 | 107 | 
22916 | 108 | class BetterFutureTime:
22917 | 109 |     @classmethod
22918 | 110 |     async def convert(cls, ctx, argument: str):
22919 | 111 |         if not "in" in argument:
22920 | 112 |             argument = "in " + argument
22921 | 113 | 
22922 | 114 |         parsed = dateparser.parse(
22923 | 115 |             argument,
22924 | 116 |             settings={
22925 | 117 |                 # "RELATIVE_BASE": dtm.datetime.now(tz=IST),
22926 | 118 |                 "TIMEZONE": "Asia/Kolkata",
22927 | 119 |                 "RETURN_AS_TIMEZONE_AWARE": True,
22928 | 120 |             },
22929 | 121 |         )
22930 | 122 |         if not parsed:
22931 | 123 |             raise exceptions.InvalidTime()
22932 | 124 | 
22933 | 125 |         if dtm.datetime.now(tz=IST) > parsed:
22934 | 126 |             parsed = parsed + dtm.timedelta(hours=24)
22935 | 127 | 
22936 | 128 |         if parsed < dtm.datetime.now(tz=IST):
22937 | 129 |             raise exceptions.PastTime()
22938 | 130 | 
22939 | 131 |         return parsed
22940 | 132 | 
22941 | 133 | 
22942 | 134 | def time(target):
22943 | 135 |     return target.strftime("%d-%b-%Y %I:%M %p")
22944 | 136 | 
22945 | 137 | 
22946 | 138 | def day_today():
22947 | 139 |     return dtm.datetime.now().strftime("%A").lower()
22948 | 140 | 
22949 | 141 | 
22950 | 142 | def strtime(target):
22951 | 143 |     return target.strftime("%d-%b-%Y %I:%M %p")
22952 | 144 | 
22953 | 145 | 
22954 | 146 | def discord_timestamp(time_to_convert, mode="R"):
22955 | 147 |     formated_strftime = f"<t:{int(time_to_convert.timestamp())}:{mode}>"
22956 | 148 | 
22957 | 149 |     return formated_strftime
22958 | 150 | 
22959 | 151 | 
22960 | 152 | # def strtime(target):
22961 | 153 | #     return f"<t:{int(target.timestamp())}:R>"
22962 | 154 | 
22963 | 155 | 
22964 | 156 | def human_join(seq, delim=", ", final="or"):
22965 | 157 |     size = len(seq)
22966 | 158 |     if size == 0:
22967 | 159 |         return ""
22968 | 160 | 
22969 | 161 |     if size == 1:
22970 | 162 |         return seq[0]
22971 | 163 | 
22972 | 164 |     if size == 2:
22973 | 165 |         return f"{seq[0]} {final} {seq[1]}"
22974 | 166 | 
22975 | 167 |     return delim.join(seq[:-1]) + f" {final} {seq[-1]}"
22976 | 168 | 
22977 | 169 | 
22978 | 170 | def human_timedelta(dt, *, source=None, accuracy=3, brief=False, suffix=True):
22979 | 171 |     now = source or dtm.datetime.now(tz=IST)
22980 | 172 |     # Microsecond free zone
22981 | 173 |     now = now.replace(microsecond=0)
22982 | 174 |     dt = dt.replace(microsecond=0)
22983 | 175 | 
22984 | 176 |     # This implementation uses relativedelta instead of the much more obvious
22985 | 177 |     # divmod approach with seconds because the seconds approach is not entirely
22986 | 178 |     # accurate once you go over 1 week in terms of accuracy since you have to
22987 | 179 |     # hardcode a month as 30 or 31 days.
22988 | 180 |     # A query like "11 months" can be interpreted as "!1 months and 6 days"
22989 | 181 |     if dt > now:
22990 | 182 |         delta = relativedelta(dt, now)
22991 | 183 |         suffix = ""
22992 | 184 |     else:
22993 | 185 |         delta = relativedelta(now, dt)
22994 | 186 |         suffix = " ago" if suffix else ""
22995 | 187 | 
22996 | 188 |     attrs = [
22997 | 189 |         ("year", "y"),
22998 | 190 |         ("month", "mo"),
22999 | 191 |         ("day", "d"),
23000 | 192 |         ("hour", "h"),
23001 | 193 |         ("minute", "m"),
23002 | 194 |         ("second", "s"),
23003 | 195 |     ]
23004 | 196 | 
23005 | 197 |     output = []
23006 | 198 |     for attr, brief_attr in attrs:
23007 | 199 |         elem = getattr(delta, attr + "s")
23008 | 200 |         if not elem:
23009 | 201 |             continue
23010 | 202 | 
23011 | 203 |         if attr == "day":
23012 | 204 |             weeks = delta.weeks
23013 | 205 |             if weeks:
23014 | 206 |                 elem -= weeks * 7
23015 | 207 |                 if not brief:
23016 | 208 |                     output.append(format(plural(weeks), "week"))
23017 | 209 |                 else:
23018 | 210 |                     output.append(f"{weeks}w")
23019 | 211 | 
23020 | 212 |         if elem <= 0:
23021 | 213 |             continue
23022 | 214 | 
23023 | 215 |         if brief:
23024 | 216 |             output.append(f"{elem}{brief_attr}")
23025 | 217 |         else:
23026 | 218 |             output.append(format(plural(elem), attr))
23027 | 219 | 
23028 | 220 |     if accuracy is not None:
23029 | 221 |         output = output[:accuracy]
23030 | 222 | 
23031 | 223 |     if len(output) == 0:
23032 | 224 |         return "now"
23033 | 225 |     if not brief:
23034 | 226 |         return human_join(output, final="and") + suffix
23035 | 227 |     return " ".join(output) + suffix
23036 | 228 | 
23037 | 229 | 
23038 | 230 | time_dict = {"h": 3600, "s": 1, "m": 60, "d": 86400}
23039 | 231 | 
23040 | 232 | 
23041 | 233 | def simple_convert(argument):
23042 | 234 |     args = argument.lower()
23043 | 235 |     matches = re.findall(TIME_REGEX, args)
23044 | 236 |     time = 0
23045 | 237 |     for key, value in matches:
23046 | 238 |         try:
23047 | 239 |             time += time_dict[value] * float(key)
23048 | 240 |         except KeyError:
23049 | 241 |             raise commands.BadArgument(f"{value} is an invalid time key! h|m|s|d are valid arguments")
23050 | 242 |         except ValueError:
23051 | 243 |             raise commands.BadArgument(f"{key} is not a number!")
23052 | 244 | 
23053 | 245 |     return round(time)
23054 | 246 | 
23055 | 247 | 
23056 | 248 | class TimeText(commands.Converter):
23057 | 249 |     def __init__(self, converter=None):
23058 | 250 |         self.converter = converter
23059 | 251 | 
23060 | 252 |     def __final_checks(self, dt, remaining=None):
23061 | 253 |         self.arg = remaining
23062 | 254 |         if remaining and remaining.strip() == "":
23063 | 255 |             self.arg = None
23064 | 256 | 
23065 | 257 |         self.dt = dt
23066 | 258 |         if self.dt:
23067 | 259 |             while self.dt < dtm.datetime.now():
23068 | 260 |                 self.dt += dtm.timedelta(days=1)
23069 | 261 | 
23070 | 262 |             self.dt = IST.localize(self.dt)
23071 | 263 |         return self
23072 | 264 | 
23073 | 265 |     async def convert(self, ctx: Context, argument: str):
23074 | 266 |         try:
23075 | 267 |             calendar = HumanTime.calendar
23076 | 268 |             regex = ShortTime.compiled
23077 | 269 |             now = dtm.datetime.now()
23078 | 270 | 
23079 | 271 |             match = regex.match(argument)
23080 | 272 |             if match is not None and match.group(0):
23081 | 273 |                 data = {k: int(v) for k, v in match.groupdict(default=0).items()}
23082 | 274 |                 remaining = argument[match.end() :].strip()
23083 | 275 |                 dt = now + relativedelta(**data)
23084 | 276 | 
23085 | 277 |                 return self.__final_checks(dt, remaining)
23086 | 278 | 
23087 | 279 |             if argument.endswith("from now"):
23088 | 280 |                 argument = argument[:-8].strip()
23089 | 281 | 
23090 | 282 |             if argument[0:2] == "me":
23091 | 283 |                 # starts with "me to", "me in", or "me at "
23092 | 284 |                 if argument[0:6] in ("me to ", "me in ", "me at "):
23093 | 285 |                     argument = argument[6:]
23094 | 286 | 
23095 | 287 |             elements = calendar.nlp(argument, sourceTime=now)
23096 | 288 |             if elements is None or len(elements) == 0:
23097 | 289 |                 return self.__final_checks(None, argument)
23098 | 290 | 
23099 | 291 |             dt, status, begin, end, dt_string = elements[0]
23100 | 292 | 
23101 | 293 |             if begin in (0, 1):
23102 | 294 |                 if begin == 1:
23103 | 295 |                     remaining = argument[end + 1 :].lstrip(" ,.!")
23104 | 296 |                 else:
23105 | 297 |                     remaining = argument[end:].lstrip(" ,.!")
23106 | 298 | 
23107 | 299 |             elif len(argument) == end:
23108 | 300 |                 remaining = argument[:begin].strip()
23109 | 301 | 
23110 | 302 |             if not status.hasDateOrTime:
23111 | 303 |                 return self.__final_checks(None, remaining)
23112 | 304 | 
23113 | 305 |             if status.accuracy == pdt.pdtContext.ACU_HALFDAY:
23114 | 306 |                 dt = dt.replace(day=now.day + 1)
23115 | 307 | 
23116 | 308 |             return self.__final_checks(dt, remaining)
23117 | 309 | 
23118 | 310 |         except:
23119 | 311 |             import traceback
23120 | 312 | 
23121 | 313 |             traceback.print_exc()
23122 | 314 |             raise
23123 | 315 | 
23124 | 
23125 | 
23126 | --------------------------------------------------------------------------------
23127 | 


--------------------------------------------------------------------------------
/__pycache__/config.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/__pycache__/config.cpython-312.pyc


--------------------------------------------------------------------------------
/__pycache__/constants.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/__pycache__/constants.cpython-312.pyc


--------------------------------------------------------------------------------
/aerich.ini:
--------------------------------------------------------------------------------
1 | [aerich]
2 | tortoise_orm = config.TORTOISE
3 | location = ./migrations
4 | 
5 | 


--------------------------------------------------------------------------------
/bot.py:
--------------------------------------------------------------------------------
1 | if __name__ == "__main__":
2 |     from core import bot
3 | 
4 |     bot.run(bot.config.DISCORD_TOKEN)
5 | 


--------------------------------------------------------------------------------
/cogs/esports/__init__.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | 
  5 | from cogs.esports.events.slots import SlotManagerEvents
  6 | from cogs.esports.views.scrims.main import ScrimsMain
  7 | from cogs.esports.views.tourney.main import TourneyManager
  8 | 
  9 | if typing.TYPE_CHECKING:
 10 |     from core import Quotient
 11 | 
 12 | import discord
 13 | from discord.ext import commands
 14 | 
 15 | from core import Cog, Context, QuotientView
 16 | from models import *
 17 | from utils import QuoRole, QuoTextChannel, checks
 18 | 
 19 | from .errors import SMError
 20 | from .events import ScrimEvents, Ssverification, TagEvents, TourneyEvents
 21 | from .helpers import delete_denied_message
 22 | from .slash import *
 23 | from .views import *
 24 | 
 25 | 
 26 | class ScrimManager(Cog, name="Esports"):
 27 |     def __init__(self, bot: Quotient):
 28 |         self.bot = bot
 29 | 
 30 |     # ************************************************************************************************
 31 |     @Cog.listener()
 32 |     async def on_message_delete(self, message: discord.Message):
 33 |         if not message.guild or message.author.bot:
 34 |             return
 35 | 
 36 |         if message.channel.id in self.bot.cache.scrim_channels:
 37 |             scrim = await Scrim.get_or_none(registration_channel_id=message.channel.id)
 38 |             if not scrim or not scrim.opened_at:  # either scrim doesn't exist or it is closed.
 39 |                 return
 40 | 
 41 |             if not message.id in (record.message_id for record in await scrim.assigned_slots.all()):
 42 |                 return
 43 | 
 44 |             slot = [
 45 |                 slot
 46 |                 for slot in await scrim.assigned_slots.all()
 47 |                 if slot.user_id == message.author.id and slot.message_id == message.id
 48 |             ]
 49 |             if not slot:  # means their registration was denied
 50 |                 return
 51 |             slot = slot[0]
 52 | 
 53 |             self.bot.dispatch("scrim_registration_delete", scrim, message, slot)
 54 | 
 55 |     # ************************************************************************************************
 56 | 
 57 |     @commands.command(aliases=("s", "sm"))
 58 |     @commands.bot_has_permissions(embed_links=True, add_reactions=True, manage_messages=True)
 59 |     @commands.bot_has_guild_permissions(manage_channels=True, manage_roles=True, manage_messages=True)
 60 |     @commands.cooldown(1, 15, type=commands.BucketType.guild)
 61 |     async def smanager(self, ctx: Context):
 62 |         """
 63 |         Contains commands related to Quotient's powerful scrims manager.
 64 |         """
 65 |         if not any((ctx.author.guild_permissions.manage_guild, Scrim.is_ignorable(ctx.author))):
 66 |             return await ctx.error(f"You need `scrims-mod` role or `Manage-Server` permissions to use this command.")
 67 | 
 68 |         v = ScrimsMain(ctx)
 69 |         v.message = await ctx.send(embed=await v.initial_embed(), view=v)
 70 | 
 71 |     # ************************************************************************************************
 72 |     # ************************************************************************************************
 73 | 
 74 |     @commands.command(aliases=("tm", "t"))
 75 |     @commands.bot_has_permissions(embed_links=True, add_reactions=True, manage_messages=True)
 76 |     @commands.bot_has_guild_permissions(
 77 |         manage_channels=True, manage_permissions=True, manage_roles=True, manage_messages=True
 78 |     )
 79 |     @commands.cooldown(1, 15, type=commands.BucketType.guild)
 80 |     async def tourney(self, ctx: Context):
 81 |         """Create & Manage tournaments with Quotient"""
 82 |         if not Tourney.is_ignorable(ctx.author) and not ctx.author.guild_permissions.manage_guild:
 83 |             return await ctx.error(
 84 |                 "You need either `Manage Server` permissions or `@tourney-mod` role to manage tournaments."
 85 |             )
 86 | 
 87 |         view = TourneyManager(ctx)
 88 |         view.add_item(QuotientView.tricky_invite_button())
 89 |         view.message = await ctx.send(embed=await view.initial_embed(), view=view)
 90 | 
 91 |     @commands.hybrid_command(
 92 |         aliases=("quickidp",),
 93 |         extras={"examples": ["idp 1234 pass Miramar", "idp 1234 pass Sanhok @role"]},
 94 |     )
 95 |     @commands.bot_has_permissions(embed_links=True, manage_messages=True)
 96 |     @checks.can_use_sm()
 97 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
 98 |     async def idp(self, ctx: Context, room_id: str, password: str, map: str, role_to_ping: Optional[discord.Role] = None):
 99 |         """
100 |         Share Id/pass with embed quickly.
101 |         Message is automatically deleted after 30 minutes.
102 |         """
103 |         await ctx.message.delete(delay=0)
104 |         room_id, password, map = truncate_string(room_id, 100), truncate_string(password, 100), truncate_string(map, 100)
105 | 
106 |         _e = discord.Embed(color=self.bot.color)
107 |         _e.set_thumbnail(url=getattr(ctx.guild.icon, "url", self.bot.user.avatar.url))
108 |         _e.set_author(name=ctx.author, icon_url=ctx.author.display_avatar.url)
109 |         _e.add_field(name="Room ID", value=room_id)
110 |         _e.add_field(name="Password", value=password)
111 |         _e.add_field(name="Map", value=map)
112 |         _e.set_footer(text=f"Auto-delete time")
113 |         _e.timestamp = self.bot.current_time + timedelta(minutes=30)
114 | 
115 |         view = IdpView(room_id, password, map)
116 |         msg = await ctx.send(
117 |             content=role_to_ping.mention if role_to_ping else None,
118 |             embed=_e,
119 |             view=view,
120 |             allowed_mentions=discord.AllowedMentions(roles=True),
121 |         )
122 |         await self.bot.wait_and_delete(msg, 30 * 60)
123 | 
124 |     @commands.group(aliases=("eztag",), invoke_without_command=True)
125 |     async def easytag(self, ctx: Context):
126 |         """Commands related to quotient's eztag"""
127 |         await ctx.send_help(ctx.command)
128 | 
129 |     @easytag.command(name="set", extras={"examples": ["eztag set #channel"]})
130 |     # @checks.has_done_setup()
131 |     @commands.bot_has_guild_permissions(manage_roles=True)
132 |     @commands.has_permissions(manage_guild=True)
133 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
134 |     async def set_eztag(self, ctx: Context, *, channel: QuoTextChannel):
135 |         """Set a channel as eztag channel."""
136 |         count = await EasyTag.filter(guild_id=ctx.guild.id).count()
137 |         guild = await Guild.get(guild_id=ctx.guild.id)
138 | 
139 |         if count == 1 and not guild.is_premium:
140 |             return await ctx.error(
141 |                 f"Upgrade your server to Quotient Premium to setup more than 1 EasyTag channel.\n[Click Me to Purchase]({self.bot.prime_link})"
142 |             )
143 | 
144 |         if channel.id in self.bot.cache.eztagchannels:
145 |             return await ctx.error(f"This channel is already a easy tag channel.")
146 | 
147 |         if (
148 |             not channel.permissions_for(ctx.me).send_messages
149 |             or not channel.permissions_for(ctx.me).embed_links
150 |             or not channel.permissions_for(ctx.me).manage_messages
151 |         ):
152 |             return await ctx.error(
153 |                 f"I need `send messages`, `embed links` and `manage messages` permission in {channel.mention}"
154 |             )
155 | 
156 |         role = discord.utils.get(ctx.guild.roles, name="quotient-tag-ignore")
157 |         if not role:
158 |             role = await ctx.guild.create_role(
159 |                 name="quotient-tag-ignore", color=self.bot.color, reason=f"Created by {ctx.author}"
160 |             )
161 | 
162 |         await EasyTag.create(guild_id=ctx.guild.id, channel_id=channel.id)
163 |         self.bot.cache.eztagchannels.add(channel.id)
164 | 
165 |         embed = self.bot.embed(ctx, title="Easy Tagging")
166 |         embed.description = """
167 |         Unable to mention teammates while registering for scrims or tournaments? Quotient is here for the rescue.
168 | 
169 |         Use `teammate's ID`, `@teammate_name` or `@teammate's_discord_tag` in your registration format. Quotient will convert that into an actual discord tag.        
170 |         """
171 |         embed.set_image(url="https://media.discordapp.net/attachments/775707108192157706/850788091236450344/eztags.gif")
172 |         msg = await channel.send(embed=embed)
173 |         await msg.pin()
174 | 
175 |         await ctx.success(
176 |             f"Successfully added **{channel}** to easy tag channels.\n\nAdd {role.mention} to your roles to ignore your messages in **{channel}**"
177 |         )
178 | 
179 |     @easytag.command(name="remove", extras={"examples": ["eztag remove #channel"]})
180 |     # @checks.has_done_setup()
181 |     @commands.has_permissions(manage_guild=True)
182 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
183 |     async def remove_eztag(self, ctx: Context, *, channel: QuoTextChannel):
184 |         """Remove a eztag channel"""
185 |         if not channel.id in self.bot.cache.eztagchannels:
186 |             return await ctx.error(f"This is not a EasyTag channel.")
187 | 
188 |         await EasyTag.filter(channel_id=channel.id).delete()
189 |         self.bot.cache.eztagchannels.discard(channel.id)
190 |         await ctx.success(f"Removed {channel} from EasyTag channels.")
191 | 
192 |     @easytag.command(name="config")
193 |     # @checks.has_done_setup()
194 |     @commands.has_permissions(manage_guild=True)
195 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
196 |     async def config_eztag(self, ctx: Context):
197 |         """Get a list of all your easytag channels."""
198 |         records = await EasyTag.filter(guild_id=ctx.guild.id)
199 |         if not records:
200 |             return await ctx.error(
201 |                 f"You haven't set any easytag channel yet.\n\nUse `{ctx.prefix}eztag set #{ctx.channel}`"
202 |             )
203 | 
204 |         eztags = []
205 |         for idx, record in enumerate(records, start=1):
206 |             channel = getattr(record.channel, "mention", record.channel_id)
207 |             eztags.append(
208 |                 f"`{idx:02}.` {channel} (Delete After: {record.delete_after if record.delete_after else 'Not Set'})"
209 |             )
210 | 
211 |         embed = self.bot.embed(ctx, title="EasyTag config", description="\n".join(eztags))
212 |         await ctx.send(embed=embed)
213 | 
214 |     @easytag.command(name="autodelete", extras={"examples": ["eztag autodelete #channel"]})
215 |     #    @checks.has_done_setup()
216 |     @commands.has_permissions(manage_guild=True)
217 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
218 |     async def delete_eztag(self, ctx: Context, channel: QuoTextChannel):
219 |         """Enable/Disable autodelete for eztag."""
220 |         record = await EasyTag.get_or_none(channel_id=channel.id)
221 |         if not record:
222 |             return await ctx.error(f"This is not a EasyTag Channel.")
223 | 
224 |         await EasyTag.filter(channel_id=channel.id).update(delete_after=not record.delete_after)
225 |         await ctx.success(
226 |             f"Delete After for **{channel}** turned {'ON' if not record.delete_after else 'OFF'}!\n\nDelete After automatically deletes the format message after some time."
227 |         )
228 | 
229 |     # ************************************************************************************************
230 |     # ************************************************************************************************
231 |     # ************************************************************************************************
232 |     # ************************************************************************************************
233 |     # ************************************************************************************************
234 |     # ************************************************************************************************
235 |     # ************************************************************************************************
236 | 
237 |     @commands.group(invoke_without_command=True, aliases=("tc",))
238 |     async def tagcheck(self, ctx: Context):
239 |         """
240 |         Setup tagcheck channels for scrims/tournaments.
241 |         """
242 |         await ctx.send_help(ctx.command)
243 | 
244 |     @tagcheck.command(name="set", extras={"examples": ["tc set #channel 4", "tagcheck set #channel 2"]})
245 |     @commands.has_permissions(manage_guild=True)
246 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
247 |     # @checks.has_done_setup()
248 |     async def tagcheck_set(self, ctx: Context, channel: discord.TextChannel, mentions: int = 4):
249 |         """
250 |         Set a channel for tagcheck.
251 |         mentions defines required mentions, It's 4 by default.
252 |         """
253 |         count = await TagCheck.filter(guild_id=ctx.guild.id).count()
254 |         guild = await Guild.get(guild_id=ctx.guild.id)
255 | 
256 |         if count == 1 and not guild.is_premium:
257 |             return await ctx.error(
258 |                 f"Upgrade your server to Quotient Premium to setup more than 1 Tagcheck channel.\n[Click Me to Purchase]({self.bot.prime_link})"
259 |             )
260 | 
261 |         if channel.id in self.bot.cache.tagcheck:
262 |             return await ctx.error(f"This channel is already a tagcheck channel.")
263 | 
264 |         if (
265 |             not channel.permissions_for(ctx.me).send_messages
266 |             or not channel.permissions_for(ctx.me).embed_links
267 |             or not channel.permissions_for(ctx.me).manage_messages
268 |         ):
269 |             return await ctx.error(
270 |                 f"I need `send_messages`, `embed_links` and `manage_messages` permission in {channel.mention}"
271 |             )
272 | 
273 |         role = discord.utils.get(ctx.guild.roles, name="quotient-tag-ignore")
274 |         if not role:
275 |             role = await ctx.guild.create_role(
276 |                 name="quotient-tag-ignore", color=self.bot.color, reason=f"Created by {ctx.author}"
277 |             )
278 | 
279 |         await TagCheck.create(guild_id=ctx.guild.id, channel_id=channel.id, required_mentions=mentions)
280 |         self.bot.cache.tagcheck.add(channel.id)
281 | 
282 |         await ctx.success(
283 |             f"Successfully added **{channel}** to tagcheck channels.\n\nAdd {role.mention} to your roles to ignore your messages in **{channel}**"
284 |         )
285 | 
286 |     @tagcheck.command(name="config")
287 |     # @checks.has_done_setup()
288 |     @commands.has_permissions(manage_guild=True)
289 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
290 |     async def tagcheck_config(self, ctx: Context):
291 |         """
292 |         Get tagcheck config.
293 |         """
294 |         records = await TagCheck.filter(guild_id=ctx.guild.id)
295 |         if not records:
296 |             return await ctx.error(
297 |                 f"You haven't set any tagcheck channel yet.\n\nUse `{ctx.prefix}tagcheck set #{ctx.channel}`"
298 |             )
299 | 
300 |         tags = []
301 |         for idx, record in enumerate(records, start=1):
302 |             channel = getattr(record.channel, "mention", record.channel_id)
303 |             tags.append(
304 |                 f"`{idx:02}.` {channel} (Mentions: {record.required_mentions},Auto-delete: {record.delete_after if record.delete_after else 'Not Set'})"
305 |             )
306 | 
307 |         embed = self.bot.embed(ctx, title="TagCheck config", description="\n".join(tags))
308 |         await ctx.send(embed=embed)
309 | 
310 |     @tagcheck.command(name="remove", extras={"examples": ["tagcheck remove #channel"]})
311 |     @commands.has_permissions(manage_guild=True)
312 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
313 |     async def tagcheck_remove(self, ctx: Context, *, channel: QuoTextChannel):
314 |         """Remove a channel from tagcheck"""
315 |         if not channel.id in self.bot.cache.tagcheck:
316 |             return await ctx.error(f"This is not a TagCheck channel.")
317 | 
318 |         await TagCheck.filter(channel_id=channel.id).delete()
319 |         self.bot.cache.tagcheck.discard(channel.id)
320 |         await ctx.success(f"Removed {channel} from TagCheck channels.")
321 | 
322 |     @tagcheck.command(name="autodelete", extras={"examples": ["tagcheck autodelete #channel"]})
323 |     @commands.has_permissions(manage_guild=True)
324 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
325 |     async def tagcheck_autodelete(self, ctx: Context, *, channel: QuoTextChannel):
326 |         """Enable/Disable autodelete wrong tagchecks."""
327 |         record = await TagCheck.get_or_none(channel_id=channel.id)
328 |         if not record:
329 |             return await ctx.error(f"This is not a TagCheck Channel.")
330 | 
331 |         await TagCheck.filter(channel_id=channel.id).update(delete_after=not record.delete_after)
332 |         await ctx.success(
333 |             f"Autodelete for **{channel}** turned {'ON' if not record.delete_after else 'OFF'}!\nThis automatically deletes the wrong format message after some time."
334 |         )
335 | 
336 |     # ************************************************************************************************
337 |     # ************************************************************************************************
338 |     # ************************************************************************************************
339 |     # ************************************************************************************************
340 |     # ************************************************************************************************
341 |     # ************************************************************************************************
342 |     # ************************************************************************************************
343 | 
344 |     @commands.command(aliases=("slotm",))
345 |     @checks.can_use_sm()
346 |     @commands.bot_has_guild_permissions(embed_links=True, manage_messages=True, manage_channels=True)
347 |     # # @checks.has_done_setup()
348 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
349 |     async def slotmanager(self, ctx: Context):
350 |         """
351 |         SlotManager helps people to setup scrims-slots cancel and claim manager.
352 |         Users can easily claim and cancel their slots anytime without bothering mods.
353 |         """
354 |         _view = ScrimsSlotManagerSetup(ctx)
355 |         _e = await _view.initial_message(ctx.guild)
356 |         _view.add_item(QuotientView.tricky_invite_button())
357 |         _view.message = await ctx.send(embed=_e, view=_view, embed_perms=True)
358 | 
359 |     @commands.command(name="banlog", extras={"examples": ["banlog #channel"]})
360 |     @checks.can_use_sm()
361 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
362 |     async def _banlog(self, ctx: Context, *, channel: discord.TextChannel = None):
363 |         """
364 |         Set a channel for all scrims ban/unban logs
365 |         """
366 |         if not channel:
367 |             record = await BanLog.get_or_none(guild_id=ctx.guild.id)
368 |             if not record:
369 |                 return await ctx.simple(
370 |                     f"You haven't setup any esports ban log channel yet.\n"
371 |                     f"Use `{ctx.prefix}banlog #{ctx.channel}` to do it."
372 |                 )
373 |             return await ctx.simple(
374 |                 f"Currently {getattr(record.channel, 'mention', 'deleted-channel')} is serving as ban/unban log channel."
375 |             )
376 |         if not channel.permissions_for(ctx.me).embed_links:
377 |             return await ctx.error(f"I need `embed_links` permission in {channel.mention} to send logs.")
378 | 
379 |         await BanLog.update_or_create(guild_id=ctx.guild.id, defaults={"channel_id": channel.id})
380 |         await ctx.success(f"Successfully set {channel.mention} as esports ban/unban log channel.")
381 | 
382 |     @commands.group(invoke_without_command=True, aliases=("ss",))
383 |     @checks.can_use_tm()
384 |     @commands.cooldown(1, 10, type=commands.BucketType.guild)
385 |     @commands.bot_has_permissions(manage_channels=True, add_reactions=True, embed_links=True, manage_roles=True)
386 |     async def ssverify(self, ctx: Context):
387 |         """
388 |         Setup/Edit ssverification in your server
389 |         """
390 |         if not await ctx.is_premium_guild():
391 |             if not ctx.guild.member_count > 100 and not ctx.guild.id == 779229001986080779:
392 |                 return await ctx.error("Your server must have atleast 100 members to setup ssverification.")
393 | 
394 |         _view = SsmodMainView(ctx)
395 |         _view.message = await ctx.send(embed=await _view.initial_message(), view=_view, embed_perms=True)
396 | 
397 | 
398 | async def setup(bot: Quotient):
399 |     await bot.add_cog(ScrimManager(bot))
400 |     await bot.add_cog(SMError(bot))
401 |     await bot.add_cog(ScrimEvents(bot))
402 |     await bot.add_cog(TourneyEvents(bot))
403 |     await bot.add_cog(TagEvents(bot))
404 |     await bot.add_cog(Ssverification(bot))
405 |     await bot.add_cog(SlotManagerEvents(bot))
406 |     await bot.add_cog(SlashCog(bot))
407 | 


--------------------------------------------------------------------------------
/cogs/esports/errors.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | 
  5 | if typing.TYPE_CHECKING:
  6 |     from core import Quotient
  7 | 
  8 | from contextlib import suppress
  9 | 
 10 | import discord
 11 | 
 12 | from constants import EsportsLog, EsportsRole, RegDeny
 13 | from core import Cog
 14 | from models import ArrayAppend, AssignedSlot, EasyTag, ReservedSlot, Scrim, TagCheck, Timer, Tourney
 15 | from utils import plural
 16 | 
 17 | from .helpers import delete_denied_message, scrim_work_role, tourney_work_role
 18 | 
 19 | 
 20 | class SMError(Cog):
 21 |     def __init__(self, bot: Quotient):
 22 |         self.bot = bot
 23 | 
 24 |     @staticmethod
 25 |     def red_embed(description: str):
 26 |         embed = discord.Embed(color=discord.Color.red(), description=description)
 27 |         return embed
 28 | 
 29 |     @Cog.listener()
 30 |     async def on_tourney_registration_deny(self, message: discord.Message, _type: RegDeny, tourney: Tourney, **kwargs):
 31 |         logschan = tourney.logschan
 32 |         if not logschan:
 33 |             return
 34 | 
 35 |         text = f"Registration of [{str(message.author)}]({message.jump_url}) has been denied in {message.channel.mention}\n**Reason:** "
 36 | 
 37 |         with suppress(discord.NotFound, discord.NotFound, AttributeError, discord.HTTPException):
 38 |             await message.add_reaction(tourney.cross_emoji)
 39 | 
 40 |             if _type == RegDeny.botmention:
 41 |                 await message.reply(
 42 |                     embed=self.red_embed("Don't mention Bots. Mention your real teammates."),
 43 |                     delete_after=5,
 44 |                 )
 45 |                 text += f"Mentioned Bots."
 46 | 
 47 |             elif _type == RegDeny.nomention:
 48 |                 await message.reply(
 49 |                     embed=self.red_embed(
 50 |                         f"{str(message.author)}, **`{plural(tourney.required_mentions):mention is |mentions are}`** required for successful registration."
 51 |                     ),
 52 |                     delete_after=5,
 53 |                 )
 54 | 
 55 |                 text += f"Insufficient Mentions (`{len(message.mentions)}/{tourney.required_mentions}`)"
 56 | 
 57 |             elif _type == RegDeny.banned:
 58 |                 await message.reply(
 59 |                     embed=self.red_embed(
 60 |                         f"{str(message.author)}, You are banned from the tournament. You cannot register."
 61 |                     ),
 62 |                     delete_after=5,
 63 |                 )
 64 |                 text += f"They are banned from tournament."
 65 | 
 66 |             elif _type == RegDeny.multiregister:
 67 |                 await message.reply(
 68 |                     embed=self.red_embed(f"{str(message.author)}, This server doesn't allow multiple registerations."),
 69 |                     delete_after=5,
 70 |                 )
 71 | 
 72 |                 text += f"They have already registered once.\n\nIf you wish to allow multiple registerations,\nuse: `tourney edit {tourney.id}`"
 73 | 
 74 |             elif _type == RegDeny.noteamname:
 75 |                 await message.reply(
 76 |                     embed=self.red_embed(f"{str(message.author)}, Team Name is required to register."),
 77 |                     delete_after=5,
 78 |                 )
 79 |                 text += f"Teamname compulsion is on and I couldn't find teamname in their registration\n\nIf you wish allow without teamname,\nUse: `tourney edit {tourney.id}`"
 80 | 
 81 |             elif _type == RegDeny.duplicate:
 82 |                 await message.reply(
 83 |                     embed=self.red_embed(f"{str(message.author)}, Someone already registered with the same team name."),
 84 |                     delete_after=5,
 85 |                 )
 86 |                 text += f"Duplicate teamname. Someone already registered with the same team name."
 87 | 
 88 |             elif _type == RegDeny.nolines:
 89 |                 await message.reply(
 90 |                     embed=self.red_embed(
 91 |                         f"{str(message.author)}, Your registration message is too short. It seems you missed some required information."
 92 |                     ),
 93 |                     delete_after=5,
 94 |                 )
 95 |                 text += f"Insufficient lines in their registration message."
 96 | 
 97 |             elif _type == RegDeny.faketag:
 98 |                 records = kwargs.get("records")
 99 |                 jump_url = records[0]["jump_url"]
100 | 
101 |                 await message.reply(
102 |                     embed=self.red_embed(
103 |                         f"{str(message.author)}, Someone already registered with the same mentions {jump_url}"
104 |                         "\n\n`If you think this is a mistake contact moderators ASAP.`"
105 |                     ),
106 |                     delete_after=10,
107 |                 )
108 |                 text += f"Fake tag used. {jump_url}"
109 | 
110 |             if tourney.autodelete_rejected:
111 |                 self.bot.loop.create_task(delete_denied_message(message))
112 | 
113 |             embed = discord.Embed(color=discord.Color.red(), description=text)
114 |             with suppress(discord.Forbidden):
115 |                 return await logschan.send(embed=embed)
116 | 
117 |     @Cog.listener()
118 |     async def on_tourney_log(self, _type: EsportsLog, tourney: Tourney, **kwargs):
119 |         """
120 |         Same as on_scrim_log but for tourneys
121 |         """
122 |         logschan = tourney.logschan
123 |         if not logschan:
124 |             return
125 | 
126 |         registration_channel = tourney.registration_channel
127 |         modrole = tourney.modrole
128 | 
129 |         open_role = tourney_work_role(tourney, EsportsRole.open)
130 |         important = False
131 | 
132 |         embed = discord.Embed(color=0x00B1FF)
133 |         if _type == EsportsLog.closed:
134 |             permission_updated = kwargs.get("permission_updated")
135 | 
136 |             embed.description = (
137 |                 f"Registration closed for {open_role} in {registration_channel.mention}(TourneyID: `{tourney.id}`)"
138 |             )
139 |             if not permission_updated:
140 |                 important = True
141 |                 embed.color = discord.Color.red()
142 |                 embed.description += f"\nI couldn't close {registration_channel.mention}."
143 | 
144 |         elif _type == EsportsLog.success:
145 |             message: discord.Message = kwargs.get("message")
146 |             embed.color = discord.Color.green()
147 |             embed.description = (
148 |                 f"Registration of [{message.author}]({message.jump_url}) has been accepted in {message.channel.mention}"
149 |             )
150 | 
151 |         with suppress(discord.Forbidden, AttributeError):
152 |             await logschan.send(
153 |                 content=modrole.mention if modrole is not None and important is True else None,
154 |                 embed=embed,
155 |                 allowed_mentions=discord.AllowedMentions(roles=True),
156 |             )
157 | 
158 |     @Cog.listener()
159 |     async def on_scrim_log(self, _type: EsportsLog, scrim: Scrim, **kwargs):
160 |         """
161 |         A listener that is dispatched everytime registration starts/ends or a registration is accepted.
162 |         """
163 |         logschan = scrim.logschan
164 |         if not logschan:
165 |             return
166 | 
167 |         registration_channel = scrim.registration_channel
168 |         modrole = scrim.modrole
169 | 
170 |         open_role = scrim_work_role(scrim, EsportsRole.open)
171 | 
172 |         important = False
173 | 
174 |         embed = discord.Embed(color=0x00B1FF)
175 |         with suppress(discord.NotFound, discord.Forbidden, AttributeError, discord.HTTPException):
176 |             if _type == EsportsLog.open:
177 |                 embed.description = (
178 |                     f"Registration opened for {open_role} in {registration_channel.mention}(ScrimsID: `{scrim.id}`)"
179 |                 )
180 | 
181 |             elif _type == EsportsLog.closed:
182 |                 permission_updated = kwargs.get("permission_updated")
183 |                 embed.description = f"Registration closed for {open_role} in {registration_channel.mention}(ScrimsID: `{scrim.id}`)\n\nUse `smanager slotlist edit {scrim.id}` to edit the slotlist."
184 | 
185 |                 await logschan.send(await scrim.get_text_slotlist())
186 | 
187 |                 if not permission_updated:
188 |                     important = True
189 |                     embed.color = discord.Color.red()
190 |                     embed.description += f"\nI couldn't close {registration_channel.mention}."
191 | 
192 |             # elif _type == EsportsLog.success:
193 | 
194 |             #     message = kwargs.get("message")
195 | 
196 |             #     embed.color = discord.Color.green()
197 |             #     embed.description = f"Registration of [{message.author}]({message.jump_url}) has been accepted in {message.channel.mention}"
198 | 
199 |             await logschan.send(
200 |                 content=modrole.mention if modrole is not None and important is True else None,
201 |                 embed=embed,
202 |                 allowed_mentions=discord.AllowedMentions(roles=True),
203 |             )
204 | 
205 |     # ==========================================================================================================================
206 |     # ==========================================================================================================================
207 | 
208 |     @Cog.listener()
209 |     async def on_scrim_registration_deny(self, message: discord.Message, _type: RegDeny, scrim: Scrim, **kwargs):
210 |         logschan = scrim.logschan
211 |         if logschan is None:
212 |             return
213 | 
214 |         text = f"Registration of [{str(message.author)}]({message.jump_url}) has been denied in {message.channel.mention}\n**Reason:** "
215 | 
216 |         with suppress(discord.NotFound, discord.Forbidden, AttributeError, discord.HTTPException):
217 |             await message.add_reaction(scrim.cross_emoji)
218 | 
219 |             if _type == RegDeny.botmention:
220 |                 await message.reply(
221 |                     embed=self.red_embed("Don't mention Bots. Mention your real teammates."),
222 |                     delete_after=5,
223 |                 )
224 |                 text += f"Mentioned Bots."
225 | 
226 |             elif _type == RegDeny.nomention:
227 |                 await message.reply(
228 |                     embed=self.red_embed(
229 |                         f"{str(message.author)}, **`{plural(scrim.required_mentions):mention is |mentions are}`** required for successful registration."
230 |                     ),
231 |                     delete_after=5,
232 |                 )
233 |                 text += f"Insufficient Mentions (`{len(message.mentions)}/{scrim.required_mentions}`)"
234 | 
235 |             elif _type == RegDeny.banned:
236 |                 await message.reply(
237 |                     embed=self.red_embed(f"{str(message.author)}, You are banned from the scrims. You cannot register."),
238 |                     delete_after=5,
239 |                 )
240 |                 text += f"They are banned from scrims."
241 | 
242 |             elif _type == RegDeny.multiregister:
243 |                 await message.reply(
244 |                     embed=self.red_embed(f"{str(message.author)}, This server doesn't allow multiple registerations."),
245 |                     delete_after=5,
246 |                 )
247 |                 text += f"They have already registered once.\n\nIf you wish to allow multiple registerations,\nuse: `smanager toggle {scrim.id} multiregister`"
248 | 
249 |             elif _type == RegDeny.noteamname:
250 |                 await message.reply(
251 |                     embed=self.red_embed(f"{str(message.author)}, Team Name is required to register."),
252 |                     delete_after=5,
253 |                 )
254 |                 text += f"Teamname compulsion is on and I couldn't find teamname in their registration\n\nIf you wish allow without teamname,\nUse: `smanager edit {scrim.id}`"
255 | 
256 |             elif _type == RegDeny.duplicate:
257 |                 await message.reply(
258 |                     embed=self.red_embed(
259 |                         f"{str(message.author)}, Someone has already registered with the same teamname."
260 |                     ),
261 |                     delete_after=5,
262 |                 )
263 |                 text += f"No duplicate team names is ON and someone has already registered with the same team name\nIf you wish to allow duplicate team names,\nUse: `smanager edit {scrim.id}`"
264 | 
265 |             elif _type == RegDeny.nolines:
266 |                 await message.reply(
267 |                     embed=self.red_embed(
268 |                         f"{str(message.author)}, Your registration message is too short. It seems you missed some required information."
269 |                     ),
270 |                     delete_after=5,
271 |                 )
272 |                 text += f"Insufficient lines in their registration message."
273 | 
274 |             elif _type == RegDeny.faketag:
275 |                 records = kwargs.get("records")
276 |                 jump_url = records[0]["jump_url"]
277 | 
278 |                 await message.reply(
279 |                     embed=self.red_embed(
280 |                         f"{str(message.author)}, Someone already registered with the same mentions {jump_url}"
281 |                         "\n\n`If you think this is a mistake contact moderators ASAP.`"
282 |                     ),
283 |                     delete_after=10,
284 |                 )
285 |                 text += f"Fake tag used. {jump_url}"
286 | 
287 |             # elif _type == RegDeny.bannedteammate:
288 |             #     await message.reply(
289 |             #         embed = self.red_embed(
290 |             #             f"{str(message.author)}, Your registration cannot be accepted because one your teammates is banned from scrims."
291 |             #     ),
292 |             #     delete_after = 5,
293 |             #     )
294 |             #     text += f"One of their teammate is banned from scrims."
295 | 
296 |             if scrim.autodelete_rejects:
297 |                 self.bot.loop.create_task(delete_denied_message(message))
298 | 
299 |             embed = discord.Embed(color=discord.Color.red(), description=text)
300 |             return await logschan.send(embed=embed)
301 | 
302 |     # ==========================================================================================================================
303 |     # ==========================================================================================================================
304 | 
305 |     @Cog.listener()
306 |     async def on_scrim_reserve_timer_complete(self, timer: Timer):
307 |         scrim_id = timer.kwargs["scrim_id"]
308 |         team_name = timer.kwargs["team_name"]
309 |         user_id = timer.kwargs["user_id"]
310 | 
311 |         scrim = await Scrim.get_or_none(pk=scrim_id)
312 |         if scrim is None:
313 |             return
314 | 
315 |         guild = scrim.guild
316 |         if not guild:
317 |             return
318 | 
319 |         if not user_id in await scrim.reserved_user_ids():
320 |             return
321 | 
322 |         team = await scrim.reserved_slots.filter(user_id=user_id).first()
323 | 
324 |         if team.expires != timer.expires:
325 |             return
326 | 
327 |         await ReservedSlot.filter(id=team.id).delete()
328 | 
329 |         logschan = scrim.logschan
330 |         if logschan is not None and logschan.permissions_for(guild.me).send_messages:
331 |             user = self.bot.get_user(user_id)
332 |             embed = discord.Embed(
333 |                 color=discord.Color.green(),
334 |                 description=f"Reservation period of **{team_name.title()}** ({user}) is now over.\nSlot will not be reserved for them in Scrim (`{scrim_id}`).",
335 |             )
336 | 
337 |             await logschan.send(embed=embed)
338 | 
339 |     @Cog.listener()
340 |     async def on_scrim_cmd_log(self, **kwargs):
341 |         ...
342 | 
343 |     @Cog.listener()
344 |     async def on_guild_channel_delete(self, channel: discord.TextChannel):
345 |         # will delete scrim/tournament if its registration channel.
346 |         self.bot.cache.eztagchannels.discard(channel.id)
347 |         self.bot.cache.tagcheck.discard(channel.id)
348 |         self.bot.cache.scrim_channels.discard(channel.id)
349 |         self.bot.cache.tourney_channels.discard(channel.id)
350 | 
351 |         await Scrim.filter(registration_channel_id=channel.id).delete()
352 |         await Tourney.filter(registration_channel_id=channel.id).delete()
353 |         await TagCheck.filter(channel_id=channel.id).delete()
354 |         await EasyTag.filter(channel_id=channel.id).delete()
355 | 
356 |     @Cog.listener()
357 |     async def on_scrim_registration_delete(self, scrim: Scrim, message: discord.Message, slot):
358 |         assert message.guild is not None
359 | 
360 |         self.bot.loop.create_task(message.author.remove_roles(scrim.role))
361 |         await AssignedSlot.filter(id=slot.id).delete()
362 |         await Scrim.filter(id=scrim.id).update(available_slots=ArrayAppend("available_slots", slot.num))
363 |         if scrim.logschan is not None:
364 |             embed = discord.Embed(color=discord.Color.red())
365 |             embed.description = f"Slot of {message.author.mention} was deleted from Scrim: {scrim.id}, because their registration was deleted from {message.channel.mention}"
366 |             await scrim.logschan.send(embed=embed)
367 | 


--------------------------------------------------------------------------------
/cogs/esports/events/__init__.py:
--------------------------------------------------------------------------------
1 | from .scrims import ScrimEvents
2 | from .slots import SlotManagerEvents
3 | from .ssverify import Ssverification
4 | from .tags import TagEvents
5 | from .tourneys import TourneyEvents
6 | 


--------------------------------------------------------------------------------
/cogs/esports/events/scrims.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | 
  5 | if typing.TYPE_CHECKING:
  6 |     from core import Quotient
  7 | 
  8 | import asyncio
  9 | from datetime import datetime, timedelta
 10 | from unicodedata import normalize
 11 | 
 12 | import discord
 13 | 
 14 | import utils
 15 | from constants import IST, AutocleanType, Day
 16 | from core import Cog
 17 | from models import ArrayRemove, AssignedSlot, BanLog, BannedTeam, Scrim, Timer
 18 | 
 19 | from ..helpers import (
 20 |     before_registrations,
 21 |     cannot_take_registration,
 22 |     check_scrim_requirements,
 23 |     should_open_scrim,
 24 | )
 25 | 
 26 | 
 27 | class ScrimEvents(Cog):
 28 |     def __init__(self, bot: Quotient):
 29 |         self.bot = bot
 30 | 
 31 |         self.__scrim_lock = asyncio.Lock()
 32 |         self.__autoclean_lock = asyncio.Lock()
 33 | 
 34 |     @Cog.listener("on_message")
 35 |     async def on_scrim_registration(self, message: discord.Message):
 36 |         if not message.guild or message.author.bot:
 37 |             return
 38 | 
 39 |         channel_id = message.channel.id
 40 | 
 41 |         if channel_id not in self.bot.cache.scrim_channels:
 42 |             return
 43 | 
 44 |         scrim = await Scrim.get_or_none(
 45 |             registration_channel_id=channel_id,
 46 |         )
 47 | 
 48 |         if scrim is None:  # Scrim is possibly deleted
 49 |             return self.bot.cache.scrim_channels.discard(channel_id)
 50 | 
 51 |         scrim_role = scrim.role
 52 | 
 53 |         if scrim.opened_at is None or scrim_role is None:
 54 |             return
 55 | 
 56 |         if Scrim.is_ignorable(message.author):
 57 |             return
 58 | 
 59 |         if not before_registrations(message, scrim_role):
 60 |             return await cannot_take_registration(message, scrim)
 61 | 
 62 |         message.content = normalize("NFKC", message.content.lower())
 63 | 
 64 |         if not await check_scrim_requirements(self.bot, message, scrim):
 65 |             return
 66 | 
 67 |         async with self.__scrim_lock:
 68 |             ctx = await self.bot.get_context(message)
 69 | 
 70 |             teamname, drop_location = utils.find_team(message), utils.find_drop_location(message)
 71 | 
 72 |             scrim = await Scrim.get_or_none(pk=scrim.id)
 73 | 
 74 |             if not scrim or scrim.closed:  # Scrim is deleted or closed.
 75 |                 return
 76 | 
 77 |             try:
 78 |                 slot_num = scrim.available_slots[0]
 79 |             except IndexError:
 80 |                 return
 81 | 
 82 |             _team = {message.author.id}
 83 |             for _ in message.mentions:
 84 |                 if not _.bot:
 85 |                     _team.add(_.id)
 86 | 
 87 |             slot = await AssignedSlot.create(
 88 |                 user_id=ctx.author.id,
 89 |                 team_name=utils.truncate_string(teamname, 30),
 90 |                 # drop_location=utils.truncate_string(drop_location, 30),
 91 |                 num=slot_num,
 92 |                 jump_url=message.jump_url,
 93 |                 message_id=message.id,
 94 |                 members=_team,
 95 |             )
 96 | 
 97 |             await scrim.assigned_slots.add(slot)
 98 | 
 99 |             await Scrim.filter(pk=scrim.id).update(available_slots=ArrayRemove("available_slots", slot_num))
100 |             self.bot.loop.create_task(scrim.add_tick(message))
101 | 
102 |             if len(scrim.available_slots) == 1:
103 |                 try:
104 |                     await scrim.close_registration()
105 |                 except Exception as e:
106 |                     print(f"scrim close error: {e}")
107 | 
108 |     # ==========================================================================================================
109 |     # ==========================================================================================================
110 | 
111 |     @Cog.listener()
112 |     async def on_scrim_open_timer_complete(self, timer: Timer):
113 |         """This listener opens the scrim registration at time."""
114 | 
115 |         scrim_id = timer.kwargs["scrim_id"]
116 |         scrim = await Scrim.get_or_none(pk=scrim_id)
117 | 
118 |         if not scrim:  # we don't want to do anything if the scrim is deleted
119 |             return
120 | 
121 |         if scrim.open_time != timer.expires:  # If time is not same return :)
122 |             return
123 | 
124 |         await Scrim.filter(pk=scrim.id).update(
125 |             open_time=scrim.open_time + timedelta(hours=24),
126 |         )
127 | 
128 |         await self.bot.reminders.create_timer(
129 |             scrim.open_time + timedelta(hours=24),
130 |             "scrim_open",
131 |             scrim_id=scrim.id,
132 |         )  # we don't want to risk this
133 | 
134 |         if scrim.toggle is not True or not Day(utils.day_today()) in scrim.open_days:
135 |             return
136 | 
137 |         if scrim.opened_at and scrim.opened_at.strftime("%d-%b-%Y %I:%M %p") == datetime.now(tz=IST).strftime("%d-%b-%Y %I:%M %p"):
138 |             return  # means we are having multiple timers for a single scrim :c shit
139 | 
140 |         guild = scrim.guild
141 | 
142 |         if not guild:
143 |             return
144 | 
145 |         if not await should_open_scrim(scrim):
146 |             return
147 | 
148 |         if not guild.chunked:
149 |             self.bot.loop.create_task(guild.chunk())
150 | 
151 |         await scrim.start_registration()
152 | 
153 |     @Cog.listener()
154 |     async def on_autoclean_timer_complete(self, timer: Timer):
155 |         scrim_id = timer.kwargs["scrim_id"]
156 | 
157 |         scrim = await Scrim.get_or_none(pk=scrim_id)
158 | 
159 |         if not scrim:  # deleted probably
160 |             return
161 | 
162 |         if timer.expires != scrim.autoclean_time:
163 |             return
164 | 
165 |         next_autoclean_time = scrim.autoclean_time + timedelta(hours=24)
166 | 
167 |         await Scrim.filter(pk=scrim.id).update(autoclean_time=next_autoclean_time)
168 |         await self.bot.reminders.create_timer(next_autoclean_time, "autoclean", scrim_id=scrim.id)
169 | 
170 |         if not scrim.toggle:  # scrim is disabled
171 |             return
172 | 
173 |         if scrim.closed_at and scrim.closed_at < self.bot.current_time - timedelta(hours=48):
174 |             return
175 | 
176 |         guild = scrim.guild
177 |         if not guild:
178 |             return
179 | 
180 |         if not guild.chunked:
181 |             self.bot.loop.create_task(guild.chunk())
182 | 
183 |         async with self.__autoclean_lock:
184 |             if AutocleanType.channel in scrim.autoclean:
185 |                 self.bot.loop.create_task(self.__purge_channel(scrim.registration_channel))
186 |                 await asyncio.sleep(2)
187 | 
188 |             if AutocleanType.role in scrim.autoclean:
189 |                 slots = await scrim.assigned_slots.filter(user_id__isnull=False)
190 | 
191 |                 users = {slot.user_id for slot in slots}
192 |                 if scrim_role := scrim.role:
193 |                     for m in scrim_role.members:
194 |                         users.add(m.id)
195 | 
196 |                 reserved_slots = await scrim.reserved_slots.filter(user_id__isnull=False)
197 |                 for slot in reserved_slots:
198 |                     users.discard(slot.user_id)
199 | 
200 |                 async for member in self.bot.resolve_member_ids(guild, users):
201 |                     try:
202 |                         await member.remove_roles(discord.Object(scrim.role_id), reason="autoclean")
203 |                         await asyncio.sleep(0.2)
204 |                     except discord.HTTPException:
205 |                         continue
206 | 
207 |             await asyncio.sleep(7)
208 | 
209 |     async def __purge_channel(self, channel: discord.TextChannel = None):
210 |         if not channel:
211 |             return
212 |         try:
213 |             await channel.purge(limit=100, check=lambda x: not x.pinned, reason="autoclean")
214 |         except discord.HTTPException:
215 |             pass
216 | 
217 |     @Cog.listener()
218 |     async def on_scrim_ban_timer_complete(self, timer: Timer):
219 |         scrims = timer.kwargs["scrims"]
220 |         user_id = timer.kwargs["user_id"]
221 | 
222 |         reason = timer.kwargs["reason"]
223 | 
224 |         new_reason = ("[Auto-Unban] because ban time's up.") + f"\nBanned for: {reason}" if reason else ""
225 | 
226 |         scrims = await Scrim.filter(pk__in=scrims)
227 |         if not scrims:
228 |             return
229 | 
230 |         guild = scrims[0].guild
231 |         if not guild:
232 |             return
233 | 
234 |         count = 0
235 |         for scrim in scrims:
236 |             bans = await scrim.banned_teams.filter(user_id=user_id)
237 |             c = await BannedTeam.filter(pk__in=[_.pk for _ in bans]).delete()
238 |             count += c
239 | 
240 |         if not count:
241 |             return
242 | 
243 |         if banlog := await BanLog.get_or_none(guild_id=guild.id):
244 |             await banlog.log_unban(user_id, guild.me, scrims, new_reason)
245 | 


--------------------------------------------------------------------------------
/cogs/esports/events/slots.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | import discord
 9 | 
10 | from core import Cog
11 | from models import Scrim, ScrimsSlotManager, Timer
12 | 
13 | 
14 | class SlotManagerEvents(Cog):
15 |     def __init__(self, bot: Quotient):
16 |         self.bot = bot
17 | 
18 |     @Cog.listener()
19 |     async def on_scrim_match_timer_complete(self, timer: Timer):
20 |         scrim_id = timer.kwargs["scrim_id"]
21 | 
22 |         scrim = await Scrim.get_or_none(pk=scrim_id)
23 |         if not scrim:
24 |             return
25 | 
26 |         if not scrim.match_time == timer.expires:
27 |             return
28 | 
29 |         record = await ScrimsSlotManager.get_or_none(guild_id=scrim.guild_id, scrim_ids__contains=scrim.id)
30 |         if record:
31 |             await record.refresh_public_message()
32 | 
33 |     @Cog.listener()
34 |     async def on_guild_channel_delete(self, channel: discord.TextChannel):
35 |         record = await ScrimsSlotManager.get_or_none(main_channel_id=channel.id)
36 |         if not record:
37 |             return
38 |         await record.full_delete()
39 | 
40 |     @Cog.listener()
41 |     async def on_raw_message_delete(self, payload: discord.RawMessageDeleteEvent):
42 |         if not payload.guild_id:
43 |             return
44 | 
45 |         record = await ScrimsSlotManager.get_or_none(message_id=payload.message_id)
46 |         if not record:
47 |             return
48 | 
49 |         await record.full_delete()
50 | 


--------------------------------------------------------------------------------
/cogs/esports/events/ssverify.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import asyncio
  4 | from typing import TYPE_CHECKING, List
  5 | 
  6 | import aiohttp
  7 | import discord
  8 | 
  9 | from constants import SSType
 10 | 
 11 | if TYPE_CHECKING:
 12 |     from core import Quotient
 13 | 
 14 | from collections import defaultdict
 15 | from contextlib import suppress
 16 | 
 17 | import humanize
 18 | 
 19 | from core import Cog, Context, QuotientRatelimiter
 20 | from models import ImageResponse, SSVerify
 21 | from utils import emote, plural
 22 | 
 23 | 
 24 | class MemberLimits(defaultdict):
 25 |     def __missing__(self, key):
 26 |         r = self[key] = QuotientRatelimiter(1, 7)
 27 |         return r
 28 | 
 29 | 
 30 | class GuildLimits(defaultdict):
 31 |     def __missing__(self, key):
 32 |         r = self[key] = QuotientRatelimiter(10, 60)
 33 |         return r
 34 | 
 35 | 
 36 | class Ssverification(Cog):
 37 |     def __init__(self, bot: Quotient):
 38 |         self.bot = bot
 39 | 
 40 |         self.request_url = self.bot.config.FASTAPI_URL + "/ocr"
 41 |         self.headers = {
 42 |             "authorization": self.bot.config.FASTAPI_KEY,
 43 |             "Content-Type": "application/json",
 44 |         }
 45 | 
 46 |         self.__mratelimiter = MemberLimits(QuotientRatelimiter)  # ss/15s by member
 47 |         self.__gratelimiter = GuildLimits(QuotientRatelimiter)  # ss/minute by guild
 48 |         self.__verify_lock = asyncio.Lock()
 49 | 
 50 |     async def __check_ratelimit(self, message: discord.Message):
 51 |         if retry := self.__mratelimiter[message.author].is_ratelimited(message.author):
 52 |             await message.reply(
 53 |                 embed=discord.Embed(
 54 |                     color=discord.Color.red(),
 55 |                     description=f"**You are too fast. Kindly resend after `{retry:.2f}` seconds.**",
 56 |                 )
 57 |             )
 58 |             return False
 59 | 
 60 |         elif retry := self.__gratelimiter[message.guild].is_ratelimited(message.guild):
 61 |             await message.reply(
 62 |                 embed=discord.Embed(
 63 |                     color=discord.Color.red(),
 64 |                     description=f"**Many users are submitting screenshots from this server at this time. Kindly retry after `{retry:.2f}` seconds.**",
 65 |                 )
 66 |             )
 67 |             return False
 68 |         return True
 69 | 
 70 |     @Cog.listener()
 71 |     async def on_message(self, message: discord.Message):
 72 |         if not all(
 73 |             (
 74 |                 message.guild,
 75 |                 not message.author.bot,
 76 |                 message.channel.id in self.bot.cache.ssverify_channels,
 77 |             )
 78 |         ):
 79 |             return
 80 | 
 81 |         record = await SSVerify.get_or_none(channel_id=message.channel.id)
 82 |         if not record:
 83 |             return self.bot.cache.ssverify_channels.discard(message.channel.id)
 84 |         #
 85 |         if "tourney-mod" in (role.name.lower() for role in message.author.roles):  # type: ignore # line guarded #70-76
 86 |             return
 87 | 
 88 |         ctx: Context = await self.bot.get_context(message)
 89 | 
 90 |         _e = discord.Embed(color=discord.Color.red())
 91 | 
 92 |         with suppress(discord.HTTPException):
 93 |             if await record.is_user_verified(message.author.id):
 94 |                 _e.description = "**Your screenshots are already verified, kindly move onto next step.**"
 95 |                 return await ctx.reply(embed=_e)
 96 | 
 97 |             if not (attachments := self.__valid_attachments(message)):
 98 |                 _e.description = "**Kindly send screenshots in `png/jpg/jpeg` format only.**"
 99 |                 return await ctx.reply(embed=_e)
100 | 
101 |             if not await self.__check_ratelimit(message):
102 |                 return
103 | 
104 |             if len(attachments) > record.required_ss:
105 |                 _e.description = (
106 |                     f"**You only have to send `{record.required_ss}` screenshots but you sent `{len(attachments)}`**"
107 |                 )
108 |                 return await ctx.reply(embed=_e)
109 | 
110 |             _e.color = discord.Color.yellow()  # type: ignore
111 |             _e.description = f"Processing your {plural(attachments):screenshot|screenshots}... {emote.loading}"
112 |             m: discord.Message = await message.reply(embed=_e)
113 | 
114 |             _data = [{"url": _.proxy_url} for _ in attachments]
115 | 
116 |             start_at = self.bot.current_time
117 | 
118 |             async with self.__verify_lock:
119 |                 async with self.bot.session.post(self.request_url, json=_data, headers=self.headers) as resp:
120 |                     complete_at = self.bot.current_time
121 | 
122 |                     try:
123 |                         _ocr = await resp.json()
124 |                     except aiohttp.ContentTypeError:
125 |                         _e.color, _e.description = (  # type: ignore
126 |                             discord.Color.red(),
127 |                             "**Failed to process your screenshots. Try again later.**",
128 |                         )
129 |                         return await message.reply(embed=_e)
130 | 
131 |             embed = await self.__verify_screenshots(ctx, record, [ImageResponse(**_) for _ in _ocr])
132 |             embed.set_footer(text=f"Time taken: {humanize.precisedelta(complete_at-start_at)}")
133 |             embed.set_author(
134 |                 name=f"Submitted {await record.data.filter(author_id=ctx.author.id).count()}/{record.required_ss}",
135 |                 icon_url=getattr(ctx.author.display_avatar, "url", None),
136 |             )
137 | 
138 |             with suppress(discord.HTTPException):
139 |                 await m.delete()
140 | 
141 |             await message.reply(embed=embed)
142 | 
143 |             if await record.is_user_verified(ctx.author.id):
144 |                 await message.author.add_roles(discord.Object(id=record.role_id))  # type: ignore # line guarded #70-76
145 | 
146 |                 if record.success_message:
147 |                     _e.title = f"Screenshot Verification Complete"
148 |                     _e.url, _e.description = message.jump_url, record.success_message
149 | 
150 |                     return await message.reply(embed=_e)
151 | 
152 |                 _e.description = f"{ctx.author.mention} Your screenshots are verified, Move to next step."
153 |                 await message.reply(embed=_e)
154 | 
155 |     async def __verify_screenshots(self, ctx: Context, record: SSVerify, _ocr: List[ImageResponse]) -> discord.Embed:
156 |         _e = discord.Embed(color=self.bot.color, description="")
157 | 
158 |         for _ in _ocr:
159 |             if not record.allow_same:
160 |                 b, t = await record._match_for_duplicate(_.dhash, _.phash, ctx.author.id)
161 |                 if b:
162 |                     _e.description += t
163 |                     continue
164 | 
165 |             if record.ss_type == SSType.anyss:
166 |                 _e.description += f"{record.emoji(True)} | Successfully Verified.\n"  # type: ignore
167 |                 await record._add_to_data(ctx, _)
168 | 
169 |             elif record.ss_type == SSType.yt:
170 |                 _e.description += await record.verify_yt(ctx, _)
171 | 
172 |             elif record.ss_type == SSType.insta:
173 |                 _e.description += await record.verify_insta(ctx, _)
174 | 
175 |             elif record.ss_type == SSType.loco:
176 |                 _e.description += await record.verify_loco(ctx, _)
177 | 
178 |             elif record.ss_type == SSType.rooter:
179 |                 _e.description += await record.verify_rooter(ctx, _)
180 | 
181 |             elif record.ss_type == SSType.custom:
182 |                 _e.description += await record.verify_custom(ctx, _)
183 | 
184 |         return _e
185 | 
186 |     def __valid_attachments(self, message: discord.Message):
187 |         return [_ for _ in message.attachments if _.content_type in ("image/png", "image/jpeg", "image/jpg")]
188 | 
189 |     @Cog.listener()
190 |     async def on_guild_channel_delete(self, channel: discord.TextChannel):
191 |         if channel.id in self.bot.cache.ssverify_channels:
192 |             record = await SSVerify.get_or_none(channel_id=channel.id)
193 |             if record:
194 |                 await record.full_delete()
195 | 
196 |     @Cog.listener()
197 |     async def on_guild_role_delete(self, role: discord.Role):
198 |         records = await SSVerify.filter(role_id=role.id)
199 |         if records:
200 |             for record in records:
201 |                 await record.full_delete()
202 | 


--------------------------------------------------------------------------------
/cogs/esports/events/tags.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | 
  5 | if typing.TYPE_CHECKING:
  6 |     from core import Quotient
  7 | 
  8 | import re
  9 | from contextlib import suppress
 10 | 
 11 | import discord
 12 | 
 13 | import utils
 14 | from core import Cog
 15 | from models import EasyTag, TagCheck
 16 | 
 17 | from ..helpers import EasyMemberConverter, delete_denied_message
 18 | 
 19 | 
 20 | class TagEvents(Cog):
 21 |     def __init__(self, bot: Quotient):
 22 |         self.bot = bot
 23 | 
 24 |     @Cog.listener(name="on_message")
 25 |     async def on_tagcheck_msg(self, message: discord.Message):
 26 |         if not message.guild or message.author.bot:
 27 |             return
 28 | 
 29 |         channel_id = message.channel.id
 30 | 
 31 |         if not channel_id in self.bot.cache.tagcheck:
 32 |             return
 33 | 
 34 |         tagcheck = await TagCheck.get_or_none(channel_id=channel_id)
 35 | 
 36 |         if not tagcheck:
 37 |             return self.bot.cache.tagcheck.discard(channel_id)
 38 | 
 39 |         ignore_role = tagcheck.ignorerole
 40 | 
 41 |         if ignore_role is not None and ignore_role in message.author.roles:  # type: ignore # line guarded #25
 42 |             return
 43 | 
 44 |         with suppress(discord.HTTPException, AttributeError):
 45 |             ctx = await self.bot.get_context(message)
 46 | 
 47 |             _react = True
 48 |             if tagcheck.required_mentions and not all(map(lambda m: not m.bot, message.mentions)):
 49 |                 _react = False
 50 |                 await message.reply("Kindly mention your real teammate.", delete_after=5)
 51 | 
 52 |             if not len(message.mentions) >= tagcheck.required_mentions:
 53 |                 _react = False
 54 |                 await message.reply(
 55 |                     f"You need to mention `{utils.plural(tagcheck.required_mentions):teammate|teammates}`.",
 56 |                     delete_after=5,
 57 |                 )
 58 | 
 59 |             team_name = utils.find_team(message)
 60 |             await message.add_reaction(("❌", "✅")[_react])
 61 | 
 62 |             if _react:
 63 |                 embed = self.bot.embed(ctx)
 64 |                 embed.description = f"Team Name: {team_name}\nPlayer(s): {(', '.join(m.mention for m in message.mentions)) if message.mentions else message.author.mention}"
 65 |                 await message.reply(embed=embed)
 66 | 
 67 |             if tagcheck.delete_after and not _react:
 68 |                 self.bot.loop.create_task(delete_denied_message(message, 15))
 69 | 
 70 |     # ==========================================================================================================
 71 |     # ==========================================================================================================
 72 | 
 73 |     @Cog.listener(name="on_message")
 74 |     async def on_eztag_msg(self, message: discord.Message):
 75 |         if not message.guild or message.author.bot:
 76 |             return
 77 | 
 78 |         if not message.channel.id in self.bot.cache.eztagchannels:
 79 |             return
 80 | 
 81 |         channel_id = message.channel.id
 82 |         eztag = await EasyTag.get_or_none(channel_id=channel_id)
 83 | 
 84 |         if not eztag:
 85 |             return self.bot.cache.eztagchannels.discard(channel_id)
 86 | 
 87 |         ignore_role = eztag.ignorerole
 88 | 
 89 |         if ignore_role is not None and ignore_role in message.author.roles:  # type: ignore # line guarded #74
 90 |             return
 91 | 
 92 |         with suppress(discord.HTTPException, AttributeError):
 93 |             ctx = await self.bot.get_context(message)
 94 | 
 95 |             tags = set(re.findall(r"\b\d{18}\b|\b@\w+", message.content, re.IGNORECASE))
 96 | 
 97 |             if not tags:
 98 |                 await message.add_reaction("❌")
 99 |                 return await ctx.reply(
100 |                     "I couldn't find any discord tag in this form.\nYou can write your teammate's id , @their_name or @their_full_discord_tag",
101 |                     delete_after=10,
102 |                 )
103 | 
104 |             members = []
105 |             for m in tags:
106 |                 members.append(await EasyMemberConverter().convert(ctx, m))
107 | 
108 |             mentions = ", ".join(members)
109 | 
110 |             msg = await ctx.reply(f"```{message.clean_content}\nDiscord Tags: {mentions}```")
111 | 
112 |             if eztag.delete_after:
113 |                 self.bot.loop.create_task(delete_denied_message(message, 60))
114 |                 self.bot.loop.create_task(delete_denied_message(msg, 60))
115 | 
116 |     @Cog.listener(name="on_guild_channel_delete")
117 |     async def on_channel_delete(self, channel: discord.abc.GuildChannel) -> None:
118 |         if not isinstance(channel, discord.TextChannel):
119 |             return
120 | 
121 |         channel_id = channel.id
122 | 
123 |         # Delete EasyTag record
124 |         if channel_id in self.bot.cache.eztagchannels:
125 |             await EasyTag.filter(channel_id=channel_id).delete()
126 |             self.bot.cache.eztagchannels.remove(channel_id)
127 | 
128 |         # Delete TagCheck record
129 |         if channel_id in self.bot.cache.tagcheck:
130 |             await TagCheck.filter(channel_id=channel_id).delete()
131 |             self.bot.cache.tagcheck.remove(channel_id)
132 | 


--------------------------------------------------------------------------------
/cogs/esports/events/tourneys.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | from contextlib import suppress
  5 | 
  6 | from cogs.esports.helpers.tourney import get_tourney_from_channel
  7 | 
  8 | if typing.TYPE_CHECKING:
  9 |     from core import Quotient
 10 | 
 11 | import asyncio
 12 | from unicodedata import normalize
 13 | 
 14 | import discord
 15 | from tortoise.exceptions import DoesNotExist
 16 | 
 17 | import utils
 18 | from constants import EsportsLog, RegDeny
 19 | from core import Cog
 20 | from models import MediaPartner, PartnerSlot, TGroupList, TMSlot, Tourney
 21 | from utils import truncate_string
 22 | 
 23 | from ..helpers import (
 24 |     before_registrations,
 25 |     cannot_take_registration,
 26 |     check_tourney_requirements,
 27 |     get_tourney_slots,
 28 |     update_confirmed_message,
 29 | )
 30 | 
 31 | 
 32 | class TourneyEvents(Cog):
 33 |     def __init__(self, bot: Quotient):
 34 |         self.bot = bot
 35 |         self.__tourney_lock = asyncio.Lock()
 36 | 
 37 |     async def __process_tourney_message(
 38 |         self, message: discord.Message, tourney: Tourney, *, check_duplicate=True, mp=False
 39 |     ):
 40 |         """
 41 |         Processes a message that is a tourney message.
 42 | 
 43 |         :param check_duplicate: In case we want a message to be processed without these checks.
 44 |         """
 45 | 
 46 |         teamname = utils.find_team(message)
 47 | 
 48 |         try:
 49 |             await tourney.refresh_from_db()  # Refetch Tourney to check get its updated instance
 50 |         except DoesNotExist:
 51 |             return
 52 |         if not tourney or tourney.closed:  # Tourney is deleted or not opened.
 53 |             return
 54 | 
 55 |         if tourney.no_duplicate_name and check_duplicate:
 56 |             if await tourney.assigned_slots.filter(team_name=teamname).exists():
 57 |                 return self.bot.dispatch("tourney_registration_deny", message, RegDeny.duplicate, tourney)
 58 | 
 59 |         if not tourney.multiregister and message.author.id in get_tourney_slots(await tourney.assigned_slots.all()):
 60 |             return self.bot.dispatch("tourney_registration_deny", message, RegDeny.multiregister, tourney)
 61 | 
 62 |         ctx = await self.bot.get_context(message)
 63 | 
 64 |         if mp:
 65 |             partner = await MediaPartner.get(pk=ctx.channel.id)
 66 | 
 67 |             media_slot = await PartnerSlot.create(
 68 |                 user_id=ctx.author.id,
 69 |                 message_id=ctx.message.id,
 70 |                 jump_url=ctx.message.jump_url,
 71 |                 members=[m.id for m in message.mentions],
 72 |             )
 73 |             await partner.slots.add(media_slot)
 74 | 
 75 |         assigned_slots = await tourney.assigned_slots.order_by("-num").first()
 76 | 
 77 |         numb = 0 if assigned_slots is None else assigned_slots.num
 78 | 
 79 |         slot = TMSlot(
 80 |             leader_id=ctx.author.id,
 81 |             team_name=truncate_string(teamname, 30),
 82 |             num=numb + 1,
 83 |             members=[m.id for m in message.mentions],
 84 |             jump_url=message.jump_url,
 85 |             message_id=message.id,
 86 |         )
 87 | 
 88 |         await tourney.add_assigned_slot(slot, ctx.message)
 89 | 
 90 |         self.bot.loop.create_task(tourney.finalize_slot(ctx, slot))
 91 | 
 92 |         self.bot.dispatch(
 93 |             "tourney_log",
 94 |             EsportsLog.success,
 95 |             tourney,
 96 |             message=ctx.message,
 97 |         )
 98 | 
 99 |         if tourney.total_slots <= await tourney.assigned_slots.all().count():
100 |             await tourney.end_process()
101 | 
102 |     @Cog.listener("on_message")
103 |     async def on_tourney_registration(self, message: discord.Message):
104 |         if not message.guild or message.author.bot:
105 |             return
106 | 
107 |         channel_id = message.channel.id
108 | 
109 |         if channel_id not in self.bot.cache.tourney_channels:
110 |             return
111 | 
112 |         tourney = await Tourney.get_or_none(registration_channel_id=channel_id)
113 | 
114 |         if tourney is None:
115 |             return self.bot.cache.tourney_channels.discard(channel_id)
116 | 
117 |         if tourney.started_at is None:
118 |             return
119 | 
120 |         if tourney.is_ignorable(message.author):
121 |             return
122 | 
123 |         if not before_registrations(message, tourney.role):
124 |             return await cannot_take_registration(message, tourney)
125 | 
126 |         message.content = normalize("NFKC", message.content.lower())
127 | 
128 |         if not await check_tourney_requirements(self.bot, message, tourney):
129 |             return
130 | 
131 |         async with self.__tourney_lock:
132 |             await self.__process_tourney_message(message, tourney)
133 | 
134 |     @Cog.listener()
135 |     async def on_raw_reaction_add(self, payload: discord.RawReactionActionEvent):
136 |         if not all((payload.guild_id, payload.member, not payload.member.bot)):
137 |             return
138 | 
139 |         if not payload.channel_id in self.bot.cache.tourney_channels:
140 |             return
141 | 
142 |         tourney = await Tourney.get_or_none(registration_channel_id=payload.channel_id)
143 | 
144 |         if not tourney:
145 |             return self.bot.cache.tourney_channels.discard(payload.channel_id)
146 | 
147 |         if not str(payload.emoji) in tourney.emojis.values():
148 |             return
149 | 
150 |         if not tourney.is_ignorable(payload.member):
151 |             return
152 | 
153 |         slot = await TMSlot.get_or_none(message_id=payload.message_id)
154 | 
155 |         e = str(payload.emoji)
156 | 
157 |         message = None
158 |         with suppress(discord.HTTPException, AttributeError):
159 |             channel = self.bot.get_channel(payload.channel_id)
160 |             message = await self.bot.get_or_fetch_message(channel, payload.message_id)
161 | 
162 |         if not message:
163 |             return
164 | 
165 |         member = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, payload.user_id)
166 | 
167 |         # if not slot and e == tourney.cross_emoji:
168 |         #     return  # no need to do anything kyuki already registered nai hai user
169 | 
170 |         if not slot and e == tourney.check_emoji:
171 |             if tourney.total_slots <= await tourney.assigned_slots.all().count():
172 |                 return await channel.send(f"{getattr(member, 'mention','')}, Slots are already full.", delete_after=6)
173 | 
174 |             # TODO:send log here
175 |             return await self.__process_tourney_message(message, tourney, check_duplicate=False)
176 | 
177 |         if str(payload.emoji) == tourney.check_emoji:
178 |             return
179 | 
180 |         if str(payload.emoji) == tourney.cross_emoji:
181 |             return await ...  # cancel kardo slot user ka
182 | 
183 |     @Cog.listener(name="on_message")
184 |     async def on_media_partner_message(self, message: discord.Message):
185 |         if not all(
186 |             (
187 |                 message.guild,
188 |                 not message.author.bot,
189 |                 message.channel.id in self.bot.cache.media_partner_channels,
190 |             )
191 |         ):
192 |             return
193 | 
194 |         media_partner = await MediaPartner.get_or_none(pk=message.channel.id)
195 | 
196 |         if not media_partner:
197 |             return self.bot.cache.media_partner_channels.discard(message.channel.id)
198 | 
199 |         tourney = await get_tourney_from_channel(message.guild.id, message.channel.id)  # type: ignore # line guarded
200 | 
201 |         if not tourney:
202 |             return self.bot.cache.media_partner_channels.discard(message.channel.id)
203 | 
204 |         if tourney.started_at is None:
205 |             return
206 | 
207 |         if tourney.is_ignorable(message.author):
208 |             return
209 | 
210 |         partner_tourney = await Tourney.get_or_none(pk=media_partner.tourney_id)
211 |         if not partner_tourney:
212 |             _e = discord.Embed(
213 |                 color=discord.Color.red(),
214 |                 description=(
215 |                     f"{message.author.mention}, you can't register because partner tournament was deleted,\n"
216 |                     f"Kindly register directly through {tourney.registration_channel.mention}."
217 |                 ),
218 |             )
219 |             await message.add_reaction(tourney.cross_emoji)
220 |             return await message.reply(embed=_e, delete_after=7)
221 | 
222 |         if not message.author.id in get_tourney_slots(await partner_tourney.assigned_slots.all()):
223 |             await message.add_reaction(tourney.cross_emoji)
224 | 
225 |             _e = discord.Embed(
226 |                 color=discord.Color.red(),
227 |                 description=(
228 |                     f"{message.author.mention}, you can't register through here because you didn't register in our "
229 |                     f"Media-Partner tourney running in {partner_tourney.guild}\n\n"
230 |                     f"Kindly register through {tourney.registration_channel.mention}."
231 |                 ),
232 |             )
233 |             return await message.reply(embed=_e, delete_after=7)
234 | 
235 |         message.content = normalize("NFKC", message.content.lower())
236 | 
237 |         if not await check_tourney_requirements(self.bot, message, tourney):
238 |             return
239 | 
240 |         async with self.__tourney_lock:
241 |             await self.__process_tourney_message(message, tourney, mp=True)
242 | 
243 |     @Cog.listener()
244 |     async def on_raw_message_delete(self, payload: discord.RawMessageDeleteEvent):
245 |         message_id = payload.message_id
246 |         _del = await Tourney.filter(slotm_message_id=message_id).update(slotm_message_id=None, slotm_channel_id=None)
247 | 
248 |         tourney = None
249 |         if not _del:
250 |             if payload.channel_id in self.bot.cache.media_partner_channels:
251 |                 media_partner = await MediaPartner.get_or_none(pk=payload.channel_id)
252 |                 if media_partner:
253 |                     tourney = await get_tourney_from_channel(payload.guild_id, payload.channel_id)
254 |             elif payload.channel_id in self.bot.cache.tourney_channels:
255 |                 tourney = await Tourney.get_or_none(registration_channel_id=payload.channel_id)
256 | 
257 |         if tourney:
258 |             slot = await tourney.assigned_slots.filter(message_id=payload.message_id).first()
259 |             if slot:
260 |                 if slot.confirm_jump_url:
261 |                     self.bot.loop.create_task(update_confirmed_message(tourney, slot.confirm_jump_url))
262 | 
263 |                 if await tourney.assigned_slots.filter(leader_id=slot.leader_id).count() == 1:
264 |                     m = tourney.guild.get_member(slot.leader_id)
265 |                     if m:
266 |                         self.bot.loop.create_task(m.remove_roles(tourney.role))
267 | 
268 |                 await TMSlot.filter(pk=slot.pk).delete()
269 | 
270 |         await TGroupList.filter(message_id=message_id).delete()
271 | 
272 |     @Cog.listener()
273 |     async def on_guild_channel_delete(self, channel: discord.TextChannel):
274 |         await Tourney.filter(slotm_channel_id=channel.id).update(slotm_channel_id=None, slotm_message_id=None)
275 |         await MediaPartner.filter(channel_id=channel.id).delete()
276 | 
277 |     @Cog.listener()
278 |     async def on_member_update(self, before: discord.Member, after: discord.Member):
279 |         if before.roles != after.roles:
280 |             tourney = await Tourney.filter(guild_id=before.guild.id).first()
281 |             if not tourney:
282 |                 return
283 | 
284 |             msg = None
285 |             if role := tourney.modrole:
286 |                 if role in after.roles and not role in before.roles:
287 |                     msg = (
288 |                         f"Congratulations {before.mention} on becoming a {role.mention},\n\n"
289 |                         "Here's a list of perks you get with the new responsibilities:\n"
290 |                         "• You can now use all `qtourney` commands.\n"
291 |                         "• You can now edit, manage or even delete any tourney.\n"
292 |                         "• **Your messages are now ignored in all the registration channels.**\n\n"
293 |                         "Good luck!"
294 |                     )
295 | 
296 |                 elif role in before.roles and not role in after.roles:
297 |                     msg = (
298 |                         f"{before.mention} is no longer a {role.mention},\n"
299 |                         "All the special perks they enjoyed, are now revoked."
300 |                     )
301 | 
302 |                 if msg:
303 |                     with suppress(discord.HTTPException, AttributeError):
304 |                         await tourney.logschan.send(msg)
305 | 
306 |     @Cog.listener()
307 |     async def on_guild_channel_update(self, before: discord.TextChannel, after: discord.TextChannel):
308 |         if before.name == after.name or not before.name == "quotient-tourney-logs":
309 |             return
310 | 
311 |         if after.permissions_for(after.guild.me).manage_channels:
312 |             return await after.edit(
313 |                 name="quotient-tourney-logs",
314 |                 reason="tourney logging won't work if you rename this.",
315 |             )
316 | 
317 |         _e = discord.Embed(
318 |             color=discord.Color.red(),
319 |             description=(
320 |                 "Someone renamed this channel kindly rename it back to `quotient-tourney-logs`, "
321 |                 "**Quotient Tourneys won't work without it.**"
322 |             ),
323 |         )
324 |         await after.send(
325 |             embed=_e, content=getattr(after.guild.owner, "mention")
326 |         )  # there is very less chances of getting attribute error on `owner.mention`
327 | 
328 |     @Cog.listener()
329 |     async def on_guild_role_update(self, before: discord.Role, after: discord.Role):
330 |         if before.name == after.name or not before.name == "tourney-mod":
331 |             return
332 | 
333 |         if after.guild.me.guild_permissions.manage_roles:
334 |             return await after.edit(name="tourney-mod", reason="tourney mod role won't work if you rename this.")
335 | 
336 |         _e = discord.Embed(
337 |             color=discord.Color.red(),
338 |             description=(
339 |                 f"Someone renamed Quotient's tourney-mod role to {after.mention}, kindly rename it back to `tourney-mod`."
340 |                 "**Quotient Tourneys need the name of this role to be `tourney-mod`**"
341 |             ),
342 |         )
343 | 
344 |         c = discord.utils.get(after.guild.text_channels, name="quotient-tourney-logs")
345 |         if c:
346 |             await c.send(
347 |                 embed=_e, content=getattr(after.guild.owner, "mention")
348 |             )  # there is very less chances of getting attribute error on `owner.mention`
349 | 


--------------------------------------------------------------------------------
/cogs/esports/helpers/__init__.py:
--------------------------------------------------------------------------------
1 | from .converters import *
2 | from .tourney import *
3 | from .utils import *
4 | 


--------------------------------------------------------------------------------
/cogs/esports/helpers/converters.py:
--------------------------------------------------------------------------------
 1 | from discord.ext import commands
 2 | from discord.ext.commands import Converter
 3 | 
 4 | from models import *
 5 | from utils import QuoMember
 6 | 
 7 | 
 8 | class EasyMemberConverter(Converter):
 9 |     async def convert(self, ctx, argument: str):
10 |         try:
11 |             member = await QuoMember().convert(ctx, argument)
12 |             return getattr(member, "mention")
13 |         except commands.MemberNotFound:
14 |             return "Invalid Member!"
15 | 


--------------------------------------------------------------------------------
/cogs/esports/helpers/image.py:
--------------------------------------------------------------------------------
  1 | # from models import PointsInfo, PointsTable
  2 | # from ast import literal_eval
  3 | # from collections import Counter
  4 | # from PIL import Image, ImageFilter, ImageFont, ImageDraw
  5 | # from pathlib import Path
  6 | # from utils import split_list
  7 | # import asyncio, io
  8 | # import random
  9 | # import discord
 10 | 
 11 | 
 12 | # def add_watermark(image, footer):
 13 | #     width, height = image.size
 14 | #     draw = ImageDraw.Draw(image)
 15 | 
 16 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "Ubuntu-Regular.ttf"), 25)
 17 | #     textwidth, textheight = draw.textsize(footer, font)
 18 | 
 19 | #     margin = 20
 20 | #     x = width - textwidth - margin
 21 | #     y = height - textheight - margin
 22 | 
 23 | #     draw.text((x, y), footer, font=font)
 24 | 
 25 | 
 26 | # def add_title(image, title, second_title=None):
 27 | 
 28 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "robo-bold.ttf"), 90)
 29 | 
 30 | #     d1 = ImageDraw.Draw(image)
 31 | 
 32 | #     w, h = d1.textsize(title.upper(), font)
 33 | 
 34 | #     left = (image.width - w) / 2
 35 | #     top = 50
 36 | #     d1.text((left, top), title.upper(), font=font)
 37 | 
 38 | #     if second_title:
 39 | #         w, h = d1.textsize(second_title.upper(), font)
 40 | #         left = (image.width - w) / 2
 41 | #         d1.text((left, 150), second_title.upper(), font=font)
 42 | 
 43 | 
 44 | # def title_rect():
 45 | #     image = Image.open(str(Path.cwd() / "src" / "data" / "img" / "rectangle.png"))
 46 | #     image = image.convert("RGBA")
 47 | 
 48 | #     image = image.resize((round(image.size[0] / 2.8), round(image.size[1] / 2.8)))
 49 | 
 50 | #     draw = ImageDraw.Draw(image)
 51 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "robo-italic.ttf"), 30)
 52 | 
 53 | #     top = 8
 54 | #     fill = (0, 0, 0)
 55 | 
 56 | #     draw.text((18, top), "Rank", fill, font=font)
 57 | #     draw.text((250, top), "Team Name", fill, font=font)
 58 | #     draw.text((610, top), "Place Pt", fill, font=font)
 59 | #     draw.text((770, top), "Kills Pt", fill, font=font)
 60 | 
 61 | #     draw.text((905, top), "Total Pt", fill, font=font)
 62 | 
 63 | #     draw.text((1046, top), "InGame", fill, font=font)
 64 | #     return image
 65 | 
 66 | 
 67 | # def rect_list(data):
 68 | 
 69 | #     fill = (0, 0, 0)
 70 | #     _list = []
 71 | 
 72 | #     top = 10
 73 | #     left = 35
 74 | 
 75 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "robo-bold.ttf"), 30)
 76 | 
 77 | #     for idx, item in enumerate(data.items(), start=1):
 78 | 
 79 | #         image = Image.open(str(Path.cwd() / "src" / "data" / "img" / "rectangle.png"))
 80 | #         image = image.convert("RGBA")
 81 | 
 82 | #         image = image.resize((round(image.size[0] / 2.8), round(image.size[1] / 2.8)))
 83 | 
 84 | #         draw = ImageDraw.Draw(image)
 85 | 
 86 | #         team = item[0]
 87 | #         win, place, kill, total = item[1]
 88 | 
 89 | #         draw.text((left, top), f"#{idx:02}", fill, font=font)
 90 | #         draw.text((left + 150, top), f"Team {team.title()}", fill, font=font)
 91 | #         draw.text((left + 610, top), f"{place:02}", fill, font=font)
 92 | #         draw.text((left + 760, top), f"{kill:02}", fill, font=font)
 93 | #         draw.text((left + 897, top), f"{total:02}", fill, font=font)
 94 | #         draw.text((left + 1025, top), f"{'Win' if win else 'Lost'}", fill, font=font)
 95 | 
 96 | #         _list.append(image)
 97 | 
 98 | #     return _list
 99 | 
100 | 
101 | # async def ptable_files(points: PointsInfo, data: PointsTable):
102 | 
103 | #     table = literal_eval(data.points_table)
104 | 
105 | #     def wrapper():
106 | 
107 | #         _list = rect_list(table)
108 | 
109 | #         images = []
110 | 
111 | #         number = random.choice(range(1, 15))
112 | #         for group in split_list(_list, 10):
113 | #             image = Image.open(str(Path.cwd() / "src" / "data" / "img" / f"ptable{number}.jpg"))
114 | #             # image = Image.open(str(Path.cwd() / "src" / "data" / "back" / f"9.jpg"))
115 | #             image = image.resize((1250, 938))
116 | #             image = image.filter(ImageFilter.GaussianBlur(4))
117 | #             top = 320
118 | 
119 | #             title_rec = title_rect()
120 | #             image.paste(title_rec, (40, 260), title_rec)
121 | 
122 | #             for rect in group:
123 | #                 image.paste(rect, (40, top), rect)
124 | #                 top += 50
125 | 
126 | #             add_watermark(image, points.footer)
127 | #             add_title(image, points.title, points.secondary_title)
128 | 
129 | #             img_bytes = io.BytesIO()
130 | #             image.save(img_bytes, "PNG")
131 | #             img_bytes.seek(0)
132 | #             images.append(discord.File(img_bytes, "points_table.png"))
133 | 
134 | #         return images
135 | 
136 | #     return await asyncio.get_event_loop().run_in_executor(None, wrapper)
137 | 
138 | 
139 | # def add_first_lb_rect(image):
140 | #     rect = Image.open(str(Path.cwd() / "src" / "data" / "img" / f"rect2.png"))
141 | #     rect = rect.convert("RGBA")
142 | #     rect = rect.resize((round(rect.size[0] / 1.5), round(rect.size[1] / 1.4)))
143 | 
144 | #     draw = ImageDraw.Draw(rect)
145 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "robo-italic.ttf"), 16)
146 | 
147 | #     top = 71
148 | #     fill = (0, 0, 0)
149 | 
150 | #     draw.text((16, top), "RANK", fill, font=font)
151 | #     draw.text((220, top), "TEAM NAME", fill, font=font)
152 | #     draw.text((492, top), "MATCHES", fill, font=font)
153 | #     draw.text((612, top), "PLACE POINTS", fill, font=font)
154 | #     draw.text((744, top), "KILL POINTS", fill, font=font)
155 | 
156 | #     draw.text((870, top), "TOTAL POINTS", fill, font=font)
157 | 
158 | #     draw.text((1024, top), "WINS", fill, font=font)
159 | 
160 | #     image.paste(rect, (46, 220), rect)
161 | 
162 | 
163 | # def lb_rects(_dict, matches) -> list:
164 | 
165 | #     font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "robo-bold.ttf"), 25)
166 | #     top, left = 68, 16
167 | 
168 | #     _list = []
169 | #     for idx, team in enumerate(_dict.items(), start=1):
170 | #         image = Image.open(str(Path.cwd() / "src" / "data" / "img" / "rect3.png"))
171 | #         image = image.convert("RGBA")
172 | 
173 | #         image = image.resize((round(image.size[0] / 1.5), round(image.size[1] / 1.4)))
174 | 
175 | #         draw = ImageDraw.Draw(image)
176 | 
177 | #         team_name = team[0]
178 | #         win, place, kill, total = team[1]
179 | 
180 | #         draw.text((left, top), f"#{idx:02}", (255, 255, 255), font=font)
181 | #         draw.text((left + 125, top), f"Team {team_name.title()}", (0, 0, 0), font=font)
182 | #         draw.text((left + 503, top), f"{matches.get(team_name):02}", (0, 0, 0), font=font)
183 | #         draw.text((left + 624, top), f"{place:02}", (0, 0, 0), font=font)
184 | #         draw.text((left + 760, top), f"{kill:02}", (0, 0, 0), font=font)
185 | #         draw.text((left + 897, top), f"{total:02}", (0, 0, 0), font=font)
186 | #         draw.text((left + 1025, top), f"x {win}", (0, 0, 0), font=font)
187 | 
188 | #         _list.append(image)
189 | 
190 | #     return _list
191 | 
192 | 
193 | # async def lb_files(points: PointsInfo, records):
194 | #     d1 = literal_eval(records[0].points_table)
195 | 
196 | #     ds = [literal_eval(record.points_table) for record in records]
197 | 
198 | #     _dict = {}
199 | #     for dict_item in ds:
200 | #         for key, value in dict_item.items():
201 | #             if key in _dict:
202 | #                 val = [a + b for a, b in zip(_dict[key], value)]
203 | #                 _dict[key] = val
204 | #             else:
205 | #                 _dict[key] = value
206 | #     _dict.update(dict(sorted(_dict.items(), reverse=True, key=lambda x: x[1][3])))
207 | 
208 | #     matches = Counter([j for i in ds for j in i.keys()])
209 | 
210 | #     def _wrapper():
211 | #         _list = lb_rects(_dict, matches)
212 | 
213 | #         images = []
214 | #         number = random.choice(range(1, 21))
215 | #         for group in split_list(_list, 10):
216 | #             image = Image.open(str(Path.cwd() / "src" / "data" / "img" / f"ptable{number}.jpg"))
217 | #             image = image.resize((1250, 938))
218 | #             image = image.filter(ImageFilter.GaussianBlur(1))
219 | #             top = 300
220 | 
221 | #             for rect in group:
222 | #                 image.paste(rect, (46, top), rect)
223 | #                 top += 50
224 | 
225 | #             add_first_lb_rect(image)
226 | #             add_watermark(image, points.footer)
227 | #             add_title(image, points.title, points.secondary_title)
228 | #             img_bytes = io.BytesIO()
229 | #             image.save(img_bytes, "PNG")
230 | #             img_bytes.seek(0)
231 | #             images.append(discord.File(img_bytes, "leaderboard.png"))
232 | 
233 | #         return images
234 | 
235 | #     return await asyncio.get_event_loop().run_in_executor(None, _wrapper)
236 | 


--------------------------------------------------------------------------------
/cogs/esports/helpers/tourney.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import re
  4 | from contextlib import suppress
  5 | from typing import Iterable, List, Optional
  6 | 
  7 | import discord
  8 | 
  9 | from constants import EsportsRole, RegDeny
 10 | from models import TMSlot, Tourney
 11 | 
 12 | 
 13 | def get_tourney_slots(slots: List[TMSlot]) -> Iterable[int]:
 14 |     for slot in slots:
 15 |         yield slot.leader_id
 16 | 
 17 | 
 18 | def tourney_work_role(tourney: Tourney, _type: EsportsRole):
 19 |     if _type == EsportsRole.ping:
 20 |         role = tourney.ping_role
 21 | 
 22 |     elif _type == EsportsRole.open:
 23 |         role = tourney.open_role
 24 | 
 25 |     if not role:
 26 |         return None
 27 | 
 28 |     if role == tourney.guild.default_role:
 29 |         return "@everyone"
 30 | 
 31 |     return getattr(role, "mention", "role-deleted")
 32 | 
 33 | 
 34 | def before_registrations(message: discord.Message, role: discord.Role) -> bool:
 35 |     assert message.guild is not None
 36 | 
 37 |     me = message.guild.me
 38 |     channel = message.channel
 39 | 
 40 |     if not role:
 41 |         return False
 42 | 
 43 |     if not all(
 44 |         (
 45 |             me.guild_permissions.manage_roles,
 46 |             role < message.guild.me.top_role,
 47 |             channel.permissions_for(me).add_reactions,  # type: ignore
 48 |             channel.permissions_for(me).use_external_emojis,  # type: ignore
 49 |         )
 50 |     ):
 51 |         return False
 52 |     return True
 53 | 
 54 | 
 55 | async def check_tourney_requirements(bot, message: discord.Message, tourney: Tourney) -> bool:
 56 |     _bool = True
 57 | 
 58 |     if tourney.teamname_compulsion:
 59 |         teamname = re.search(r"team.*", message.content)
 60 |         if not teamname or not teamname.group().strip():
 61 |             _bool = False
 62 |             bot.dispatch("tourney_registration_deny", message, RegDeny.noteamname, tourney)
 63 | 
 64 |     if tourney.required_mentions and not all(map(lambda m: not m.bot, message.mentions)):
 65 |         _bool = False
 66 |         bot.dispatch("tourney_registration_deny", message, RegDeny.botmention, tourney)
 67 | 
 68 |     elif not len(message.mentions) >= tourney.required_mentions:
 69 |         _bool = False
 70 |         bot.dispatch("tourney_registration_deny", message, RegDeny.nomention, tourney)
 71 | 
 72 |     elif message.author.id in tourney.banned_users:
 73 |         _bool = False
 74 |         bot.dispatch("tourney_registration_deny", message, RegDeny.banned, tourney)
 75 | 
 76 |     elif len(message.content.splitlines()) < tourney.required_lines:
 77 |         _bool = False
 78 |         bot.dispatch("tourney_registration_deny", message, RegDeny.nolines, tourney)
 79 | 
 80 |     elif not tourney.allow_duplicate_tags:
 81 |         records = await tourney.check_fake_tags(message)
 82 |         if records:
 83 |             _bool = False
 84 |             bot.dispatch("tourney_registration_deny", message, RegDeny.faketag, tourney, records=records)
 85 | 
 86 |     return _bool
 87 | 
 88 | 
 89 | async def t_ask_embed(ctx, value, description: str):
 90 |     embed = discord.Embed(
 91 |         color=ctx.bot.color,
 92 |         title=f"🛠️ Tournament Manager ({value}/5)",
 93 |         description=description,
 94 |     )
 95 |     embed.set_footer(text=f'Reply with "cancel" to stop the process.')
 96 |     await ctx.send(embed=embed, embed_perms=True)
 97 | 
 98 | 
 99 | async def update_confirmed_message(tourney: Tourney, link: str):
100 |     _ids = [int(i) for i in link.split("/")[5:]]
101 | 
102 |     message = None
103 | 
104 |     with suppress(discord.HTTPException, IndexError):
105 |         message = await tourney.guild.get_channel(_ids[0]).fetch_message(_ids[1])
106 | 
107 |         if message:
108 |             e = message.embeds[0]
109 | 
110 |             e.description = "~~" + e.description.strip() + "~~"
111 |             e.title = "Cancelled Slot"
112 |             e.color = discord.Color.red()
113 | 
114 |             await message.edit(embed=e)
115 | 
116 | 
117 | async def get_tourney_from_channel(guild_id: int, channel_id: int) -> Optional[Tourney]:
118 |     tourneys = await Tourney.filter(guild_id=guild_id)
119 | 
120 |     for tourney in tourneys:
121 |         if await tourney.media_partners.filter(pk=channel_id).exists():
122 |             return tourney
123 | 
124 |     return None
125 | 


--------------------------------------------------------------------------------
/cogs/esports/helpers/utils.py:
--------------------------------------------------------------------------------
  1 | import asyncio
  2 | import re
  3 | from contextlib import suppress
  4 | from typing import Union
  5 | 
  6 | import discord
  7 | 
  8 | import constants
  9 | from models import Scrim, Tourney
 10 | from utils import find_team
 11 | 
 12 | 
 13 | def get_slots(slots):
 14 |     for slot in slots:
 15 |         yield slot.user_id
 16 | 
 17 | 
 18 | async def already_reserved(scrim: Scrim):
 19 |     return [i.num for i in await scrim.reserved_slots.all()]
 20 | 
 21 | 
 22 | async def available_to_reserve(scrim: Scrim):
 23 |     reserved = await already_reserved(scrim)
 24 |     return sorted([i for i in scrim.available_to_reserve if i not in reserved])
 25 | 
 26 | 
 27 | async def cannot_take_registration(message: discord.Message, obj: Union[Scrim, Tourney]):
 28 |     assert message.guild is not None
 29 | 
 30 |     logschan = obj.logschan
 31 | 
 32 |     with suppress(AttributeError, discord.Forbidden):
 33 |         embed = discord.Embed(
 34 |             color=discord.Color.red(),
 35 |             description=f"**Registration couldn't be accepted in {message.channel.mention}**",
 36 |         )
 37 |         embed.description += (  # type: ignore # line guarded above
 38 |             "\nPossible reasons are:\n"
 39 |             "> Success Role of tourney has been deleted.\n"
 40 |             "> I don't have add reaction permission in the channel\n"
 41 |             "> I don't have manage_roles permission in the server\n"
 42 |             f"> My top role({message.guild.me.top_role.mention}) is below {obj.role.mention}\n"
 43 |             "> I don't have use external emojis permission in the channel."
 44 |         )
 45 | 
 46 |         await logschan.send(
 47 |             content=getattr(obj.modrole, "mention", None),
 48 |             embed=embed,
 49 |             allowed_mentions=discord.AllowedMentions(roles=True),
 50 |         )
 51 | 
 52 | 
 53 | async def toggle_channel(channel, role, _bool=True) -> bool:
 54 |     overwrite = channel.overwrites_for(role)
 55 |     overwrite.update(send_messages=_bool)
 56 |     try:
 57 |         await channel.set_permissions(
 58 |             role,
 59 |             overwrite=overwrite,
 60 |             reason=("Registration is over!", "Open for Registrations!")[_bool],  # False=0, True=1
 61 |         )
 62 | 
 63 |         return True
 64 | 
 65 |     except:
 66 |         return False
 67 | 
 68 | 
 69 | async def wait_and_purge(channel, *, limit=100, wait_for=15, check=lambda m: True):
 70 |     await asyncio.sleep(wait_for)
 71 | 
 72 |     with suppress(discord.HTTPException):
 73 |         await channel.purge(limit=limit, check=check)
 74 | 
 75 | 
 76 | async def delete_denied_message(message: discord.Message, seconds=10):
 77 |     with suppress(AttributeError, discord.HTTPException, discord.NotFound, discord.Forbidden):
 78 |         await asyncio.sleep(seconds)
 79 |         await message.delete()
 80 | 
 81 | 
 82 | async def check_scrim_requirements(bot, message: discord.Message, scrim: Scrim) -> bool:
 83 |     _bool = True
 84 | 
 85 |     if scrim.teamname_compulsion:
 86 |         teamname = re.search(r"team.*", message.content)
 87 |         if not teamname or not teamname.group().strip():
 88 |             _bool = False
 89 |             bot.dispatch("scrim_registration_deny", message, constants.RegDeny.noteamname, scrim)
 90 | 
 91 |     if scrim.required_mentions and not all(map(lambda m: not m.bot, message.mentions)):
 92 |         _bool = False
 93 |         bot.dispatch("scrim_registration_deny", message, constants.RegDeny.botmention, scrim)
 94 | 
 95 |     elif not len(message.mentions) >= scrim.required_mentions:
 96 |         _bool = False
 97 |         bot.dispatch("scrim_registration_deny", message, constants.RegDeny.nomention, scrim)
 98 | 
 99 |     elif message.author.id in await scrim.banned_user_ids():
100 |         _bool = False
101 |         bot.dispatch("scrim_registration_deny", message, constants.RegDeny.banned, scrim)
102 | 
103 |     elif len(message.content.splitlines()) < scrim.required_lines:
104 |         _bool = False
105 |         bot.dispatch("scrim_registration_deny", message, constants.RegDeny.nolines, scrim)
106 | 
107 |     # elif any(x in banned for x in (i.id for i in message.mentions)):
108 |     #     _bool = False
109 |     #     bot.dispatch("scrim_registration_deny", message, constants.RegDeny.bannedteammate, scrim)
110 | 
111 |     elif not scrim.multiregister and message.author.id in get_slots(await scrim.assigned_slots.all()):
112 |         _bool = False
113 |         bot.dispatch("scrim_registration_deny", message, constants.RegDeny.multiregister, scrim)
114 | 
115 |     elif scrim.no_duplicate_name:
116 |         teamname = find_team(message)
117 |         async for slot in scrim.assigned_slots.all():
118 |             if slot.team_name == teamname:
119 |                 _bool = False
120 |                 bot.dispatch("scrim_registration_deny", message, constants.RegDeny.duplicate, scrim)
121 |                 break
122 |             else:
123 |                 continue
124 | 
125 |     elif not scrim.allow_duplicate_tags:
126 |         records = await scrim.check_fake_tags(message)
127 |         if records:
128 |             _bool = False
129 |             bot.dispatch("tourney_registration_deny", message, constants.RegDeny.faketag, scrim, records=records)
130 | 
131 |     return _bool
132 | 
133 | 
134 | async def should_open_scrim(scrim: Scrim):
135 |     guild = scrim.guild
136 |     registration_channel = scrim.registration_channel
137 |     role = scrim.role
138 |     _bool = True
139 | 
140 |     text = f"Registration of Scrim: `{scrim.id}` couldn't be opened due to the following reason:\n\n"
141 | 
142 |     if not registration_channel:
143 |         _bool = False
144 |         text += "I couldn't find registration channel. Maybe its deleted or hidden from me."
145 | 
146 |     elif not registration_channel.permissions_for(guild.me).manage_channels:
147 |         _bool = False
148 |         text += "I do not have `manage_channels` permission in {0}".format(registration_channel.mention)
149 | 
150 |     elif role is None:
151 |         _bool = False
152 |         text += "I couldn't find success registration role."
153 | 
154 |     elif not guild.me.guild_permissions.manage_roles or role >= guild.me.top_role:
155 |         _bool = False
156 |         text += "I don't have permissions to `manage roles` in this server or {0} is above my top role ({1}).".format(
157 |             role.mention, guild.me.top_role.mention
158 |         )
159 | 
160 |     elif scrim.open_role_id and not scrim.open_role:
161 |         _bool = False
162 |         text += "You have setup an open role earlier and I couldn't find it."
163 | 
164 |     if not _bool:
165 |         logschan = scrim.logschan
166 |         if logschan:
167 |             embed = discord.Embed(color=discord.Color.red())
168 |             embed.description = text
169 |             with suppress(discord.Forbidden, discord.NotFound):
170 |                 await logschan.send(
171 |                     content=getattr(scrim.modrole, "mention", None),
172 |                     embed=embed,
173 |                     allowed_mentions=discord.AllowedMentions(roles=True),
174 |                 )
175 | 
176 |     return _bool
177 | 
178 | 
179 | def scrim_work_role(scrim: Scrim, _type: constants.EsportsRole):
180 |     if _type == constants.EsportsRole.ping:
181 |         role = scrim.ping_role
182 | 
183 |     elif _type == constants.EsportsRole.open:
184 |         role = scrim.open_role
185 | 
186 |     if not role:
187 |         return None
188 | 
189 |     if role == scrim.guild.default_role:
190 |         return "@everyone"
191 |     return getattr(role, "mention", "Role deleted!")
192 | 


--------------------------------------------------------------------------------
/cogs/esports/menus.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import string
  4 | 
  5 | import aiohttp
  6 | from discord.ext import menus
  7 | from discord.ext.menus import Button
  8 | 
  9 | import config
 10 | import constants
 11 | from models import Scrim
 12 | from models.helpers import *  # noqa: F401, F403
 13 | from utils import *  # noqa: F401, F403
 14 | 
 15 | from .errors import ScrimError
 16 | from .helpers import delete_denied_message, scrim_work_role
 17 | 
 18 | # class PointsConfigEditor(menus.Menu):
 19 | #     def __init__(self, points: PointsInfo):
 20 | #         super().__init__(
 21 | #             timeout=60,
 22 | #             delete_message_after=False,
 23 | #             clear_reactions_after=True,
 24 | #         )
 25 | 
 26 | #         self.points = points
 27 | #         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
 28 | 
 29 | #     def inital_embed(self):
 30 | #         points = self.points
 31 | #         embed = discord.Embed(color=self.bot.color, title=f"Ptable Setup Editor: {points.id}")
 32 | 
 33 | #         fields = {
 34 | #             "Title": points.title,
 35 | #             "Secondary Title": points.secondary_title,
 36 | #             "Watermark": points.footer,
 37 | #             "Channel": getattr(points.channel, "mention", "`Not Found!`"),
 38 | #             "Per kill point": points.kill_points,
 39 | #             "Default Position Points": "Click me for preview",
 40 | #         }
 41 | 
 42 | #         for idx, (name, value) in enumerate(fields.items()):
 43 | #             embed.add_field(
 44 | #                 name=f"{regional_indicator(string.ascii_uppercase[idx])} {name}:",
 45 | #                 value=value,
 46 | #                 inline=False,
 47 | #             )
 48 | 
 49 | #         embed.set_thumbnail(url=self.bot.user.display_avatar.url)
 50 | #         return embed
 51 | 
 52 | #     async def send_initial_message(self, ctx, channel):
 53 | #         return await channel.send(embed=self.inital_embed())
 54 | 
 55 | #     async def refresh(self):
 56 | #         self.points = await PointsInfo.get(id=self.points.id)
 57 | #         await self.message.edit(embed=self.inital_embed())
 58 | 
 59 | #     @menus.button(regional_indicator("A"))
 60 | #     async def on_a(self, payload):
 61 | #         msg = await self.ctx.simple(
 62 | #             f"What do you want the title of points table to be?\n\n`Please enter a title under 22 characters.`"
 63 | #         )
 64 | 
 65 | #         title = await inputs.string_input(self.ctx, self.check, delete_after=True)
 66 | #         await inputs.safe_delete(msg)
 67 | 
 68 | #         if len(title) > 22:
 69 | #             return await self.ctx.error("Character length of title cannot exceed 22 characters.", delete_after=3)
 70 | 
 71 | #         await PointsInfo.filter(id=self.points.id).update(title=title)
 72 | #         await self.refresh()
 73 | 
 74 | #     @menus.button(regional_indicator("B"))
 75 | #     async def on_b(self, payload):
 76 | #         msg = await self.ctx.simple(
 77 | #             "What do you want to secondary title to be? This will be shown under the main title.\n\n`Please keep this under 22 characters.`"
 78 | #         )
 79 | 
 80 | #         title = await inputs.string_input(self.ctx, self.check, delete_after=True)
 81 | #         await inputs.safe_delete(msg)
 82 | 
 83 | #         if len(title) > 22:
 84 | #             return await self.ctx.error(
 85 | #                 "Character length of secondary title cannot exceed 22 characters.", delete_after=3
 86 | #             )
 87 | 
 88 | #         await PointsInfo.filter(id=self.points.id).update(secondary_title=title)
 89 | #         await self.refresh()
 90 | 
 91 | #     @menus.button(regional_indicator("C"))
 92 | #     async def on_c(self, payload):
 93 | #         if not await self.ctx.is_premium_guild():
 94 | #             return await self.ctx.error(
 95 | #                 "This feature is available to premium servers only.\n\nYou can upgrade your server with Quotient Premium to use this.\n\n`Kindly use qperks cmd to know more.`",
 96 | #                 delete_after=4,
 97 | #             )
 98 | 
 99 | #         msg = await self.ctx.simple("What do you want the footer text to be?\n\n`Please keep it under 50 characters.`")
100 | #         title = await inputs.string_input(self.ctx, self.check, delete_after=True)
101 | #         await inputs.safe_delete(msg)
102 | 
103 | #         if len(title) > 50:
104 | #             return await self.ctx.error("Character length of footer cannot exceed 50 characters.", delete_after=3)
105 | 
106 | #         await PointsInfo.filter(id=self.points.id).update(footer=title)
107 | #         await self.refresh()
108 | 
109 | #     @menus.button(regional_indicator("D"))
110 | #     async def on_d(self, payload):
111 | #         msg = await self.ctx.simple(
112 | #             f"Which channel should I use to send points tables?\n\n`Either mention the channel or write its name`"
113 | #         )
114 | 
115 | #         channel = await inputs.channel_input(self.ctx, self.check, delete_after=True)
116 | #         await inputs.safe_delete(msg)
117 | 
118 | #         perms = channel.permissions_for(self.ctx.me)
119 | #         if not all((perms.send_messages, perms.embed_links)):
120 | #             return await self.ctx.error(
121 | #                 f"kindly make sure I have `send_messages` and `embed_links` permissions in {channel.mention}",
122 | #                 delete_after=3,
123 | #             )
124 | 
125 | #         await PointsInfo.filter(id=self.points.id).update(channel_id=channel.id)
126 | #         await self.refresh()
127 | 
128 | #     @menus.button(regional_indicator("E"))
129 | #     async def on_e(self, payload):
130 | #         msg = await self.ctx.simple(
131 | #             f"How many points do you want me to give per kill?\n\n`Enter a number between 1 and 10.`"
132 | #         )
133 | #         kill_point = await inputs.integer_input(self.ctx, self.check, delete_after=True, limits=(0, 10))
134 | #         await inputs.safe_delete(msg)
135 | #         await PointsInfo.filter(id=self.points.id).update(kill_points=kill_point)
136 | #         await self.refresh()
137 | 
138 | #     @menus.button(regional_indicator("F"))
139 | #     async def on_f(self, payload):
140 | #         return await self.ctx.error(
141 | #             f"This feature is currently under development, it will be available soon", delete_after=3
142 | #         )
143 | 
144 | #     @menus.button("\N{BLACK SQUARE FOR STOP}")
145 | #     async def on_stop(self, payload):
146 | #         self.stop()
147 | 
148 | 
149 | # class PointsMenu(menus.Menu):
150 | #     def __init__(self, points: PointsInfo, msg: discord.Message):
151 | #         super().__init__(
152 | #             timeout=60,
153 | #             delete_message_after=False,
154 | #             clear_reactions_after=True,
155 | #         )
156 | #         self.msg = msg
157 | #         self.points = points
158 | #         self._dict = {}
159 | #         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
160 | 
161 | #     def table_embed(self):
162 | #         table = PrettyTable()
163 | #         table.field_names = ["S.No", "Team Name", "Posi Pt", "Kills", "Total"]
164 | #         for idx, teams in enumerate(self._dict.items(), start=1):
165 | #             team = teams[0]
166 | #             _list = teams[1]
167 | #             win, posi, kill, total = _list
168 | #             table.add_row([idx, textwrap.fill(team, width=12), posi, kill, total])
169 | 
170 | #         embed = discord.Embed(color=self.bot.color, title=self.points.title)
171 | #         embed.description = f"```ml\n{table.get_string()}```"
172 | #         return embed
173 | 
174 | #     def initial_embed(self):
175 | #         embed = discord.Embed(color=self.bot.color)
176 | #         embed.description = "▶️ | Start or Edit points table\n" "❌ | Do not save & abort\n" "✅ | Save and Create Image"
177 | #         return embed
178 | 
179 | #     async def send_initial_message(self, ctx, channel):
180 | #         await self.msg.edit(embed=self.table_embed())
181 | #         return await channel.send(embed=self.initial_embed())
182 | 
183 | #     async def pointsembed(self, description: str):
184 | #         embed = discord.Embed(color=self.bot.color, title=f"📊 Points Table Menu")
185 | #         embed.description = description
186 | #         return await self.ctx.send(embed=embed, embed_perms=True)
187 | 
188 | #     async def refresh(self):
189 | #         try:
190 | #             await self.msg.edit(embed=self.table_embed())
191 | #         except Exception as e:
192 | #             await self.ctx.send(e)
193 | 
194 | #     @menus.button("▶️")
195 | #     async def on_start(self, payload):
196 | #         msg = await self.pointsembed(
197 | #             "Enter team names with their kill points.\n"
198 | #             "Format:\n`<Team Name> = <Kills>`\nKindly don't use special characters in team names.\n"
199 | #             "Separate them with comma (`,`)\n"
200 | #             "Example:\n"
201 | #             "```Team Quotient = 20,\nTeam Butterfly = 14,\nTeam Kite = 5,\nTeam 4Pandas = 8```\n"
202 | #             "Write these according to their position in match.\n"
203 | #             "You have 10 minutes to answer this."
204 | #         )
205 | #         teams = await inputs.string_input(self.ctx, self.check, delete_after=True, timeout=600)
206 | #         await inputs.safe_delete(msg)
207 | 
208 | #         result = {}
209 | #         try:
210 | 
211 | #             for idx, line in enumerate(teams.replace("\n", "").split(","), start=1):
212 | #                 line_values = [value.strip() for value in line.split("=")]
213 | 
214 | #                 teamname = " ".join(
215 | #                     normalize("NFKC", line_values[0]).lower().replace("team", "").replace("name", "").split()
216 | #                 )
217 | #                 # teamname = (
218 | #                 #     re.sub(r"<@*#*!*&*\d+>|team|name|[^\w\s]", "", normalize("NFKC", line_values[0].lower()))
219 | #                 # ).split()[0]
220 | 
221 | #                 posi = self.points.posi_points.get(str(idx), 0)
222 | #                 kills = int(line_values[1]) * self.points.kill_points
223 | 
224 | #                 if kills > 99:
225 | #                     return await self.ctx.error(
226 | #                         f"Kills value (`{kills}`) too large at **{str(line_values[0])}**", delete_after=4
227 | #                     )
228 | 
229 | #                 if not teamname:
230 | #                     return await self.ctx.error(f"I couldn't determine team name.", delete_after=4)
231 | 
232 | #                 if len(teamname) > 22:
233 | #                     return await self.ctx.error(f"Team name too large at **{teamname}**", delete_after=4)
234 | 
235 | #                 result[teamname] = [1 if idx == 1 else 0, posi, kills, posi + kills]
236 | 
237 | #         except Exception as e:
238 | #             return await self.ctx.error(f"Oops , you entered wrong format", delete_after=3)
239 | 
240 | #         if len(result) > 25:
241 | #             return await self.ctx.error(f"You cannot enter more than 25 teams :c", delete_after=4)
242 | 
243 | #         _dict = dict(sorted(result.items(), key=lambda x: x[1][3], reverse=True))
244 | #         self._dict.update(_dict)
245 | #         await self.refresh()
246 | 
247 | #     @menus.button("❌")
248 | #     async def on_cross(self, payload):
249 | #         self.stop()
250 | 
251 | #     @menus.button("✅")
252 | #     async def on_check(self, payload):
253 | #         table = await PointsTable.create(
254 | #             points_table=str(self._dict),
255 | #             created_by=self.ctx.author.id,
256 | #             created_at=(datetime.now(constants.IST).replace(hour=0, minute=0, second=0, microsecond=0)),
257 | #         )
258 | #         await self.points.data.add(table)
259 | #         await self.ctx.success(
260 | #             f"Successfully created points table.\n\nYou can use `pt match show {self.points.id}` to get it in image format.\nOr you can send the image to a channel with `pt match send {self.points.id}`"
261 | #         )
262 | #         self.stop()
263 | 
264 | 
265 | class IDPMenu(menus.Menu):
266 |     def __init__(self, send_channel: QuoTextChannel, role: QuoRole):
267 |         super().__init__(timeout=60, delete_message_after=False, clear_reactions_after=True)
268 |         self.embed = None
269 |         self._id = "Not Set!"
270 |         self._pass = "Not Set!"
271 |         self.msg = None
272 |         self.send_channel = send_channel
273 |         self.ping_role = role
274 |         self.delete_in = 30
275 |         self.id_pass_content = False
276 |         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
277 | 
278 |     def idp_embed(self):
279 |         embed = self.ctx.bot.embed(self.ctx, title="New Custom Room. JOIN NOW!")
280 |         embed.set_thumbnail(url=self.ctx.guild.icon.url)
281 |         embed.add_field(name="Room ID", value=self._id)
282 |         embed.add_field(name="Password", value=self._pass)
283 |         embed.add_field(name="Map", value="Not Set")
284 |         embed.add_field(name="Match Starts at", value="Not Set")
285 | 
286 |         embed.set_footer(
287 |             text=f"Shared by: {self.ctx.author} • Auto delete in {plural(self.delete_in):minute|minutes}.",
288 |             icon_url=self.ctx.author.display_avatar.url,
289 |         )
290 |         return embed
291 | 
292 |     @staticmethod
293 |     def inital_embed():
294 |         embed = discord.Embed(color=config.COLOR, title="ID-PASS Menu")
295 |         embed.description = (
296 |             "🇹 | Set Title\n"
297 |             "🆔 | Set Room ID\n"
298 |             "🇵 | Set Room Password\n"
299 |             "🗺️ | Set Room Map\n"
300 |             "🕰️ | Set Start Time\n"
301 |             "🖼️ | Set thumbnail image\n"
302 |             "❔ | ID/Pass as Content\n"
303 |             "⏰ | Autodelete after\n"
304 |         )
305 |         return embed
306 | 
307 |     async def refresh(self):
308 |         try:
309 |             content = self.ping_role.mention if self.ping_role else ""
310 |             if self.id_pass_content:
311 |                 content += f"\nID: {self._id} | Password: {self._pass}"
312 |             await self.msg.edit(
313 |                 content=content,
314 |                 embed=self.embed,
315 |                 allowed_mentions=discord.AllowedMentions(everyone=False, roles=False),
316 |             )
317 |         except:
318 |             self.stop()
319 | 
320 |     async def cembed(self, description):
321 |         return await self.ctx.send(
322 |             embed=discord.Embed(
323 |                 color=discord.Color(config.COLOR),
324 |                 title=f"🛠️ ID/Pass Formatter",
325 |                 description=description,
326 |             )
327 |         )
328 | 
329 |     async def send_initial_message(self, ctx, channel):
330 |         self.embed = self.idp_embed()
331 |         self.msg = await channel.send(embed=self.idp_embed())
332 |         return await channel.send(embed=self.inital_embed())
333 | 
334 |     @menus.button(regional_indicator("T"))
335 |     async def set_title(self, payload):
336 |         msg = await self.cembed(f"What do you want the title to be?\n\nTitle cannot exceed 256 characters.")
337 | 
338 |         title = await inputs.string_input(self.ctx, self.check, delete_after=True)
339 |         if len(title) > 256:
340 |             return await self.ctx.error(f"Title cannot exceed 256 characters.", delete_after=3)
341 | 
342 |         await inputs.safe_delete(msg)
343 |         if title.lower() == "none":
344 |             self.embed.title = None
345 |         else:
346 |             self.embed.title = title
347 |         await self.refresh()
348 | 
349 |     @menus.button("🆔")
350 |     async def set_id(self, payload):
351 |         msg = await self.cembed(f"What is the ID of custom room?")
352 | 
353 |         _id = await inputs.string_input(self.ctx, self.check, delete_after=True)
354 | 
355 |         await inputs.safe_delete(msg)
356 |         self.embed.set_field_at(0, name="Room ID", value=_id)
357 |         self._id = _id
358 |         await self.refresh()
359 | 
360 |     @menus.button("🇵")
361 |     async def set_pass(self, payload):
362 |         msg = await self.cembed(f"What is the password for room?")
363 | 
364 |         _pass = await inputs.string_input(self.ctx, self.check, delete_after=True)
365 | 
366 |         await inputs.safe_delete(msg)
367 |         self.embed.set_field_at(1, name="Password", value=_pass)
368 |         self._pass = _pass
369 |         await self.refresh()
370 | 
371 |     @menus.button("🗺️")
372 |     async def set_map(self, payload):
373 |         msg = await self.cembed(f"What is the name of map?")
374 | 
375 |         _map = await inputs.string_input(self.ctx, self.check, delete_after=True)
376 | 
377 |         await inputs.safe_delete(msg)
378 |         self.embed.set_field_at(2, name="Maps", value=_map)
379 |         await self.refresh()
380 | 
381 |     @menus.button("🕰️")
382 |     async def set_starttime(self, payload):
383 |         msg = await self.cembed(f"What is the match start time?")
384 | 
385 |         start_time = await inputs.string_input(self.ctx, self.check, delete_after=True)
386 | 
387 |         await inputs.safe_delete(msg)
388 |         self.embed.set_field_at(3, name="Match Starts at", value=start_time)
389 |         await self.refresh()
390 | 
391 |     @menus.button("🖼️")
392 |     async def set_thumbnail(self, payload):
393 |         msg = await self.cembed(f"Enter the Image URL you want to set as thumbnail.")
394 |         image = await inputs.string_input(self.ctx, self.check, delete_after=True)
395 | 
396 |         await inputs.safe_delete(msg)
397 | 
398 |         if image.lower() == "none":
399 |             self.embed.set_thumbnail(url=None)
400 |         else:
401 |             try:
402 |                 image_formats = ("image/png", "image/jpeg", "image/jpg", "image/gif")
403 |                 res = await self.bot.session.get(image)
404 |                 if res.headers["content-type"] in image_formats:
405 |                     check = True
406 | 
407 |                 else:
408 |                     check = False
409 | 
410 |             except aiohttp.client_exceptions.InvalidURL:
411 |                 return await self.ctx.error(f"This is not a valid Image URL", delete_after=3)
412 | 
413 |             if not check:
414 |                 return await self.ctx.error(f"The URL didn't contain a valid Image format.", delete_after=3)
415 | 
416 |             self.embed.set_thumbnail(url=image)
417 |             await self.refresh()
418 | 
419 |     @menus.button("❔")
420 |     async def idp_content(self, payload):
421 |         self.id_pass_content = not self.id_pass_content
422 |         await self.refresh()
423 | 
424 |     @menus.button("⏰")
425 |     async def delete_time(self, payload):
426 |         msg = await self.cembed(
427 |             f"After how many minutes do you want me to delete the idp message?\nIt can be between 1-30"
428 |         )
429 |         delete_time = await inputs.integer_input(self.ctx, self.check, delete_after=True, limits=(None, None))
430 |         await inputs.safe_delete(msg)
431 |         self.delete_in = delete_time
432 |         self.embed.set_footer(
433 |             text=f"Shared by: {self.ctx.author} • Auto delete in {plural(self.delete_in):minute|minutes}",
434 |             icon_url=self.ctx.author.display_avatar.url,
435 |         )
436 |         await self.refresh()
437 | 
438 |     @menus.button("❌")
439 |     async def on_cancel(self, payload):
440 |         self.stop()
441 | 
442 |     @menus.button("✅")
443 |     async def on_confirm(self, payload):
444 |         content = self.ping_role.mention if self.ping_role else ""
445 |         if self.id_pass_content:
446 |             content += f"\nID: {self._id} | Password: {self._pass}"
447 | 
448 |         msg = await self.send_channel.send(
449 |             content=content,
450 |             embed=self.embed,
451 |             allowed_mentions=discord.AllowedMentions(everyone=True, roles=True),
452 |         )
453 | 
454 |         self.bot.loop.create_task(delete_denied_message(msg, self.delete_in * 60))
455 |         self.stop()
456 | 
457 | 
458 | class AutocleanMenu(menus.Menu):
459 |     def __init__(self, *, scrim: Scrim):
460 |         super().__init__(
461 |             timeout=60,
462 |             delete_message_after=False,
463 |             clear_reactions_after=True,
464 |         )
465 |         self.scrim = scrim
466 |         self.days = scrim.open_days
467 |         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
468 | 
469 |     def initial_embed(self):
470 |         scrim = self.scrim
471 |         autoclean_time = (scrim.autoclean_time).strftime("%I:%M %p") if scrim.autoclean_time else "Not Set!"
472 | 
473 |         embed = discord.Embed(color=config.COLOR)
474 |         embed.title = "Edit Autoclean: {0}".format(scrim.id)
475 |         description = "\n".join(
476 |             f"{idx:02}. {(_type.value.title()).ljust(15)} {('❌', '✅')[_type in scrim.autoclean]}"
477 |             for idx, _type in enumerate(constants.AutocleanType, start=1)
478 |         )
479 |         embed.description = f"```{description}```"
480 |         embed.description += f"```03. Clean At: {autoclean_time}```"
481 |         return embed
482 | 
483 |     async def send_initial_message(self, ctx, channel):
484 |         return await channel.send(embed=self.initial_embed())
485 | 
486 |     async def refresh(self):
487 |         self.scrim = await Scrim.get(pk=self.scrim.id)
488 |         await self.message.edit(embed=self.initial_embed())
489 | 
490 |     @menus.button(keycap_digit(1))
491 |     async def on_one(self, payload):
492 |         func = (ArrayAppend, ArrayRemove)[constants.AutocleanType.channel in self.scrim.autoclean]
493 |         await Scrim.filter(pk=self.scrim.id).update(autoclean=func("autoclean", constants.AutocleanType.channel))
494 |         await self.refresh()
495 | 
496 |     @menus.button(keycap_digit(2))
497 |     async def on_two(self, payload):
498 |         func = (ArrayAppend, ArrayRemove)[constants.AutocleanType.role in self.scrim.autoclean]
499 |         await Scrim.filter(pk=self.scrim.id).update(autoclean=func("autoclean", constants.AutocleanType.role))
500 |         await self.refresh()
501 | 
502 |     @menus.button(keycap_digit(3))
503 |     async def on_three(self, payload):
504 |         msg = await self.ctx.send(
505 |             "**At what time should I run cleaner?**"
506 |             "**Example: 14:00** - Registration will open at 2PM.\n\n"
507 |             "**Currently Quotient works according to Indian Standard Time (UTC+05:30)**"
508 |         )
509 | 
510 |         clean_time = await inputs.time_input(self.ctx, self.check, delete_after=True)
511 |         await inputs.safe_delete(msg)
512 | 
513 |         await self.bot.get_cog("Reminders").create_timer(
514 |             clean_time,
515 |             "autoclean",
516 |             scrim_id=self.scrim.id,
517 |         )
518 |         await Scrim.filter(pk=self.scrim.id).update(autoclean_time=clean_time)
519 |         await self.refresh()
520 | 
521 |     @menus.button("\N{BLACK SQUARE FOR STOP}")
522 |     async def on_stop(self, payload):
523 |         self.stop()
524 | 
525 | 
526 | class DaysMenu(menus.Menu):
527 |     def __init__(self, *, scrim: Scrim):
528 |         super().__init__(
529 |             timeout=60,
530 |             delete_message_after=False,
531 |             clear_reactions_after=True,
532 |         )
533 |         self.scrim = scrim
534 |         self.days = scrim.open_days
535 |         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
536 | 
537 |         # Adding buttons dynamically
538 |         for idx, day in enumerate(constants.Day, start=1):
539 | 
540 |             def action(day):
541 |                 async def wraps(self, payload):
542 |                     await self.update_scrim(day)
543 | 
544 |                 return wraps
545 | 
546 |             self.add_button(Button(keycap_digit(idx), action(day)))
547 | 
548 |     def initial_embed(self):
549 |         scrim = self.scrim
550 |         embed = discord.Embed(color=discord.Color(config.COLOR))
551 |         embed.title = "Edit Open Days: {0}".format(scrim.id)
552 |         description = "\n".join(
553 |             f"{idx:02}. {(day.value.title()).ljust(10)}   {('❌', '✅')[day in scrim.open_days]}"
554 |             for idx, day in enumerate(constants.Day, start=1)
555 |         )
556 |         embed.description = f"```{description}```"
557 |         return embed
558 | 
559 |     async def refresh(self):
560 |         self.scrim = await Scrim.get(pk=self.scrim.id)
561 |         await self.message.edit(embed=self.initial_embed())
562 | 
563 |     async def update_scrim(self, day):
564 |         # Lets do some magic
565 |         func = (ArrayAppend, ArrayRemove)[day in self.scrim.open_days]
566 |         await Scrim.filter(pk=self.scrim.id).update(open_days=func("open_days", day))
567 |         await self.refresh()
568 | 
569 |     async def send_initial_message(self, ctx, channel):
570 |         return await channel.send(embed=self.initial_embed())
571 | 
572 |     @menus.button("\N{BLACK SQUARE FOR STOP}\ufe0f")
573 |     async def on_stop(self, payload):
574 |         self.stop()
575 | 
576 | 
577 | class ConfigEditMenu(menus.Menu):
578 |     def __init__(self, *, scrim: Scrim):
579 |         super().__init__(
580 |             timeout=100,
581 |             delete_message_after=False,
582 |             clear_reactions_after=True,
583 |         )
584 |         self.scrim = scrim
585 |         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
586 | 
587 |     def initial_embed(self):
588 |         scrim = self.scrim
589 |         slotlist_channel = getattr(scrim.slotlist_channel, "mention", "`Channel Deleted!`")
590 |         registration_channel = getattr(scrim.registration_channel, "mention", "`Channel Deleted!`")
591 |         scrim_role = getattr(scrim.role, "mention", "`Role Deleted!`")
592 |         open_time = (scrim.open_time).strftime("%I:%M %p")
593 | 
594 |         ping_role = scrim_work_role(scrim, constants.EsportsRole.ping)
595 |         open_role = getattr(scrim.open_role, "mention", "`Role Deleted!`") if scrim.open_role_id else "@everyone"
596 | 
597 |         embed = discord.Embed(color=discord.Color(config.COLOR))
598 |         embed.title = f"Edit Scrims Configuration: {scrim.id}"
599 | 
600 |         fields = {
601 |             "Name": f"`{scrim.name}`",
602 |             "Registration Channel": registration_channel,
603 |             "Slotlist Channel": slotlist_channel,
604 |             "Role": scrim_role,
605 |             "Mentions": f"`{scrim.required_mentions:,}`",
606 |             "Slots": f"`{scrim.total_slots:,}`",
607 |             "Open Time": f"`{open_time}`",
608 |             "Auto-clean": "`qsm autoclean {0}`".format(scrim.id),
609 |             "Ping Role": ping_role,
610 |             "Open Role": open_role,
611 |             "Multi Register": ("`No!`", "`Yes!`")[scrim.multiregister],
612 |             "Slotlist Start from": scrim.start_from,
613 |             "Autodelete Rejected Registrations": ("`No!`", "`Yes!`")[scrim.autodelete_rejects],
614 |             "Team Name compulsion": ("`No!`", "`Yes!`")[scrim.teamname_compulsion],
615 |             "Duplicate Team Names": ("`Allowed!`", "`Not Allowed`")[scrim.no_duplicate_name],
616 |         }
617 | 
618 |         for idx, (name, value) in enumerate(fields.items()):
619 |             embed.add_field(
620 |                 name=f"{regional_indicator(string.ascii_uppercase[idx])} {name}:",
621 |                 value=value,
622 |             )
623 | 
624 |         embed.set_thumbnail(url=self.bot.user.display_avatar.url)
625 |         return embed
626 | 
627 |     async def cembed(self, description):
628 |         return await self.ctx.send(
629 |             embed=discord.Embed(
630 |                 color=discord.Color(config.COLOR),
631 |                 title=f"🛠️ Scrims Manager",
632 |                 description=description,
633 |             )
634 |         )
635 | 
636 |     async def send_initial_message(self, ctx, channel):
637 |         return await channel.send(embed=self.initial_embed())
638 | 
639 |     async def refresh(self):
640 |         self.scrim = await Scrim.get(pk=self.scrim.id)
641 |         await self.message.edit(embed=self.initial_embed())
642 | 
643 |     async def update_scrim(self, **kwargs):
644 |         await Scrim.filter(pk=self.scrim.id).update(**kwargs)
645 |         await self.refresh()
646 | 
647 |     @menus.button(regional_indicator("A"))
648 |     async def change_scrim_name(self, payload):
649 |         msg = await self.cembed("What is the new name you want to give to these scrims?")
650 |         name = await inputs.string_input(
651 |             self.ctx,
652 |             self.check,
653 |             delete_after=True,
654 |         )
655 |         if len(name) > 30:
656 |             raise ScrimError("Scrims Name cannot exceed 30 characters.")
657 |         elif len(name) < 5:
658 |             raise ScrimError("The length of new name is too short.")
659 | 
660 |         await inputs.safe_delete(msg)
661 |         await self.update_scrim(name=name)
662 | 
663 |     @menus.button(regional_indicator("B"))
664 |     async def change_registration_channel(self, payload):
665 |         msg = await self.cembed("Which is the new channel for registrations?")
666 |         channel = await inputs.channel_input(
667 |             self.ctx,
668 |             self.check,
669 |             delete_after=True,
670 |         )
671 |         await inputs.safe_delete(msg)
672 |         await self.update_scrim(registration_channel_id=channel.id)
673 | 
674 |     @menus.button(regional_indicator("C"))
675 |     async def change_slotlist_channel(self, payload):
676 |         msg = await self.cembed("Which is the new channel for slotlists?")
677 |         channel = await inputs.channel_input(
678 |             self.ctx,
679 |             self.check,
680 |             delete_after=True,
681 |         )
682 |         await inputs.safe_delete(msg)
683 |         await self.update_scrim(slotlist_channel_id=channel.id)
684 | 
685 |     @menus.button(regional_indicator("D"))
686 |     async def change_scrim_role(self, payload):
687 |         msg = await self.cembed("Which is the new role for correct registration?")
688 |         role = await inputs.role_input(
689 |             self.ctx,
690 |             self.check,
691 |             delete_after=True,
692 |         )
693 |         await inputs.safe_delete(msg)
694 |         await self.update_scrim(role_id=role.id)
695 | 
696 |     @menus.button(regional_indicator("E"))
697 |     async def change_required_mentions(self, payload):
698 |         msg = await self.cembed("How many mentions are required for successful registration?")
699 |         mentions = await inputs.integer_input(
700 |             self.ctx,
701 |             self.check,
702 |             delete_after=True,
703 |             limits=(0, 10),
704 |         )
705 |         await inputs.safe_delete(msg)
706 |         await self.update_scrim(required_mentions=mentions)
707 | 
708 |     @menus.button(regional_indicator("F"))
709 |     async def change_total_slots(self, payload):
710 |         msg = await self.cembed("How many total slots are there?")
711 |         slots = await inputs.integer_input(
712 |             self.ctx,
713 |             self.check,
714 |             delete_after=True,
715 |             limits=(1, 30),
716 |         )
717 |         await inputs.safe_delete(msg)
718 |         await self.update_scrim(total_slots=slots)
719 | 
720 |     @menus.button(regional_indicator("G"))
721 |     async def change_open_time(self, payload):
722 |         msg = await self.cembed(
723 |             "**At what time should I open registrations?**"
724 |             "**Example: 14:00** - Registration will open at 2PM.\n\n"
725 |             "**Currently Quotient works according to Indian Standard Time (UTC+05:30)**"
726 |         )
727 | 
728 |         open_time = await inputs.time_input(self.ctx, self.check, delete_after=True)
729 |         await inputs.safe_delete(msg)
730 | 
731 |         await self.bot.get_cog("Reminders").create_timer(
732 |             open_time,
733 |             "scrim_open",
734 |             scrim_id=self.scrim.id,
735 |         )
736 | 
737 |         await self.update_scrim(open_time=open_time)
738 | 
739 |     @menus.button(regional_indicator("H"))
740 |     async def change_cleanup(self, payload):
741 |         pass
742 | 
743 |     @menus.button(regional_indicator("I"))
744 |     async def change_ping_role(self, payload):
745 |         msg = await self.cembed("Which role should I ping when I open registrations?")
746 | 
747 |         role = await inputs.role_input(
748 |             self.ctx,
749 |             self.check,
750 |             delete_after=True,
751 |         )
752 |         await inputs.safe_delete(msg)
753 |         await self.update_scrim(ping_role_id=role.id)
754 | 
755 |     @menus.button(regional_indicator("J"))
756 |     async def change_open_role(self, payload):
757 |         msg = await self.cembed("For which role should I open registrations?")
758 | 
759 |         role = await inputs.role_input(
760 |             self.ctx,
761 |             self.check,
762 |             delete_after=True,
763 |         )
764 | 
765 |         await inputs.safe_delete(msg)
766 |         await self.update_scrim(open_role_id=role.id)
767 | 
768 |     @menus.button(regional_indicator("K"))
769 |     async def change_multiregister(self, payload):
770 |         await self.ctx.success(
771 |             f"Multiple registrations from a single user are now **{'Allowed' if not self.scrim.multiregister else 'Not Allowed'}!**",
772 |             delete_after=3,
773 |         )
774 |         await self.update_scrim(multiregister=not self.scrim.multiregister)
775 | 
776 |     @menus.button(regional_indicator("L"))
777 |     async def change_start_from(self, payload):
778 |         m = await self.ctx.send(
779 |             "From which slot do you want me to start slotlist?\n\nThis can be any number between 1 and 20."
780 |         )
781 |         start_from = await inputs.integer_input(
782 |             self.ctx,
783 |             self.check,
784 |             delete_after=True,
785 |             limits=(1, self.scrim.total_slots),
786 |         )
787 | 
788 |         await inputs.safe_delete(m)
789 |         await self.update_scrim(start_from=start_from)
790 | 
791 |     @menus.button(regional_indicator("M"))
792 |     async def auto_delete_rejects(self, payload):
793 |         await self.ctx.success(
794 |             f"Rejected registrations will **{'NOW' if not self.scrim.autodelete_rejects else 'NOT'}** be deleted.",
795 |             delete_after=2,
796 |         )
797 |         await self.update_scrim(autodelete_rejects=not self.scrim.autodelete_rejects)
798 | 
799 |     @menus.button(regional_indicator("N"))
800 |     async def teamname_compulsory(self, payload):
801 |         await self.ctx.success(
802 |             f"Team name in registrations is now **{'Necessary' if not self.scrim.teamname_compulsion else 'Not Necessary'}!**",
803 |             delete_after=2,
804 |         )
805 |         await self.update_scrim(teamname_compulsion=not self.scrim.teamname_compulsion)
806 | 
807 |     @menus.button(regional_indicator("O"))
808 |     async def _no_team_name(self, payload):
809 |         await self.ctx.success(
810 |             f"Duplicate team names are not **{'Allowed' if self.scrim.no_duplicate_name else 'Not Allowed'}!**",
811 |             delete_after=2,
812 |         )
813 |         await self.update_scrim(no_duplicate_name=not self.scrim.no_duplicate_name)
814 | 
815 |     @menus.button("\N{BLACK SQUARE FOR STOP}\ufe0f")
816 |     async def on_stop(self, payload):
817 |         self.stop()
818 | 


--------------------------------------------------------------------------------
/cogs/esports/slash/__init__.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing as T
 4 | 
 5 | if T.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from core import Cog
 9 | 
10 | from .scrims import *
11 | 
12 | __all__ = ("SlashCog",)
13 | 
14 | 
15 | class SlashCog(Cog):
16 |     def __init__(self, bot: Quotient):
17 |         self.bot = bot
18 | 
19 |     async def cog_load(self) -> None:
20 |         await self.bot.add_cog(ScrimsSlash(self.bot))
21 | 


--------------------------------------------------------------------------------
/cogs/esports/slash/scrims.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | 
  5 | if T.TYPE_CHECKING:
  6 |     from core import Quotient
  7 | 
  8 | from datetime import datetime, timedelta
  9 | from random import randint
 10 | 
 11 | import dateparser
 12 | import discord
 13 | from discord import app_commands
 14 | from discord.ext import commands
 15 | 
 16 | from core import Context
 17 | from models import BanLog, Guild, ReservedSlot, Scrim
 18 | from utils import Prompt, discord_timestamp, emote, plural, split_list
 19 | 
 20 | __all__ = ("ScrimsSlash",)
 21 | 
 22 | 
 23 | class ScrimsSelector(discord.ui.Select):
 24 |     def __init__(self, placeholder: str, scrims: list[Scrim], multi: bool):
 25 |         _options = []
 26 |         for scrim in scrims:
 27 |             _options.append(
 28 |                 discord.SelectOption(
 29 |                     label=getattr(scrim.registration_channel, "name", "deleted-channel"),  # type: ignore
 30 |                     value=scrim.id,
 31 |                     description=f"{scrim.name} (ScrimID: {scrim.id})",
 32 |                     emoji=emote.TextChannel,
 33 |                 )
 34 |             )
 35 | 
 36 |         super().__init__(placeholder=placeholder, options=_options, max_values=len(_options) if multi else 1)
 37 | 
 38 |     async def callback(self, interaction: discord.Interaction):
 39 |         await interaction.response.defer()
 40 | 
 41 |         for option in self.options:
 42 |             self.view.selected_scrims.discard(option.value)
 43 | 
 44 |         for val in self.values:
 45 |             self.view.selected_scrims.add(val)
 46 | 
 47 | 
 48 | class ScrimsSelector(discord.ui.Select):
 49 |     def __init__(self, placeholder: str, scrims: list[Scrim], multi: bool):
 50 |         _options = []
 51 |         for scrim in scrims:
 52 |             _options.append(
 53 |                 discord.SelectOption(
 54 |                     label=getattr(scrim.registration_channel, "name", "deleted-channel"),  # type: ignore
 55 |                     value=scrim.id,
 56 |                     description=f"{scrim.name} (ScrimID: {scrim.id})",
 57 |                     emoji=emote.TextChannel,
 58 |                 )
 59 |             )
 60 | 
 61 |         super().__init__(placeholder=placeholder, options=_options, max_values=len(_options) if multi else 1)
 62 | 
 63 |     async def callback(self, interaction: discord.Interaction):
 64 |         await interaction.response.defer()
 65 | 
 66 |         for option in self.options:
 67 |             self.view.selected_scrims.discard(option.value)
 68 | 
 69 |         for val in self.values:
 70 |             self.view.selected_scrims.add(val)
 71 | 
 72 | 
 73 | class ConfirmButton(discord.ui.Button):
 74 |     def __init__(self):
 75 |         super().__init__(style=discord.ButtonStyle.green, label="Confirm")
 76 | 
 77 |     async def callback(self, interaction: discord.Interaction):
 78 |         await interaction.response.defer()
 79 |         self.view.proceed = True
 80 | 
 81 |         for child in self.view.children:
 82 |             child.disabled = True
 83 | 
 84 |         await interaction.edit_original_response(view=self.view)
 85 |         self.view.stop()
 86 | 
 87 | 
 88 | class CancelButton(discord.ui.Button):
 89 |     def __init__(self):
 90 |         super().__init__(style=discord.ButtonStyle.red, label="Cancel")
 91 | 
 92 |     async def callback(self, interaction: discord.Interaction):
 93 |         await interaction.response.defer()
 94 | 
 95 |         for child in self.view.children:
 96 |             child.disabled = True
 97 | 
 98 |         await interaction.edit_original_response(view=self.view)
 99 | 
100 |         self.view.stop()
101 | 
102 | 
103 | class ConfirmButton(discord.ui.Button):
104 |     def __init__(self):
105 |         super().__init__(style=discord.ButtonStyle.green, label="Confirm")
106 | 
107 |     async def callback(self, interaction: discord.Interaction):
108 |         await interaction.response.defer()
109 |         self.view.proceed = True
110 | 
111 |         for child in self.view.children:
112 |             child.disabled = True
113 | 
114 |         await interaction.edit_original_response(view=self.view)
115 |         self.view.stop()
116 | 
117 | 
118 | class CancelButton(discord.ui.Button):
119 |     def __init__(self):
120 |         super().__init__(style=discord.ButtonStyle.red, label="Cancel")
121 | 
122 |     async def callback(self, interaction: discord.Interaction):
123 |         await interaction.response.defer()
124 | 
125 |         for child in self.view.children:
126 |             child.disabled = True
127 | 
128 |         await interaction.edit_original_response(view=self.view)
129 | 
130 |         self.view.stop()
131 | 
132 | 
133 | class ScrimsSlash(commands.GroupCog, name="scrims"):
134 |     def __init__(self, bot: Quotient):
135 |         self.bot = bot
136 | 
137 |         super().__init__()
138 | 
139 |     async def can_use_command(self, interaction: discord.Interaction) -> bool:
140 |         if not any(
141 |             (interaction.user.guild_permissions.manage_guild, Scrim.is_ignorable(interaction.user))  # type: ignore # line guarded #25
142 |         ):
143 |             await interaction.response.send_message(
144 |                 embed=discord.Embed(
145 |                     color=discord.Color.red(),
146 |                     description=f"You need `scrims-mod` role or `Manage-Server` permissions to use this command.",
147 |                 )
148 |             )
149 |             return False
150 | 
151 |         return True
152 | 
153 |     def channel_perms(self, channel: discord.TextChannel) -> bool:
154 |         perms = channel.permissions_for(channel.guild.me)
155 |         return all((perms.manage_channels, perms.manage_permissions))
156 | 
157 |     def role_perms(self, role: discord.Role) -> bool:
158 |         perms = role.permissions
159 |         return any(
160 |             (
161 |                 perms.manage_guild,
162 |                 perms.administrator,
163 |                 perms.manage_channels,
164 |                 perms.manage_roles,
165 |                 perms.kick_members,
166 |                 perms.ban_members,
167 |             )
168 |         )
169 | 
170 |     async def show_scrims_selector(
171 |         self,
172 |         interaction: discord.Interaction,
173 |         scrims: list[Scrim],
174 |         multi: bool = False,
175 |         ephemeral: bool = True,
176 |         placeholder: str = "Select scrim(s) to proceed.",
177 |     ):
178 |         if len(scrims) == 1:
179 |             return scrims
180 | 
181 |         view = discord.ui.View(timeout=100)
182 |         view.selected_scrims = set()
183 |         view.proceed: bool = False
184 | 
185 |         if len(scrims) <= 25:
186 |             view.add_item(ScrimsSelector(placeholder, scrims, multi=multi))
187 | 
188 |         else:
189 |             for scrims_chunk in split_list(scrims, 25):
190 |                 view.add_item(ScrimsSelector(placeholder, scrims_chunk, multi=multi))
191 | 
192 |         view.add_item(ConfirmButton())
193 |         view.add_item(CancelButton())
194 | 
195 |         await interaction.followup.send("Select scrim(s) & press `Confirm`!", view=view, ephemeral=ephemeral)
196 |         await view.wait()
197 | 
198 |         if not view.proceed:
199 |             return
200 | 
201 |         return await Scrim.filter(id__in=view.selected_scrims).order_by("id")
202 | 
203 |     async def reserve_slot(self, scrim: Scrim, num: int, team_name: str, user_id: int = None, expires: datetime = None):
204 |         to_del = await scrim.reserved_slots.filter(num=num).first()
205 |         if to_del:
206 |             await ReservedSlot.filter(pk=to_del.id).delete()
207 | 
208 |         slot = await ReservedSlot.create(num=num, user_id=user_id, team_name=team_name, expires=expires)
209 |         await scrim.reserved_slots.add(slot)
210 |         if expires and user_id:
211 |             await scrim.bot.reminders.create_timer(
212 |                 expires, "scrim_reserve", scrim_id=scrim.id, user_id=user_id, team_name=team_name, num=num
213 |             )
214 | 
215 |     async def parse_datetime(self, interaction: discord.Interaction, time: str) -> datetime:
216 |         try:
217 |             parsed = dateparser.parse(
218 |                 time,
219 |                 settings={
220 |                     #  "RELATIVE_BASE": datetime.now(tz=IST),
221 |                     "TIMEZONE": "Asia/Kolkata",
222 |                     "RETURN_AS_TIMEZONE_AWARE": True,
223 |                 },
224 |             )
225 | 
226 |             while self.bot.current_time > parsed:
227 |                 parsed = parsed + timedelta(hours=24)
228 | 
229 |             return parsed
230 | 
231 |         except TypeError:
232 |             await interaction.followup.send(
233 |                 embed=discord.Embed(
234 |                     color=discord.Color.red(), description=f"Invalid time format. Please try again."
235 |                 ).set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/958291942062587934/timex.gif")
236 |             )
237 | 
238 |     @app_commands.command()
239 |     @app_commands.describe(
240 |         registration_channel="The channel where users will register for scrims.",
241 |         slotlist_channel="The channel where slotlist will be posted.",
242 |         success_role="The role that will be given to users who successfully register for scrims.",
243 |         required_mentions="The number of mentions required to register for scrims.",
244 |         total_slots="The total number of slots available for scrims.",
245 |         open_time="The time when registration will be opened.",
246 |     )
247 |     async def create(
248 |         self,
249 |         interaction: discord.Interaction,
250 |         registration_channel: discord.TextChannel,
251 |         slotlist_channel: discord.TextChannel,
252 |         success_role: discord.Role,
253 |         required_mentions: app_commands.Range[int, None, 5],
254 |         total_slots: app_commands.Range[int, 1, 30],
255 |         open_time: str,
256 |     ):
257 |         """Create a scrim."""
258 |         if not await self.can_use_command(interaction):
259 |             return
260 | 
261 |         await interaction.response.defer(thinking=True, ephemeral=False)
262 | 
263 |         if not await Guild.filter(pk=interaction.guild_id, is_premium=True).exists():
264 |             if await Scrim.filter(guild_id=interaction.guild_id).count() >= 3:
265 |                 return await interaction.followup.send(
266 |                     embed=discord.Embed(
267 |                         color=discord.Color.red(),
268 |                         description=(
269 |                             "You can only create 3 scrims in a server without premium.\n\n"
270 |                             "### Use `qpro` command to activate Quotient Pro."
271 |                         ),
272 |                     )
273 |                 )
274 | 
275 |         if not self.channel_perms(registration_channel):
276 |             return await interaction.followup.send(
277 |                 f"{emote.xmark} | I don't have permissions to manage {registration_channel.mention}.",
278 |                 ephemeral=True,
279 |             )
280 | 
281 |         if not self.channel_perms(slotlist_channel):
282 |             return await interaction.followup.send(
283 |                 f"{emote.xmark} | I don't have permissions to manage {slotlist_channel.mention}.",
284 |                 ephemeral=True,
285 |             )
286 | 
287 |         if await Scrim.filter(registration_channel_id=registration_channel.id).exists():
288 |             return await interaction.followup.send(
289 |                 f"{emote.xmark} | A scrim already exists in {registration_channel.mention}.",
290 |                 ephemeral=True,
291 |             )
292 | 
293 |         if not interaction.guild.me.guild_permissions.manage_roles:
294 |             return await interaction.followup.send(
295 |                 f"{emote.xmark} | I don't have permissions to manage roles.",
296 |                 ephemeral=True,
297 |             )
298 | 
299 |         if success_role.managed:
300 |             return await interaction.followup.send(
301 |                 f"{emote.xmark} | I can't give a managed role to users.",
302 |                 ephemeral=True,
303 |             )
304 | 
305 |         if success_role >= interaction.guild.me.top_role:
306 |             return await interaction.followup.send(
307 |                 f"{emote.xmark} | I can't set a success role ({success_role.mention}) higher than my top role ({interaction.guild.me.top_role.mention}).",
308 |                 ephemeral=True,
309 |             )
310 | 
311 |         if success_role >= interaction.user.top_role:
312 |             return await interaction.followup.send(
313 |                 f"{emote.xmark} | You can't set a success role ({success_role.mention}) higher than your top role ({interaction.user.top_role.mention}).",
314 |                 ephemeral=True,
315 |             )
316 | 
317 |         if self.role_perms(success_role):
318 |             return await interaction.followup.send(
319 |                 f"{emote.xmark} | {success_role.mention} has dangerous permissions.",
320 |                 ephemeral=True,
321 |             )
322 | 
323 |         parsed = await self.parse_datetime(interaction, open_time)
324 |         if not parsed:
325 |             return
326 | 
327 |         autoclean_time = self.bot.current_time.replace(
328 |             hour=randint(3, 6), minute=randint(1, 60), second=0, microsecond=0
329 |         ) + timedelta(days=1)
330 | 
331 |         scrim = Scrim(
332 |             registration_channel_id=registration_channel.id,
333 |             slotlist_channel_id=slotlist_channel.id,
334 |             role_id=success_role.id,
335 |             required_mentions=required_mentions,
336 |             total_slots=total_slots,
337 |             open_time=parsed,
338 |             host_id=interaction.user.id,
339 |             autoclean_time=autoclean_time,
340 |             guild_id=interaction.guild.id,
341 |         )
342 |         try:
343 |             await scrim.setup_logs()
344 |         except Exception as e:
345 |             return await interaction.followup.send(
346 |                 f"### {emote.xmark} An error occured! \n{e}",
347 |                 ephemeral=True,
348 |             )
349 |         await scrim.save()
350 |         await self.bot.reminders.create_timer(scrim.open_time, "scrim_open", scrim_id=scrim.id)
351 |         await self.bot.reminders.create_timer(scrim.autoclean_time, "autoclean", scrim_id=scrim.id)
352 | 
353 |         e = discord.Embed(
354 |             color=discord.Color.green(),
355 |             url=self.bot.config.SERVER_LINK,
356 |             title="Scrim created successfully!",
357 |             description=(
358 |                 f"**Registration Channel:** {registration_channel.mention}\n"
359 |                 f"**Slotlist Channel:** {slotlist_channel.mention}\n"
360 |                 f"**Success Role:** {success_role.mention}\n"
361 |                 f"**Required Mentions:** `{required_mentions}`\n"
362 |                 f"**Total Slots:** `{total_slots}`\n"
363 |                 f"**Open Time:** {discord_timestamp(parsed,'f')}\n"
364 |                 f"**Autoclean Time:** {discord_timestamp(autoclean_time,'f')}\n"
365 |                 f"**Host:** {interaction.user.mention}\n"
366 |             ),
367 |         )
368 |         e.set_footer(text="Get more info, using `s` command.")
369 | 
370 |         await interaction.followup.send(embed=e)
371 | 
372 |     @app_commands.command()
373 |     @app_commands.describe(
374 |         registration_channel="The channel where the scrim is hosted.",
375 |         slot="The slot you want to reserve. (1 to 30)",
376 |         team_name="The name of team.",
377 |         user="(Optional) The user you want to reserve the slot for.",
378 |         expire_time="(Optional) The time when the reservation will expire.",
379 |     )
380 |     async def reserve(
381 |         self,
382 |         interaction: discord.Interaction,
383 |         registration_channel: discord.TextChannel,
384 |         slot: app_commands.Range[int, 1, 30],
385 |         team_name: str,
386 |         user: discord.User = None,
387 |         expire_time: str = None,
388 |     ):
389 |         """Reserve slot in any scrim."""
390 |         await interaction.response.defer(thinking=True, ephemeral=True)
391 | 
392 |         scrim = await Scrim.get_or_none(registration_channel_id=registration_channel.id)
393 |         if not scrim:
394 |             return await interaction.followup.send(
395 |                 embed=discord.Embed(
396 |                     color=discord.Color.red(), description=f"No Scrim found in {registration_channel.mention}."
397 |                 )
398 |             )
399 | 
400 |         expiry = None
401 |         if expire_time:
402 |             expiry = await self.parse_datetime(interaction, expire_time)
403 |             if not expiry:
404 |                 return
405 | 
406 |         await self.reserve_slot(
407 |             scrim=scrim,
408 |             num=slot,
409 |             team_name=team_name,
410 |             user_id=getattr(user, "id", None),
411 |             expires=expiry,
412 |         )
413 |         await interaction.followup.send(
414 |             embed=discord.Embed(
415 |                 color=discord.Color.green(),
416 |                 description=(
417 |                     f"`Slot {slot}` has been reserved for `{team_name}` in {scrim}. "
418 |                     f"[Time: {'`Lifetime`' if not expiry else discord_timestamp(expiry)}] "
419 |                 ),
420 |             )
421 |         )
422 | 
423 |         other_scrims = await Scrim.filter(
424 |             registration_channel_id__not=registration_channel.id, guild_id=interaction.guild_id
425 |         )
426 | 
427 |         if not other_scrims:
428 |             return
429 | 
430 |         prompt = Prompt(interaction.user.id)
431 |         m = await interaction.followup.send("`Do you want to reserve this slot in other scrims as well?`", view=prompt)
432 |         await prompt.wait()
433 | 
434 |         await m.delete(delay=0)
435 |         if not prompt.value:
436 |             return
437 | 
438 |         scrims = await self.show_scrims_selector(
439 |             interaction, other_scrims, multi=True, placeholder="Select the scrim you want to reserve slot in."
440 |         )
441 |         if not scrims:
442 |             return
443 | 
444 |         for scrim in scrims:
445 |             await self.reserve_slot(
446 |                 scrim=scrim,
447 |                 num=slot,
448 |                 team_name=team_name,
449 |                 user_id=getattr(user, "id", None),
450 |                 expires=expiry,
451 |             )
452 |         await interaction.followup.send(
453 |             embed=discord.Embed(
454 |                 color=discord.Color.green(), description=f"`Slot {slot}` reserved successfully for all selected scrims."
455 |             )
456 |         )
457 | 
458 |     @app_commands.command()
459 |     @app_commands.describe(user="The user you want to unban from scrims.", reason="The reason for unbanning the user.")
460 |     async def unban(self, interaction: discord.Interaction, user: discord.User, reason: str = None):
461 |         """Unban any user from scrims."""
462 |         if not await self.can_use_command(interaction):
463 |             return
464 |         reason = reason or "No reason given."
465 | 
466 |         # fetching scrims where given user is banned
467 |         query = """
468 |             (SELECT *
469 | 		        FROM
470 | 			    (SELECT SCRIMS.ID AS SCRIM_ID,
471 | 					*
472 | 				FROM PUBLIC."sm.scrims" AS SCRIMS
473 | 				FULL OUTER JOIN
474 | 					(SELECT ID AS BANNED_SLOT_ID,
475 | 							*
476 | 						FROM PUBLIC."sm.scrims_sm.banned_teams" AS BANNED_SLOT
477 | 						INNER JOIN PUBLIC."sm.banned_teams" AS SLOTS ON SLOTS.ID = BANNED_SLOT.BANNEDTEAM_ID) AS BANNED_SLOT ON SCRIMS.ID = BANNED_SLOT."sm.scrims_id"
478 | 				WHERE (SCRIMS.GUILD_ID = $1 
479 | 										AND BANNED_SLOT."sm.scrims_id" IS NOT NULL)) AS SM
480 | 		    WHERE USER_ID = $2)        
481 |             """
482 | 
483 |         records: T.List[T.Any] = await self.bot.db.fetch(query, interaction.guild_id, user.id)
484 |         if not records:
485 |             return await interaction.response.send_message(f"{user.mention} is not banned from any scrim in this server.")
486 | 
487 |         await interaction.response.defer(thinking=True, ephemeral=True)
488 | 
489 |         scrims: T.List[Scrim] = []
490 |         for record in records:
491 |             scrim_id = record["scrim_id"]
492 |             record = dict(record)
493 |             record.pop("id")
494 | 
495 |             scrims.append(Scrim(id=scrim_id, **record))
496 | 
497 |         scrims = await Scrim.show_selector(await Context.from_interaction(interaction), scrims)
498 |         if not scrims:
499 |             return
500 | 
501 |         scrims = [scrims] if isinstance(scrims, Scrim) else scrims
502 | 
503 |         for scrim in scrims:
504 |             scrim = await Scrim.get_or_none(pk=scrim.id)
505 |             if scrim:
506 |                 r = await scrim.banned_teams.filter(user_id=user.id).first()
507 |                 if r:
508 |                     await r.delete()
509 | 
510 |         await interaction.followup.send(
511 |             f"{emote.check} | {user.mention} has been unbanned from `{plural(scrims):scrim|scrims}`.",
512 |             ephemeral=True,
513 |         )
514 | 
515 |         banlog = await BanLog.get_or_none(guild_id=interaction.guild_id)
516 |         if banlog:
517 |             await banlog.log_unban(user.id, interaction.user, scrims, f"```{reason}```")
518 | 
519 |     @app_commands.command()
520 |     @app_commands.describe(user="The user whose slots you want to see.")
521 |     async def slotinfo(self, interaction: discord.Interaction, user: discord.Member):
522 |         """Get info about all the slots a user has."""
523 | 
524 |         if not await self.can_use_command(interaction):
525 |             return
526 | 
527 |         await interaction.response.defer(thinking=True)
528 | 
529 |         # I hope one day these ORMs will be able to do this
530 |         query = """
531 |         
532 |         	(SELECT *
533 | 		FROM
534 | 			(SELECT SCRIMS.ID AS SCRIM_ID,
535 | 					*
536 | 				FROM PUBLIC."sm.scrims" AS SCRIMS
537 | 				FULL OUTER JOIN
538 | 					(SELECT ID AS ASSIGNED_SLOT_ID,
539 | 							*
540 | 						FROM PUBLIC."sm.scrims_sm.assigned_slots" AS ASSIGNED_SLOT
541 | 						INNER JOIN PUBLIC."sm.assigned_slots" AS SLOTS ON SLOTS.ID = ASSIGNED_SLOT.ASSIGNEDSLOT_ID) AS ASSIGNED_SLOT ON SCRIMS.ID = ASSIGNED_SLOT."sm.scrims_id"
542 | 				WHERE (SCRIMS.GUILD_ID = $1
543 | 											AND ASSIGNED_SLOT."sm.scrims_id" IS NOT NULL)) AS SM
544 | 		WHERE USER_ID = $2)
545 | 
546 |         
547 |         """
548 | 
549 |         records: T.List[T.Any] = await self.bot.db.fetch(query, interaction.guild_id, user.id)
550 |         if not records:
551 |             embed = discord.Embed(
552 |                 color=discord.Color.red(),
553 |                 description=f"{user.mention} doesn't have any slot in any scrim of this server.",
554 |             )
555 |             return await interaction.followup.send(embed=embed)
556 | 
557 |         embed = discord.Embed(color=self.bot.color)
558 |         embed.set_author(name=f"{user}'s slots", icon_url=user.display_avatar.url)
559 |         embed.description = ""
560 |         for idx, record in enumerate(records, start=1):
561 |             embed.description += (
562 |                 f"`[{idx:02}] ` [**{record['team_name']}**]({record['jump_url']}) - <#{record['registration_channel_id']}>\n"
563 |                 "Team: {0}\n\n".format(", ".join([f"<@{member}>" for member in record["members"]]))
564 |             )
565 | 
566 |         embed.set_footer(text=f"Requested by {interaction.user}", icon_url=interaction.user.display_avatar.url)
567 |         await interaction.followup.send(embed=embed)
568 | 
569 |     @app_commands.command()
570 |     @app_commands.describe(registration_channel="Scrims registration channel.")
571 |     async def slotlist(self, interaction: discord.Interaction, registration_channel: discord.TextChannel):
572 |         """Post scrims slotlist to current channel."""
573 | 
574 |         if not await self.can_use_command(interaction):
575 |             return
576 | 
577 |         scrim = await Scrim.get_or_none(registration_channel_id=registration_channel.id, guild_id=interaction.guild_id)
578 |         if not scrim:
579 |             return await interaction.response.send_message(
580 |                 f"No scrim found in {registration_channel.mention}.", ephemeral=True
581 |             )
582 | 
583 |         if not await scrim.teams_registered.count():
584 |             return await interaction.response.send_message(f"{scrim} has no registrations.")
585 | 
586 |         embed, schannel = await scrim.create_slotlist()
587 |         await interaction.response.send_message(embed=embed)
588 | 


--------------------------------------------------------------------------------
/cogs/esports/views/__init__.py:
--------------------------------------------------------------------------------
1 | from .base import *
2 | from .groupm import *
3 | from .idp import *
4 | from .slotm import *
5 | from .smslotlist import *
6 | from .ssmod import *
7 | from .tourney import *
8 | 


--------------------------------------------------------------------------------
/cogs/esports/views/base.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from contextlib import suppress
 9 | 
10 | import discord
11 | 
12 | from core import Context
13 | 
14 | 
15 | class EsportsBaseView(discord.ui.View):
16 |     message: discord.Message
17 |     custom_id: str
18 | 
19 |     def __init__(self, ctx: Context, **kwargs):
20 |         super().__init__(timeout=kwargs.get("timeout", 60))
21 | 
22 |         self.ctx = ctx
23 |         self.title = kwargs.get("title", "")
24 |         self.bot: Quotient = ctx.bot
25 |         self.check = lambda msg: msg.channel == self.ctx.channel and msg.author == self.ctx.author
26 | 
27 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
28 |         if interaction.user.id != self.ctx.author.id:
29 |             await interaction.response.send_message(
30 |                 "Sorry, you can't use this interaction as it is not started by you.", ephemeral=True
31 |             )
32 |             return False
33 |         return True
34 | 
35 |     async def on_timeout(self) -> None:
36 |         if hasattr(self, "message"):
37 |             for b in self.children:
38 |                 if isinstance(b, discord.ui.Button) and not b.style == discord.ButtonStyle.link:
39 |                     b.style, b.disabled = discord.ButtonStyle.grey, True
40 | 
41 |             with suppress(discord.HTTPException):
42 |                 await self.message.edit(view=self)
43 | 
44 |     async def on_error(self, interaction: discord.Interaction, error: Exception, item) -> None:
45 |         print("Esports view error:", error)
46 |         self.ctx.bot.dispatch("command_error", self.ctx, error)
47 | 
48 |     async def ask_embed(self, desc: str, *, image=None):
49 |         embed = discord.Embed(color=self.bot.color, description=desc, title=self.title)
50 |         if image:
51 |             embed.set_image(url=image)
52 |         embed.set_footer(text=f"Reply with 'cancel' to stop this process.")
53 | 
54 |         return await self.ctx.send(embed=embed, embed_perms=True)
55 | 
56 |     async def error_embed(self, desc: str, *, footer: str = None, delete_after=3):
57 |         embed = discord.Embed(color=discord.Color.red(), title="Whoopsi-Doopsi", description=desc)
58 |         if footer:
59 |             embed.set_footer(text=footer)
60 |         await self.ctx.send(embed=embed, delete_after=delete_after, embed_perms=True)
61 | 
62 |     def red_embed(self, description: str) -> discord.Embed:
63 |         return discord.Embed(color=discord.Color.red(), title=self.title, description=description)
64 | 


--------------------------------------------------------------------------------
/cogs/esports/views/groupm/__init__.py:
--------------------------------------------------------------------------------
1 | from ._refresh import *
2 | from .main import *
3 | 


--------------------------------------------------------------------------------
/cogs/esports/views/groupm/_paginator.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | from contextlib import suppress
  5 | 
  6 | import discord
  7 | 
  8 | from core import Context
  9 | from models.esports.tourney import TGroupList, TMSlot, Tourney
 10 | from utils import emote, inputs
 11 | 
 12 | from ..base import EsportsBaseView
 13 | from ._refresh import GroupRefresh
 14 | 
 15 | 
 16 | class GroupPages(EsportsBaseView):
 17 |     def __init__(self, ctx: Context, tourney: Tourney, *, ping_all: bool = True, category=None):
 18 |         super().__init__(ctx)
 19 | 
 20 |         self.ping_all = ping_all
 21 |         self.tourney = tourney
 22 | 
 23 |         self.records: T.List[T.List["TMSlot"]] = None
 24 |         self.record: T.List[TMSlot] = None
 25 | 
 26 |         self.category: discord.CategoryChannel = category
 27 |         self.send_to = None
 28 | 
 29 |     async def rendor(self, msg: discord.Message):
 30 |         self.records = await self.tourney._get_groups()
 31 |         self.record = self.records[0]
 32 | 
 33 |         self.message = await msg.edit(embed=self.initial_embed, view=self)
 34 | 
 35 |     async def refresh_view(self):
 36 |         _e = self.initial_embed
 37 |         try:
 38 |             self.message = await self.message.edit(embed=_e, view=self)
 39 |         except discord.HTTPException:
 40 |             await self.on_timeout()
 41 | 
 42 |     @property
 43 |     def send_channel(self):
 44 |         index = self.records.index(self.record) + 1
 45 |         if self.category:
 46 |             with suppress(StopIteration):
 47 |                 return next(c for c in self.category.text_channels if str(index) in c.name)
 48 | 
 49 |     @property
 50 |     def initial_embed(self):
 51 |         current_page = self.records.index(self.record) + 1
 52 |         _e = discord.Embed(color=0x00FFB3, title=f"{self.tourney.name} - Group {current_page}")
 53 |         _e.set_thumbnail(url=getattr(self.ctx.guild.icon, "url", None))
 54 | 
 55 |         _e.description = (
 56 |             "```\n"
 57 |             + "".join(
 58 |                 [
 59 |                     f"Slot {idx:02}  ->  {slot.team_name}\n"
 60 |                     for idx, slot in enumerate(self.record, self.tourney.slotlist_start)
 61 |                 ]
 62 |             )
 63 |             + "```"
 64 |         )
 65 | 
 66 |         if s_t := self.send_to:
 67 |             _e.add_field(name="Send to", value=getattr(s_t, "mention", "`Not-Set`"))
 68 | 
 69 |         else:
 70 |             _e.add_field(name="Send to", value=getattr(self.send_channel, "mention", "`Not-Set`"))
 71 | 
 72 |         _e.add_field(name="Ping @everyone", value=("`No`", "`Yes`")[self.ping_all])
 73 |         _e.set_footer(text="Page {}/{}".format(current_page, len(self.records)))
 74 |         return _e
 75 | 
 76 |     @discord.ui.button(emoji="<:left:878668491660623872>")
 77 |     async def prev_button(self, interaction: discord.Interaction, button: discord.Button):
 78 |         await interaction.response.defer()
 79 | 
 80 |         index = self.records.index(self.record)
 81 |         if index == 0:
 82 |             self.record = self.records[-1]
 83 |         else:
 84 |             self.record = self.records[index - 1]
 85 | 
 86 |         await self.refresh_view()
 87 | 
 88 |     @discord.ui.button(label="Skip to...")
 89 |     async def skip_to(self, interaction: discord.Interaction, button: discord.Button):
 90 |         await interaction.response.defer()
 91 |         m = await self.ctx.simple("What page do you want to go to? (Enter page number)")
 92 |         p = await inputs.integer_input(self.ctx, delete_after=True, timeout=30)
 93 |         await self.ctx.safe_delete(m)
 94 | 
 95 |         if p > len(self.records) + 1 or p <= 0:
 96 |             return await self.ctx.error("Invalid page number.", 4)
 97 | 
 98 |         if self.record == self.records[p - 1]:
 99 |             return await self.ctx.error("We are already on that page, ya dumb dumb.", 4)
100 | 
101 |         self.record = self.records[p - 1]
102 |         await self.refresh_view()
103 | 
104 |     @discord.ui.button(emoji="<:right:878668370331983913>")
105 |     async def next_button(self, interaction: discord.Interaction, button: discord.Button):
106 |         await interaction.response.defer()
107 | 
108 |         index = self.records.index(self.record)
109 |         if index == len(self.records) - 1:
110 |             self.record = self.records[0]
111 |         else:
112 |             self.record = self.records[index + 1]
113 | 
114 |         await self.refresh_view()
115 | 
116 |     @discord.ui.button(label="Give Roles")
117 |     async def give_roles(self, interaction: discord.Interaction, button: discord.ui.Button):
118 |         await interaction.response.defer()
119 | 
120 |         m = await self.ctx.simple(
121 |             f"Mention the role you want to give to Group {self.records.index(self.record) + 1} members."
122 |         )
123 |         role = await inputs.role_input(self.ctx, delete_after=True)
124 |         await self.ctx.safe_delete(m)
125 | 
126 |         m = await self.ctx.simple(f"Ok, Please wait... {emote.loading}")
127 | 
128 |         for slot in self.record:
129 |             member = await self.bot.get_or_fetch_member(self.ctx.guild, slot.leader_id)
130 |             if member and not role in member.roles:
131 |                 try:
132 |                     await member.add_roles(role)
133 |                 except Exception as e:
134 |                     await self.ctx.error(e)
135 | 
136 |         try:
137 |             await m.edit(
138 |                 embed=discord.Embed(
139 |                     color=self.ctx.bot.color,
140 |                     description=f"Done! Given {role.mention} to group {self.records.index(self.record) + 1}.",
141 |                 ),
142 |                 delete_after=6,
143 |             )
144 |         except discord.HTTPException:
145 |             await self.ctx.simple(
146 |                 f"Done, Given {role.mention} to group {self.records.index(self.record) + 1}.", delete_after=6
147 |             )
148 | 
149 |     @discord.ui.button(label="Send to", row=2, style=discord.ButtonStyle.blurple)
150 |     async def send_channl(self, interaction: discord.Interaction, button: discord.Button):
151 |         await interaction.response.defer()
152 | 
153 |         m = await self.ctx.simple("Mention the channel where you want to send this grouplist.")
154 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
155 |         await self.ctx.safe_delete(m)
156 | 
157 |         self.send_to = channel
158 |         self.category = channel.category
159 | 
160 |         await self.refresh_view()
161 | 
162 |     @discord.ui.button(label="Send", style=discord.ButtonStyle.green, row=2)
163 |     async def send_now(self, interaction: discord.Interaction, button: discord.Button):
164 |         await interaction.response.defer()
165 | 
166 |         c = self.send_to if self.send_to else self.send_channel
167 |         if not c:
168 |             return await self.ctx.error("You need to set a channel first.", 3)
169 | 
170 |         embed = self.initial_embed
171 | 
172 |         embed.set_thumbnail(url=None)
173 |         embed.clear_fields()
174 |         embed.set_footer(text=self.ctx.guild.name, icon_url=getattr(self.ctx.guild.icon, "url", None))
175 |         try:
176 |             m = await c.send(
177 |                 "@everyone" if self.ping_all else "",
178 |                 embed=embed,
179 |                 view=GroupRefresh(),
180 |                 allowed_mentions=discord.AllowedMentions(everyone=True),
181 |             )
182 | 
183 |             # I am 100% sure there is a better way to do this but as long as this works, i am good.
184 | 
185 |             await TGroupList.filter(tourney_id=self.tourney.id, group_number=self.records.index(self.record) + 1).delete()
186 | 
187 |             await TGroupList.create(
188 |                 message_id=m.id,
189 |                 channel_id=c.id,
190 |                 tourney_id=self.tourney.id,
191 |                 group_number=self.records.index(self.record) + 1,
192 |             )
193 |         except Exception as e:
194 |             await self.ctx.error(e)
195 | 
196 |         await self.ctx.success("GroupList published.", 3)
197 |         await self.refresh_view()
198 |         self.send_to = None
199 | 


--------------------------------------------------------------------------------
/cogs/esports/views/groupm/_refresh.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | 
  5 | import discord
  6 | 
  7 | from models import TGroupList, TMSlot, Tourney
  8 | from utils import emote
  9 | 
 10 | from ..tourney._select import TourneySlotSelec
 11 | 
 12 | __all__ = ("GroupRefresh",)
 13 | 
 14 | 
 15 | class GroupRefresh(discord.ui.View):
 16 |     def __init__(self):
 17 |         super().__init__(timeout=None)
 18 | 
 19 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
 20 |         if not Tourney.is_ignorable(interaction.user) and not interaction.user.guild_permissions.manage_guild:
 21 |             await interaction.response.send_message(
 22 |                 "You need either `manage-server` permissions or `@tourney-mod` role to refresh grouplist.", ephemeral=True
 23 |             )
 24 |             return False
 25 | 
 26 |         return True
 27 | 
 28 |     @discord.ui.button(
 29 |         custom_id="t_groups_refresh",
 30 |         emoji="<:refresh:953888517619064833>",
 31 |         label="Refresh",
 32 |         style=discord.ButtonStyle.green,
 33 |     )
 34 |     async def refresh_group(self, interaction: discord.Interaction, button: discord.Button):
 35 |         await interaction.response.defer()
 36 | 
 37 |         _checks = await self.__do_checks(interaction, True)
 38 | 
 39 |         try:
 40 |             record, tourney, group = _checks
 41 |         except:
 42 |             return
 43 | 
 44 |         await TGroupList.filter(pk=record.pk).update(refresh_at=record.bot.current_time)
 45 | 
 46 |         _e = discord.Embed(color=0x00FFB3, title=f"{tourney.name} - Group {record.group_number}")
 47 |         # _e.set_thumbnail(url=getattr(tourney.guild.icon, "url", None))
 48 | 
 49 |         _e.description = (
 50 |             "```\n"
 51 |             + "".join(
 52 |                 [f"Slot {idx:02}  ->  {slot.team_name}\n" for idx, slot in enumerate(group, tourney.slotlist_start)]
 53 |             )
 54 |             + "```"
 55 |         )
 56 |         _e.set_footer(text=tourney.guild.name, icon_url=getattr(tourney.guild.icon, "url", None))
 57 | 
 58 |         await interaction.edit_original_response(embed=_e, view=self)
 59 |         await interaction.followup.send("Grouplist message was refreshed successfully.", ephemeral=True)
 60 | 
 61 |     @discord.ui.button(custom_id="gl_info_b", emoji=emote.info, label="Info")
 62 |     async def slots_info(self, interaction: discord.Interaction, button: discord.Button):
 63 |         await interaction.response.defer()
 64 | 
 65 |         _checks = await self.__do_checks(interaction)
 66 |         if not len(_checks) == 3:
 67 |             return
 68 | 
 69 |         record, tourney, group = _checks
 70 | 
 71 |         for _ in group:
 72 |             setattr(_, "tourney", tourney)
 73 | 
 74 |         v = discord.ui.View()
 75 |         v.add_item(TourneySlotSelec(group, "Select the slot to see the team info."))
 76 | 
 77 |         await interaction.followup.send("", view=v, ephemeral=True)
 78 |         await v.wait()
 79 |         if hasattr(v, "custom_id"):
 80 |             for _ in v.custom_id:
 81 |                 slot_id, tourney_id = _.split(":")
 82 |                 _slot = await TMSlot.get(pk=slot_id)
 83 | 
 84 |                 member = await tourney.bot.get_or_fetch_member(tourney.guild, _slot.leader_id)
 85 |                 _e = discord.Embed(color=0x00FFB3, title=f"Slot {group.index(_slot)+1}, Group {record.group_number}")
 86 |                 _e.description = (
 87 |                     f"> Team Name: `{_slot.team_name}`\n"
 88 |                     f"> Team Leader: `{member}`\n"
 89 |                     f"> Registration Message: [Click here]({_slot.jump_url})\n"
 90 |                     f"> Confirm Message: [Click here]({_slot.confirm_jump_url})"
 91 |                 )
 92 | 
 93 |                 await interaction.followup.send(embed=_e, ephemeral=True)
 94 | 
 95 |     async def __do_checks(self, interaction: discord.Interaction, refresh_too=False):
 96 |         record = await TGroupList.get_or_none(pk=interaction.message.id)
 97 |         tourney = None
 98 |         if record:
 99 |             tourney = await Tourney.get_or_none(pk=record.tourney_id)
100 | 
101 |         if not record or not tourney:
102 |             self.children[0].disabled = True
103 |             return await interaction.edit_original_response(view=self)
104 | 
105 |         if refresh_too:
106 |             if (record.bot.current_time - record.refresh_at).total_seconds() < 120:
107 |                 return await interaction.followup.send("You can only refresh every 2 minutes.", ephemeral=True)
108 | 
109 |         group = await tourney.get_group(record.group_number)
110 |         if not group:
111 |             await interaction.delete_original_response()
112 |             return await interaction.followup.send("Group not found.", ephemeral=True)
113 | 
114 |         return record, tourney, group
115 | 


--------------------------------------------------------------------------------
/cogs/esports/views/groupm/main.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | from contextlib import suppress
  5 | 
  6 | import discord
  7 | 
  8 | from core import Context
  9 | from models import Tourney
 10 | from utils import inputs, keycap_digit
 11 | 
 12 | from ..base import EsportsBaseView
 13 | from ..tourney._buttons import DiscardButton
 14 | from ._paginator import GroupPages
 15 | 
 16 | __all__ = ("TourneyGroupManager",)
 17 | 
 18 | 
 19 | class TourneyGroupManager(EsportsBaseView):
 20 |     def __init__(self, ctx: Context, tourney: Tourney, **kwargs):
 21 |         super().__init__(ctx, **kwargs)
 22 | 
 23 |         self.tourney = tourney
 24 |         self.category = None
 25 | 
 26 |         self.ping_all = False
 27 | 
 28 |         self.start_from = tourney.slotlist_start
 29 | 
 30 |     @property
 31 |     def initial_embed(self):
 32 |         _e = discord.Embed(
 33 |             color=self.ctx.bot.color, title="Tourney Group Management", url=self.tourney.bot.config.SERVER_LINK
 34 |         )
 35 |         _e.description = (
 36 |             f"Use `create channels & roles` to setup tourney groups.\n"
 37 |             "Use `Group List` to post group/slotlist in channels."
 38 |         )
 39 |         _e.add_field(name=f"{keycap_digit(1)} Slotlist Start from", value=f"`Slot {self.start_from}`")
 40 |         _e.add_field(name=f"{keycap_digit(2)} Ping @everyone", value=("`No`", "`Yes`")[self.ping_all])
 41 |         return _e
 42 | 
 43 |     async def __refresh_msg(self):
 44 |         with suppress(discord.HTTPException):
 45 |             self.message = await self.message.edit(embed=self.initial_embed)
 46 | 
 47 |     @discord.ui.button(emoji=keycap_digit(1))
 48 |     async def change_slotlist_start(self, interaction: discord.Interaction, button: discord.Button):
 49 |         await interaction.response.defer()
 50 | 
 51 |         m = await self.ctx.simple("Enter the slot number to start group/slotlist. (Max `20`)")
 52 |         self.start_from = await inputs.integer_input(self.ctx, limits=(1, 20), delete_after=True)
 53 |         await self.ctx.safe_delete(m)
 54 | 
 55 |         await self.tourney.make_changes(slotlist_start=self.start_from)
 56 |         await self.tourney.refresh_from_db()
 57 | 
 58 |         await self.__refresh_msg()
 59 | 
 60 |     @discord.ui.button(emoji=keycap_digit(2))
 61 |     async def toggle_ping_all(self, interaction: discord.Interaction, button: discord.Button):
 62 |         await interaction.response.defer()
 63 |         self.ping_all = not self.ping_all
 64 |         await self.__refresh_msg()
 65 | 
 66 |     @discord.ui.button(label="Create Channels & Roles")
 67 |     async def create_roles_channels(self, interaction: discord.Interaction, button: discord.Button):
 68 |         await interaction.response.defer()
 69 |         if len(self.ctx.guild.channels) >= 490:
 70 |             return await self.ctx.error("Too many channels in server. Please delete some first.", 4)
 71 | 
 72 |         _e = discord.Embed(color=0x00FFB3)
 73 |         _e.description = (
 74 |             "**Enter the format for group roles & channels creation.**\n"
 75 |             "*`{0}` will be replaced by the number of group or roles*\n\nExamples:"
 76 |         )
 77 |         _e.set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/953163516481777684/unknown.png")
 78 | 
 79 |         m = await interaction.followup.send(embed=_e)
 80 |         _format = await inputs.string_input(self.ctx, timeout=60, delete_after=True)
 81 | 
 82 |         await self.ctx.safe_delete(m)
 83 |         if len(_format) > 35:
 84 |             return await self.ctx.error("Name too long. Max 35 characters.", 4)
 85 | 
 86 |         if not "{0}" in _format:
 87 |             return await self.ctx.error("No `{0}` found in input.", 4)
 88 | 
 89 |         p = await self.ctx.prompt(
 90 |             f"Group Roles/channels will look like this: `{_format.replace('{0}','1')}`,`{_format.replace('{0}','2')}`",
 91 |             title="Is this correct?",
 92 |         )
 93 | 
 94 |         if not p:
 95 |             return await self.ctx.error("Cancelled.", 4)
 96 |         _e.description = (
 97 |             "Enter the range of group numbers to create channels & setup roles.\n"
 98 |             "For example:\n"
 99 |             "`1-5` will create channels for group 1 to 5 and setup roles."
100 |         )
101 |         _e.set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/955013587049525278/unknown.png")
102 |         m = await interaction.followup.send(embed=_e)
103 |         _range = await inputs.string_input(self.ctx, delete_after=True)
104 |         await self.ctx.safe_delete(m)
105 |         _range = _range.strip().split("-")
106 |         if not len(_range) == 2:
107 |             return await self.ctx.error("Invalid format provided.", 4)
108 |         try:
109 |             x, y = tuple(map(int, _range))
110 |         except ValueError:
111 |             return await self.ctx.error("Invalid format provided.", 4)
112 | 
113 |         if x == y:
114 |             return await self.ctx.error("Invalid range provided.", 4)
115 | 
116 |         cat_name = _format.replace("{0}", "") + f" {x}-{y}"
117 | 
118 |         overwrites = {
119 |             self.ctx.guild.default_role: discord.PermissionOverwrite(read_messages=False),
120 |         }
121 |         if mod := self.tourney.modrole:
122 |             overwrites[mod] = discord.PermissionOverwrite(
123 |                 read_messages=True,
124 |                 send_messages=True,
125 |                 read_message_history=True,
126 |                 manage_channels=True,
127 |                 mention_everyone=True,
128 |             )
129 | 
130 |         await self.ctx.simple(f"Please wait ...", 5)
131 |         category = await self.ctx.guild.create_category(
132 |             name=cat_name, overwrites=overwrites, reason="for group management by {0}".format(self.ctx.author)
133 |         )
134 |         self.category = category
135 |         for i in range(x, y + 1):
136 |             role = await self.__get_or_create_role(_format.replace("{0}", str(i)))
137 |             if not isinstance(role, discord.Role):
138 |                 return await self.ctx.error(role, 10)
139 | 
140 |             _n = {
141 |                 role: discord.PermissionOverwrite(read_messages=True, send_messages=False, read_message_history=True),
142 |                 **overwrites,
143 |             }
144 |             try:
145 |                 await self.category.create_text_channel(_format.replace("{0}", str(i)), overwrites=_n)
146 |             except Exception as e:
147 |                 return await self.ctx.error(e)
148 | 
149 |         await self.ctx.simple("Group channels and roles creation successfuly", 5)
150 | 
151 |     @discord.ui.button(label="Group List", style=discord.ButtonStyle.green)
152 |     async def send_grouplist(self, interaction: discord.Interaction, button: discord.Button):
153 |         await interaction.response.defer()
154 | 
155 |         if not self.tourney.group_size:
156 |             return await self.ctx.error(
157 |                 "**Group size/Teams Per Group is not set.**\n\n"
158 |                 "Please press `Go Back` and click on Edit Settings to set Group Size.",
159 |                 6,
160 |             )
161 | 
162 |         if not await self.tourney.assigned_slots.all():
163 |             return await self.ctx.error("Noboby registered yet.", 4)
164 | 
165 |         self.stop()
166 |         _v = GroupPages(self.ctx, self.tourney, ping_all=self.ping_all, category=self.category)
167 |         _v.add_item(DiscardButton(self.ctx, "Main Menu", 2))
168 |         await _v.rendor(self.message)
169 | 
170 |     async def __get_or_create_role(self, name: str) -> T.Union[discord.Role, str]:
171 |         role = discord.utils.get(self.ctx.guild.roles, name=name)
172 |         if role:
173 |             return role
174 | 
175 |         try:
176 |             role = await self.ctx.guild.create_role(
177 |                 name=name, reason="created for group management by {0}".format(self.ctx.author)
178 |             )
179 |         except Exception as e:
180 |             return e
181 | 
182 |         else:
183 |             return role
184 | 


--------------------------------------------------------------------------------
/cogs/esports/views/idp/__init__.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import discord
 4 | 
 5 | __all__ = ("IdpView",)
 6 | 
 7 | 
 8 | class IdpView(discord.ui.View):
 9 |     def __init__(self, room_id: str, password: str, map: str):
10 |         self.room_id = room_id
11 |         self.password = password
12 |         self.map = map
13 |         super().__init__(timeout=None)
14 | 
15 |     @discord.ui.button(label="Get in Copy Format", style=discord.ButtonStyle.green)
16 |     async def copy_format(self, interaction: discord.Interaction, button: discord.Button):
17 |         await interaction.response.send_message(
18 |             "ID: {}\nPassword: {}\nMap: {}".format(self.room_id, self.password, self.map), ephemeral=True
19 |         )
20 | 


--------------------------------------------------------------------------------
/cogs/esports/views/paginator/__init__.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import discord
 4 | 
 5 | from utils import integer_input
 6 | 
 7 | from ...views.base import Context, EsportsBaseView
 8 | 
 9 | 
10 | class NextButton(discord.ui.Button):
11 |     view: "EsportsBaseView"
12 | 
13 |     def __init__(self):
14 |         super().__init__(emoji="<:double_right:878668437193359392>")
15 | 
16 |     async def callback(self, interaction: discord.Interaction):
17 |         await interaction.response.defer()
18 | 
19 |         self.view.current_page += 1
20 |         await self.view.refresh_view()
21 | 
22 | 
23 | class PrevButton(discord.ui.Button):
24 |     view: "EsportsBaseView"
25 | 
26 |     def __init__(self):
27 |         super().__init__(emoji="<:double_left:878668594530099220>")
28 | 
29 |     async def callback(self, interaction: discord.Interaction):
30 |         await interaction.response.defer()
31 | 
32 |         self.view.current_page -= 1
33 |         await self.view.refresh_view()
34 | 
35 | 
36 | class SkipToButton(discord.ui.Button):
37 |     view: "EsportsBaseView"
38 | 
39 |     def __init__(self, ctx: Context):
40 |         super().__init__(label="Skip to page ...")
41 |         self.ctx = ctx
42 | 
43 |     async def callback(self, interaction: discord.Interaction):
44 |         await interaction.response.defer()
45 | 
46 |         m = await self.ctx.simple(
47 |             "Please enter the page number you want to skip to. (`1` to `{}`)".format(len(self.view.records))
48 |         )
49 |         _page = await integer_input(self.ctx, timeout=30, delete_after=True, limits=(1, len(self.view.records)))
50 |         await self.ctx.safe_delete(m)
51 | 
52 |         self.view.current_page = _page
53 | 
54 |         await self.view.refresh_view()
55 | 
56 | 
57 | class StopButton(discord.ui.Button):
58 |     view: "EsportsBaseView"
59 | 
60 |     def __init__(self):
61 |         super().__init__(emoji="⏹️")
62 | 
63 |     async def callback(self, interaction: discord.Interaction):
64 |         await self.view.on_timeout()
65 | 


--------------------------------------------------------------------------------
/cogs/esports/views/points/__init__.py:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/cogs/esports/views/points/__init__.py


--------------------------------------------------------------------------------
/cogs/esports/views/points/conts.py:
--------------------------------------------------------------------------------
 1 | from uuid import UUID, uuid4
 2 | 
 3 | from pydantic import BaseModel, Field
 4 | 
 5 | 
 6 | class Team(BaseModel):
 7 |     id: str = Field(default_factory=uuid4)
 8 |     name: str
 9 |     matches: str
10 |     kills: int
11 |     placepts: int
12 |     totalpts: int
13 | 


--------------------------------------------------------------------------------
/cogs/esports/views/points/main.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | from contextlib import suppress
  5 | 
  6 | import discord
  7 | 
  8 | from core import Context, QuotientView
  9 | from utils import emote
 10 | 
 11 | from .conts import Team
 12 | 
 13 | 
 14 | class PointsTable(QuotientView):
 15 |     def __init__(self, ctx: Context):
 16 |         super().__init__(ctx, timeout=100)
 17 | 
 18 |         self.teams: T.List[Team] = []
 19 |         self.header: str = None
 20 | 
 21 |         self.footer: str = None
 22 | 
 23 |     @property
 24 |     def initial_msg(self):
 25 |         _e = discord.Embed(color=self.bot.color, title="Points Table Maker")
 26 |         _e.description = "S.No. " + "Team Name".ljust(22) + "Place Pts".ljust(5) + "Kills".ljust(5) + "Total\n" "```\n"
 27 |         for idx, team in enumerate(self.teams, 1):
 28 |             _e.description += (
 29 |                 f"{idx:02}. {team.name.ljust(22)} {str(team.placepts).ljust(5)} {str(team.kills).ljust(5)}"
 30 |                 f"{str(team.totalpts)}\n"
 31 |             )
 32 | 
 33 |         _e.description += "```"
 34 |         _e.set_footer(text=f"Header: {self.header or 'Not Set'}\nFooter: {self.footer or 'Not Set'}")
 35 |         return _e
 36 | 
 37 |     async def refresh_view(self):
 38 |         self.message = await self.message.edit(embed=self.initial_msg, view=self)
 39 | 
 40 |     @discord.ui.button(label="Title & Footer")
 41 |     async def set_title(self, inter: discord.Interaction, btn: discord.Button):
 42 |         modal = ...
 43 |         await inter.response.send_modal()
 44 |         await modal.wait()
 45 | 
 46 |         self.header = modal.header.value
 47 |         self.footer = modal.footer.value
 48 | 
 49 |         await self.refresh_view()
 50 | 
 51 |     @discord.ui.button(label="Add Team")
 52 |     async def add_team(self, inter: discord.Interaction, btn: discord.Button):
 53 |         modal = TeamInput()
 54 |         await inter.response.send_modal(modal)
 55 |         await modal.wait()
 56 | 
 57 |         kills, placepts = None, None
 58 | 
 59 |         with suppress(ValueError):
 60 |             kills = int(modal.kills.value)
 61 |             placepts = int(modal.placepts.value)
 62 | 
 63 |         if not all((kills, placepts)):
 64 |             return await self.ctx.error("Invalid input", 5)
 65 | 
 66 |         self.teams.append(
 67 |             Team(
 68 |                 name=modal.team_name.value,
 69 |                 matches=modal.matches.value,
 70 |                 kills=kills,
 71 |                 placepts=placepts,
 72 |                 totalpts=kills + placepts,
 73 |             )
 74 |         )
 75 |         await self.refresh_view()
 76 | 
 77 |     @discord.ui.button(label="Remove Team")
 78 |     async def remove_team(self, inter: discord.Interaction, btn: discord.Button):
 79 |         await inter.response.defer()
 80 |         if not self.teams:
 81 |             return await self.ctx.error("No teams to remove.", 5)
 82 | 
 83 |         v = QuotientView(self.ctx)
 84 |         v.add_item(TeamSelector(self.teams))
 85 |         v.message = await inter.followup.send("", view=v, ephemeral=True)
 86 |         await v.wait()
 87 | 
 88 |         for _ in self.teams:
 89 |             if str(_.id) in v.custom_id:
 90 |                 self.teams.remove(_)
 91 | 
 92 |         await self.refresh_view()
 93 | 
 94 |     @discord.ui.button(label="Create Image")
 95 |     async def create_image(self, inter: discord.Interaction, btn: discord.Button):
 96 |         await inter.response.send_message(self.teams)
 97 | 
 98 | 
 99 | class HeaderInput(discord.ui.Modal, title="Set Title & Footer"):
100 |     header = discord.ui.TextInput(
101 |         label="Header (optional)",
102 |         max_length=100,
103 |         placeholder="Enter a title for the table",
104 |     )
105 |     footer = discord.ui.TextInput(
106 |         label="Footer (optional)",
107 |         max_length=100,
108 |         placeholder="Enter a footer for the table",
109 |     )
110 | 
111 |     async def on_submit(self, interaction: discord.Interaction) -> None:
112 |         await interaction.response.defer()
113 | 
114 | 
115 | class TeamInput(discord.ui.Modal, title="Add New Team"):
116 |     team_name = discord.ui.TextInput(
117 |         label="Team Name",
118 |         placeholder="Enter team name",
119 |         max_length=20,
120 |         min_length=4,
121 |         required=True,
122 |         style=discord.TextStyle.short,
123 |     )
124 | 
125 |     matches = discord.ui.TextInput(
126 |         label="No. of Matches",
127 |         placeholder="Enter no. of matches",
128 |         max_length=2,
129 |         min_length=1,
130 |         required=True,
131 |         default=1,
132 |     )
133 | 
134 |     kills = discord.ui.TextInput(
135 |         label="No. of Kills",
136 |         placeholder="Enter no. of kills",
137 |         max_length=2,
138 |         min_length=1,
139 |         required=True,
140 |     )
141 | 
142 |     placepts = discord.ui.TextInput(
143 |         label="Place Points",
144 |         placeholder="Enter placement points",
145 |         max_length=2,
146 |         min_length=1,
147 |         required=True,
148 |     )
149 | 
150 |     async def on_submit(self, interaction: discord.Interaction) -> None:
151 |         await interaction.response.defer()
152 | 
153 | 
154 | class TeamSelector(discord.ui.Select):
155 |     view: QuotientView
156 | 
157 |     def __init__(self, teams: T.List[Team]):
158 |         _options = []
159 |         for _ in teams:
160 |             _options.append(discord.SelectOption(label=_.name, value=str(_.id), emoji=emote.TextChannel))
161 | 
162 |         super().__init__(placeholder="Select the teams you want to remove...", max_values=len(teams), options=_options)
163 | 
164 |     async def callback(self, interaction: discord.Interaction):
165 |         await interaction.response.defer()
166 |         self.view.custom_id = self.values
167 |         self.view.stop()
168 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/__init__.py:
--------------------------------------------------------------------------------
1 | from ._edit import *
2 | from .main import *
3 | from .selector import *
4 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_ac.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | 
  5 | import discord
  6 | 
  7 | from constants import AutocleanType
  8 | from core import Context
  9 | from models import ArrayAppend, ArrayRemove, Scrim, Timer
 10 | from utils import keycap_digit as kd
 11 | from utils import time_input
 12 | 
 13 | from ._base import ScrimsButton, ScrimsView
 14 | from ._pages import *
 15 | 
 16 | __all__ = ("AutocleanView",)
 17 | 
 18 | 
 19 | class AutocleanView(ScrimsView):
 20 |     def __init__(self, ctx: Context, scrim: Scrim):
 21 |         super().__init__(ctx)
 22 |         self.ctx = ctx
 23 |         self.record = scrim
 24 | 
 25 |     @property
 26 |     async def initial_embed(self) -> discord.Embed:
 27 |         autoclean_time = (self.record.autoclean_time).strftime("%I:%M %p") if self.record.autoclean_time else "Not Set!"
 28 | 
 29 |         _e = discord.Embed(color=self.ctx.bot.color, description=f"**Scrim Autoclean - {self.record}**\n")
 30 |         _d = "\n".join(
 31 |             f"{idx:02}. {(_type.value.title()).ljust(15)} {('❌', '✅')[_type in self.record.autoclean]}"
 32 |             for idx, _type in enumerate(AutocleanType, start=1)
 33 |         )
 34 | 
 35 |         _e.description += f"```{_d}```\n"
 36 |         _e.description += f"```03. Clean At: {autoclean_time}```"
 37 |         _e.set_footer(text=f"Page - {' / '.join(await self.record.scrim_posi())}")
 38 | 
 39 |         return _e
 40 | 
 41 |     async def refresh_view(self):
 42 |         await self.record.refresh_from_db()
 43 | 
 44 |         await self._add_buttons()
 45 |         try:
 46 |             self.message = await self.message.edit(embed=await self.initial_embed)
 47 |         except discord.HTTPException:
 48 |             await self.on_timeout()
 49 | 
 50 |     async def _add_buttons(self):
 51 |         self.clear_items()
 52 | 
 53 |         self.add_item(OnOne())
 54 |         self.add_item(OnTwo())
 55 |         self.add_item(OnThree())
 56 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
 57 |             self.add_item(Prev(self.ctx, 2))
 58 |             self.add_item(SkipTo(self.ctx, 2))
 59 |             self.add_item(Next(self.ctx, 2))
 60 | 
 61 |         self.add_item(Back())
 62 | 
 63 | 
 64 | class OnOne(ScrimsButton):
 65 |     def __init__(self):
 66 |         super().__init__(emoji=kd(1))
 67 | 
 68 |     async def callback(self, interaction: discord.Interaction):
 69 |         await interaction.response.defer()
 70 |         func = (ArrayAppend, ArrayRemove)[AutocleanType.channel in self.view.record.autoclean]
 71 |         await Scrim.filter(pk=self.view.record.id).update(autoclean=func("autoclean", AutocleanType.channel))
 72 |         await self.view.refresh_view()
 73 | 
 74 |         await self.view.ctx.success(
 75 |             f"Registration channel will {('not be','be')[AutocleanType.channel in self.view.record.autoclean]} autocleaned.",
 76 |             4,
 77 |         )
 78 | 
 79 | 
 80 | class OnTwo(ScrimsButton):
 81 |     def __init__(self):
 82 |         super().__init__(emoji=kd(2))
 83 | 
 84 |     async def callback(self, interaction: discord.Interaction):
 85 |         await interaction.response.defer()
 86 | 
 87 |         func = (ArrayAppend, ArrayRemove)[AutocleanType.role in self.view.record.autoclean]
 88 |         await Scrim.filter(pk=self.view.record.id).update(autoclean=func("autoclean", AutocleanType.role))
 89 |         await self.view.refresh_view()
 90 | 
 91 |         await self.view.ctx.success(
 92 |             f"Scrim role will {('not be','be')[AutocleanType.role in self.view.record.autoclean]} removed from everyone.",
 93 |             4,
 94 |         )
 95 | 
 96 | 
 97 | class OnThree(ScrimsButton):
 98 |     def __init__(self):
 99 |         super().__init__(emoji=kd(3))
100 | 
101 |     async def callback(self, interaction: discord.Interaction):
102 |         await interaction.response.defer()
103 |         m = await self.view.ctx.simple(
104 |             "At what time do you want me to run autoclean?\n\nTime examples:",
105 |             image="https://cdn.discordapp.com/attachments/851846932593770496/958291942062587934/timex.gif",
106 |             footer="Time is according to Indian Standard Time (UTC+05:30)",
107 |         )
108 |         t = await time_input(self.view.ctx, delete_after=True)
109 |         await self.view.ctx.safe_delete(m)
110 |         self.view.record.autoclean_time = t
111 | 
112 |         await Timer.filter(extra={"args": [], "kwargs": {"scrim_id": self.view.record.id}}, event="autoclean").delete()
113 | 
114 |         await self.view.bot.reminders.create_timer(t, "autoclean", scrim_id=self.view.record.id)
115 | 
116 |         await self.view.record.make_changes(autoclean_time=t)
117 |         await self.view.refresh_view()
118 | 
119 | 
120 | class Back(ScrimsButton):
121 |     def __init__(self):
122 |         super().__init__(label="Back", style=discord.ButtonStyle.red, row=2)
123 | 
124 |     async def callback(self, interaction: discord.Interaction):
125 |         await interaction.response.defer()
126 |         self.view.stop()
127 | 
128 |         from ._edit import ScrimsEditor
129 | 
130 |         v = ScrimsEditor(self.view.ctx, self.view.record)
131 |         await v._add_buttons()
132 |         v.message = await self.view.message.edit(embed=await v.initial_message, view=v)
133 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_ban.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import asyncio
  4 | import typing as T
  5 | from contextlib import suppress
  6 | from datetime import timedelta
  7 | 
  8 | import dateparser
  9 | import discord
 10 | 
 11 | from core import Context, QuotientView
 12 | from models import BanLog, BannedTeam, Scrim
 13 | from utils import discord_timestamp, emote, get_chunks, plural, truncate_string
 14 | 
 15 | from ._base import ScrimsButton, ScrimsView
 16 | from ._btns import Discard
 17 | from ._pages import *
 18 | 
 19 | __all__ = ("ScrimBanManager",)
 20 | 
 21 | 
 22 | class ScrimBanManager(ScrimsView):
 23 |     def __init__(self, ctx: Context, scrim: Scrim):
 24 |         super().__init__(ctx)
 25 | 
 26 |         self.ctx = ctx
 27 |         self.record = scrim
 28 | 
 29 |     @property
 30 |     async def initial_message(self):
 31 |         banned = [_ async for _ in self.record.banned_teams.all()]
 32 | 
 33 |         _e = discord.Embed(color=self.bot.color)
 34 |         _e.description = f"**Ban / Unban users from {self.record}**\n\n__Banned:__\n"
 35 | 
 36 |         t = ""
 37 |         for idx, _ in enumerate(banned, 1):
 38 |             t += (
 39 |                 f"`{idx:02}.` {getattr(self.bot.get_user(_.user_id),'mention','`unknown-user`')} "
 40 |                 f"`[{_.user_id}]` - {discord_timestamp(_.expires) if _.expires else 'Lifetime'}\n"
 41 |             )
 42 | 
 43 |         if t != "":
 44 |             _e.description += truncate_string(t, 3900)
 45 |         else:
 46 |             _e.description += "```\nNo Banned user\n```"
 47 | 
 48 |         _e.set_author(name=f"Page - {' / '.join(await self.record.scrim_posi())}", icon_url=self.bot.user.avatar.url)
 49 | 
 50 |         return _e
 51 | 
 52 |     async def refresh_view(self):
 53 |         await self._add_buttons()
 54 |         try:
 55 |             self.message = await self.message.edit(embed=await self.initial_message, view=self)
 56 |         except discord.HTTPException:
 57 |             await self.on_timeout()
 58 | 
 59 |     async def _add_buttons(self):
 60 |         self.clear_items()
 61 | 
 62 |         self.add_item(Ban())
 63 |         self.add_item(UnBan())
 64 |         self.add_item(UnbanAll())
 65 | 
 66 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
 67 |             self.add_item(Prev(self.ctx, 2))
 68 |             self.add_item(SkipTo(self.ctx, 2))
 69 |             self.add_item(Next(self.ctx, 2))
 70 | 
 71 |         self.add_item(Discard(self.ctx, "Main Menu", 2))
 72 | 
 73 | 
 74 | class Ban(ScrimsButton):
 75 |     def __init__(self):
 76 |         super().__init__(label="Ban Users", style=discord.ButtonStyle.red)
 77 | 
 78 |     async def callback(self, interaction: discord.Interaction):
 79 |         modal = MainInput()
 80 |         await interaction.response.send_modal(modal)
 81 |         await modal.wait()
 82 | 
 83 |         m = await self.view.ctx.simple("Please mention the users to ban from this scrim.")
 84 |         try:
 85 |             msg: discord.Message = await self.view.bot.wait_for(
 86 |                 "message",
 87 |                 check=lambda x: x.author.id == interaction.user.id and x.channel.id == interaction.channel_id,
 88 |                 timeout=60.0,
 89 |             )
 90 |         except asyncio.TimeoutError:
 91 |             await self.view.ctx.safe_delete(m)
 92 |             return await self.view.ctx.error("Time out, Please try again later.", 5)
 93 | 
 94 |         await self.view.ctx.safe_delete(m)
 95 |         await self.view.ctx.safe_delete(msg)
 96 | 
 97 |         if not (user_ids := msg.raw_mentions):
 98 |             return await self.view.ctx.error("You didn't mention any user to ban.", 5)
 99 | 
100 |         expires = None
101 |         if modal.m_time.value:
102 |             with suppress(TypeError):
103 |                 expires = dateparser.parse(
104 |                     "in " + modal.m_time.value,
105 |                     settings={
106 |                         "RELATIVE_BASE": self.view.ctx.bot.current_time,
107 |                         "TIMEZONE": "Asia/Kolkata",
108 |                         "RETURN_AS_TIMEZONE_AWARE": True,
109 |                     },
110 |                 )
111 | 
112 |                 while self.view.bot.current_time > expires:
113 |                     expires = expires + timedelta(hours=24)
114 | 
115 |         count = 0
116 |         for user_id in user_ids:
117 |             if await self.view.record.banned_teams.filter(user_id=user_id).exists():
118 |                 continue
119 | 
120 |             b = await BannedTeam.create(user_id=user_id, expires=expires, reason=modal.m_reason.value)
121 |             await self.view.record.banned_teams.add(b)
122 | 
123 |             if banlog := await BanLog.get_or_none(guild_id=interaction.guild_id):
124 |                 await banlog.log_ban(user_id, interaction.user, [self.view.record], modal.m_reason.value, expires)
125 | 
126 |             if expires:
127 |                 await self.view.bot.reminders.create_timer(
128 |                     expires,
129 |                     "scrim_ban",
130 |                     scrims=[self.view.record.id],
131 |                     user_id=user_id,
132 |                     mod=interaction.user.id,
133 |                     reason=modal.m_reason.value,
134 |                 )
135 |             count += 1
136 | 
137 |         await self.view.ctx.success(f"Successfuly banned `{plural(count):user|users}` from {self.view.record}.", 6)
138 |         return await self.view.refresh_view()
139 | 
140 | 
141 | class UnBan(ScrimsButton):
142 |     def __init__(self):
143 |         super().__init__(label="Unban Users", style=discord.ButtonStyle.green)
144 | 
145 |     async def callback(self, interaction: discord.Interaction):
146 |         await interaction.response.defer()
147 | 
148 |         if not (banned_teams := await self.view.record.banned_teams.order_by("id")):
149 |             return await self.view.ctx.error("No banned user found.", 5)
150 | 
151 |         v = QuotientView(self.view.ctx)
152 |         for chunk in get_chunks(banned_teams, 25):
153 |             v.add_item(BanSelector(self.view.ctx, chunk))
154 |         v.message = await interaction.followup.send("", view=v, ephemeral=True)
155 |         await v.wait()
156 |         if v.custom_id:
157 |             banlog = await BanLog.get_or_none(guild_id=interaction.guild_id)
158 | 
159 |             for b in v.custom_id:
160 |                 slot = await BannedTeam.get_or_none(pk=b)
161 |                 if not slot:
162 |                     continue
163 | 
164 |                 await slot.delete()
165 | 
166 |                 if banlog:
167 |                     await banlog.log_unban(
168 |                         slot.user_id, self.view.ctx.author, [self.view.record], "```No reason given```"
169 |                     )
170 | 
171 |         await self.view.ctx.success(f"Successfully unbanned `{plural(v.custom_id):user|users}`.", 6)
172 |         return await self.view.refresh_view()
173 | 
174 | 
175 | class UnbanAll(ScrimsButton):
176 |     def __init__(self):
177 |         super().__init__(label="Unban All", style=discord.ButtonStyle.blurple)
178 | 
179 |     async def callback(self, interaction: discord.Interaction):
180 |         await interaction.response.defer()
181 | 
182 |         scrims = await Scrim.show_selector(self.view.ctx, multi=True)
183 | 
184 |         scrims = [scrims] if not isinstance(scrims, list) else scrims
185 | 
186 |         prompt = await self.view.ctx.prompt(f"Every banned user will be unbanned from `{plural(scrims):scrim|scrims}`")
187 |         if not prompt:
188 |             return await self.view.ctx.error("OK! Aborting.", 4)
189 | 
190 |         count = 0
191 |         for scrim in scrims:
192 |             bans = await scrim.banned_teams.all()
193 |             await BannedTeam.filter(pk__in=(_.pk for _ in bans)).delete()
194 |             count += len(bans)
195 | 
196 |         await self.view.ctx.success(f"Unbanned `{plural(count):user|users}` from `{plural(len(scrims)):scrim|scrims}`", 5)
197 |         return await self.view.refresh_view()
198 | 
199 | 
200 | class MainInput(discord.ui.Modal, title="Ban Time & Reason"):
201 |     m_time = discord.ui.TextInput(
202 |         label="Ban Duration (Optional)",
203 |         placeholder="Eg: 7 days, 1d, 24h, Friday at 6pm, etc.",
204 |         max_length=256,
205 |         required=False,
206 |         style=discord.TextStyle.short,
207 |     )
208 | 
209 |     m_reason = discord.ui.TextInput(
210 |         label="Reason for Ban (Optional)",
211 |         placeholder="khelne nahi aaye harami :)",
212 |         max_length=256,
213 |         required=False,
214 |         style=discord.TextStyle.short,
215 |     )
216 | 
217 |     async def on_submit(self, interaction: discord.Interaction) -> None:
218 |         await interaction.response.defer()
219 | 
220 | 
221 | class BanSelector(discord.ui.Select):
222 |     view: QuotientView
223 | 
224 |     def __init__(self, ctx: Context, teams: T.List[BannedTeam]):
225 |         _options = []
226 | 
227 |         for _ in teams:
228 |             _options.append(
229 |                 discord.SelectOption(
230 |                     label=f"{getattr(ctx.bot.get_user(_.user_id),'name','unknown-user')} [{_.user_id}]",
231 |                     description=f"Expires: {_.expires.strftime('%d %b %Y %H:%M') if _.expires else 'Never'}",
232 |                     emoji=emote.TextChannel,
233 |                     value=_.id,
234 |                 )
235 |             )
236 | 
237 |         super().__init__(placeholder="Select the players to Unban...", options=_options, max_values=len(_options))
238 | 
239 |     async def callback(self, interaction: discord.Interaction):
240 |         await interaction.response.defer()
241 |         self.view.custom_id = self.values
242 |         self.view.stop()
243 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_base.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import discord
 4 | 
 5 | from models import Scrim
 6 | 
 7 | from ...views.base import EsportsBaseView
 8 | 
 9 | __all__ = ("ScrimsView", "ScrimsButton")
10 | 
11 | 
12 | class ScrimsView(EsportsBaseView):
13 |     record: Scrim
14 |     # scrim:Scrim
15 | 
16 |     def __init__(self, ctx, **kwargs):
17 |         super().__init__(ctx, **kwargs)
18 | 
19 |     async def on_error(self, interaction: discord.Interaction, error: Exception, item) -> None:
20 |         print("Scrims View Error:", error)
21 |         self.ctx.bot.dispatch("command_error", self.ctx, error)
22 | 
23 | 
24 | class ScrimsButton(discord.ui.Button):
25 |     view: ScrimsView
26 | 
27 |     def __init__(self, **kwargs):
28 |         super().__init__(**kwargs)
29 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_btns.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from datetime import timedelta
  4 | 
  5 | import discord
  6 | from discord import Interaction
  7 | 
  8 | from core import Context
  9 | from models import Scrim
 10 | from utils import discord_timestamp as dt
 11 | from utils import emote, inputs
 12 | from utils import regional_indicator as ri
 13 | from utils import truncate_string
 14 | 
 15 | from ._base import ScrimsButton
 16 | 
 17 | 
 18 | class SetName(ScrimsButton):
 19 |     def __init__(self, ctx: Context, letter: str):
 20 |         super().__init__(emoji=ri(letter))
 21 |         self.ctx = ctx
 22 | 
 23 |     async def callback(self, interaction: Interaction):
 24 |         await interaction.response.defer()
 25 |         m = await self.ctx.simple("Enter the new name of this scrim. (`Max 30 characters`)")
 26 |         name = await inputs.string_input(self.ctx, delete_after=True)
 27 |         await self.ctx.safe_delete(m)
 28 |         self.view.record.name = truncate_string(name, 30)
 29 | 
 30 |         await self.view.refresh_view()
 31 | 
 32 | 
 33 | class RegChannel(ScrimsButton):
 34 |     def __init__(self, ctx: Context, letter: str):
 35 |         super().__init__(emoji=ri(letter))
 36 |         self.ctx = ctx
 37 | 
 38 |     async def callback(self, interaction: Interaction):
 39 |         await interaction.response.defer()
 40 |         m = await self.ctx.simple("Mention the channel where you want to take registrations.")
 41 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
 42 |         await self.ctx.safe_delete(m)
 43 | 
 44 |         if await Scrim.filter(registration_channel_id=channel.id).exists():
 45 |             return await self.ctx.error("That channel is already in use for another scrim.", 5)
 46 | 
 47 |         self.view.record.registration_channel_id = channel.id
 48 | 
 49 |         if not self.view.record.slotlist_channel_id:
 50 |             self.view.record.slotlist_channel_id = channel.id
 51 | 
 52 |         await self.view.refresh_view()
 53 | 
 54 | 
 55 | class SlotChannel(ScrimsButton):
 56 |     def __init__(self, ctx: Context, letter: str):
 57 |         super().__init__(emoji=ri(letter))
 58 |         self.ctx = ctx
 59 | 
 60 |     async def callback(self, interaction: Interaction):
 61 |         await interaction.response.defer()
 62 | 
 63 |         m = await self.ctx.simple("Mention the channel where you want me to post slotlist after registrations.")
 64 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
 65 |         await self.ctx.safe_delete(m)
 66 | 
 67 |         self.view.record.slotlist_channel_id = channel.id
 68 | 
 69 |         await self.view.refresh_view()
 70 | 
 71 | 
 72 | class SetRole(ScrimsButton):
 73 |     def __init__(self, ctx: Context, letter: str):
 74 |         super().__init__(emoji=ri(letter))
 75 |         self.ctx = ctx
 76 | 
 77 |     async def callback(self, interaction: Interaction):
 78 |         await interaction.response.defer()
 79 |         m = await self.ctx.simple("Mention the role you want to give for correct registration.")
 80 |         role = await inputs.role_input(self.ctx, delete_after=True)
 81 |         await self.ctx.safe_delete(m)
 82 | 
 83 |         self.view.record.role_id = role.id
 84 | 
 85 |         await self.view.refresh_view()
 86 | 
 87 | 
 88 | class SetMentions(ScrimsButton):
 89 |     def __init__(self, ctx: Context, letter: str):
 90 |         super().__init__(emoji=ri(letter))
 91 |         self.ctx = ctx
 92 | 
 93 |     async def callback(self, interaction: Interaction):
 94 |         await interaction.response.defer()
 95 |         m = await self.ctx.simple("How many mentions are required for registration? (Max `10`)")
 96 |         self.view.record.required_mentions = await inputs.integer_input(self.ctx, delete_after=True, limits=(0, 10))
 97 |         await self.ctx.safe_delete(m)
 98 | 
 99 |         await self.view.refresh_view()
100 | 
101 | 
102 | class MinLines(ScrimsButton):
103 |     def __init__(self, ctx: Context, letter: str):
104 |         super().__init__(emoji=ri(letter))
105 |         self.ctx = ctx
106 | 
107 |     async def callback(self, interaction: Interaction):
108 |         await interaction.response.defer()
109 |         if not await self.ctx.is_premium_guild():
110 |             return await self.ctx.error(
111 |                 "**Quotient Premium is required to use this feature.**\n\n`Use qpro command to activate Premium.`", 5
112 |             )
113 | 
114 |         m = await self.ctx.simple("How many lines in registration message are required for registration? (Max `100`)")
115 |         self.view.record.required_lines = await inputs.integer_input(self.ctx, delete_after=True, limits=(0, 10))
116 |         await self.ctx.safe_delete(m)
117 | 
118 |         await self.view.refresh_view()
119 | 
120 | 
121 | class DuplicateTags(ScrimsButton):
122 |     def __init__(self, ctx: Context, letter: str):
123 |         super().__init__(emoji=ri(letter))
124 | 
125 |         self.ctx = ctx
126 | 
127 |     async def callback(self, interaction: discord.Interaction):
128 |         await interaction.response.defer()
129 | 
130 |         if not await self.ctx.is_premium_guild():
131 |             return await self.ctx.error(
132 |                 "[Quotient Premium](https://quotientbot.xyz/premium) is required to use this feature.", 4
133 |             )
134 | 
135 |         self.view.record.allow_duplicate_tags = not self.view.record.allow_duplicate_tags
136 |         await self.ctx.success(
137 |             f"Registrations with fake / duplicate mentions are now **{'allowed' if self.view.record.allow_duplicate_tags else 'not allowed'}**.",
138 |             3,
139 |         )
140 |         await self.view.refresh_view()
141 |         await self.view.record.confirm_all_scrims(self.ctx, allow_duplicate_tags=self.view.record.allow_duplicate_tags)
142 | 
143 | 
144 | class TotalSlots(ScrimsButton):
145 |     def __init__(self, ctx: Context, letter: str):
146 |         super().__init__(emoji=ri(letter))
147 |         self.ctx = ctx
148 | 
149 |     async def callback(self, interaction: Interaction):
150 |         await interaction.response.defer()
151 | 
152 |         m = await self.ctx.simple("How many total slots are there? (Max `30`)")
153 |         self.view.record.total_slots = await inputs.integer_input(self.ctx, delete_after=True, limits=(1, 30))
154 |         await self.ctx.safe_delete(m)
155 | 
156 |         await self.view.refresh_view()
157 | 
158 | 
159 | class OpenTime(ScrimsButton):
160 |     def __init__(self, ctx: Context, letter: str):
161 |         super().__init__(emoji=ri(letter))
162 |         self.ctx = ctx
163 | 
164 |     async def callback(self, interaction: Interaction):
165 |         await interaction.response.defer()
166 |         m = await self.ctx.simple(
167 |             "At what time do you want me to open registrations daily?\n\nTime examples:",
168 |             image="https://cdn.discordapp.com/attachments/851846932593770496/958291942062587934/timex.gif",
169 |             footer="Time is according to Indian Standard Time (UTC+05:30)",
170 |         )
171 |         self.view.record.open_time = await inputs.time_input(self.ctx, delete_after=True)
172 |         await self.ctx.safe_delete(m)
173 | 
174 |         await self.view.refresh_view()
175 | 
176 | 
177 | class SetEmojis(ScrimsButton):
178 |     def __init__(self, ctx: Context, letter: str):
179 |         super().__init__(emoji=ri(letter))
180 |         self.ctx = ctx
181 | 
182 |     async def callback(self, interaction: Interaction):
183 |         await interaction.response.defer()
184 |         if not await self.ctx.is_premium_guild():
185 |             return await self.ctx.error(
186 |                 "[Quotient Premium](https://quotientbot.xyz/premium) is required to use this feature.", 4
187 |             )
188 | 
189 |         e = discord.Embed(color=self.ctx.bot.color, title="Edit scrims emojis")
190 | 
191 |         e.description = (
192 |             "Which emojis do you want to use for tick and cross in scrims registrations?\n\n"
193 |             "`Please enter two emojis and separate them with a comma`"
194 |         )
195 | 
196 |         e.set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/888097255607906354/unknown.png")
197 |         e.set_footer(text="The first emoji must be the emoji for tick mark.")
198 | 
199 |         m = await interaction.followup.send(embed=e)
200 |         emojis = await inputs.string_input(self.ctx, delete_after=True)
201 | 
202 |         await self.ctx.safe_delete(m)
203 | 
204 |         emojis = emojis.strip().split(",")
205 |         if not len(emojis) == 2:
206 |             return await interaction.followup.send("You didn't enter the correct format.", ephemeral=True)
207 | 
208 |         check, cross = emojis
209 | 
210 |         for emoji in emojis:
211 |             try:
212 |                 await self.view.message.add_reaction(emoji.strip())
213 |                 await self.view.message.clear_reactions()
214 |             except discord.HTTPException:
215 |                 return await interaction.followup.send("One of the emojis you entered is invalid.", ephemeral=True)
216 | 
217 |         self.view.record.emojis = {"tick": check.strip(), "cross": cross.strip()}
218 |         await self.view.refresh_view()
219 |         await self.view.record.confirm_all_scrims(self.ctx, emojis=self.view.record.emojis)
220 | 
221 | 
222 | class SetAutoclean(ScrimsButton):
223 |     def __init__(self, ctx: Context, letter: str):
224 |         super().__init__(emoji=ri(letter))
225 |         self.ctx = ctx
226 | 
227 |     async def callback(self, interaction: Interaction):
228 |         await interaction.response.defer()
229 | 
230 |         from ._ac import AutocleanView
231 | 
232 |         self.view.stop()
233 | 
234 |         view = AutocleanView(self.ctx, self.view.record)
235 |         await view._add_buttons()
236 |         view.message = await self.view.message.edit(embed=await view.initial_embed, view=view)
237 | 
238 | 
239 | class PingRole(ScrimsButton):
240 |     def __init__(self, ctx: Context, letter: str):
241 |         super().__init__(emoji=ri(letter))
242 |         self.ctx = ctx
243 | 
244 |     async def callback(self, interaction: Interaction):
245 |         await interaction.response.defer()
246 |         if self.view.record.ping_role_id:
247 |             self.view.record.ping_role_id = None
248 |             await self.view.refresh_view()
249 |             return await self.ctx.success("Removed ping-role, click again to set.", 5)
250 | 
251 |         m = await self.ctx.simple("Mention the role you want to ping when registration starts.")
252 |         role = await inputs.role_input(self.ctx, delete_after=True)
253 |         await self.ctx.safe_delete(m)
254 |         self.view.record.ping_role_id = role.id
255 |         await self.view.refresh_view()
256 | 
257 | 
258 | class OpenRole(ScrimsButton):
259 |     def __init__(self, ctx: Context, letter: str):
260 |         super().__init__(emoji=ri(letter))
261 |         self.ctx = ctx
262 | 
263 |     async def callback(self, interaction: Interaction):
264 |         await interaction.response.defer()
265 |         m = await self.ctx.simple("Mention the role you want to open registration for.")
266 |         role = await inputs.role_input(self.ctx, delete_after=True)
267 |         await self.ctx.safe_delete(m)
268 |         self.view.record.open_role_id = role.id
269 |         await self.view.refresh_view()
270 | 
271 | 
272 | class OpenDays(ScrimsButton):
273 |     def __init__(self, ctx: Context, letter: str):
274 |         super().__init__(emoji=ri(letter))
275 |         self.ctx = ctx
276 | 
277 |     async def callback(self, interaction: Interaction):
278 |         from ._days import WeekDays
279 | 
280 |         await interaction.response.defer()
281 |         v = discord.ui.View(timeout=60.0)
282 |         v.add_item(WeekDays())
283 | 
284 |         await interaction.followup.send("Please select the days to open registrations:", view=v, ephemeral=True)
285 |         await v.wait()
286 |         if c := getattr(v, "custom_id", None):
287 |             self.view.record.open_days = c
288 |             await self.view.refresh_view()
289 | 
290 | 
291 | class MultiReg(ScrimsButton):
292 |     def __init__(self, ctx: Context, letter: str):
293 |         super().__init__(emoji=ri(letter))
294 |         self.ctx = ctx
295 | 
296 |     async def callback(self, interaction: Interaction):
297 |         await interaction.response.defer()
298 | 
299 |         self.view.record.multiregister = not self.view.record.multiregister
300 |         await self.ctx.success(
301 |             f"Now users **{'can' if self.view.record.multiregister else 'can not'}** register more than once.", 3
302 |         )
303 |         await self.view.refresh_view()
304 | 
305 |         await self.view.record.confirm_all_scrims(self.ctx, multiregister=self.view.record.multiregister)
306 | 
307 | 
308 | class TeamCompulsion(ScrimsButton):
309 |     def __init__(self, ctx: Context, letter: str):
310 |         super().__init__(emoji=ri(letter))
311 |         self.ctx = ctx
312 | 
313 |     async def callback(self, interaction: Interaction):
314 |         await interaction.response.defer()
315 |         self.view.record.teamname_compulsion = not self.view.record.teamname_compulsion
316 |         await self.ctx.success(
317 |             f"Now Team Name **{'is' if self.view.record.teamname_compulsion else 'is not'}** required to register.", 3
318 |         )
319 |         await self.view.refresh_view()
320 |         await self.view.record.confirm_all_scrims(self.ctx, teamname_compulsion=self.view.record.teamname_compulsion)
321 | 
322 | 
323 | class DuplicateTeam(ScrimsButton):
324 |     def __init__(self, ctx: Context, letter: str):
325 |         super().__init__(emoji=ri(letter))
326 |         self.ctx = ctx
327 | 
328 |     async def callback(self, interaction: Interaction):
329 |         await interaction.response.defer()
330 | 
331 |         self.view.record.no_duplicate_name = not self.view.record.no_duplicate_name
332 |         await self.ctx.success(
333 |             f"Duplicate team names are now **{'not allowed' if self.view.record.no_duplicate_name else 'allowed'}**.", 3
334 |         )
335 |         await self.view.refresh_view()
336 | 
337 |         await self.view.record.confirm_all_scrims(self.ctx, no_duplicate_name=self.view.record.no_duplicate_name)
338 | 
339 | 
340 | class DeleteReject(ScrimsButton):
341 |     def __init__(self, ctx: Context, letter: str):
342 |         super().__init__(emoji=ri(letter))
343 |         self.ctx = ctx
344 | 
345 |     async def callback(self, interaction: Interaction):
346 |         await interaction.response.defer()
347 |         self.view.record.autodelete_rejects = not self.view.record.autodelete_rejects
348 |         await self.ctx.success(
349 |             f"Rejected registrations will **{'be' if self.view.record.autodelete_rejects else 'not be'}** deleted automatically.",
350 |             3,
351 |         )
352 |         await self.view.refresh_view()
353 |         await self.view.record.confirm_all_scrims(self.ctx, autodelete_rejects=self.view.record.autodelete_rejects)
354 | 
355 | 
356 | class DeleteLate(ScrimsButton):
357 |     def __init__(self, ctx: Context, letter: str):
358 |         super().__init__(emoji=ri(letter))
359 |         self.ctx = ctx
360 | 
361 |     async def callback(self, interaction: Interaction):
362 |         await interaction.response.defer()
363 | 
364 |         self.view.record.autodelete_extras = not self.view.record.autodelete_extras
365 |         await self.ctx.success(
366 |             f"Late/Extra registration messages will **{'be' if self.view.record.autodelete_extras else 'not be'}** deleted automatically.",
367 |             3,
368 |         )
369 |         await self.view.refresh_view()
370 |         await self.view.record.confirm_all_scrims(self.ctx, autodelete_extras=self.view.record.autodelete_extras)
371 | 
372 | 
373 | class SlotlistStart(ScrimsButton):
374 |     def __init__(self, ctx: Context, letter: str):
375 |         super().__init__(emoji=ri(letter))
376 |         self.ctx = ctx
377 | 
378 |     async def callback(self, interaction: Interaction):
379 |         await interaction.response.defer()
380 | 
381 |         m = await self.ctx.success(
382 |             f"From which slot number do you want to start the slotlist? (Enter a number between 1 and {self.view.record.total_slots})"
383 |         )
384 |         self.view.record.start_from = await inputs.integer_input(
385 |             self.ctx, delete_after=True, limits=(1, self.view.record.total_slots)
386 |         )
387 | 
388 |         await self.ctx.safe_delete(m)
389 |         await self.view.refresh_view()
390 |         await self.view.record.confirm_all_scrims(self.ctx, start_from=self.view.record.start_from)
391 | 
392 | 
393 | class Discard(ScrimsButton):
394 |     def __init__(self, ctx: Context, label="Back", row: int = None):
395 |         super().__init__(style=discord.ButtonStyle.red, label=label, row=row)
396 |         self.ctx = ctx
397 | 
398 |     async def callback(self, interaction: Interaction):
399 |         await interaction.response.defer()
400 | 
401 |         from .main import ScrimsMain as SM
402 | 
403 |         self.view.stop()
404 |         v = SM(self.ctx)
405 |         v.message = await self.view.message.edit(embed=await v.initial_embed(), view=v)
406 | 
407 | 
408 | class DeleteScrim(ScrimsButton):
409 |     def __init__(self, ctx: Context):
410 |         super().__init__(emoji=emote.trash, label="Delete")
411 |         self.ctx = ctx
412 | 
413 |     async def callback(self, interaction: Interaction):
414 |         await interaction.response.defer()
415 | 
416 |         prompt = await self.ctx.prompt(
417 |             f"{self.view.record} will be permanently deleted. This action is irreversible.",
418 |             title="Are you sure you want to continue?",
419 |         )
420 |         if not prompt:
421 |             return await self.ctx.simple("OK! Not deleting.", 4)
422 | 
423 |         await self.view.record.full_delete()
424 |         await self.ctx.success(f"{self.view.record} has been deleted.", 4)
425 | 
426 |         from .main import ScrimsMain as SM
427 | 
428 |         self.view.stop()
429 |         v = SM(self.ctx)
430 |         v.message = await self.view.message.edit(embed=await v.initial_embed(), view=v)
431 | 
432 | 
433 | class SaveScrim(ScrimsButton):
434 |     def __init__(self, ctx: Context):
435 |         super().__init__(style=discord.ButtonStyle.green, label="Save Scrim", disabled=True)
436 |         self.ctx = ctx
437 | 
438 |     async def callback(self, interaction: Interaction):
439 |         await interaction.response.defer()
440 | 
441 |         self.ctx.bot.loop.create_task(self.view.record.setup_logs())
442 | 
443 |         self.view.record.autoclean_time = self.ctx.bot.current_time.replace(
444 |             hour=4, minute=0, second=0, microsecond=0
445 |         ) + timedelta(days=1)
446 | 
447 |         await self.view.record.save()
448 | 
449 |         await self.ctx.bot.reminders.create_timer(self.view.record.open_time, "scrim_open", scrim_id=self.view.record.id)
450 | 
451 |         await self.ctx.bot.reminders.create_timer(
452 |             self.view.record.autoclean_time, "autoclean", scrim_id=self.view.record.id
453 |         )
454 | 
455 |         self.view.stop()
456 |         await self.ctx.success(f"Scrim was successfully created. (Registration: {dt(self.view.record.open_time)})", 6)
457 | 
458 |         from .main import ScrimsMain
459 | 
460 |         view = ScrimsMain(self.ctx)
461 |         view.message = await self.view.message.edit(embed=await view.initial_embed(), view=view)
462 | 
463 | 
464 | #!add option to add this scrim to cancel claim
465 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_cdn.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | 
  5 | import discord
  6 | from pydantic import BaseModel
  7 | 
  8 | import config
  9 | from core import Context
 10 | from core.embeds import EmbedBuilder
 11 | from models import Scrim
 12 | from utils import integer_input
 13 | from utils import keycap_digit as kd
 14 | 
 15 | from ._base import ScrimsView
 16 | 
 17 | __all__ = ("ScrimsCDN",)
 18 | 
 19 | 
 20 | class CDN(BaseModel):
 21 |     status: bool = False
 22 |     countdown: int = 5
 23 |     msg: dict = ...
 24 | 
 25 | 
 26 | class ScrimsCDN(ScrimsView):
 27 |     def __init__(self, ctx: Context, scrim: Scrim):
 28 |         super().__init__(ctx, timeout=60.0)
 29 | 
 30 |         self.scrim = scrim
 31 | 
 32 |     @property
 33 |     def initial_embed(self):
 34 |         _e = discord.Embed(
 35 |             color=self.bot.color,
 36 |         )
 37 |         _e.description = "**Registration open countdown editor -** {0}".format(self.scrim)
 38 | 
 39 |         fields = {
 40 |             "ON / OFF": ("`OFF`", "`ON`")[self.scrim.cdn["status"]],
 41 |             "Countdown": f"`{self.scrim.cdn['countdown']}s`",
 42 |             "Message": "`Click to view or edit`",
 43 |         }
 44 | 
 45 |         for idx, (name, value) in enumerate(fields.items(), 1):
 46 |             _e.add_field(
 47 |                 name=f"{kd(idx)} {name}:",
 48 |                 value=value,
 49 |                 inline=False,
 50 |             )
 51 | 
 52 |         return _e
 53 | 
 54 |     async def refresh_view(self, **kwargs):
 55 |         await self.scrim.make_changes(**kwargs)
 56 |         self.message = await self.message.edit(embed=self.initial_embed, view=self)
 57 | 
 58 |     @discord.ui.button(emoji=kd(1))
 59 |     async def change_status(self, inter: discord.Interaction, btn: discord.Button):
 60 |         await inter.response.defer()
 61 | 
 62 |         self.scrim.cdn["status"] = not self.scrim.cdn["status"]
 63 |         await self.refresh_view(cdn=self.scrim.cdn)
 64 | 
 65 |     @discord.ui.button(emoji=kd(2))
 66 |     async def set_time(self, inter: discord.Interaction, btn: discord.Button):
 67 |         await inter.response.defer()
 68 | 
 69 |         _m = await self.ctx.simple("How many seconds should the countdown be? (Min: `3` Max: `10`)")
 70 |         self.scrim.cdn["countdown"] = await integer_input(self.ctx, limits=(5, 15), delete_after=True)
 71 |         await self.ctx.safe_delete(_m)
 72 |         await self.refresh_view(cdn=self.scrim.cdn)
 73 | 
 74 |     @discord.ui.button(emoji=kd(3))
 75 |     async def set_msg(self, inter: discord.Interaction, btn: discord.Button):
 76 |         await inter.response.defer()
 77 |         await self.scrim.refresh_from_db()
 78 | 
 79 |         from ._design import BackBtn, MsgType, SaveMessageBtn, ScrimDesign, SetDefault
 80 | 
 81 |         if len(self.scrim.cdn["msg"]) <= 1:
 82 |             _e = ScrimDesign.default_countdown_msg()
 83 | 
 84 |         else:
 85 |             _e = discord.Embed.from_dict(self.scrim.cdn["msg"])
 86 | 
 87 |         self.stop()
 88 | 
 89 |         embed = discord.Embed(color=self.bot.color, title="Click Me if you need Help", url=self.bot.config.SERVER_LINK)
 90 |         embed.description = (
 91 |             f"\n*You are editing registration close message for {self.scrim}*\n\n"
 92 |             "**__Keywords you can use in design:__**\n"
 93 |             "`<<t>>` - Seconds left in opening reg (counter).\n"
 94 |         )
 95 |         await self.message.edit(embed=embed, content="", view=None)
 96 | 
 97 |         _v = EmbedBuilder(
 98 |             self.ctx,
 99 |             items=[
100 |                 SaveMessageBtn(self.ctx, self.scrim, MsgType.countdown, self.message),
101 |                 BackBtn(self.ctx, self.scrim, self.message),
102 |                 SetDefault(self.ctx, self.scrim, MsgType.countdown),
103 |             ],
104 |         )
105 | 
106 |         await _v.rendor(embed=_e)
107 | 
108 |     @discord.ui.button(style=discord.ButtonStyle.red, label="Back")
109 |     async def go_back(self, inter: discord.Interaction, btn: discord.Button):
110 |         await inter.response.defer()
111 | 
112 |         from ._design import ScrimDesign
113 | 
114 |         self.stop()
115 |         v = ScrimDesign(self.ctx, self.scrim)
116 |         v.message = await self.message.edit(embed=v.initial_embed, view=v)
117 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_days.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import discord
 4 | 
 5 | from constants import Day
 6 | from utils import keycap_digit
 7 | 
 8 | __all__ = ("WeekDays",)
 9 | 
10 | 
11 | class WeekDays(discord.ui.Select):
12 |     def __init__(self, placeholder="Select the weekdays for registrations", max=7):
13 |         _o = []
14 |         for idx, day in enumerate(Day, start=1):
15 |             _o.append(discord.SelectOption(label=day.name.title(), value=day.name, emoji=keycap_digit(idx)))
16 | 
17 |         super().__init__(placeholder=placeholder, max_values=max, options=_o)
18 | 
19 |     async def callback(self, interaction: discord.Interaction):
20 |         await interaction.response.defer()
21 |         self.view.stop()
22 | 
23 |         self.view.custom_id = [Day(_) for _ in self.values]
24 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_design.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | from enum import Enum
  5 | 
  6 | import discord
  7 | 
  8 | import config
  9 | from core import Context
 10 | from core.embeds import EmbedBuilder
 11 | from models import Scrim
 12 | from utils import regional_indicator as ri
 13 | 
 14 | from ._base import ScrimsButton, ScrimsView
 15 | from ._btns import Discard
 16 | from ._cdn import ScrimsCDN
 17 | from ._formatter import show_slotlist_formatter
 18 | from ._pages import *
 19 | 
 20 | 
 21 | class MsgType(Enum):
 22 |     open = "1"
 23 |     close = "2"
 24 |     countdown = "3"
 25 | 
 26 | 
 27 | class ScrimDesign(ScrimsView):
 28 |     def __init__(self, ctx: Context, scrim: Scrim):
 29 |         super().__init__(ctx, timeout=60.0)
 30 | 
 31 |         self.record = scrim
 32 |         self.ctx = ctx
 33 | 
 34 |     @staticmethod
 35 |     def default_open_msg():
 36 |         return discord.Embed(
 37 |             color=config.COLOR,
 38 |             title="Registration is now open!",
 39 |             description=f"📣 **`<<mentions>>`** mentions required.\n"
 40 |             f"📣 Total slots: **`<<slots>>`** [`<<reserved>>` slots reserved]",
 41 |         )
 42 | 
 43 |     @staticmethod
 44 |     def default_close_msg():
 45 |         return discord.Embed(color=config.COLOR, description="**Registration is now Closed!**")
 46 | 
 47 |     @staticmethod
 48 |     def default_countdown_msg():
 49 |         return discord.Embed(color=config.COLOR, description="*Registration is starting in* **`<<t>>` seconds.**")
 50 | 
 51 |     @property
 52 |     async def initial_embed(self):
 53 |         _e = discord.Embed(color=0x00FFB3)
 54 |         _e.description = (
 55 |             f"[**Scrims - Design Settings - {self.record}**]({self.ctx.config.SERVER_LINK})\n"
 56 |             "What do you want to design today?\n\n"
 57 |             f"{ri('a')} - Registration Open Message\n"
 58 |             f"{ri('b')} - Registration Close Message\n"
 59 |             # f"{ri('c')} - Registration Open Countdown\n"
 60 |             f"{ri('c')} - Slotlist Design\n"
 61 |         )
 62 |         _e.set_footer(text=f"Page - {' / '.join(await self.record.scrim_posi())}")
 63 |         return _e
 64 | 
 65 |     async def _add_buttons(self):
 66 |         self.clear_items()
 67 | 
 68 |         self.add_item(OpenMessage())
 69 |         self.add_item(CloseMessage())
 70 |         # self.add_item(CDNmsg())
 71 |         self.add_item(SlotlistFormat())
 72 | 
 73 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
 74 |             self.add_item(Prev(self.ctx, 2))
 75 |             self.add_item(SkipTo(self.ctx, 2))
 76 |             self.add_item(Next(self.ctx, 2))
 77 | 
 78 |         self.add_item(Discard(self.ctx, "Main Menu", 2))
 79 | 
 80 |     async def refresh_view(self):
 81 |         await self._add_buttons()
 82 |         try:
 83 |             self.message = await self.message.edit(embed=await self.initial_embed, view=self)
 84 |         except discord.HTTPException:
 85 |             await self.on_timeout()
 86 | 
 87 | 
 88 | class OpenMessage(ScrimsButton):
 89 |     def __init__(self):
 90 |         super().__init__(emoji=ri("a"))
 91 | 
 92 |     async def callback(self, interaction: discord.Interaction):
 93 |         await interaction.response.defer()
 94 | 
 95 |         await self.view.record.refresh_from_db()
 96 | 
 97 |         if len(self.view.record.open_message) <= 1:
 98 |             _e = ScrimDesign.default_open_msg()
 99 | 
100 |         else:
101 |             _e = discord.Embed.from_dict(self.view.record.open_message)
102 | 
103 |         self.view.stop()
104 | 
105 |         embed = discord.Embed(color=self.view.bot.color, title="Click me to Get Help", url=config.SERVER_LINK)
106 |         embed.description = (
107 |             f"\n*You are editing registration open message for {self.view.record}*\n\n"
108 |             "**__Keywords you can use in design:__**\n"
109 |             "`<<mentions>>` - Number of mentions required\n"
110 |             "`<<slots>>` - Total slots in this scrim\n"
111 |             "`<<reserved>>` - Number of Reserved slots\n"
112 |             "`<<slotlist>>` - Slotlist Channel mention.\n"
113 |             "`<<mention_banned>>` -  Mention banned users.\n"
114 |             "`<<mention_reserved>>` - Mention reserved slot owners.\n"
115 |         )
116 |         await self.view.message.edit(embed=embed, content="", view=None)
117 | 
118 |         _v = EmbedBuilder(
119 |             self.view.ctx,
120 |             items=[
121 |                 SaveMessageBtn(self.view.ctx, self.view.record, MsgType.open, self.view.message),
122 |                 BackBtn(self.view.ctx, self.view.record, self.view.message),
123 |                 SetDefault(self.view.ctx, self.view.record, MsgType.open),
124 |             ],
125 |         )
126 | 
127 |         await _v.rendor(embed=_e)
128 | 
129 | 
130 | class CloseMessage(ScrimsButton):
131 |     def __init__(self):
132 |         super().__init__(emoji=ri("b"))
133 | 
134 |     async def callback(self, interaction: discord.Interaction):
135 |         await interaction.response.defer()
136 | 
137 |         await self.view.record.refresh_from_db()
138 | 
139 |         if len(self.view.record.close_message) <= 1:
140 |             _e = ScrimDesign.default_close_msg()
141 | 
142 |         else:
143 |             _e = discord.Embed.from_dict(self.view.record.close_message)
144 | 
145 |         self.view.stop()
146 |         embed = discord.Embed(
147 |             color=self.view.bot.color, title="Click Me if you need Help", url=self.view.bot.config.SERVER_LINK
148 |         )
149 |         embed.description = (
150 |             f"\n*You are editing registration close message for {self.view.record}*\n\n"
151 |             "**__Keywords you can use in design:__**\n"
152 |             "`<<slots>>` - Total slots in this scrim.\n"
153 |             "`<<filled>>` - Number of slots filled during registration.\n"
154 |             "`<<time_taken>>` - Time taken in registration.\n"
155 |             "`<<open_time>>` - Next day's registration time."
156 |         )
157 |         await self.view.message.edit(embed=embed, content="", view=None)
158 | 
159 |         _v = EmbedBuilder(
160 |             self.view.ctx,
161 |             items=[
162 |                 SaveMessageBtn(self.view.ctx, self.view.record, MsgType.close, self.view.message),
163 |                 BackBtn(self.view.ctx, self.view.record, self.view.message),
164 |                 SetDefault(self.view.ctx, self.view.record, MsgType.close),
165 |             ],
166 |         )
167 | 
168 |         await _v.rendor(embed=_e)
169 | 
170 | 
171 | class CDNmsg(ScrimsButton):
172 |     def __init__(self):
173 |         super().__init__(emoji=ri("c"))
174 | 
175 |     async def callback(self, interaction: discord.Interaction):
176 |         await interaction.response.defer()
177 | 
178 |         self.view.stop()
179 |         v = ScrimsCDN(self.view.ctx, self.view.record)
180 |         v.message = await self.view.message.edit(embed=v.initial_embed, view=v)
181 | 
182 | 
183 | class SlotlistFormat(ScrimsButton):
184 |     def __init__(self):
185 |         super().__init__(emoji=ri("c"))
186 | 
187 |     async def callback(self, interaction: discord.Interaction):
188 |         await interaction.response.defer()
189 |         self.view.stop()
190 |         await show_slotlist_formatter(self.view.ctx, self.view.record, self.view.message)
191 | 
192 | 
193 | class SaveMessageBtn(discord.ui.Button):
194 |     view: EmbedBuilder
195 | 
196 |     def __init__(self, ctx: Context, scrim: Scrim, _type: MsgType, msg: discord.Message = None):
197 |         super().__init__(style=discord.ButtonStyle.green, label="Save this design")
198 |         self.scrim = scrim
199 | 
200 |         self.ctx = ctx
201 |         self.msg = msg
202 |         self._type = _type
203 | 
204 |     async def callback(self, interaction: discord.Interaction):
205 |         await interaction.response.defer()
206 | 
207 |         await self.ctx.simple(f"Saving Changes...", 2)
208 | 
209 |         if self._type == MsgType.open:
210 |             await self.scrim.make_changes(open_message=self.view.formatted)
211 |             await self.scrim.confirm_all_scrims(self.ctx, open_message=self.view.formatted)
212 | 
213 |         elif self._type == MsgType.close:
214 |             await self.scrim.make_changes(close_message=self.view.formatted)
215 |             await self.scrim.confirm_all_scrims(self.ctx, close_message=self.view.formatted)
216 | 
217 |         elif self._type == MsgType.countdown:
218 |             self.scrim.cdn["msg"] = self.view.formatted
219 |             await self.scrim.make_changes(cdn=self.scrim.cdn)
220 |             await self.scrim.confirm_all_scrims(self.ctx, cdn=self.scrim.cdn)
221 | 
222 |         await self.ctx.success(f"Saved!", 2)
223 | 
224 |         self.view.stop()
225 | 
226 |         if self.msg:
227 |             await self.ctx.safe_delete(self.msg)
228 | 
229 |         v = ScrimDesign(self.ctx, self.scrim)
230 |         await v._add_buttons()
231 |         v.message = await self.view.message.edit(embed=await v.initial_embed, view=v)
232 | 
233 | 
234 | class BackBtn(discord.ui.Button):
235 |     view: EmbedBuilder
236 | 
237 |     def __init__(self, ctx: Context, scrim: Scrim, msg: discord.Message = None):
238 |         super().__init__(style=discord.ButtonStyle.red, label="Exit")
239 |         self.ctx = ctx
240 |         self.scrim = scrim
241 | 
242 |         self.msg = msg
243 | 
244 |     async def callback(self, interaction: discord.Interaction):
245 |         await interaction.response.defer()
246 |         prompt = await self.ctx.prompt("All unsaved changes will be lost forever. Do you still want to continue?")
247 |         if not prompt:
248 |             return await self.ctx.simple("OK. Not Exiting.", 4)
249 | 
250 |         self.view.stop()
251 | 
252 |         if self.msg:
253 |             await self.ctx.safe_delete(self.msg)
254 |         v = ScrimDesign(self.ctx, self.scrim)
255 |         await v._add_buttons()
256 |         v.message = await self.view.message.edit(embed=await v.initial_embed, view=v)
257 | 
258 | 
259 | class SetDefault(discord.ui.Button):
260 |     view: EmbedBuilder
261 | 
262 |     def __init__(self, ctx: Context, scrim: Scrim, _type: MsgType):
263 |         super().__init__(style=discord.ButtonStyle.blurple, label="Reset to default")
264 |         self._type = _type
265 |         self.scrim = scrim
266 |         self.ctx = ctx
267 | 
268 |     async def callback(self, interaction: discord.Interaction):
269 |         await interaction.response.defer()
270 |         prompt = await self.ctx.prompt("All changes will be lost. Do you still want to continue?")
271 |         if not prompt:
272 |             return await self.ctx.simple("OK, not reseting.", 3)
273 | 
274 |         if self._type == MsgType.open:
275 |             self.view.embed = ScrimDesign.default_open_msg()
276 | 
277 |         elif self._type == MsgType.close:
278 |             self.view.embed = ScrimDesign.default_close_msg()
279 | 
280 |         else:
281 |             self.view.embed = ScrimDesign.default_countdown_msg()
282 | 
283 |         self.view.content = ""
284 |         await self.view.refresh_view()
285 |         await self.ctx.success("Message set to default. Click `Save` to save this design.", 4)
286 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_edit.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | from string import ascii_uppercase
  5 | 
  6 | import discord
  7 | 
  8 | from core import Context
  9 | from models import Scrim, Timer
 10 | from utils import discord_timestamp as dt
 11 | from utils import regional_indicator as ri
 12 | 
 13 | from ._base import ScrimsView
 14 | from ._btns import *
 15 | from ._pages import *
 16 | 
 17 | 
 18 | class ScrimsEditor(ScrimsView):
 19 |     def __init__(self, ctx: Context, scrim: Scrim):
 20 |         super().__init__(ctx, timeout=60.0)
 21 |         self.ctx = ctx
 22 |         self.record = scrim
 23 | 
 24 |         self.page_info = ("x", "y")
 25 | 
 26 |     async def refresh_view(self):
 27 |         _d = dict(self.record)
 28 | 
 29 |         del _d["id"]
 30 |         del _d["autoclean"]
 31 |         del _d["available_slots"]
 32 |         del _d["open_days"]
 33 | 
 34 |         await Timer.filter(extra={"args": [], "kwargs": {"scrim_id": self.record.id}}, event="scrim_open").delete()
 35 |         await self.bot.reminders.create_timer(_d["open_time"], "scrim_open", scrim_id=self.record.id)
 36 | 
 37 |         await self.bot.db.execute(
 38 |             """UPDATE public."sm.scrims" SET open_days = $1 WHERE id = $2""",
 39 |             [_.value for _ in self.record.open_days],
 40 |             self.record.id,
 41 |         )
 42 | 
 43 |         await self.record.make_changes(**_d)
 44 | 
 45 |         await self._add_buttons()
 46 |         try:
 47 |             self.message = await self.message.edit(embed=await self.initial_message, view=self)
 48 |         except discord.HTTPException:
 49 |             await self.on_timeout()
 50 | 
 51 |     @property
 52 |     async def initial_message(self):
 53 |         scrim = self.record
 54 | 
 55 |         _e = discord.Embed(color=0x00FFB3, url=self.ctx.config.SERVER_LINK)
 56 |         _e.title = "Scrims Editor - Edit Settings"
 57 | 
 58 |         fields = {
 59 |             "Name": "`{0}`".format(scrim.name),
 60 |             "Registration Channel": getattr(scrim.registration_channel, "mention", "`channel-deleted`"),
 61 |             "Slotlist Channel": getattr(scrim.slotlist_channel, "mention", "`deleted-channel`"),
 62 |             "Success Role": getattr(scrim.role, "mention", "`role-deleted`"),
 63 |             "Mentions": f"`{scrim.required_mentions}`",
 64 |             "Slots": f"`{scrim.total_slots}`",
 65 |             "Open Time": f"{dt(scrim.open_time,'t')} ({dt(scrim.open_time)})",
 66 |             f"Reactions {self.bot.config.PRIME_EMOJI}": f"{scrim.check_emoji},{scrim.cross_emoji}",
 67 |             "Ping Role": getattr(scrim.ping_role, "mention", "`Not-Set`"),
 68 |             "Open Role": getattr(scrim.open_role, "mention", "`role-deleted`"),
 69 |             "Multi-Register": ("`Not allowed!`", "`Allowed`")[scrim.multiregister],
 70 |             "Team Compulsion": ("`No!`", "`Yes!`")[scrim.teamname_compulsion],
 71 |             "Duplicate Team Name": ("`Allowed`", "`Not allowed!`")[scrim.no_duplicate_name],
 72 |             "Autodelete Rejected": ("`No!`", "`Yes!`")[scrim.autodelete_rejects],
 73 |             "Autodelete Late Messages": ("`No!`", "`Yes!`")[scrim.autodelete_extras],
 74 |             "Slotlist Start from": "`{}`".format(scrim.start_from),
 75 |             "Autoclean": f"{dt(scrim.autoclean_time,'t')} (`{', '.join(_.name.title() for _ in scrim.autoclean)}`)"
 76 |             if scrim.autoclean_time
 77 |             else "`Turned OFF`",
 78 |             "Scrim Days": ", ".join(map(lambda x: "`{0}`".format(x.name.title()[:2]), self.record.open_days))
 79 |             if self.record.open_days
 80 |             else "`Not set`",
 81 |             f"Required Lines {self.bot.config.PRIME_EMOJI}": ("`Not set`", "`{0}`".format(scrim.required_lines))[
 82 |                 bool(scrim.required_lines)
 83 |             ],
 84 |             f"Duplicate / Fake Tags {self.bot.config.PRIME_EMOJI}": ("`Not allowed!`", "`Allowed`")[
 85 |                 scrim.allow_duplicate_tags
 86 |             ],
 87 |         }
 88 | 
 89 |         for idx, (name, value) in enumerate(fields.items()):
 90 |             _e.add_field(
 91 |                 name=f"{ri(ascii_uppercase[idx])} {name}:",
 92 |                 value=value,
 93 |             )
 94 |         _e.add_field(name="\u200b", value="\u200b")  # invisible field
 95 |         _e.set_footer(text=f"Page - {' / '.join(await self.record.scrim_posi())}")
 96 |         return _e
 97 | 
 98 |     async def _add_buttons(self):
 99 |         self.clear_items()
100 | 
101 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
102 |             self.add_item(Prev(self.ctx))
103 |             self.add_item(SkipTo(self.ctx))
104 |             self.add_item(Next(self.ctx))
105 | 
106 |         self.add_item(SetName(self.ctx, "a"))
107 |         self.add_item(RegChannel(self.ctx, "b"))
108 |         self.add_item(SlotChannel(self.ctx, "c"))
109 |         self.add_item(SetRole(self.ctx, "d"))
110 |         self.add_item(SetMentions(self.ctx, "e"))
111 |         self.add_item(TotalSlots(self.ctx, "f"))
112 |         self.add_item(OpenTime(self.ctx, "g"))
113 |         self.add_item(SetEmojis(self.ctx, "h"))
114 |         self.add_item(PingRole(self.ctx, "i"))
115 |         self.add_item(OpenRole(self.ctx, "j"))
116 | 
117 |         self.add_item(MultiReg(self.ctx, "k"))
118 |         self.add_item(TeamCompulsion(self.ctx, "l"))
119 |         self.add_item(DuplicateTeam(self.ctx, "m"))
120 |         self.add_item(DeleteReject(self.ctx, "n"))
121 |         self.add_item(DeleteLate(self.ctx, "o"))
122 |         self.add_item(SlotlistStart(self.ctx, "p"))
123 |         self.add_item(SetAutoclean(self.ctx, "q"))
124 |         self.add_item(OpenDays(self.ctx, "r"))
125 |         self.add_item(MinLines(self.ctx, "s"))
126 |         self.add_item(DuplicateTags(self.ctx, "t"))
127 | 
128 |         self.add_item(DeleteScrim(self.ctx))
129 |         self.add_item(Discard(self.ctx, "Main Menu"))
130 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_formatter.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import discord
  4 | 
  5 | from core import Context
  6 | from core.embeds import EmbedBuilder
  7 | from models import Scrim
  8 | 
  9 | DEFAULT_MSG = Scrim.default_slotlist_format()
 10 | 
 11 | __all__ = ("show_slotlist_formatter",)
 12 | 
 13 | 
 14 | async def show_slotlist_formatter(ctx: Context, scrim: Scrim, view_msg: discord.Message):
 15 |     await scrim.refresh_from_db()
 16 | 
 17 |     embed = discord.Embed(color=ctx.bot.color, title="Click me to Get Help", url=ctx.config.SERVER_LINK)
 18 |     embed.description = (
 19 |         f"\n*You are editing slotlist design for {scrim}*\n\n"
 20 |         "**__Keywords you can use in design:__**\n"
 21 |         "`<<slots>>` - Slot number and team names (**Most Important**)\n"
 22 |         "`<<name>>` -  Name of the scrim\n"
 23 |         "`<<open_time>>` - Next day's registration open time.\n"
 24 |         "`<<time_taken>>` - Time taken in registration.\n"
 25 |     )
 26 | 
 27 |     await view_msg.edit(embed=embed, content="", view=None)
 28 | 
 29 |     if len(scrim.slotlist_format) <= 1:
 30 |         embed = DEFAULT_MSG
 31 |     else:
 32 |         embed = discord.Embed.from_dict(scrim.slotlist_format)
 33 | 
 34 |     _v = EmbedBuilder(
 35 |         ctx,
 36 |         items=[
 37 |             SaveBtn(ctx, scrim, view_msg),
 38 |             BackBtn(ctx, scrim, view_msg),
 39 |             SetDefault(ctx, scrim),
 40 |         ],
 41 |     )
 42 | 
 43 |     await _v.rendor(embed=embed)
 44 | 
 45 | 
 46 | class SaveBtn(discord.ui.Button):
 47 |     view: EmbedBuilder
 48 | 
 49 |     def __init__(self, ctx: Context, scrim: Scrim, msg: discord.Message = None):
 50 |         super().__init__(style=discord.ButtonStyle.green, label="Save this design")
 51 | 
 52 |         self.ctx = ctx
 53 |         self.scrim = scrim
 54 |         self.msg = msg
 55 | 
 56 |     async def callback(self, interaction: discord.Interaction):
 57 |         await interaction.response.defer()
 58 | 
 59 |         await self.ctx.simple(f"Saving Changes...", 2)
 60 | 
 61 |         await self.scrim.make_changes(slotlist_format=self.view.formatted)
 62 |         await self.scrim.confirm_all_scrims(self.ctx, slotlist_format=self.view.formatted)
 63 | 
 64 |         await self.ctx.success(f"Saved your new design!", 2)
 65 |         self.view.stop()
 66 | 
 67 |         if self.msg:
 68 |             await self.ctx.safe_delete(self.msg)
 69 | 
 70 |         from .main import ScrimsMain
 71 | 
 72 |         v = ScrimsMain(self.ctx)
 73 |         v.message = await self.view.message.edit(content="", embed=await v.initial_embed(), view=v)
 74 | 
 75 | 
 76 | class BackBtn(discord.ui.Button):
 77 |     view: EmbedBuilder
 78 | 
 79 |     def __init__(self, ctx: Context, scrim: Scrim, msg: discord.Message = None):
 80 |         super().__init__(style=discord.ButtonStyle.red, label="Exit")
 81 |         self.ctx = ctx
 82 |         self.scrim = scrim
 83 | 
 84 |         self.msg = msg
 85 | 
 86 |     async def callback(self, interaction: discord.Interaction):
 87 |         await interaction.response.defer()
 88 |         prompt = await self.ctx.prompt("All unsaved changes will be lost forever. Do you still want to continue?")
 89 |         if not prompt:
 90 |             return await self.ctx.simple("OK. Not Exiting.", 4)
 91 | 
 92 |         self.view.stop()
 93 | 
 94 |         if self.msg:
 95 |             await self.ctx.safe_delete(self.msg)
 96 | 
 97 |         from .main import ScrimsMain
 98 | 
 99 |         v = ScrimsMain(self.ctx)
100 |         v.message = await self.view.message.edit(content="", embed=await v.initial_embed(), view=v)
101 | 
102 | 
103 | class SetDefault(discord.ui.Button):
104 |     view: EmbedBuilder
105 | 
106 |     def __init__(self, ctx: Context, scrim: Scrim):
107 |         super().__init__(style=discord.ButtonStyle.blurple, label="Reset to default")
108 | 
109 |         self.scrim = scrim
110 |         self.ctx = ctx
111 | 
112 |     async def callback(self, interaction: discord.Interaction):
113 |         await interaction.response.defer()
114 |         prompt = await self.ctx.prompt("All changes will be lost. Do you still want to continue?")
115 |         if not prompt:
116 |             return await self.ctx.simple("OK, not reseting.", 3)
117 | 
118 |         self.view.embed = DEFAULT_MSG
119 | 
120 |         self.view.content = ""
121 |         await self.view.refresh_view()
122 |         await self.ctx.success("Slotlist design set to default. Click `Save` to save this design.", 4)
123 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_pages.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import discord
 4 | 
 5 | from core import Context
 6 | from models import Scrim
 7 | 
 8 | from ._base import ScrimsButton
 9 | 
10 | __all__ = "Next", "Prev", "SkipTo"
11 | 
12 | 
13 | class Next(ScrimsButton):
14 |     def __init__(self, ctx: Context, row: int = None):
15 |         super().__init__(emoji="<:double_right:878668437193359392>", row=row)
16 |         self.ctx = ctx
17 | 
18 |     async def callback(self, interaction: discord.Interaction):
19 |         await interaction.response.defer()
20 | 
21 |         _ids = [_.pk async for _ in Scrim.filter(guild_id=self.ctx.guild.id).order_by("open_time")]
22 |         current = _ids.index(self.view.record.pk)
23 | 
24 |         try:
25 |             next_id = _ids[current + 1]
26 |         except IndexError:
27 |             next_id = _ids[0]
28 | 
29 |         new_scrim = await Scrim.get(pk=next_id)
30 |         if not self.view.record == new_scrim:
31 |             self.view.record = new_scrim
32 |             await self.view.refresh_view()
33 | 
34 | 
35 | class Prev(ScrimsButton):
36 |     def __init__(self, ctx: Context, row: int = None):
37 |         super().__init__(emoji="<:double_left:878668594530099220>", row=row)
38 |         self.ctx = ctx
39 | 
40 |     async def callback(self, interaction: discord.Interaction):
41 |         await interaction.response.defer()
42 | 
43 |         _ids = [_.pk async for _ in Scrim.filter(guild_id=self.ctx.guild.id).order_by("open_time")]
44 |         current = _ids.index(self.view.record.pk)
45 | 
46 |         try:
47 |             next_id = _ids[current - 1]
48 |         except IndexError:
49 |             next_id = _ids[-1]
50 | 
51 |         new_scrim = await Scrim.get(pk=next_id)
52 |         if not self.view.record == new_scrim:
53 |             self.view.record = new_scrim
54 |             await self.view.refresh_view()
55 | 
56 | 
57 | class SkipTo(ScrimsButton):
58 |     def __init__(self, ctx: Context, row: int = None):
59 |         super().__init__(label="Skip to...", row=row)
60 |         self.ctx = ctx
61 | 
62 |     async def callback(self, interaction: discord.Interaction):
63 |         await interaction.response.defer()
64 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_reserve.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | 
  5 | import discord
  6 | 
  7 | from core import Context
  8 | from models import ReservedSlot, Scrim
  9 | from utils import BetterFutureTime, QuoMember, emote, string_input, truncate_string
 10 | 
 11 | from ._base import ScrimsButton, ScrimsView
 12 | from ._btns import Discard
 13 | from ._pages import *
 14 | 
 15 | __all__ = ("ScrimsSlotReserve",)
 16 | 
 17 | 
 18 | class ScrimsSlotReserve(ScrimsView):
 19 |     def __init__(self, ctx: Context, scrim: Scrim):
 20 |         super().__init__(ctx)
 21 | 
 22 |         self.ctx = ctx
 23 |         self.record = scrim
 24 | 
 25 |     @property
 26 |     async def initial_embed(self):
 27 |         _e = discord.Embed(color=self.bot.color)
 28 |         _e.description = f"**{self.record}  -  Reserved Slots**\n\n"
 29 | 
 30 |         reserved = await self.record.reserved_slots.order_by("num")
 31 |         _l = []
 32 |         for _ in range(self.record.start_from, self.record.total_slots + self.record.start_from):
 33 |             team_name = next(
 34 |                 (
 35 |                     f"{i.team_name} [{'Lifetime' if not i.expires else i.expires.strftime('%b/%d')}]"
 36 |                     for i in reserved
 37 |                     if i.num == _
 38 |                 ),
 39 |                 "❌",
 40 |             )
 41 |             _l.append(f"Slot {_:02}  -->  " + team_name + "\n")
 42 | 
 43 |         _e.description += f"```{''.join(_l)}```"
 44 | 
 45 |         _e.set_footer(text=f"Page - {' / '.join(await self.record.scrim_posi())}")
 46 |         return _e
 47 | 
 48 |     async def refresh_view(self):
 49 |         await self.add_buttons()
 50 |         try:
 51 |             self.message = await self.message.edit(embed=await self.initial_embed, view=self)
 52 |         except discord.HTTPException:
 53 |             await self.on_timeout()
 54 | 
 55 |     async def add_buttons(self):
 56 |         self.clear_items()
 57 | 
 58 |         self.add_item(NewReserve(self.ctx))
 59 | 
 60 |         self.add_item(RemoveReserve(self.ctx, not bool(await self.record.reserved_slots.all().count())))
 61 | 
 62 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
 63 |             self.add_item(Prev(self.ctx, 2))
 64 |             self.add_item(SkipTo(self.ctx, 2))
 65 |             self.add_item(Next(self.ctx, 2))
 66 | 
 67 |         self.add_item(Discard(self.ctx, "Main Menu", 2))
 68 | 
 69 | 
 70 | class NewReserve(ScrimsButton):
 71 |     view: ScrimsSlotReserve
 72 | 
 73 |     def __init__(self, ctx: Context):
 74 |         super().__init__(style=discord.ButtonStyle.green, label="Reserve Slot(s)")
 75 | 
 76 |         self.ctx = ctx
 77 | 
 78 |     async def callback(self, interaction: discord.Interaction):
 79 |         await interaction.response.defer()
 80 | 
 81 |         m = await self.ctx.simple(
 82 |             "Enter the slot details you want to reserve in the following format:\n"
 83 |             "> `slot_number`,`team_name`, `team_owner`, `time to reserve`\n\n"
 84 |             "Enter `none` in place of:\n"
 85 |             "- `team owner` if you want the slot be a management slot.\n"
 86 |             "- `time to reserve` if you want the reserve time to never expire.\n\n"
 87 |             "\n*don't forget to separate everything with comma (`,`)*\n",
 88 |             image="https://cdn.discordapp.com/attachments/851846932593770496/988408404341039134/reserve_help.gif",
 89 |         )
 90 | 
 91 |         slots = await string_input(self.ctx, delete_after=True)
 92 |         await self.ctx.safe_delete(m)
 93 | 
 94 |         if slots.strip().lower() == "cancel":
 95 |             return await self.ctx.error("Alright, Aborting.", 4)
 96 | 
 97 |         slots = slots.split("\n")
 98 |         for _ in slots:
 99 |             _ = _.split(",")
100 | 
101 |             try:
102 |                 num, team_name, team_owner, time_to_reserve = _
103 |                 num = int(num.strip())
104 | 
105 |                 team_name = truncate_string(team_name.strip(), 25)
106 | 
107 |             except ValueError:
108 |                 return await self.ctx.error(
109 |                     "The details you entered were not according to the proper format. Please refer to example image.", 6
110 |                 )
111 | 
112 |             owner_id = None
113 |             if team_owner.strip().lower() != "none":
114 |                 owner = await QuoMember().convert(self.ctx, team_owner.strip())
115 |                 owner_id = owner.id
116 | 
117 |             expire = None
118 |             if time_to_reserve.strip().lower() != "none":
119 |                 expire = await BetterFutureTime().convert(self.ctx, time_to_reserve.strip())
120 | 
121 |             if num not in (_range := self.view.record.available_to_reserve):
122 |                 return await self.ctx.error(
123 |                     f"The slot-number you entered (`{num}`) cannot be reserved.\n"
124 |                     f"\nThe slot-number must be a number between `{_range.start}` and `{_range.stop}`",
125 |                     5,
126 |                 )
127 | 
128 |             to_del = await self.view.record.reserved_slots.filter(num=num).first()
129 |             if to_del:
130 |                 await ReservedSlot.filter(pk=to_del.id).delete()
131 | 
132 |             slot = await ReservedSlot.create(num=num, user_id=owner_id, team_name=team_name, expires=expire)
133 |             await self.view.record.reserved_slots.add(slot)
134 |             if expire and owner_id:
135 |                 await self.ctx.bot.reminders.create_timer(
136 |                     expire, "scrim_reserve", scrim_id=self.view.record.id, user_id=owner_id, team_name=team_name, num=num
137 |                 )
138 | 
139 |         await self.view.refresh_view()
140 | 
141 | 
142 | class RemoveReserve(ScrimsButton):
143 |     def __init__(self, ctx: Context, disabled: bool = True):
144 |         super().__init__(style=discord.ButtonStyle.red, label="Remove Reserved", disabled=disabled)
145 | 
146 |         self.ctx = ctx
147 | 
148 |     async def callback(self, interaction: discord.Interaction):
149 |         await interaction.response.defer()
150 | 
151 |         v = ScrimsView(self.ctx)
152 |         v.add_item(SlotSelect(await self.view.record.reserved_slots.all().order_by("num")))
153 | 
154 |         m = await self.ctx.send("Please select the slots to remove from reserved:", view=v)
155 |         await v.wait()
156 | 
157 |         if v.custom_id:
158 |             await ReservedSlot.filter(id__in=v.custom_id).delete()
159 |             await self.view.refresh_view()
160 | 
161 |         await self.ctx.safe_delete(m)
162 | 
163 | 
164 | class SlotSelect(discord.ui.Select):
165 |     view: ScrimsView
166 | 
167 |     def __init__(self, slots: T.List[ReservedSlot]):
168 |         _options = []
169 |         for _ in slots:
170 |             _options.append(
171 |                 discord.SelectOption(
172 |                     label=f"Slot {_.num}",
173 |                     description=f"Team: {_.team_name} ({_.leader or 'No leader'})",
174 |                     value=_.id.__str__(),
175 |                     emoji=emote.TextChannel,
176 |                 )
177 |             )
178 |         super().__init__(
179 |             max_values=len(slots), placeholder="Select the slot(s) you want to remove from reserved", options=_options
180 |         )
181 | 
182 |     async def callback(self, interaction: discord.Interaction):
183 |         await interaction.response.defer()
184 |         self.view.custom_id = self.values
185 |         self.view.stop()
186 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_slotlist.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from contextlib import suppress
 4 | 
 5 | import discord
 6 | 
 7 | from core import Context
 8 | from models import Scrim
 9 | from utils import emote, inputs
10 | 
11 | from ._base import ScrimsView
12 | from ._formatter import show_slotlist_formatter
13 | 
14 | __all__ = ("ManageSlotlist",)
15 | 
16 | 
17 | class ManageSlotlist(discord.ui.Select):
18 |     view: ScrimsView
19 | 
20 |     def __init__(self, ctx: Context, scrim: Scrim):
21 |         super().__init__(
22 |             placeholder="Select an option to manage slotlist.",
23 |             options=[
24 |                 discord.SelectOption(
25 |                     label="Repost Slotlist",
26 |                     emoji="🔁",
27 |                     description="Respost slotlist to a channel",
28 |                     value="repost",
29 |                 ),
30 |                 discord.SelectOption(
31 |                     label="Change Design",
32 |                     description="Design slotlist of any scrim.",
33 |                     emoji="⚙️",
34 |                     value="format",
35 |                 ),
36 |                 discord.SelectOption(
37 |                     label="Edit Slotlist",
38 |                     description="Edit slotlist (Remove/Add New teams).",
39 |                     emoji=emote.edit,
40 |                     value="edit",
41 |                 ),
42 |                 discord.SelectOption(
43 |                     label="Go Back",
44 |                     description="Move back to Main Menu",
45 |                     emoji=emote.exit,
46 |                     value="back",
47 |                 ),
48 |             ],
49 |         )
50 | 
51 |         self.ctx = ctx
52 |         self.record = scrim
53 | 
54 |     async def callback(self, interaction: discord.Interaction):
55 |         await interaction.response.defer()
56 | 
57 |         if (selected := self.values[0]) == "repost":
58 |             m = await self.ctx.simple("Mention the channel to send slotlist.")
59 |             channel = await inputs.channel_input(self.ctx, delete_after=True)
60 |             await self.ctx.safe_delete(m)
61 | 
62 |             if not await self.record.teams_registered.count():
63 |                 return await self.ctx.error("No registrations found in {0}.".format(self.record), 5)
64 | 
65 |             m = await self.record.send_slotlist(channel)
66 |             await self.ctx.success("Slotlist sent! [Click to Jump]({0})".format(m.jump_url), 5)
67 | 
68 |             from .main import ScrimsMain
69 | 
70 |             self.view.stop()
71 |             v = ScrimsMain(self.ctx)
72 |             v.message = await self.view.message.edit(content="", embed=await v.initial_embed(), view=v)
73 | 
74 |         elif selected == "format":
75 |             self.view.stop()
76 |             await show_slotlist_formatter(self.ctx, self.record, self.view.message)
77 | 
78 |         elif selected == "edit":
79 |             if self.record.slotlist_message_id == None:
80 |                 return await self.ctx.error("Slotlist not found. Please repost.", 5)
81 | 
82 |             msg = None
83 |             with suppress(discord.HTTPException):
84 |                 msg = await self.ctx.bot.get_or_fetch_message(
85 |                     self.record.slotlist_channel, self.record.slotlist_message_id
86 |                 )
87 |             if not msg:
88 |                 return await self.ctx.error("Slotlist Message not found. Repost first.", 5)
89 | 
90 |             return await self.ctx.success("Click `Edit` button under [slotlist message]({0}).".format(msg.jump_url), 6)
91 | 
92 |         elif selected == "back":
93 |             from .main import ScrimsMain
94 | 
95 |             self.view.stop()
96 |             v = ScrimsMain(self.ctx)
97 |             v.message = await self.view.message.edit(content="", embed=await v.initial_embed(), view=v)
98 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_toggle.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import discord
 4 | 
 5 | from core import Context
 6 | from models import Scrim
 7 | 
 8 | from ._base import ScrimsButton, ScrimsView
 9 | from ._btns import Discard
10 | from ._pages import *
11 | 
12 | __all__ = ("ScrimsToggle",)
13 | 
14 | 
15 | class ScrimsToggle(ScrimsView):
16 |     def __init__(self, ctx: Context, scrim: Scrim):
17 |         self.ctx = ctx
18 |         self.record = scrim
19 | 
20 |         super().__init__(ctx)
21 | 
22 |     @property
23 |     async def initial_message(self):
24 |         _e = discord.Embed(color=self.bot.color)
25 |         _e.description = "**Start / Stop scrim registration of {}**".format(self.record)
26 |         _e.set_author(name=f"Page - {' / '.join(await self.record.scrim_posi())}", icon_url=self.bot.user.avatar.url)
27 |         return _e
28 | 
29 |     async def refresh_view(self):
30 |         await self._add_buttons()
31 |         try:
32 |             self.message = await self.message.edit(embed=await self.initial_message, view=self)
33 |         except discord.HTTPException:
34 |             await self.on_timeout()
35 | 
36 |     async def _add_buttons(self):
37 |         self.clear_items()
38 | 
39 |         if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 2:
40 |             self.add_item(Prev(self.ctx))
41 |             self.add_item(SkipTo(self.ctx))
42 |             self.add_item(Next(self.ctx))
43 | 
44 |         self.add_item(StartReg())
45 |         self.add_item(StopReg())
46 |         self.add_item(Discard(self.ctx, "Main Menu", 2))
47 | 
48 | 
49 | class StartReg(ScrimsButton):
50 |     def __init__(self):
51 |         super().__init__(label="Start Reg", style=discord.ButtonStyle.green, row=2)
52 | 
53 |     async def callback(self, interaction: discord.Interaction):
54 |         await interaction.response.defer()
55 | 
56 |         if not self.view.record.closed_at and self.view.record.opened_at:
57 |             return await self.view.ctx.error("Registration is already open. To restart, pls stop registration first.", 4)
58 | 
59 |         try:
60 |             await self.view.record.start_registration()
61 |         except Exception as e:
62 |             return await self.view.ctx.error(e, 10)
63 | 
64 |         else:
65 |             await self.view.ctx.success(f"Registration opened {self.view.record}.", 5)
66 |             await self.view.record.refresh_from_db()
67 | 
68 | 
69 | class StopReg(ScrimsButton):
70 |     def __init__(self):
71 |         super().__init__(label="Stop Reg", style=discord.ButtonStyle.red, row=2)
72 | 
73 |     async def callback(self, interaction: discord.Interaction):
74 |         await interaction.response.defer()
75 | 
76 |         if not self.view.record.opened_at:
77 |             return await self.view.ctx.error("Registration is already closed.", 5)
78 | 
79 |         try:
80 |             await self.view.record.close_registration()
81 |         except Exception as e:
82 |             return await self.view.ctx.error(e, 10)
83 | 
84 |         else:
85 |             await self.view.record.refresh_from_db()
86 |             await self.view.ctx.success(f"Registration closed {self.view.record}.", 5)
87 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/_wiz.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing as T
 4 | from string import ascii_uppercase
 5 | 
 6 | import discord
 7 | 
 8 | from core import Context
 9 | from models import Scrim
10 | from utils import discord_timestamp as dt
11 | 
12 | from ._base import ScrimsView
13 | from ._btns import *
14 | 
15 | __all__ = ("ScrimSetup",)
16 | 
17 | 
18 | class ScrimSetup(ScrimsView):
19 |     def __init__(self, ctx: Context):
20 |         super().__init__(ctx, timeout=60)
21 | 
22 |         self.ctx = ctx
23 |         self.record: Scrim = None
24 | 
25 |         self.add_item(RegChannel(ctx, "a"))
26 |         self.add_item(SlotChannel(ctx, "b"))
27 |         self.add_item(SetRole(ctx, "c"))
28 |         self.add_item(SetMentions(ctx, "d"))
29 |         self.add_item(TotalSlots(ctx, "e"))
30 |         self.add_item(OpenTime(ctx, "f"))
31 | 
32 |         self.add_item(OpenDays(ctx, "g"))
33 |         self.add_item(SetEmojis(ctx, "h"))
34 |         self.add_item(Discard(ctx, "Cancel"))
35 |         self.add_item(SaveScrim(ctx))
36 | 
37 |     def initial_message(self):
38 |         if not self.record:
39 |             self.record = Scrim(guild_id=self.ctx.guild.id, host_id=self.ctx.author.id)
40 | 
41 |         d_link = "https://quotientbot.xyz/dashboard/{0}/scrims/create".format(self.ctx.guild.id)
42 | 
43 |         _e = discord.Embed(color=0x00FFB3, title="Enter details & Press Save", url=self.bot.config.SERVER_LINK)
44 |         _e.description = f"[`Scrim Creation is a piece of cake through dashboard, Click Me`]({d_link})\n\n"
45 | 
46 |         fields = {
47 |             "Reg. Channel": getattr(self.record.registration_channel, "mention", "`Not-Set`"),
48 |             "Slotlist Channel": getattr(self.record.slotlist_channel, "mention", "`Not-Set`"),
49 |             "Success Role": getattr(self.record.role, "mention", "`Not-Set`"),
50 |             "Req. Mentions": f"`{self.record.required_mentions}`",
51 |             "Total Slots": f"`{self.record.total_slots or 'Not-Set'}`",
52 |             "Open Time": f"{dt(self.record.open_time,'t')} ({dt(self.record.open_time)})"
53 |             if self.record.open_time
54 |             else "`Not-Set`",
55 |             "Scrim Days": ", ".join(map(lambda x: "`{0}`".format(x.name.title()[:2]), self.record.open_days)),
56 |             f"Reactions {self.bot.config.PRIME_EMOJI}": f"{self.record.check_emoji},{self.record.cross_emoji}",
57 |         }
58 | 
59 |         for idx, (name, value) in enumerate(fields.items()):
60 |             _e.add_field(
61 |                 name=f"{ri(ascii_uppercase[idx])} {name}:",
62 |                 value=value,
63 |             )
64 |         _e.add_field(name="\u200b", value="\u200b")
65 |         _e.set_footer(
66 |             text="Quotient Premium servers can set custom reactions.", icon_url=self.ctx.guild.me.display_avatar.url
67 |         )
68 | 
69 |         return _e
70 | 
71 |     async def refresh_view(self):
72 |         _e = self.initial_message()
73 | 
74 |         if all(
75 |             (
76 |                 self.record.registration_channel_id,
77 |                 self.record.slotlist_channel_id,
78 |                 self.record.role_id,
79 |                 self.record.total_slots,
80 |                 self.record.open_time,
81 |             )
82 |         ):
83 |             self.children[-1].disabled = False
84 | 
85 |         try:
86 |             self.message = await self.message.edit(embed=_e, view=self)
87 |         except discord.HTTPException:
88 |             await self.on_timeout()
89 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/main.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import asyncio
  4 | import random
  5 | import typing as T
  6 | from contextlib import suppress
  7 | 
  8 | import discord
  9 | from discord import ButtonStyle, Interaction, ui
 10 | 
 11 | from core import Context
 12 | from models import Scrim
 13 | from utils import discord_timestamp, emote, truncate_string
 14 | 
 15 | from ._ban import ScrimBanManager
 16 | from ._base import ScrimsView
 17 | from ._design import ScrimDesign
 18 | from ._edit import ScrimsEditor
 19 | from ._reserve import ScrimsSlotReserve
 20 | from ._slotlist import ManageSlotlist
 21 | from ._toggle import ScrimsToggle
 22 | from ._wiz import ScrimSetup
 23 | 
 24 | 
 25 | class ScrimsMain(ScrimsView):
 26 |     def __init__(self, ctx: Context):
 27 |         super().__init__(ctx, timeout=100)
 28 | 
 29 |         self.ctx = ctx
 30 | 
 31 |     async def initial_embed(self):
 32 |         _e = discord.Embed(color=0x00FFB3, title="Quotient's Smart Scrims Manager", url=self.ctx.config.SERVER_LINK)
 33 | 
 34 |         to_show = []
 35 |         for idx, _r in enumerate(await Scrim.filter(guild_id=self.ctx.guild.id).order_by("open_time"), start=1):
 36 |             to_show.append(
 37 |                 f"`{idx:02}.` {(emote.xmark,emote.check)[_r.stoggle]}: {str(_r)} - {discord_timestamp(_r.open_time,'t')}"
 38 |             )
 39 | 
 40 |         _e.description = "\n".join(to_show) if to_show else "```Click Create button for new Scrim.```"
 41 |         _e.description = truncate_string(_e.description, 3999)
 42 | 
 43 |         _e.set_footer(
 44 |             text=f"Total Scrims in this server: {len(to_show)}",
 45 |             icon_url=getattr(self.ctx.author.display_avatar, "url", None),
 46 |         )
 47 | 
 48 |         if not to_show:
 49 |             for _ in self.children[1:]:
 50 |                 _.disabled = True
 51 | 
 52 |         return _e
 53 | 
 54 |     @discord.ui.button(label="Create Scrim", style=ButtonStyle.green)
 55 |     async def create_new_scrim(self, interaction: Interaction, button: ui.Button):
 56 |         await interaction.response.defer()
 57 | 
 58 |         if not await self.ctx.is_premium_guild():
 59 |             if await Scrim.filter(guild_id=self.ctx.guild.id).count() >= 3:
 60 |                 return await self.ctx.premium_mango("Only 3 scrims can be created with free plan.")
 61 | 
 62 |         self.stop()
 63 |         v = ScrimSetup(self.ctx)
 64 |         v.message = await self.message.edit(embed=v.initial_message(), view=v)
 65 | 
 66 |     @discord.ui.button(label="Edit Settings", style=ButtonStyle.blurple)
 67 |     async def edit_scrim(self, interaction: Interaction, button: ui.Button):
 68 |         await interaction.response.defer()
 69 |         scrim = await Scrim.show_selector(self.ctx, multi=False)
 70 |         self.stop()
 71 | 
 72 |         if not scrim:
 73 |             return
 74 | 
 75 |         v = ScrimsEditor(self.ctx, scrim)
 76 |         await v._add_buttons()
 77 |         v.message = await self.message.edit(embed=await v.initial_message, view=v)
 78 | 
 79 |     @discord.ui.button(label="Instant Start/Stop Reg", style=ButtonStyle.green)
 80 |     async def toggle_reg(self, interaction: Interaction, button: ui.Button):
 81 |         await interaction.response.defer()
 82 | 
 83 |         scrim = await Scrim.show_selector(
 84 |             self.ctx, multi=False, placeholder="Please select the scrim to stop or start registration."
 85 |         )
 86 |         self.stop()
 87 |         if not scrim:
 88 |             return
 89 | 
 90 |         v = ScrimsToggle(self.ctx, scrim)
 91 |         await v._add_buttons()
 92 |         v.message = await self.message.edit(embed=await v.initial_message, view=v)
 93 | 
 94 |     @discord.ui.button(label="Reserve Slots", style=ButtonStyle.green)
 95 |     async def reserve_slots(self, interaction: Interaction, button: ui.Button):
 96 |         await interaction.response.defer()
 97 |         scrim = await Scrim.show_selector(self.ctx, multi=False)
 98 |         self.stop()
 99 | 
100 |         if not scrim:
101 |             return
102 | 
103 |         view = ScrimsSlotReserve(self.ctx, scrim)
104 |         await view.add_buttons()
105 |         view.message = await self.message.edit(embed=await view.initial_embed, view=view)
106 | 
107 |     @discord.ui.button(label="Ban/Unban", style=ButtonStyle.red)
108 |     async def ban_unban(self, interaction: Interaction, button: ui.Button):
109 |         await interaction.response.defer()
110 | 
111 |         scrim = await Scrim.show_selector(self.ctx, multi=False)
112 |         self.stop()
113 |         if not scrim:
114 |             return
115 | 
116 |         v = ScrimBanManager(self.ctx, scrim)
117 |         await v._add_buttons()
118 |         v.message = await self.message.edit(embed=await v.initial_message, view=v)
119 | 
120 |     @discord.ui.button(label="Design", style=ButtonStyle.red)
121 |     async def change_design(self, interaction: Interaction, button: ui.Button):
122 |         await interaction.response.defer()
123 | 
124 |         scrim = await Scrim.show_selector(self.ctx, multi=False)
125 |         self.stop()
126 | 
127 |         if not scrim:
128 |             return
129 | 
130 |         view = ScrimDesign(self.ctx, scrim)
131 |         await view._add_buttons()
132 |         view.message = await self.message.edit(embed=await view.initial_embed, view=view)
133 | 
134 |     @discord.ui.button(label="Manage Slotlist", style=ButtonStyle.blurple)
135 |     async def manage_slotlist(self, interaction: Interaction, button: ui.Button):
136 |         await interaction.response.defer()
137 | 
138 |         scrim = await Scrim.show_selector(
139 |             self.ctx, multi=False, placeholder="Please select the scrim to manage slotlist."
140 |         )
141 | 
142 |         self.stop()
143 | 
144 |         if not scrim:
145 |             return
146 | 
147 |         v = ScrimsView(self.ctx)
148 |         v.add_item(ManageSlotlist(self.ctx, scrim))
149 |         v.message = await self.message.edit(content="Please choose an action:", embed=None, view=v)
150 | 
151 |     @discord.ui.button(label="Enable/Disable", style=discord.ButtonStyle.red)
152 |     async def toggle(self, interaction: Interaction, button: ui.Button):
153 |         await interaction.response.defer()
154 |         scrims = await Scrim.show_selector(self.ctx, multi=True)
155 |         if not scrims:
156 |             return
157 | 
158 |         scrims = [scrims] if not isinstance(scrims, list) else scrims
159 | 
160 |         self.stop()
161 |         for scrim in scrims:
162 |             await scrim.make_changes(stoggle=not scrim.stoggle)
163 | 
164 |         await self.ctx.success(
165 |             f"Done! Note that registration of disabled scrims will not be opened, until they are enabled back.", 6
166 |         )
167 | 
168 |         v = ScrimsMain(self.ctx)
169 |         v.message = await self.message.edit(embed=await v.initial_embed(), view=v)
170 | 
171 |     # @discord.ui.button(label="Scrim not working, Need Help!", style=ButtonStyle.red)
172 |     # async def troubleshoot_scrim(self, interaction: Interaction, button: ui.Button):
173 |     #     await interaction.response.defer()
174 | 
175 |     #     scrim = await Scrim.show_selector(
176 |     #         self.ctx, multi=False, placeholder="Please select the scrim you need help with."
177 |     #     )
178 | 
179 |     #     if not scrim:
180 |     #         return
181 | 
182 |     #     _e = discord.Embed(
183 |     #         color=self.bot.color, title="Join Support Server for more assistance", url=self.ctx.config.SERVER_LINK
184 |     #     )
185 |     #     _e.description = "**Analyzing {0}...**".format(scrim)
186 | 
187 |     #     m = await self.ctx.send(embed=_e)
188 |     #     _results, t, x = [], emote.check, emote.xmark
189 | 
190 |     #     _results.append(
191 |     #         (f"{x} Registration channel not found.", f"{t} Registration channel found.")[bool(scrim.registration_channel)]
192 |     #     )
193 |     #     _results.append(
194 |     #         (f"{x} Slotlist channel not found.", f"{t} Slotlist channel found.")[bool(scrim.slotlist_channel)]
195 |     #     )
196 | 
197 |     #     perms = False
198 |     #     with suppress(AttributeError):
199 |     #         perms = scrim.registration_channel.permissions_for(self.ctx.guild.me)
200 |     #         perms = all(
201 |     #             (
202 |     #                 perms.manage_channels,
203 |     #                 perms.manage_permissions,
204 |     #                 perms.manage_messages,
205 |     #                 perms.use_external_emojis,
206 |     #                 perms.add_reactions,
207 |     #                 perms.embed_links,
208 |     #             )
209 |     #         )
210 |     #     _results.append(
211 |     #         (f"{x} Need permissions in registration channel", f"{t} Registration channel permissions are ok.")[perms]
212 |     #     )
213 | 
214 |     #     _results.append((f"{x} Success Role not found.", f"{t} Success Role found.")[bool(scrim.role)])
215 |     #     _results.append(
216 |     #         (f"{x} `Manage-Roles` perms required.", f"{t} `Manage-Roles` perms found.")[
217 |     #             scrim.guild.me.guild_permissions.manage_roles
218 |     #         ]
219 |     #     )
220 | 
221 |     #     role_perm = False
222 |     #     if scrim.role:
223 |     #         if not scrim.role >= scrim.guild.me.top_role:
224 |     #             role_perm = True
225 | 
226 |     #     _results.append((f"{x} Success Role is above my toprole.", f"{t} Success Role is below my toprole.")[role_perm])
227 |     #     _results.append((f"{x} Open role not found.", f"{t} Open role found.")[bool(scrim.open_role)])
228 |     #     _results.append((f"{x} Logs-Channel not found", f"{t} Logs-Channel found.")[bool(scrim.logschan)])
229 |     #     _results.append(f"\nRegistration open time is {discord_timestamp(scrim.open_time,'f')}")
230 |     #     _results.append(f"{t} Scrim analyzing complete.")
231 | 
232 |     #     for _ in _results:
233 |     #         _e.description += "\n" + _
234 |     #         await asyncio.sleep(random.randint(1, 3))
235 |     #         with suppress(discord.HTTPException):
236 |     #             await m.edit(embed=_e)
237 | 
238 |     #     await self.ctx.safe_delete(m, 8)
239 | 


--------------------------------------------------------------------------------
/cogs/esports/views/scrims/selector.py:
--------------------------------------------------------------------------------
  1 | from contextlib import suppress
  2 | from typing import List, Union
  3 | 
  4 | import discord
  5 | from aiocache import cached
  6 | 
  7 | from core.Context import Context
  8 | from core.views import QuotientView
  9 | from models import Scrim
 10 | from utils import emote, split_list
 11 | 
 12 | __all__ = ("ScrimSelectorView",)
 13 | 
 14 | 
 15 | class ScrimSelector(discord.ui.Select):
 16 |     view: "ScrimSelectorView"
 17 | 
 18 |     def __init__(self, placeholder: str, scrims: List[Scrim], max_values=25):
 19 |         _options = []
 20 |         for scrim in scrims:
 21 |             _options.append(
 22 |                 discord.SelectOption(
 23 |                     label=scrim.registration_channel.name,  # type: ignore
 24 |                     value=scrim.id,
 25 |                     description=f"{scrim.name} (ScrimID: {scrim.id})",
 26 |                     emoji=emote.TextChannel,
 27 |                 )
 28 |             )
 29 | 
 30 |         # print(scrims, _options)
 31 |         super().__init__(placeholder=placeholder, options=_options, max_values=max_values)
 32 | 
 33 |     async def callback(self, interaction: discord.Interaction):
 34 |         await interaction.response.defer()
 35 |         self.view.custom_id = self.values
 36 | 
 37 |         self.view.stop()
 38 | 
 39 | 
 40 | class ScrimSelectorView(discord.ui.View):
 41 |     message: discord.Message
 42 |     custom_id: List[str] = []
 43 | 
 44 |     def __init__(self, user: Union[discord.Member, discord.User], scrims: List[Scrim], **kwargs):
 45 |         self.user = user
 46 | 
 47 |         timeout = kwargs.get("timeout", 30)
 48 |         placeholder = kwargs.get("placeholder", "Select a scrim ...")
 49 |         max_values = kwargs.get("max_values", len(scrims))
 50 | 
 51 |         super().__init__(timeout=timeout)
 52 | 
 53 |         # scrims = scrims[:25]
 54 | 
 55 |         self.add_item(ScrimSelector(placeholder, scrims, max_values))
 56 | 
 57 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
 58 |         if interaction.user.id != self.user.id:
 59 |             await interaction.response.send_message(f"Sorry, only **{self.user}** can use this dropdown.", ephemeral=True)
 60 |             return False
 61 | 
 62 |         return True
 63 | 
 64 |     async def on_timeout(self) -> None:
 65 |         if hasattr(self, "message"):
 66 |             with suppress(discord.HTTPException):
 67 |                 await self.message.delete()
 68 | 
 69 | 
 70 | async def prompt_selector(ctx: Context, scrims: List[Scrim] = None, *, placeholder: str = None, multi: bool = True):
 71 |     placeholder = placeholder or "Choose {0} to continue...".format("Scrims" if multi else "a Scrim")
 72 | 
 73 |     scrims = scrims or await Scrim.filter(guild_id=ctx.guild.id).order_by("open_time")
 74 |     if not scrims:
 75 |         return None
 76 | 
 77 |     if len(scrims) == 1:
 78 |         return scrims[0]
 79 | 
 80 |     view = QuotientView(ctx)
 81 |     if len(scrims) <= 25:
 82 |         view.add_item(Select(placeholder, scrims, multi=multi))
 83 |     else:
 84 |         for scrims_chunk in split_list(scrims, 25):
 85 |             view.add_item(Select(placeholder, scrims_chunk, multi=multi))
 86 | 
 87 |     view.message = await ctx.send(
 88 |         "Choose {0} from the dropdown below:".format("Scrims" if multi else "a Scrim"),
 89 |         view=view,
 90 |     )
 91 |     await view.wait()
 92 |     if view.custom_id:
 93 |         with suppress(discord.HTTPException):
 94 |             await view.message.delete()
 95 | 
 96 |         if not len(view.custom_id) > 1:
 97 |             return await Scrim.get_or_none(pk=view.custom_id[0])
 98 | 
 99 |         return await Scrim.filter(pk__in=view.custom_id)
100 | 
101 | 
102 | class Select(discord.ui.Select):
103 |     view: QuotientView
104 | 
105 |     def __init__(self, placeholder: str, scrims: List[Scrim], multi: bool):
106 |         _options = []
107 |         for scrim in scrims:
108 |             _options.append(
109 |                 discord.SelectOption(
110 |                     label=getattr(scrim.registration_channel, "name", "deleted-channel"),  # type: ignore
111 |                     value=scrim.id,
112 |                     description=f"{scrim.name} (ScrimID: {scrim.id})",
113 |                     emoji=emote.TextChannel,
114 |                 )
115 |             )
116 | 
117 |         super().__init__(placeholder=placeholder, options=_options, max_values=len(_options) if multi else 1)
118 | 
119 |     async def callback(self, interaction: discord.Interaction):
120 |         await interaction.response.defer()
121 |         self.view.custom_id = self.values
122 | 
123 |         self.view.stop()
124 | 
125 | 
126 | @cached(ttl=10)
127 | async def scrim_position(scrim_id: int, guild_id: int):
128 |     """
129 |     returns the position of scrim in all scrims of a server
130 |     """
131 |     scrims = await Scrim.filter(guild_id=guild_id).order_by("open_time")
132 |     return str(scrims.index(next(s for s in scrims if s.pk == scrim_id)) + 1), len(scrims).__str__()
133 | 


--------------------------------------------------------------------------------
/cogs/esports/views/slotm/__init__.py:
--------------------------------------------------------------------------------
1 | from .editor import *
2 | from .public import *
3 | from .setup import *
4 | 


--------------------------------------------------------------------------------
/cogs/esports/views/slotm/editor.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from typing import TYPE_CHECKING
  4 | 
  5 | from utils.buttons import Prompt
  6 | 
  7 | if TYPE_CHECKING:
  8 |     from core import Quotient
  9 | 
 10 | from string import ascii_uppercase
 11 | 
 12 | import discord
 13 | 
 14 | from core import Context
 15 | from models.esports.slotm import ScrimsSlotManager
 16 | from utils import plural
 17 | from utils import regional_indicator as ri
 18 | 
 19 | from ...views.base import EsportsBaseView
 20 | from .scrimsedit import SlotmScrimsEditor
 21 | 
 22 | __all__ = ("ScrimsSlotmEditor",)
 23 | 
 24 | 
 25 | class ScrimsSlotmEditor(EsportsBaseView):
 26 |     def __init__(self, ctx: Context, *, record: ScrimsSlotManager):
 27 |         super().__init__(ctx, timeout=30, title="Slot-M Editor")
 28 | 
 29 |         self.ctx = ctx
 30 |         self.bot: Quotient = ctx.bot
 31 |         self.record = record
 32 | 
 33 |     def initial_embed(self):
 34 |         _e = discord.Embed(color=0x00FFB3, title="Slot-M Editor")
 35 | 
 36 |         fields = {
 37 |             "Main Channel": getattr(self.record.main_channel, "mention", "Not-Found"),
 38 |             "Slot-m Status": f"{'Enabled' if self.record.toggle else 'Disabled'}",
 39 |             "Reminders button": f"{'Enabled' if self.record.allow_reminders else 'Disabled'}",
 40 |             "Multi Slot-Claim": f"{'Enabled' if self.record.multiple_slots else 'Disabled'}",
 41 |             "Scrims": f"{plural(self.record.scrim_ids):scrim|scrims} (`Click to edit`)",
 42 |         }
 43 | 
 44 |         for idx, (name, value) in enumerate(fields.items()):
 45 |             _e.add_field(
 46 |                 name=f"{ri(ascii_uppercase[idx])} {name}:",
 47 |                 value=value,
 48 |             )
 49 |         _e.add_field(name=f"🟥 Delete Slot-M", value=f"`Click to delete`")
 50 |         return _e
 51 | 
 52 |     async def __update_record(self, **kwargs):
 53 |         await ScrimsSlotManager.filter(pk=self.record.pk).update(**kwargs)
 54 |         await self.__refresh_embed()
 55 |         await self.record.refresh_public_message()
 56 | 
 57 |     async def __refresh_embed(self):
 58 |         await self.record.refresh_from_db()
 59 |         embed = self.initial_embed()
 60 | 
 61 |         try:
 62 |             self.message = await self.message.edit(embed=embed, view=self)
 63 |         except discord.HTTPException:
 64 |             await self.on_timeout()
 65 | 
 66 |     @discord.ui.button(custom_id="edit_main_slotm_channel", emoji=ri("A"))
 67 |     async def edit_main_slotm_channel(self, interaction: discord.Interaction, button: discord.Button):
 68 |         await interaction.response.defer()
 69 |         return await interaction.followup.send("Main Channel can't be edited. Sorry 🥲", ephemeral=True)
 70 | 
 71 |     @discord.ui.button(custom_id="edit_slotm_status", emoji=ri("B"))
 72 |     async def edit_slotm_status(self, interaction: discord.Interaction, button: discord.Button):
 73 |         await interaction.response.defer()
 74 |         await self.__update_record(toggle=not self.record.toggle)
 75 | 
 76 |     @discord.ui.button(custom_id="edit_slotm_reminders", emoji=ri("C"))
 77 |     async def edit_slotm_reminders(self, interaction: discord.Interaction, button: discord.Button):
 78 |         await interaction.response.defer()
 79 |         await self.__update_record(allow_reminders=not self.record.allow_reminders)
 80 | 
 81 |     @discord.ui.button(custom_id="edit_slotm_multi_claim", emoji=ri("D"))
 82 |     async def edit_slotm_multi_claim(self, interaction: discord.Interaction, button: discord.Button):
 83 |         await interaction.response.defer()
 84 |         await self.__update_record(multiple_slots=not self.record.multiple_slots)
 85 | 
 86 |     @discord.ui.button(custom_id="edit_slotm_scrims", emoji=ri("E"))
 87 |     async def edit_slotm_scrims(self, interaction: discord.Interaction, button: discord.Button):
 88 |         await interaction.response.defer()
 89 | 
 90 |         _view = SlotmScrimsEditor(self.ctx, self.record)
 91 |         await interaction.followup.send(embed=_view.initial_embed(), view=_view, ephemeral=True)
 92 |         await self.on_timeout()
 93 | 
 94 |     @discord.ui.button(custom_id="delete_slotm", label="Delete Slot-Manager", style=discord.ButtonStyle.red)
 95 |     async def delete_slotm(self, interaction: discord.Interaction, button: discord.Button):
 96 |         await interaction.response.defer()
 97 | 
 98 |         prompt = Prompt(self.ctx.author.id)
 99 |         await interaction.followup.send("Are you sure you want to delete this Slot-Manager?", view=prompt, ephemeral=True)
100 |         await prompt.wait()
101 |         if not prompt.value:
102 |             return await self.ctx.simple("Alright, Aborting.", 2)
103 | 
104 |         await self.record.full_delete()
105 |         await self.ctx.success("Slot-M Deleted.", 2)
106 |         await self.on_timeout()
107 | 


--------------------------------------------------------------------------------
/cogs/esports/views/slotm/public/__init__.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing as T
 4 | 
 5 | import discord as d
 6 | 
 7 | from models import Scrim, ScrimsSlotManager
 8 | 
 9 | __all__ = ("ScrimsSlotmPublicView",)
10 | 
11 | 
12 | class ScrimsSlotmPublicView(d.ui.View):
13 |     children: T.List[d.ui.Button]
14 | 
15 |     def __init__(self, record: ScrimsSlotManager):
16 |         super().__init__(timeout=None)
17 | 
18 |         self.record = record
19 |         self.bot = record.bot
20 |         self.claimable: T.List[Scrim] = []
21 | 
22 |         from ._cancel import ScrimsCancel
23 |         from ._claim import ScrimsClaim
24 |         from ._idp import IdpTransfer
25 |         from ._reminder import ScrimsRemind
26 | 
27 |         self.add_item(ScrimsCancel(style=d.ButtonStyle.danger, custom_id="scrims_slot_cancel", label="Cancel Slot"))
28 |         self.add_item(ScrimsClaim(style=d.ButtonStyle.green, custom_id="scrims_slot_claim", label="Claim Slot"))
29 |         self.add_item(ScrimsRemind(label="Remind Me", custom_id="scrims_slot_reminder", emoji="🔔"))
30 |         self.add_item(
31 |             IdpTransfer(label="Transfer IDP Role", custom_id="scrims_transfer_idp_role", style=d.ButtonStyle.green)
32 |         )
33 | 
34 |         self.bot.loop.create_task(self.__refresh_cache())
35 | 
36 |     async def on_error(self, interaction: d.Interaction, error: Exception, item: d.ui.Item[T.Any]) -> None:
37 |         if isinstance(error, d.NotFound):
38 |             return
39 |         print("Scrims Slotm Public View Error:", error)
40 | 
41 |     async def __refresh_cache(self):
42 |         async for scrim in self.record.claimable_slots:
43 |             self.claimable.append(scrim)
44 | 


--------------------------------------------------------------------------------
/cogs/esports/views/slotm/public/_cancel.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | from contextlib import suppress
  5 | 
  6 | import discord
  7 | 
  8 | from models import ArrayAppend, AssignedSlot, Scrim
  9 | from utils import BaseSelector, Prompt, emote, plural
 10 | 
 11 | from ..public import ScrimsSlotmPublicView
 12 | 
 13 | __all__ = ("ScrimsCancel",)
 14 | 
 15 | 
 16 | class ScrimsCancel(discord.ui.Button):
 17 |     view: ScrimsSlotmPublicView
 18 | 
 19 |     def __init__(self, **kwargs):
 20 |         super().__init__(**kwargs)
 21 | 
 22 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
 23 |         await interaction.response.defer(thinking=True, ephemeral=True)
 24 | 
 25 |         if not (slots := await self.view.record.user_slots(interaction.user.id)):
 26 |             return await interaction.followup.send("You have no slots that can be cancelled.", ephemeral=True)
 27 | 
 28 |         cancel_view = BaseSelector(interaction.user.id, CancelSlotSelector, bot=self.view.bot, records=slots)
 29 |         await interaction.followup.send("Select the slots you want to remove:", view=cancel_view, ephemeral=True)
 30 |         await cancel_view.wait()
 31 |         if not cancel_view.custom_id:
 32 |             return
 33 | 
 34 |         p_str = f"{plural(cancel_view.custom_id):slot|slots}"
 35 |         prompt = Prompt(interaction.user.id)
 36 |         await interaction.followup.send(
 37 |             f"Your `{p_str}` will be cancelled.\n" "*`Are you sure you want to continue?`*",
 38 |             view=prompt,
 39 |             ephemeral=True,
 40 |         )
 41 |         await prompt.wait()
 42 |         if not prompt.value:
 43 |             return await interaction.followup.send("Alright, Aborting.", ephemeral=True)
 44 | 
 45 |         m = await interaction.followup.send(f"Cancelling your `{p_str}`... {emote.loading}", ephemeral=True)
 46 |         for _ in cancel_view.custom_id:
 47 |             scrim_id, slot_id = _.split(":")
 48 | 
 49 |             scrim = await Scrim.get_or_none(pk=scrim_id)
 50 |             if not scrim:
 51 |                 continue
 52 | 
 53 |             if not await scrim.assigned_slots.filter(user_id=interaction.user.id, pk__not=slot_id).exists():
 54 |                 with suppress(discord.HTTPException):
 55 |                     if interaction.user._roles.has(scrim.role_id):
 56 |                         await interaction.user.remove_roles(discord.Object(id=scrim.role_id))
 57 | 
 58 |             _slot = await AssignedSlot.filter(pk=slot_id).first()
 59 | 
 60 |             await AssignedSlot.filter(pk=slot_id).update(team_name="Cancelled Slot")
 61 |             await scrim.refresh_slotlist_message()
 62 |             await _slot.delete()
 63 | 
 64 |             await Scrim.filter(pk=scrim_id).update(available_slots=ArrayAppend("available_slots", _slot.num))
 65 | 
 66 |             link = f"https://discord.com/channels/{scrim.guild_id}/{interaction.channel_id}/{self.view.record.message_id}"
 67 |             await scrim.dispatch_reminders(interaction.channel, link)
 68 |             with suppress(discord.HTTPException, AttributeError):
 69 |                 user = interaction.user
 70 |                 await scrim.logschan.send(
 71 |                     embed=discord.Embed(
 72 |                         title="Slot-Cancelled",
 73 |                         color=self.view.bot.color,
 74 |                         description=f"{user} ({user.mention}) cancelled their `Slot {_slot.num}` from {scrim}.",
 75 |                     )
 76 |                 )
 77 | 
 78 |         await m.edit(content=f"Alright, Cancelled your `{p_str}`.")
 79 |         await self.view.record.refresh_public_message()
 80 | 
 81 | 
 82 | class CancelSlotSelector(discord.ui.Select):
 83 |     view: BaseSelector
 84 | 
 85 |     def __init__(self, bot, records):
 86 |         _options = []
 87 |         for record in records[:25]:
 88 |             reg_channel = bot.get_channel(record["registration_channel_id"])
 89 |             _options.append(
 90 |                 discord.SelectOption(
 91 |                     label=f"Slot {record['num']} ─ #{getattr(reg_channel,'name','deleted-channel')}",
 92 |                     description=f"{record['team_name']} (ID: {record['scrim_id']})",
 93 |                     value=f"{record['scrim_id']}:{record['assigned_slot_id']}",
 94 |                     emoji="📇",
 95 |                 )
 96 |             )
 97 | 
 98 |         super().__init__(placeholder="Select slot(s) from this dropdown...", options=_options, max_values=len(records))
 99 | 
100 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
101 |         await interaction.response.defer()
102 |         self.view.stop()
103 |         self.view.custom_id = interaction.data["values"]
104 | 


--------------------------------------------------------------------------------
/cogs/esports/views/slotm/public/_claim.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import asyncio
  4 | import re
  5 | import typing as T
  6 | from contextlib import suppress
  7 | 
  8 | import discord
  9 | 
 10 | from models import ArrayRemove, AssignedSlot, Scrim, ScrimsSlotManager
 11 | from utils import BaseSelector, emote
 12 | 
 13 | from ..public import ScrimsSlotmPublicView
 14 | 
 15 | claim_lock = asyncio.Lock()
 16 | 
 17 | __all__ = ("ScrimsClaim",)
 18 | #!TODO: do some processing on the team name
 19 | 
 20 | 
 21 | class ScrimsClaim(discord.ui.Button):
 22 |     view: ScrimsSlotmPublicView
 23 | 
 24 |     def __init__(self, **kwargs):
 25 |         super().__init__(**kwargs)
 26 | 
 27 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
 28 |         if not self.view.claimable:  # this can never be true but still
 29 |             await interaction.response.send_message("No slot available right now.", ephemeral=True)
 30 |             return await self.view.record.refresh_public_message()
 31 | 
 32 |         await interaction.response.defer(thinking=True, ephemeral=True)
 33 |         claim_view = BaseSelector(
 34 |             interaction.user.id,
 35 |             ClaimSlotSelector,
 36 |             scrims=self.view.claimable,
 37 |             multiple_slots=self.view.record.multiple_slots,
 38 |         )
 39 |         await interaction.followup.send("Select the slot you want to claim:", view=claim_view, ephemeral=True)
 40 | 
 41 | 
 42 | class ClaimSlotModal(discord.ui.Modal, title="Claim Scrims Slot"):
 43 |     multiple_slots: bool
 44 |     selected_slot: str
 45 | 
 46 |     async def on_submit(self, interaction: discord.Interaction) -> None:
 47 |         await interaction.response.defer(thinking=True, ephemeral=True)
 48 | 
 49 |         team_name = str(self.children[0])
 50 |         scrim_id, num = self.selected_slot.split(":")
 51 |         num = int(num)
 52 | 
 53 |         team_name = "Team " + re.sub(r"team|name|[^\w\s]", "", team_name.lower()).strip().title()
 54 | 
 55 |         scrim = await Scrim.get_or_none(pk=scrim_id)
 56 |         if not scrim:
 57 |             return await interaction.followup.send("Scrim not found.", ephemeral=True)
 58 | 
 59 |         if await scrim.banned_teams.filter(user_id=interaction.user.id).exists():
 60 |             return await interaction.followup.send("You are banned from this scrim.", ephemeral=True)
 61 | 
 62 |         if not self.multiple_slots:
 63 |             if await scrim.assigned_slots.filter(user_id=interaction.user.id).exists():
 64 |                 return await interaction.followup.send("You already have a slot in this scrim.", ephemeral=True)
 65 | 
 66 |         async with claim_lock:
 67 |             await scrim.refresh_from_db(("available_slots",))
 68 | 
 69 |             if num not in scrim.available_slots:
 70 |                 return await interaction.followup.send("Somebody claimed this slot before you.", ephemeral=True)
 71 | 
 72 |             await Scrim.filter(pk=scrim_id).update(available_slots=ArrayRemove("available_slots", num))
 73 | 
 74 |             scrim.bot.loop.create_task(self.add_role(interaction.user, scrim.role_id))
 75 | 
 76 |             user_id = interaction.user.id
 77 |             _slot = await AssignedSlot.create(num=num, user_id=user_id, members=[user_id], team_name=team_name)
 78 |             await scrim.assigned_slots.add(_slot)
 79 | 
 80 |             scrim.bot.loop.create_task(self.proccess_claim(scrim, _slot))
 81 |             await interaction.followup.send(f"{emote.check} Slot claimed successfully.", ephemeral=True)
 82 | 
 83 |     async def add_role(self, user: discord.Member, role_id: int):
 84 |         with suppress(discord.HTTPException):
 85 |             if not user._roles.has(role_id):
 86 |                 await user.add_roles(discord.Object(id=role_id))
 87 | 
 88 |     async def proccess_claim(self, scrim: Scrim, slot: AssignedSlot):
 89 |         await scrim.refresh_slotlist_message()
 90 | 
 91 |         await ScrimsSlotManager.refresh_guild_message(scrim.guild_id, scrim.id)
 92 | 
 93 |         with suppress(AttributeError, discord.HTTPException):
 94 |             await scrim.slotlist_channel.send(f"{slot.team_name} ({slot.owner.mention}) -> Claimed Slot {slot.num}")
 95 | 
 96 | 
 97 | class ClaimSlotSelector(discord.ui.Select):
 98 |     view: BaseSelector
 99 | 
100 |     def __init__(self, scrims: T.List[Scrim], multiple_slots: bool):
101 |         _options = []
102 |         for scrim in scrims:
103 |             slots = sorted(scrim.available_slots)
104 | 
105 |             _options.append(
106 |                 discord.SelectOption(
107 |                     label=f"Slot {slots[0]} ─ #{getattr(scrim.registration_channel,'name','deleted-channel')}",
108 |                     description=f"{scrim.name} (ID: {scrim.id})",
109 |                     value=f"{scrim.id}:{slots[0]}",
110 |                     emoji="📇",
111 |                 )
112 |             )
113 | 
114 |         super().__init__(options=_options)
115 |         self.multiple_slots = multiple_slots
116 | 
117 |     async def callback(self, interaction: discord.Interaction):
118 |         self.view.stop()
119 | 
120 |         v = ClaimSlotModal()
121 |         v.multiple_slots = self.multiple_slots
122 |         v.selected_slot = interaction.data["values"][0]
123 | 
124 |         v.add_item(
125 |             discord.ui.TextInput(
126 |                 label="Team Name",
127 |                 style=discord.TextStyle.short,
128 |                 placeholder="Enter your team name here...",
129 |                 min_length=3,
130 |                 max_length=25,
131 |             )
132 |         )
133 |         await interaction.response.send_modal(v)
134 | 


--------------------------------------------------------------------------------
/cogs/esports/views/slotm/public/_idp.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | from contextlib import suppress
  5 | 
  6 | import discord
  7 | 
  8 | from models import AssignedSlot, Scrim
  9 | from utils import BaseSelector, emote
 10 | 
 11 | from ..public import ScrimsSlotmPublicView
 12 | 
 13 | __all__ = ("IdpTransfer",)
 14 | 
 15 | 
 16 | class IdpTransfer(discord.ui.Button):
 17 |     view: ScrimsSlotmPublicView
 18 | 
 19 |     def __init__(self, **kwargs):
 20 |         super().__init__(**kwargs)
 21 | 
 22 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
 23 |         await interaction.response.defer(thinking=True, ephemeral=True)
 24 | 
 25 |         if not await self.view.bot.is_premium_guild(interaction.guild_id):
 26 |             return await interaction.followup.send(
 27 |                 "IDP Transfer feature is only available for premium servers.\n\n"
 28 |                 f"*This server needs to purchase [Quotient Premium]({self.view.bot.prime_link}) to use this feature.*",
 29 |                 ephemeral=True,
 30 |             )
 31 | 
 32 |         if not (slots := await self.view.record.user_slots(interaction.user.id)):
 33 |             return await interaction.followup.send("You don't have any slot that can be transferred.", ephemeral=True)
 34 | 
 35 |         transfer_view = BaseSelector(interaction.user.id, SlotSelector, bot=self.view.bot, records=slots)
 36 |         await interaction.followup.send(
 37 |             "Choose a slot to transfer ID-Pass Role to your teammates:", view=transfer_view, ephemeral=True
 38 |         )
 39 |         await transfer_view.wait()
 40 |         if not transfer_view.custom_id:
 41 |             return
 42 | 
 43 |         scrim_id, slot_id = transfer_view.custom_id.split(":")
 44 |         scrim = await Scrim.get(pk=scrim_id)
 45 |         _slot = await AssignedSlot.filter(pk=slot_id).first()
 46 | 
 47 |         with suppress(ValueError):
 48 |             _slot.members.remove(interaction.user.id)
 49 | 
 50 |         if not _slot.members:
 51 |             return await interaction.followup.send(
 52 |                 f"{interaction.user.mention}, you cannot transfer ID-Pass role to your teammates "
 53 |                 "because you didn't mention them during registration.",
 54 |                 ephemeral=True,
 55 |             )
 56 | 
 57 |         users = [member async for member in self.view.bot.resolve_member_ids(interaction.guild, _slot.members)]
 58 |         if not users:
 59 |             return await interaction.followup.send("All your teammates seems to have left the server.", ephemeral=True)
 60 | 
 61 |         if len(users) == 1:
 62 |             user_id = users[0].id
 63 | 
 64 |         else:
 65 |             users_view = BaseSelector(interaction.user.id, UserSelector, users=users)
 66 |             await interaction.followup.send(
 67 |                 "Please select your teammate to transfer ID-Pass Role.", view=users_view, ephemeral=True
 68 |             )
 69 |             await users_view.wait()
 70 |             if not users_view.custom_id:
 71 |                 return
 72 | 
 73 |             user_id = int(users_view.custom_id)
 74 | 
 75 |         await AssignedSlot.filter(pk=_slot.pk).update(user_id=user_id)
 76 |         self.view.bot.loop.create_task(interaction.user.remove_roles(discord.Object(scrim.role_id)))
 77 |         self.view.bot.loop.create_task(interaction.guild.get_member(user_id).add_roles(discord.Object(scrim.role_id)))
 78 |         return await interaction.followup.send(
 79 |             f"{emote.check} | ID-Pass Role & Slot ownership transferred to <@{user_id}>", ephemeral=True
 80 |         )
 81 | 
 82 | 
 83 | class SlotSelector(discord.ui.Select):
 84 |     view: BaseSelector
 85 | 
 86 |     def __init__(self, bot, records):
 87 |         _options = []
 88 |         for record in records[:25]:
 89 |             reg_channel = bot.get_channel(record["registration_channel_id"])
 90 |             _options.append(
 91 |                 discord.SelectOption(
 92 |                     label=f"Slot {record['num']} ─ #{getattr(reg_channel,'name','deleted-channel')}",
 93 |                     description=f"{record['team_name']} (ID: {record['scrim_id']})",
 94 |                     value=f"{record['scrim_id']}:{record['assigned_slot_id']}",
 95 |                     emoji="📇",
 96 |                 )
 97 |             )
 98 | 
 99 |         super().__init__(placeholder="Select slot from this dropdown...", options=_options, max_values=1)
100 | 
101 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
102 |         await interaction.response.defer()
103 |         self.view.stop()
104 |         self.view.custom_id = interaction.data["values"][0]
105 | 
106 | 
107 | class UserSelector(discord.ui.Select):
108 |     view: BaseSelector
109 | 
110 |     def __init__(self, users: T.List[discord.Member]):
111 |         _options = []
112 |         for user in users:
113 |             _options.append(
114 |                 discord.SelectOption(
115 |                     label=f"{user.name}#{user.discriminator}",
116 |                     value=user.id,
117 |                     emoji="📇",
118 |                 )
119 |             )
120 | 
121 |         super().__init__(placeholder="Select your teammate from this dropdown", options=_options)
122 | 
123 |     async def callback(self, interaction: discord.Interaction):
124 |         await interaction.response.defer()
125 |         self.view.stop()
126 |         self.view.custom_id = interaction.data["values"][0]
127 | 


--------------------------------------------------------------------------------
/cogs/esports/views/slotm/public/_reminder.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | 
  5 | import discord
  6 | 
  7 | from cogs.esports.views.scrims import ScrimSelectorView
  8 | from models import Scrim, ScrimsSlotReminder
  9 | from utils import plural
 10 | 
 11 | from ..public import ScrimsSlotmPublicView
 12 | 
 13 | __all__ = ("ScrimsRemind",)
 14 | 
 15 | 
 16 | class ScrimsRemind(discord.ui.Button):
 17 |     view: ScrimsSlotmPublicView
 18 | 
 19 |     def __init__(self, **kwargs):
 20 |         super().__init__(**kwargs)
 21 | 
 22 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
 23 |         await interaction.response.defer(thinking=True, ephemeral=True)
 24 | 
 25 |         if not await self.view.bot.is_premium_guild(interaction.guild_id):
 26 |             return await interaction.followup.send(
 27 |                 "Cancel Reminder feature is only available for premium servers.\n\n"
 28 |                 f"*This server needs to purchase [Quotient Premium]({self.view.bot.prime_link}) to use this feature.*",
 29 |                 ephemeral=True,
 30 |             )
 31 | 
 32 |         scrims = await Scrim.filter(
 33 |             pk__in=self.view.record.scrim_ids,
 34 |             closed_at__gt=self.view.bot.current_time.replace(hour=0, minute=0, second=0, microsecond=0),
 35 |             match_time__gt=self.view.bot.current_time,
 36 |             opened_at__isnull=True,
 37 |         ).order_by("open_time")
 38 | 
 39 |         scrims = [scrim for scrim in scrims if not scrim.available_slots]
 40 | 
 41 |         for scrim in await self.banned_from(interaction.user.id):
 42 |             for _ in scrims:
 43 |                 if _.id == scrim["scrim_id"]:
 44 |                     scrims.remove(_)
 45 | 
 46 |         for scrim in await self.already_reminder_of(interaction.user.id):
 47 |             for _ in scrims:
 48 |                 if _.id == scrim["scrim_id"]:
 49 |                     scrims.remove(_)
 50 | 
 51 |         if not self.view.record.multiple_slots:
 52 |             for slot in await self.view.record.user_slots(interaction.user.id):
 53 |                 for _ in scrims:
 54 |                     if _.id == slot["scrim_id"]:
 55 |                         scrims.remove(_)
 56 | 
 57 |         if not scrims:
 58 |             return await interaction.followup.send("You can't set reminder in any scrim at this time.", ephemeral=True)
 59 | 
 60 |         _view = ScrimSelectorView(interaction.user, scrims[:25], placeholder="Select scrims to add slot reminder")
 61 |         await interaction.followup.send(
 62 |             "Select 1 or multiple scrims to set reminder\n\n*By selecting scrims, you confirm that Quotient can "
 63 |             "DM you when any slot is available of the selected scrims.*",
 64 |             view=_view,
 65 |             ephemeral=True,
 66 |         )
 67 |         await _view.wait()
 68 |         if not _view.custom_id:
 69 |             return
 70 | 
 71 |         scrims = await Scrim.filter(pk__in=_view.custom_id)
 72 | 
 73 |         for _ in scrims:
 74 |             _r = await ScrimsSlotReminder.create(user_id=interaction.user.id)
 75 |             await _.slot_reminders.add(_r)
 76 | 
 77 |         _e = discord.Embed(
 78 |             color=0x00FFB3, description=f"Successfully created reminder for {plural(scrims):scrim|scrims}."
 79 |         )
 80 | 
 81 |         await interaction.followup.send(embed=_e, ephemeral=True)
 82 | 
 83 |     async def banned_from(self, user_id: int) -> T.List[int]:
 84 |         # now, can tortoise do this? - no way
 85 |         query = """
 86 |         (SELECT *
 87 | 		    FROM
 88 | 			(SELECT SCRIMS.ID AS SCRIM_ID,
 89 | 					*
 90 | 				FROM PUBLIC."sm.scrims" AS SCRIMS
 91 | 				FULL OUTER JOIN
 92 | 					(SELECT ID AS ASSIGNED_SLOT_ID,
 93 | 							*
 94 | 						FROM PUBLIC."sm.scrims_sm.banned_teams" AS SCRIM_SLOT
 95 | 						INNER JOIN PUBLIC."sm.banned_teams" AS SLOTS ON SLOTS.ID = SCRIM_SLOT.BANNEDTEAM_ID) AS SCRIM_SLOT ON SCRIMS.ID = SCRIM_SLOT."sm.scrims_id"
 96 | 				WHERE (SCRIMS.ID = ANY ($1)
 97 | 										AND SCRIM_SLOT."sm.scrims_id" IS NOT NULL)) AS SM
 98 | 		WHERE USER_ID = $2)        
 99 |         """
100 | 
101 |         return await self.view.bot.db.fetch(query, self.view.record.scrim_ids, user_id)
102 | 
103 |     async def already_reminder_of(self, user_id: int) -> T.List[int]:
104 |         query = """
105 |         (SELECT *
106 | 		    FROM
107 | 			    (SELECT SCRIMS.ID AS SCRIM_ID,
108 | 					*
109 | 				    FROM PUBLIC."sm.scrims" AS SCRIMS
110 | 				    FULL OUTER JOIN
111 | 					    (SELECT ID AS REMINDER_SLOT_ID,
112 | 							*
113 | 						    FROM PUBLIC."sm.scrims_scrims_slot_reminders" AS REMINDER_SLOT
114 | 						    INNER JOIN PUBLIC."scrims_slot_reminders" AS SLOTS ON SLOTS.ID = REMINDER_SLOT.SCRIMSSLOTREMINDER_ID) AS REMINDER_SLOT ON SCRIMS.ID = REMINDER_SLOT."sm.scrims_id"
115 | 				    WHERE (SCRIMS.ID = ANY ($1)
116 | 											AND REMINDER_SLOT."sm.scrims_id" IS NOT NULL)) AS SM
117 | 		WHERE USER_ID = $2)
118 |         """
119 |         return await self.view.bot.db.fetch(query, self.view.record.scrim_ids, user_id)
120 | 


--------------------------------------------------------------------------------
/cogs/esports/views/slotm/scrimsedit.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import discord
 4 | 
 5 | from cogs.esports.views.scrims import ScrimSelectorView
 6 | from core import Context
 7 | from models import Scrim, ScrimsSlotManager
 8 | from utils import emote
 9 | 
10 | from ...views.base import EsportsBaseView
11 | 
12 | __all__ = ("SlotmScrimsEditor",)
13 | 
14 | 
15 | class SlotmScrimsEditor(EsportsBaseView):
16 |     def __init__(self, ctx: Context, record: ScrimsSlotManager):
17 |         super().__init__(ctx, timeout=100, title="Slot-M Editor")
18 | 
19 |         self.ctx = ctx
20 |         self.record = record
21 | 
22 |     def initial_embed(self) -> discord.Embed:
23 |         _e = discord.Embed(color=0x00FFB3)
24 |         _e.description = (
25 |             "Do you want to add scrims of remove scrims from this slot-m?\n\n"
26 |             f"Current scrims: {', '.join(f'`{str(_)}`' for _ in self.record.scrim_ids)}"
27 |         )
28 | 
29 |         return _e
30 | 
31 |     @discord.ui.button(custom_id="slotm_scrims_add", emoji=emote.add)
32 |     async def add_new_scrims(self, interaction: discord.Interaction, button: discord.Button):
33 |         await interaction.response.defer()
34 |         await self.record.refresh_from_db()
35 | 
36 |         scrims = await self.record.available_scrims(self.ctx.guild)
37 |         if not scrims:
38 |             return await self.ctx.error("All scrims are already added to this or another slot-m.", 3)
39 | 
40 |         scrims = scrims[:25]
41 |         _view = ScrimSelectorView(interaction.user, scrims, placeholder="Select scrims to add to this slot-manager ...")
42 |         await interaction.followup.send("Choose the scrims you want to add to this slotm.", view=_view, ephemeral=True)
43 | 
44 |         await _view.wait()
45 |         if _view.custom_id:
46 |             _q = "UPDATE slot_manager SET scrim_ids = scrim_ids || $1 WHERE id = $2"
47 |             await self.ctx.bot.db.execute(_q, [int(i) for i in _view.custom_id], self.record.id)
48 |             await self.record.refresh_public_message()
49 |             await self.ctx.success("Successfully added new scrims.", 3)
50 | 
51 |     @discord.ui.button(custom_id="slotm_scrims_remove", emoji=emote.remove)
52 |     async def remove_scrims(self, interaction: discord.Interaction, button: discord.Button):
53 |         await interaction.response.defer()
54 | 
55 |         await self.record.refresh_from_db()
56 |         if not self.record.scrim_ids:
57 |             return await self.ctx.error("There are no scrims added to this slot-m.", 3)
58 | 
59 |         scrims = await Scrim.filter(pk__in=self.record.scrim_ids).limit(25)
60 |         _view = ScrimSelectorView(
61 |             interaction.user, scrims, placeholder="Select scrims to remove from this slot-manager ..."
62 |         )
63 | 
64 |         await interaction.followup.send(
65 |             "Choose the scrims you want to remove from this slotm.", view=_view, ephemeral=True
66 |         )
67 |         await _view.wait()
68 |         if _view.custom_id:
69 |             _q = "UPDATE slot_manager SET scrim_ids = $1 WHERE id = $2"
70 |             await self.ctx.bot.db.execute(
71 |                 _q, [_ for _ in self.record.scrim_ids if not str(_) in _view.custom_id], self.record.id
72 |             )
73 |             await self.record.refresh_public_message()
74 |             await self.ctx.success("Successfully removed selected scrims.", 3)
75 | 


--------------------------------------------------------------------------------
/cogs/esports/views/slotm/setup.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from code import interact
  4 | from typing import TYPE_CHECKING, List
  5 | 
  6 | if TYPE_CHECKING:
  7 |     from core import Quotient
  8 | 
  9 | import discord
 10 | 
 11 | from cogs.esports.views.scrims import ScrimSelectorView
 12 | from core import Context, QuotientView
 13 | from models import Scrim
 14 | from models.esports.slotm import ScrimsSlotManager
 15 | from utils import Prompt, emote, truncate_string
 16 | 
 17 | from ...views.base import EsportsBaseView
 18 | from .editor import ScrimsSlotmEditor
 19 | from .time import MatchTimeEditor
 20 | 
 21 | __all__ = ("ScrimsSlotManagerSetup",)
 22 | 
 23 | 
 24 | class ScrimsSlotmSelector(discord.ui.Select):
 25 |     def __init__(self, records: List[ScrimsSlotManager]):
 26 |         _o = []
 27 |         for record in records:
 28 |             _o.append(
 29 |                 discord.SelectOption(
 30 |                     label=getattr(record.main_channel, "name", "channel-not-found"),  # type: ignore
 31 |                     value=record.id,
 32 |                     description=truncate_string(f"Scrims: {', '.join(str(_) for _ in record.scrim_ids)}", 100),
 33 |                     emoji=emote.TextChannel,
 34 |                 )
 35 |             )
 36 | 
 37 |         super().__init__(placeholder="Select a slot-manager channel ...", options=_o)
 38 | 
 39 |     async def callback(self, interaction: discord.Interaction):
 40 |         await interaction.response.defer()
 41 |         self.view.custom_id = self.values[0]
 42 | 
 43 |         self.view.stop()
 44 | 
 45 | 
 46 | class ScrimsSlotManagerSetup(EsportsBaseView):
 47 |     def __init__(self, ctx: Context):
 48 |         super().__init__(ctx, timeout=60, title="Scrims Slot Manager")
 49 | 
 50 |         self.ctx = ctx
 51 |         self.bot: Quotient = ctx.bot
 52 | 
 53 |     @staticmethod
 54 |     async def initial_message(guild: discord.Guild):
 55 |         records = await ScrimsSlotManager.filter(guild_id=guild.id)
 56 |         _to_show = [f"`{idx}.` {_.__str__()}" for idx, _ in enumerate(records, start=1)]
 57 | 
 58 |         _sm = "\n".join(_to_show) if _to_show else "```Click add-channel to set cancel-claim.```"
 59 | 
 60 |         _e = discord.Embed(color=0x00FFB3, title=f"Scrims Slot-Manager Setup")
 61 | 
 62 |         _e.description = (
 63 |             "Slot-Manager is a way to ease-up scrims slot management process. With Quotient's slotm users can - "
 64 |             "cancel their slot, claim an empty slot and also set reminder for vacant slots, All without bugging any mod.\n\n"
 65 |             f"**Current slot-manager channels:**\n{_sm}\n\nDon't forget to set the match times :)"
 66 |         )
 67 |         # _e.set_thumbnail(url=guild.me.display_avatar.url)
 68 |         return _e
 69 | 
 70 |     @discord.ui.button(label="Add Channel", custom_id="scrims_slotm_addc", emoji=emote.TextChannel)
 71 |     async def add_channel(self, interaction: discord.Interaction, button: discord.Button):
 72 |         await interaction.response.defer()
 73 | 
 74 |         if not await self.ctx.is_premium_guild():
 75 |             if await ScrimsSlotManager.filter(guild_id=self.ctx.guild.id).count() >= 1:
 76 |                 return await self.ctx.premium_mango("You need Quotient Premium to add more than 1 Slot-Manager channel.")
 77 | 
 78 |         available_scrims = await ScrimsSlotManager.available_scrims(self.ctx.guild)
 79 |         if not available_scrims:
 80 |             return await self.error_embed(
 81 |                 f"There are no scrims available for a new slotmanager channel.\n\n"
 82 |                 "If you have other slot-m channel, first remove the scrims from that channel to add them to new slot-m."
 83 |             )
 84 | 
 85 |         available_scrims = available_scrims[:25]
 86 |         _view = ScrimSelectorView(
 87 |             interaction.user, available_scrims, placeholder="Select scrims to add to slot-manager ..."
 88 |         )
 89 |         await interaction.followup.send(
 90 |             "Choose 1 or multiple scrims that you want to add to new slot-manager."
 91 |             "\n\n`If a scrim isn't in the dropdown that means it has been addded to another slotm.`",
 92 |             view=_view,
 93 |             ephemeral=True,
 94 |         )
 95 |         await _view.wait()
 96 | 
 97 |         prompt = Prompt(interaction.user.id)
 98 |         await interaction.followup.send(
 99 |             "A new channel will be created for the selected scrims slot manager.\n\n`Do you want to continue?`",
100 |             view=prompt,
101 |             ephemeral=True,
102 |         )
103 |         await prompt.wait()
104 | 
105 |         if not prompt.value:
106 |             return await interaction.followup.send("Alright, Aborting.", ephemeral=True)
107 | 
108 |         slotm = ScrimsSlotManager(scrim_ids=_view.custom_id, guild_id=interaction.guild_id)
109 |         self.record = await slotm.setup(self.ctx.guild, interaction.user)
110 |         await self.ctx.success(
111 |             f"Successfully setup slotm for selected scrims in {self.record.main_channel.mention}.\n\n"
112 |             "`You can rename this channel if you want to.`",
113 |             10,
114 |         )
115 | 
116 |     @discord.ui.button(label="Edit Config", custom_id="scrims_slotm_editc", emoji=emote.edit)
117 |     async def edit_config(self, interaction: discord.Interaction, button: discord.Button):
118 |         await interaction.response.defer()
119 | 
120 |         records = await ScrimsSlotManager.filter(guild_id=self.ctx.guild.id)
121 |         if not records:
122 |             return await self.ctx.error(
123 |                 "You haven't added any slot-manager channel yet.\n\nClick `Add Channel` to add a new slot-m channel.", 2
124 |             )
125 | 
126 |         _view = QuotientView(self.ctx)
127 |         _view.add_item(ScrimsSlotmSelector(records))
128 |         # _view.add_item(QuotientView.tricky_invite_button())
129 |         await interaction.followup.send("Kindly choose a slot-manager channel to edit.", view=_view, ephemeral=True)
130 |         await _view.wait()
131 | 
132 |         if _view.custom_id:
133 |             __record = await ScrimsSlotManager.get(pk=_view.custom_id)
134 | 
135 |             __editor_view = ScrimsSlotmEditor(self.ctx, record=__record)
136 |             __editor_view.add_item(QuotientView.tricky_invite_button())
137 | 
138 |             __editor_view.message = await interaction.followup.send(
139 |                 embed=__editor_view.initial_embed(), view=__editor_view
140 |             )
141 | 
142 |     @discord.ui.button(emoji="🔒", label="Match Time", custom_id="scrims_slotm_matcht")
143 |     async def set_match_time(self, interaction: discord.Interaction, button: discord.Button):
144 |         await interaction.response.defer()
145 | 
146 |         scrims = await Scrim.filter(guild_id=self.ctx.guild.id).order_by("open_time")
147 |         _to_show = [
148 |             f"{idx}) {getattr(_.registration_channel,'name','deleted-channel').ljust(18)}"
149 |             f"   {_.match_time.strftime('%I:%M %p') if _.match_time else 'Not-Set'}"
150 |             for idx, _ in enumerate(scrims, start=1)
151 |         ]
152 |         _to_show.insert(0, f"   {'Scrims'.ljust(18)}   Match Time\n")
153 | 
154 |         _e = discord.Embed(color=self.ctx.bot.color, title="Scrims-Match time", url=self.bot.config.SERVER_LINK)
155 | 
156 |         _to_show = "\n".join(_to_show)
157 |         _e.description = (
158 |             f"Match time means the time when `ID/Pass` \nof that particular scrim is shared.\n```{_to_show}```"
159 |         )
160 | 
161 |         _e.set_footer(
162 |             text="Users cannot cancel/claim slots after this time.", icon_url=self.ctx.guild.me.display_avatar.url
163 |         )
164 | 
165 |         _view = QuotientView(self.ctx)
166 |         _view.add_item(MatchTimeEditor(self.ctx))
167 |         _view.add_item(QuotientView.tricky_invite_button())
168 | 
169 |         _view.message = await interaction.followup.send(embed=_e, view=_view, ephemeral=True)
170 | 


--------------------------------------------------------------------------------
/cogs/esports/views/slotm/time.py:
--------------------------------------------------------------------------------
 1 | from contextlib import suppress
 2 | from datetime import timedelta
 3 | 
 4 | import dateparser
 5 | import discord
 6 | from discord.ext.commands import ChannelNotFound, TextChannelConverter
 7 | 
 8 | from core import Context
 9 | from models import Scrim
10 | from utils import emote, string_input
11 | 
12 | __all__ = ("MatchTimeEditor",)
13 | 
14 | 
15 | class MatchTimeEditor(discord.ui.Button):
16 |     def __init__(self, ctx: Context):
17 |         self.ctx = ctx
18 | 
19 |         super().__init__(label="Set Match Time", style=discord.ButtonStyle.green)
20 | 
21 |     async def callback(self, interaction: discord.Interaction):
22 |         await interaction.response.defer()
23 | 
24 |         _e = discord.Embed(color=0x00FFB3)
25 |         _e.description = (
26 |             "Please enter the time of matches/scrims in the following format:\n"
27 |             "`#registration_channel match_time`\n\n"
28 |             "Note that slotmanager will automatically lock for the scrim at specified time. This means "
29 |             "that `users will not be able to cancel/claim after the specified time.`\n\n"
30 |             "**Separate multiple match time with a new line.**"
31 |         )
32 |         _e.set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/931035634464849970/unknown.png")
33 |         _e.set_footer(text="You only have to enter match time once, I'll handle the rest automatically.")
34 |         await interaction.followup.send(embed=_e, ephemeral=True)
35 |         match_times = await string_input(
36 |             self.ctx,
37 |             lambda x: x.author == interaction.user and x.channel == self.ctx.channel,
38 |             delete_after=True,
39 |             timeout=300,
40 |         )
41 | 
42 |         match_times = match_times.strip().split("\n")
43 |         for _ in match_times:
44 |             with suppress(AttributeError, ValueError, ChannelNotFound, TypeError):
45 |                 channel, time = _.strip().split()
46 |                 if not all((channel, time)):
47 |                     continue
48 | 
49 |                 _c = await TextChannelConverter().convert(self.ctx, channel.strip())
50 |                 parsed = dateparser.parse(
51 |                     time,
52 |                     settings={
53 |                         # "RELATIVE_BASE": self.ctx.bot.current_time,
54 |                         "TIMEZONE": "Asia/Kolkata",
55 |                         "RETURN_AS_TIMEZONE_AWARE": True,
56 |                     },
57 |                 )
58 | 
59 |                 parsed = parsed + timedelta(hours=24) if parsed < self.ctx.bot.current_time else parsed
60 | 
61 |                 if not all((_c, parsed, parsed > self.ctx.bot.current_time)):
62 |                     continue
63 | 
64 |                 scrim = await Scrim.get_or_none(guild_id=self.ctx.guild.id, registration_channel_id=_c.id)
65 |                 if scrim:
66 |                     await self.ctx.bot.reminders.create_timer(parsed, "scrim_match", scrim_id=scrim.id)
67 |                     await Scrim.filter(pk=scrim.pk).update(match_time=parsed)
68 | 
69 |         await interaction.followup.send(f"{emote.check} Done, click Match-Time button to see changes.", ephemeral=True)
70 | 


--------------------------------------------------------------------------------
/cogs/esports/views/smslotlist/__init__.py:
--------------------------------------------------------------------------------
1 | from .button import *
2 | from .editor import *
3 | from .select import *
4 | 


--------------------------------------------------------------------------------
/cogs/esports/views/smslotlist/button.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | from contextlib import suppress
  5 | 
  6 | import discord
  7 | 
  8 | from models import AssignedSlot, BanLog, Scrim
  9 | 
 10 | if T.TYPE_CHECKING:
 11 |     from core import Quotient
 12 | 
 13 | import asyncio
 14 | import random
 15 | 
 16 | from tortoise.exceptions import OperationalError
 17 | 
 18 | from utils import TimeText, emote
 19 | 
 20 | from .editor import *
 21 | from .select import BanOptions, prompt_slot_selection
 22 | 
 23 | __all__ = ("SlotlistEditButton",)
 24 | 
 25 | 
 26 | class SlotlistEditButton(discord.ui.View):
 27 |     message: discord.Message
 28 | 
 29 |     def __init__(self, bot: Quotient, scrim: Scrim):
 30 |         super().__init__(timeout=None)
 31 | 
 32 |         self.bot = bot
 33 |         self.scrim = scrim
 34 | 
 35 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
 36 |         if not any(
 37 |             (
 38 |                 interaction.user.guild_permissions.manage_guild,
 39 |                 "scrims-mod" in (_.name.strip().lower() for _ in interaction.user.roles),
 40 |             )
 41 |         ):
 42 |             return await interaction.response.send_message(
 43 |                 embed=discord.Embed(
 44 |                     color=discord.Color.red(),
 45 |                     description=("You need `manage server` permissions or `scrims-mod` role to edit this slotlist."),
 46 |                 ),
 47 |                 ephemeral=True,
 48 |             )
 49 | 
 50 |         return True
 51 | 
 52 |     @discord.ui.button(label="Edit", emoji="📝", style=discord.ButtonStyle.green, custom_id="scrim_slotlist_edit_b")
 53 |     async def edit_slotlist(self, interaction: discord.Interaction, button: discord.Button):
 54 |         await interaction.response.defer(thinking=True, ephemeral=True)
 55 | 
 56 |         try:
 57 |             await self.scrim.refresh_from_db()
 58 |         except OperationalError:
 59 |             await interaction.followup.send("This scrim has been deleted.", ephemeral=True)
 60 | 
 61 |         _view = ScrimsSlotlistEditor(
 62 |             self.bot, self.scrim, await self.scrim.slotlist_channel.fetch_message(self.scrim.slotlist_message_id)
 63 |         )
 64 |         embed = _view.initial_embed()
 65 |         _view.message = await interaction.followup.send(embed=embed, view=_view, ephemeral=True)
 66 | 
 67 |     @discord.ui.button(label="Punish", emoji="🛠️", style=discord.ButtonStyle.danger, custom_id="scrim_slotlist_ban_b")
 68 |     async def ban_slot(self, interaction: discord.Interaction, button: discord.Button):
 69 |         await interaction.response.defer(thinking=True, ephemeral=True)
 70 | 
 71 |         __slots = await self.scrim.assigned_slots.all().order_by("num")
 72 |         if not __slots:
 73 |             return await interaction.followup.send("No slot in the scrim to ban.", ephemeral=True)
 74 | 
 75 |         _v = await prompt_slot_selection(__slots, placeholder="Select the slots to ban the teams...", multiple=True)
 76 | 
 77 |         _e = discord.Embed(color=0x00FFB3, description="Kindly choose slots from the dropdown.")
 78 | 
 79 |         await interaction.followup.send(embed=_e, view=_v, ephemeral=True)
 80 | 
 81 |         await _v.wait()
 82 |         if slot_ids := _v.custom_id:
 83 |             _slots = await AssignedSlot.filter(pk__in=slot_ids)
 84 |             _e.description = "Enter the time & reason to ban the teams. (Time is optional)\n\nExamples:"
 85 |             _e.set_image(url="https://cdn.discordapp.com/attachments/782161513825042462/947436682800685056/banreason.gif")
 86 |             await interaction.followup.send(embed=_e, ephemeral=True)
 87 | 
 88 |             try:
 89 |                 message: discord.Message = await self.bot.wait_for(
 90 |                     "message",
 91 |                     check=lambda x: x.author == interaction.user and x.channel == interaction.channel,
 92 |                     timeout=60,
 93 |                 )
 94 | 
 95 |             except asyncio.TimeoutError:
 96 |                 return await interaction.followup.send("Timed out", ephemeral=True)
 97 | 
 98 |             await message.delete()
 99 |             reason = await TimeText().convert(await self.bot.get_context(message), message.content)
100 | 
101 |             _v = BanOptions()
102 |             await interaction.followup.send(embed=_v.initial_embed(), view=_v, ephemeral=True)
103 |             await _v.wait()
104 |             if _v.value:
105 |                 _e.title = "Banning teams..."
106 |                 _e.description = ""
107 |                 _e.set_image(url=None)
108 | 
109 |                 m = await interaction.followup.send(embed=_e, ephemeral=True)
110 | 
111 |                 for idx, _ in enumerate(_slots, start=1):
112 |                     _e.description += f"`{idx}`: {emote.check} {await self.scrim.ban_slot(_,mod=interaction.user,reason=reason,ban_type=_v.value)}\n"
113 |                     with suppress(discord.HTTPException):
114 |                         await m.edit(embed=_e)
115 |                         await asyncio.sleep(0.5)
116 | 
117 |                 _e.title = "Banning Complete!"
118 |                 with suppress(discord.HTTPException):
119 |                     await m.edit(embed=_e)
120 | 
121 |                 if not await BanLog.get(guild_id=interaction.guild_id).exists():
122 |                     if random.randint(1, 50) == 1:
123 |                         _e = discord.Embed(
124 |                             color=0x00FFB3,
125 |                             description=(
126 |                                 "I see You don't have a public banlog channel in your server.\n\n"
127 |                                 "You can set it up with `qbanlog #channel`."
128 |                             ),
129 |                         )
130 |                         return await interaction.followup.send(embed=_e, ephermeral=True)
131 | 
132 |     @discord.ui.button(label="Info", emoji="🧐", style=discord.ButtonStyle.green, custom_id="scrim_slotlist_info_b")
133 |     async def get_slot_info(self, interaction: discord.Interaction, button: discord.Button):
134 |         await interaction.response.defer(thinking=True, ephemeral=True)
135 | 
136 |         __slots = await self.scrim.assigned_slots.all().order_by("num")
137 |         if not __slots:
138 |             return await interaction.followup.send("No slot in the scrim to fetch info.", ephemeral=True)
139 | 
140 |         _v = await prompt_slot_selection(__slots, placeholder="Select the slot to get info...", multiple=False)
141 | 
142 |         _e = discord.Embed(color=0x00FFB3, description="Kindly choose slots from the dropdown.")
143 | 
144 |         await interaction.followup.send(embed=_e, view=_v, ephemeral=True)
145 | 
146 |         await _v.wait()
147 |         if slot_id := _v.custom_id:
148 |             _slot = await AssignedSlot.filter(pk=slot_id).first()
149 | 
150 |             if not _slot.user_id:
151 |                 return await interaction.followup.send(
152 |                     "**This slot was manually added by a Scrims Moderator.**\n\n`No other info present.`", ephemeral=True
153 |                 )
154 | 
155 |             leader = await self.bot.get_or_fetch_member(interaction.guild, _slot.user_id)
156 | 
157 |             _e = discord.Embed(
158 |                 color=0x00FFB3,
159 |                 description=(
160 |                     f"**Slot No:** `{_slot.num}`\n"
161 |                     f"**Name:** `{_slot.team_name}`\n"
162 |                     f"**Captain:** `{leader}` (<@{_slot.user_id}>)\n"
163 |                     f"**Team:** " + ", ".join([f"<@{i}>" for i in _slot.members])
164 |                 ),
165 |             )
166 | 
167 |             if _slot.jump_url:
168 |                 _e.add_field(name="Registration Message", value=f"[Click me to Jump]({_slot.jump_url})", inline=False)
169 | 
170 |             _e.set_author(name="Slot Info", icon_url=self.bot.user.display_avatar.url)
171 |             await interaction.followup.send(embed=_e, ephemeral=True)
172 | 


--------------------------------------------------------------------------------
/cogs/esports/views/smslotlist/editor.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import asyncio
  4 | import re
  5 | import typing as T
  6 | from contextlib import suppress
  7 | 
  8 | import discord
  9 | 
 10 | from models import ArrayAppend, ArrayRemove, AssignedSlot, Scrim, ScrimsSlotManager
 11 | from utils import emote, truncate_string
 12 | 
 13 | from .select import prompt_slot_selection
 14 | 
 15 | if T.TYPE_CHECKING:
 16 |     from core import Quotient
 17 | 
 18 | __all__ = ("ScrimsSlotlistEditor",)
 19 | 
 20 | 
 21 | class ScrimsSlotlistEditor(discord.ui.View):
 22 |     message: discord.Message
 23 | 
 24 |     def __init__(self, bot: Quotient, scrim: Scrim, slotlist_message: discord.Message):
 25 |         super().__init__(timeout=30)
 26 | 
 27 |         self.bot = bot
 28 |         self.scrim = scrim
 29 |         self.slotlist_message = slotlist_message
 30 | 
 31 |         self.custom_id = None
 32 | 
 33 |     async def on_timeout(self) -> None:
 34 |         if not hasattr(self, "message"):
 35 |             return
 36 | 
 37 |         for _ in self.children:
 38 |             if isinstance(_, discord.ui.Button):
 39 |                 _.disabled = True
 40 | 
 41 |         with suppress(discord.HTTPException):
 42 |             return await self.message.edit(view=self)
 43 | 
 44 |     def initial_embed(self) -> discord.Embed:
 45 |         _e = discord.Embed(color=0x00FFB3, description="Choose an option below to edit the slotlist.")
 46 |         return _e
 47 | 
 48 |     @discord.ui.button(style=discord.ButtonStyle.success, label="Change Team", custom_id="smslot_change_team")
 49 |     async def change_team_name(self, interaction: discord.Interaction, button: discord.Button):
 50 |         await interaction.response.defer()
 51 | 
 52 |         __slots = await self.scrim.assigned_slots.all().order_by("num")
 53 |         if not __slots:
 54 |             return await interaction.followup.send("No slot available to replace.", ephemeral=True)
 55 |         _v = await prompt_slot_selection(__slots, placeholder="Select the slot to change...")
 56 | 
 57 |         _e = discord.Embed(color=0x00FFB3, description="Kindly choose a slot from the dropdown.")
 58 | 
 59 |         await interaction.followup.send(embed=_e, view=_v, ephemeral=True)
 60 | 
 61 |         await _v.wait()
 62 |         if slot_id := _v.custom_id:
 63 |             _slot = await AssignedSlot.get_or_none(pk=slot_id)
 64 | 
 65 |             _e.description = "Please enter the team name. Also mention the leader of that team (Optional)"
 66 |             await interaction.followup.send(embed=_e, ephemeral=True)
 67 | 
 68 |             try:
 69 |                 _ms: discord.Message = await self.bot.wait_for(
 70 |                     "message",
 71 |                     check=lambda m: m.author == interaction.user and m.channel == interaction.channel,
 72 |                     timeout=50,
 73 |                 )
 74 |             except asyncio.TimeoutError:
 75 |                 return await interaction.followup.send("Timed out. Please try again.", ephemeral=True)
 76 | 
 77 |             await _ms.delete()
 78 |             user_id = None
 79 |             if _ms.mentions:
 80 |                 user_id = _ms.mentions[0].id
 81 | 
 82 |                 with suppress(discord.HTTPException):
 83 |                     await _ms.mentions[0].add_roles(discord.Object(id=self.scrim.role_id))
 84 | 
 85 |             _ms.content = re.sub(r"<@*!*&*\d+>", "", _ms.content)
 86 | 
 87 |             team_name = truncate_string(_ms.content, 22)
 88 |             if not team_name:
 89 |                 return await interaction.followup.send("Team name cannot be empty.", ephemeral=True)
 90 | 
 91 |             await AssignedSlot.filter(pk=slot_id).update(team_name=team_name, user_id=user_id)
 92 | 
 93 |             if _slot and _slot.user_id:
 94 |                 if not await self.scrim.assigned_slots.filter(user_id=_slot.user_id).exists():
 95 |                     member = self.scrim.guild.get_member(_slot.user_id)
 96 |                     with suppress(discord.HTTPException):
 97 |                         await member.remove_roles(discord.Object(id=self.scrim.role_id))
 98 | 
 99 |             _e.description = "Slotlist updated successfully."
100 |             await interaction.followup.send(embed=_e, ephemeral=True)
101 |             return await self.scrim.refresh_slotlist_message(self.slotlist_message)
102 | 
103 |     @discord.ui.button(style=discord.ButtonStyle.red, label="Remove Team", custom_id="smslot_remove_team")
104 |     async def remove_team_name(self, interaction: discord.Interaction, button: discord.Button):
105 |         await interaction.response.defer()
106 | 
107 |         __slots = await self.scrim.assigned_slots.all().order_by("num")
108 |         if not __slots:
109 |             return await interaction.followup.send("No slot available to remove.", ephemeral=True)
110 | 
111 |         _v = await prompt_slot_selection(__slots, placeholder="Select the slot to remove...")
112 |         await interaction.followup.send("Kindly choose a slot from the dropdown.", view=_v, ephemeral=True)
113 | 
114 |         await _v.wait()
115 |         if slot_id := _v.custom_id:
116 |             _slot = await AssignedSlot.get_or_none(pk=slot_id)
117 |             if not _slot:
118 |                 return
119 | 
120 |             if _slot.user_id:
121 |                 if await self.scrim.assigned_slots.filter(user_id=_slot.user_id).count() == 1:
122 |                     with suppress(discord.HTTPException, AttributeError):
123 |                         m = self.scrim.guild.get_member(_slot.user_id)
124 |                         await m.remove_roles(discord.Object(id=self.scrim.role_id))
125 | 
126 |             await self.scrim.make_changes(available_slots=ArrayAppend("available_slots", _slot.num))
127 |             await AssignedSlot.filter(pk=slot_id).update(team_name="❌")
128 |             await self.scrim.refresh_slotlist_message(self.slotlist_message)
129 | 
130 |             await AssignedSlot.filter(pk=slot_id).delete()
131 | 
132 |             _e = discord.Embed(color=0x00FFB3, description="Team Removed from slotlist.")
133 | 
134 |             await interaction.followup.send(embed=_e, ephemeral=True)
135 | 
136 |             slotm = await ScrimsSlotManager.get_or_none(guild_id=self.scrim.guild_id, scrim_ids__contains=self.scrim.id)
137 |             if slotm:
138 |                 await slotm.refresh_public_message()
139 | 
140 |     @discord.ui.button(label="Add Team", custom_id="smslot_add_team", style=discord.ButtonStyle.green)
141 |     async def add_new_team(self, interaction: discord.Interaction, button: discord.Button):
142 |         await interaction.response.defer()
143 | 
144 |         _list = list(range(self.scrim.start_from, 30))
145 |         async for _ in self.scrim.assigned_slots.order_by("num"):
146 |             _list.remove(_.num)
147 | 
148 |         _slots = [AssignedSlot(num=_, id=_, team_name="Click to add") for _ in _list]
149 |         if not _slots:
150 |             return await interaction.followup.send("No slots available to add this time.", ephemeral=True)
151 | 
152 |         _v = await prompt_slot_selection(_slots, placeholder="Select the slot to add...")
153 | 
154 |         await interaction.followup.send("Kindly choose a slot from the dropdown.", view=_v, ephemeral=True)
155 |         await _v.wait()
156 |         if slot_id := _v.custom_id:
157 |             await interaction.followup.send(
158 |                 "Please enter the team name. Also mention the leader of that team (Optional)", ephemeral=True
159 |             )
160 | 
161 |             try:
162 |                 _ms: discord.Message = await self.bot.wait_for(
163 |                     "message",
164 |                     check=lambda m: m.author == interaction.user and m.channel == interaction.channel,
165 |                     timeout=50,
166 |                 )
167 |             except asyncio.TimeoutError:
168 |                 return await interaction.followup.send("Timed out. Please try again.", ephemeral=True)
169 | 
170 |             await _ms.delete()
171 |             user_id = None
172 |             if _ms.mentions:
173 |                 user_id = _ms.mentions[0].id
174 | 
175 |                 with suppress(discord.HTTPException):
176 |                     await _ms.mentions[0].add_roles(discord.Object(id=self.scrim.role_id))
177 | 
178 |             _ms.content = re.sub(r"<@*!*&*\d+>", "", _ms.content)
179 | 
180 |             team_name = truncate_string(_ms.content, 22)
181 |             if not team_name:
182 |                 return await interaction.followup.send("Team name cannot be empty.", ephemeral=True)
183 | 
184 |             _slot = await AssignedSlot.create(num=slot_id, team_name=team_name, user_id=user_id)
185 |             await self.scrim.assigned_slots.add(_slot)
186 |             await self.scrim.make_changes(available_slots=ArrayRemove("available_slots", slot_id))
187 | 
188 |             await self.scrim.refresh_slotlist_message(self.slotlist_message)
189 | 
190 |             return await interaction.followup.send(f"{emote.check} Team added successfully.", ephemeral=True)
191 | 


--------------------------------------------------------------------------------
/cogs/esports/views/smslotlist/select.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from typing import List
 4 | 
 5 | import discord
 6 | 
 7 | import config
 8 | from models import AssignedSlot
 9 | from utils import emote
10 | from utils import keycap_digit as kd
11 | from utils import truncate_string as ts
12 | 
13 | 
14 | class ScrimSlotSelector(discord.ui.Select):
15 |     def __init__(self, slots: List[AssignedSlot], *, placeholder: str, multiple=False):
16 |         _options = []
17 |         for slot in slots:
18 |             _options.append(
19 |                 discord.SelectOption(
20 |                     label=f"Slot {slot.num}", description=ts(slot.team_name, 22), emoji=emote.TextChannel, value=slot.id
21 |                 )
22 |             )
23 | 
24 |         super().__init__(options=_options, placeholder=placeholder, max_values=len(_options) if multiple else 1)
25 | 
26 |     async def callback(self, interaction: discord.Interaction):
27 |         await interaction.response.defer()
28 |         self.view.stop()
29 |         self.view.custom_id = interaction.data["values"][0] if not self.max_values > 1 else interaction.data["values"]
30 | 
31 | 
32 | async def prompt_slot_selection(slots: List[AssignedSlot], placeholder: str, multiple: bool = False):
33 |     first, rest = slots[:25], slots[25:]
34 | 
35 |     _view = discord.ui.View(timeout=60)
36 |     _view.custom_id = None
37 | 
38 |     _view.add_item(ScrimSlotSelector(first, placeholder=placeholder, multiple=multiple))
39 | 
40 |     if rest:
41 |         _view.add_item(ScrimSlotSelector(rest, placeholder=placeholder, multiple=multiple))
42 | 
43 |     return _view
44 | 
45 | 
46 | class BanOptions(discord.ui.View):
47 |     def __init__(self):
48 |         super().__init__(timeout=60)
49 |         self.value: str = None
50 | 
51 |     def initial_embed(self):
52 |         _e = discord.Embed(color=0x00FFB3, title="Ban karne ka style choose karo :)", url=config.SERVER_LINK)
53 |         _e.description = (
54 |             f"{kd(1)} - Ban Team leader from this scrim.\n\n"
55 |             f"{kd(2)} - Ban whole team from this scrim.\n\n"
56 |             f"{kd(3)} - Ban Team leader from all scrims.\n\n"
57 |             f"{kd(4)} - Ban whole team from all scrims."
58 |         )
59 |         return _e
60 | 
61 |     @discord.ui.button(emoji=kd(1))
62 |     async def on_one(self, interaction: discord.Interaction, button: discord.Button):
63 |         await interaction.response.defer()
64 |         self.value = "1"
65 |         self.stop()
66 | 
67 |     @discord.ui.button(emoji=kd(2))
68 |     async def on_two(self, interaction: discord.Interaction, button: discord.Button):
69 |         await interaction.response.defer()
70 |         self.value = "2"
71 |         self.stop()
72 | 
73 |     @discord.ui.button(emoji=kd(3))
74 |     async def on_three(self, interaction: discord.Interaction, button: discord.Button):
75 |         await interaction.response.defer()
76 |         self.value = "3"
77 |         self.stop()
78 | 
79 |     @discord.ui.button(emoji=kd(4))
80 |     async def on_four(self, interaction: discord.Interaction, button: discord.Button):
81 |         await interaction.response.defer()
82 |         self.value = "4"
83 |         self.stop()
84 | 


--------------------------------------------------------------------------------
/cogs/esports/views/ssmod/__init__.py:
--------------------------------------------------------------------------------
1 | from ._edit import *  # noqa: F401, F403
2 | from ._setup import *  # noqa: F401, F403
3 | 


--------------------------------------------------------------------------------
/cogs/esports/views/ssmod/_buttons.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import discord
  4 | 
  5 | from constants import SSType
  6 | from core import Context
  7 | from models import SSVerify
  8 | from utils import BaseSelector, Prompt, inputs
  9 | from utils import keycap_digit as kd
 10 | from utils import truncate_string
 11 | 
 12 | from ._type import SStypeSelector
 13 | 
 14 | 
 15 | class SetChannel(discord.ui.Button):
 16 |     def __init__(self, ctx: Context):
 17 |         super().__init__(emoji=kd(1))
 18 | 
 19 |         self.ctx = ctx
 20 | 
 21 |     async def callback(self, interaction: discord.Interaction):
 22 |         await interaction.response.defer()
 23 | 
 24 |         _m = await self.ctx.simple("Mention the channel you want to use for ssverification.")
 25 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
 26 | 
 27 |         await self.ctx.safe_delete(_m)
 28 | 
 29 |         if await SSVerify.filter(channel_id=channel.id).exists():
 30 |             return await self.ctx.error(f"{channel.mention} is already a ssverification channel.", 3)
 31 | 
 32 |         if not channel.permissions_for(self.ctx.guild.me).embed_links:
 33 |             return await self.ctx.error(f"I need `embed_links` permission in {channel.mention}", 3)
 34 | 
 35 |         self.view.record.channel_id = channel.id
 36 |         self.ctx.bot.cache.ssverify_channels.add(channel.id)
 37 | 
 38 |         await self.view.refresh_view()
 39 | 
 40 | 
 41 | class SetRole(discord.ui.Button):
 42 |     def __init__(self, ctx: Context):
 43 |         super().__init__(emoji=kd(2))
 44 |         self.ctx = ctx
 45 | 
 46 |     async def callback(self, interaction: discord.Interaction):
 47 |         await interaction.response.defer()
 48 | 
 49 |         _m = await self.ctx.simple("Mention the role you want to give for ssverification.")
 50 |         role = await inputs.role_input(self.ctx, delete_after=True)
 51 | 
 52 |         await self.ctx.safe_delete(_m)
 53 |         self.view.record.role_id = role.id
 54 | 
 55 |         await self.view.refresh_view()
 56 | 
 57 | 
 58 | class RequiredSS(discord.ui.Button):
 59 |     def __init__(self, ctx: Context):
 60 |         super().__init__(emoji=kd(3))
 61 | 
 62 |         self.ctx = ctx
 63 | 
 64 |     async def callback(self, interaction: discord.Interaction):
 65 |         await interaction.response.defer()
 66 | 
 67 |         _m = await self.ctx.simple("How many screenshots do you need me to verify? (`1-5`)")
 68 |         _ss = await inputs.integer_input(self.ctx, delete_after=True, limits=(1, 5))
 69 | 
 70 |         await self.ctx.safe_delete(_m)
 71 |         self.view.record.required_ss = _ss
 72 | 
 73 |         await self.view.refresh_view()
 74 | 
 75 | 
 76 | class ScreenshotType(discord.ui.Button):
 77 |     def __init__(self, ctx: Context):
 78 |         super().__init__(emoji=kd(4))
 79 | 
 80 |         self.ctx = ctx
 81 | 
 82 |     async def callback(self, interaction: discord.Interaction):
 83 |         await interaction.response.defer()
 84 | 
 85 |         _v = BaseSelector(self.ctx.author.id, SStypeSelector)
 86 |         _m = await self.ctx.simple("What type of screenshots do you want to verify?", view=_v)
 87 |         await _v.wait()
 88 |         await _m.delete()
 89 |         if _v.custom_id:
 90 |             self.view.record.ss_type = SSType(_v.custom_id)
 91 | 
 92 |             if not self.view.record.ss_type == SSType.yt:
 93 |                 if not await self.ctx.is_premium_guild():
 94 |                     return await self.ctx.error("You need Quotient Prime to set this filter. (Use `qperks`)", 4)
 95 | 
 96 |             if _v.custom_id == "custom":
 97 |                 _m = await self.ctx.simple(
 98 |                     "What name do want to give this filter?\n\n" "Enter any name relevant to what you want to verify.\n"
 99 |                 )
100 |                 _name = await inputs.string_input(self.ctx, delete_after=True)
101 |                 await self.ctx.safe_delete(_m)
102 |                 _name = truncate_string(_name, max_length=50)
103 | 
104 |                 _m = await self.ctx.simple(
105 |                     "What words might appear in the screenshot? Maybe like name of the game/app or "
106 |                     "anything that you believe to be common in the screenshots.\n\n"
107 |                     "*Separate with comma `,`*"
108 |                 )
109 |                 _keys = await inputs.string_input(self.ctx, delete_after=True)
110 |                 await self.ctx.safe_delete(_m)
111 | 
112 |                 _keys = _keys.split(",")
113 |                 self.view.record.keywords = [_name, *[truncate_string(i, 50).strip() for i in _keys]]
114 | 
115 |                 from ._edit import SSmodEditor
116 | 
117 |                 if isinstance(self.view, SSmodEditor):
118 |                     await self.ctx.bot.db.execute(
119 |                         "UPDATE ss_info SET keywords = $2 WHERE id = $1", self.view.record.id, self.view.record.keywords
120 |                     )
121 | 
122 |                 self.view.record.channel_name = _name
123 | 
124 |                 await self.ctx.success(
125 |                     f"Successfully set custom filter.\nKeywords: `{', '.join(self.view.record.keywords)}`", 4
126 |                 )
127 | 
128 |         await self.view.refresh_view()
129 | 
130 | 
131 | class PageName(discord.ui.Button):
132 |     def __init__(self, ctx: Context):
133 |         super().__init__(emoji=kd(5))
134 | 
135 |         self.ctx = ctx
136 | 
137 |     async def callback(self, interaction: discord.Interaction):
138 |         await interaction.response.defer()
139 | 
140 |         _m = await self.ctx.simple("Enter the exact name of your page/channel.")
141 |         _name = await inputs.string_input(self.ctx, delete_after=True)
142 | 
143 |         await self.ctx.safe_delete(_m)
144 |         self.view.record.channel_name = truncate_string(_name, 30)
145 |         await self.view.refresh_view()
146 | 
147 | 
148 | class PageLink(discord.ui.Button):
149 |     def __init__(self, ctx: Context):
150 |         super().__init__(emoji=kd(6))
151 | 
152 |         self.ctx = ctx
153 | 
154 |     async def callback(self, interaction: discord.Interaction):
155 |         await interaction.response.defer()
156 | 
157 |         _m = await self.ctx.simple("Enter the direct link to your page/channel.")
158 |         _name = await inputs.string_input(self.ctx, delete_after=True)
159 | 
160 |         await self.ctx.safe_delete(_m)
161 |         self.view.record.channel_link = truncate_string(_name, 130)
162 |         await self.view.refresh_view()
163 | 
164 | 
165 | class AllowSame(discord.ui.Button):
166 |     def __init__(self):
167 |         super().__init__(emoji=kd(7))
168 | 
169 |     async def callback(self, interaction: discord.Interaction):
170 |         await interaction.response.defer()
171 |         self.view.record.allow_same = not self.view.record.allow_same
172 |         await self.view.refresh_view()
173 | 
174 | 
175 | class SuccessMessage(discord.ui.Button):
176 |     def __init__(self, ctx, **kwargs):
177 |         super().__init__(emoji=kd(8), **kwargs)
178 | 
179 |         self.ctx = ctx
180 | 
181 |     async def callback(self, interaction: discord.Interaction):
182 |         await interaction.response.defer()
183 | 
184 |         m = await self.ctx.simple(
185 |             "What message do you want me to show for successful verification? This message will be sent to "
186 |             "players who verify screenshots successfully.\n\n**Current Success Message:**"
187 |             f"```{self.view.record.success_message if self.view.record.success_message else 'Not Set Yet.'}```"
188 |             "\n`Kindly keep it under 500 characters. Enter none to remove it.`"
189 |         )
190 | 
191 |         msg = await inputs.string_input(self.ctx, delete_after=True)
192 |         await self.ctx.safe_delete(m)
193 | 
194 |         msg = truncate_string(msg, 500)
195 |         if msg.lower().strip() == "none":
196 |             msg = None
197 |             await self.ctx.success("Removed Success Message.", 3)
198 | 
199 |         elif msg.lower().strip() == "cancel":
200 |             return
201 | 
202 |         if msg != None:
203 |             await self.ctx.success("Success Message Updated.", 3)
204 | 
205 |         self.view.record.success_message = msg
206 |         await self.view.refresh_view()
207 | 
208 | 
209 | class DeleteButton(discord.ui.Button):
210 |     def __init__(self, ctx: Context, record: SSVerify):
211 |         super().__init__(label="Delete ssverify", style=discord.ButtonStyle.red)
212 |         self.ctx = ctx
213 |         self.record = record
214 | 
215 |     async def callback(self, interaction: discord.Interaction):
216 |         await interaction.response.defer()
217 |         prompt = await self.ctx.prompt("Are you sure you want to delete this ssverify?")
218 |         if not prompt:
219 |             return await self.ctx.simple("Okay, not deleting.", 3)
220 | 
221 |         await self.record.full_delete()
222 |         await self.ctx.success("Successfully deleted ssverify.", 3)
223 |         return await self.view.on_timeout()
224 | 
225 | 
226 | class DiscardButton(discord.ui.Button):
227 |     def __init__(self):
228 |         super().__init__(label="Cancel", style=discord.ButtonStyle.red)
229 | 
230 |     async def callback(self, interaction: discord.Interaction):
231 |         return await self.view.on_timeout()
232 | 
233 | 
234 | class SaveButton(discord.ui.Button):
235 |     def __init__(self, ctx: Context):
236 |         self.ctx = ctx
237 |         super().__init__(label="Save & Setup", style=discord.ButtonStyle.green, disabled=True)
238 | 
239 |     async def callback(self, interaction: discord.Interaction):
240 |         await interaction.response.defer()
241 | 
242 |         if not await self.ctx.is_premium_guild():
243 |             if await SSVerify.filter(guild_id=self.ctx.guild.id).exists():
244 |                 return await self.ctx.premium_mango("You need Quotient Premium to setup more than 1 ssverify.")
245 | 
246 |         await self.view.record.save()
247 |         self.ctx.bot.cache.ssverify_channels.add(self.view.record.channel_id)
248 |         await self.view.on_timeout()
249 |         await self.ctx.success(f"Successfully set ssverification in {self.view.record.channel.mention}.", 3)
250 | 


--------------------------------------------------------------------------------
/cogs/esports/views/ssmod/_edit.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from typing import TYPE_CHECKING, List
  4 | 
  5 | if TYPE_CHECKING:
  6 |     from core import Quotient
  7 | 
  8 | import config
  9 | from core import Context
 10 | from models import SSVerify
 11 | 
 12 | from ...views.base import EsportsBaseView
 13 | from ..paginator import NextButton, PrevButton, StopButton
 14 | from ._buttons import *
 15 | 
 16 | 
 17 | class SSmodEditor(EsportsBaseView):
 18 |     def __init__(self, ctx: Context, records: List[SSVerify]):
 19 |         super().__init__(ctx)
 20 | 
 21 |         self.ctx = ctx
 22 |         self.bot: Quotient = ctx.bot
 23 | 
 24 |         self.records = records
 25 | 
 26 |         self.record = self.records[0]
 27 | 
 28 |         self.current_page = 1
 29 | 
 30 |     async def refresh_view(self):
 31 |         self.record = self.records[self.current_page - 1]
 32 | 
 33 |         _d = dict(self.record)
 34 | 
 35 |         del _d["id"]
 36 |         del _d["keywords"]
 37 | 
 38 |         await SSVerify.filter(pk=self.record.pk).update(**_d)
 39 | 
 40 |         _e = await self.initial_embed(self.record)
 41 | 
 42 |         await self._add_buttons(self.ctx)
 43 | 
 44 |         try:
 45 |             self.message = await self.message.edit(embed=_e, view=self)
 46 |         except discord.HTTPException:
 47 |             await self.on_timeout()
 48 | 
 49 |     async def initial_embed(self, record: SSVerify):
 50 |         _index = self.records.index(record)
 51 |         await record.refresh_from_db()
 52 |         self.records[_index] = record
 53 | 
 54 |         _e = discord.Embed(color=0x00FFB3, title=f"Screenshots Manager - Edit Config", url=config.SERVER_LINK)
 55 | 
 56 |         fields = {
 57 |             "Channel": getattr(record.channel, "mention", "`deleted-channel`"),
 58 |             "Role": getattr(record.role, "mention", "`deleted-role`"),
 59 |             "Required ss": f"`{record.required_ss}`",
 60 |             "Screenshot Type": f"`{record.ss_type.value.title()}`",
 61 |             "Page Name": f"`{record.channel_name}`",
 62 |             "Page URL": f"[Click Here]({record.channel_link})",
 63 |             "Allow Same SS": "`Yes`" if record.allow_same else "`No`",
 64 |             f"Success Message {config.PRIME_EMOJI}": "`Click to view or edit`",
 65 |         }
 66 | 
 67 |         for _idx, (name, value) in enumerate(fields.items(), start=1):
 68 |             _e.add_field(
 69 |                 name=f"{kd(_idx)} {name}:",
 70 |                 value=value,
 71 |             )
 72 |         _e.add_field(name="\u200b", value="\u200b")
 73 |         _e.set_footer(text=f"Page {self.current_page}/{len(self.records)}")
 74 | 
 75 |         return _e
 76 | 
 77 |     async def _add_buttons(self, ctx):
 78 |         self.clear_items()
 79 | 
 80 |         cur_page = self.current_page - 1
 81 | 
 82 |         if cur_page > 0:
 83 |             self.add_item(PrevButton())
 84 | 
 85 |         self.add_item(StopButton())
 86 | 
 87 |         if len(self.records) > 1 and cur_page < len(self.records) - 1:
 88 |             self.add_item(NextButton())
 89 | 
 90 |         self.add_item(SetChannel(ctx))
 91 |         self.add_item(SetRole(ctx))
 92 |         self.add_item(RequiredSS(ctx))
 93 |         self.add_item(ScreenshotType(ctx))
 94 |         self.add_item(PageName(ctx))
 95 |         self.add_item(PageLink(ctx))
 96 |         self.add_item(AllowSame())
 97 | 
 98 |         self.add_item(SuccessMessage(ctx))
 99 |         self.add_item(DeleteButton(ctx, self.record))
100 | 
101 |         if not await self.ctx.is_premium_guild():
102 |             self.children[-2].disabled = True
103 | 


--------------------------------------------------------------------------------
/cogs/esports/views/ssmod/_setup.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from typing import TYPE_CHECKING
 4 | 
 5 | if TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | import discord
 9 | 
10 | from core import Context
11 | from models import SSVerify
12 | from utils import emote
13 | 
14 | from ...views.base import EsportsBaseView
15 | from ._edit import SSmodEditor
16 | from ._wiz import SetupWizard
17 | 
18 | 
19 | class SsmodMainView(EsportsBaseView):
20 |     def __init__(self, ctx: Context):
21 |         super().__init__(ctx, timeout=90, title="Screenshots Manager")
22 | 
23 |         self.ctx = ctx
24 |         self.bot: Quotient = ctx.bot
25 | 
26 |     async def initial_message(self):
27 |         records = await SSVerify.filter(guild_id=self.ctx.guild.id).order_by("id")
28 |         if not records:
29 |             self.children[-2].disabled = True
30 | 
31 |         _to_show = [f"`{idx}.` {_.__str__()}" for idx, _ in enumerate(records, start=1)]
32 | 
33 |         _sm = "\n".join(_to_show) if _to_show else "```Click Setup button for new ssverify.```"
34 | 
35 |         _e = discord.Embed(color=0x00FFB3, title=f"Advanced Screenshots Manager", url=self.ctx.config.SERVER_LINK)
36 |         _e.set_thumbnail(url=self.bot.user.display_avatar.url)
37 |         _e.description = _sm
38 |         _e.set_footer(text="When in doubt, press '?' :)", icon_url=getattr(self.ctx.author, "url", None))
39 |         return _e
40 | 
41 |     @discord.ui.button(label="Setup ssverify", custom_id="setup_ssverify_button", emoji=emote.add)
42 |     async def setup_ssverify_button(self, interaction: discord.Interaction, button: discord.Button):
43 |         await interaction.response.defer()
44 | 
45 |         if not await self.ctx.is_premium_guild():
46 |             if await SSVerify.filter(guild_id=self.ctx.guild.id).exists():
47 |                 return await self.ctx.premium_mango("You need Quotient Premium to setup more than 1 ssverify.")
48 | 
49 |         view = SetupWizard(self.ctx)
50 |         _e = view.initial_message()
51 |         view.message = await interaction.followup.send(embed=_e, view=view)
52 | 
53 |     @discord.ui.button(label="Change Settings", custom_id="edit_ssmod_config", emoji="⚒️")
54 |     async def edit_ssmod_config(self, interaction: discord.Interaction, button: discord.Button):
55 |         await interaction.response.defer()
56 | 
57 |         records = await SSVerify.filter(guild_id=self.ctx.guild.id).order_by("id")
58 |         _view = SSmodEditor(self.ctx, records)
59 |         await _view._add_buttons(self.ctx)
60 |         _view.message = await interaction.followup.send(embed=await _view.initial_embed(records[0]), view=_view)
61 | 
62 |     @discord.ui.button(emoji="❔", custom_id="info_ssmod_button")
63 |     async def stop_ssmod_button(self, interaction: discord.Interaction, button: discord.Button):
64 |         _e = discord.Embed(color=0x00FFB3, title="Screenshots Manager FAQ", url=self.ctx.config.SERVER_LINK)
65 |         _e.description = (
66 |             "**How to setup Quotient ssverification?**\n"
67 |             "> Click the `Setup ssverify` button to set up ssverify.\n\n"
68 |             "**What is Custom Filter?**\n"
69 |             "> Custom Filter allows you to set ssverification for any app or for any type of ss.\n\n"
70 |             "**My question isn't listed here. What should I do?**\n"
71 |             "> You can talk to us directly in the support server: {0}".format(self.ctx.config.SERVER_LINK)
72 |         )
73 |         return await interaction.response.send_message(embed=_e, ephemeral=True)
74 | 


--------------------------------------------------------------------------------
/cogs/esports/views/ssmod/_type.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import discord
 4 | 
 5 | from constants import SSType
 6 | from utils import BaseSelector
 7 | 
 8 | 
 9 | class SStypeSelector(discord.ui.Select):
10 |     view: BaseSelector
11 | 
12 |     def __init__(self):
13 |         super().__init__(
14 |             placeholder="Select the type of screenshots ... ",
15 |             options=[
16 |                 discord.SelectOption(
17 |                     label="Youtube",
18 |                     emoji="<:youtube:938835185976344576>",
19 |                     value=SSType.yt.value,
20 |                     description="Youtube Channel Screenshots",
21 |                 ),
22 |                 discord.SelectOption(
23 |                     label="Instagram",
24 |                     emoji="<:instagram:938834438656249896>",
25 |                     value=SSType.insta.value,
26 |                     description="Instagram Screenshots (Premium only)",
27 |                 ),
28 |                 discord.SelectOption(
29 |                     label="Rooter",
30 |                     emoji="<:rooter:938834226483171418>",
31 |                     value=SSType.rooter.value,
32 |                     description="Rooter Screenshots (Premium only)",
33 |                 ),
34 |                 discord.SelectOption(
35 |                     label="Loco",
36 |                     emoji="<:loco:938834181088219146>",
37 |                     value=SSType.loco.value,
38 |                     description="Loco Screenshots (Premium only)",
39 |                 ),
40 |                 discord.SelectOption(
41 |                     label="Any SS",
42 |                     emoji="<:hehe:874303673981878272>",
43 |                     value=SSType.anyss.value,
44 |                     description="Verify any Image (Premium only)",
45 |                 ),
46 |                 discord.SelectOption(
47 |                     label="Create Custom Filter",
48 |                     emoji="<a:rooCoder:881404453415186502>",
49 |                     value=SSType.custom.value,
50 |                     description="For anything like app installation, any mobile app,etc.",
51 |                 ),
52 |             ],
53 |         )
54 | 
55 |     async def callback(self, interaction: discord.Interaction):
56 |         await interaction.response.defer()
57 |         self.view.stop()
58 |         self.view.custom_id = interaction.data["values"][0]
59 | 


--------------------------------------------------------------------------------
/cogs/esports/views/ssmod/_wiz.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import discord
 4 | 
 5 | import config
 6 | from core import Context
 7 | from models import SSVerify
 8 | from utils import keycap_digit as kd
 9 | 
10 | from ...views.base import EsportsBaseView
11 | from ._buttons import *
12 | 
13 | __all__ = ("SetupWizard",)
14 | 
15 | 
16 | class SetupWizard(EsportsBaseView):
17 |     def __init__(self, ctx: Context):
18 |         super().__init__(ctx)
19 | 
20 |         self.ctx = ctx
21 |         self.record = None
22 | 
23 |         self.add_item(SetChannel(ctx))
24 |         self.add_item(SetRole(ctx))
25 |         self.add_item(RequiredSS(ctx))
26 |         self.add_item(ScreenshotType(ctx))
27 |         self.add_item(PageName(ctx))
28 |         self.add_item(PageLink(ctx))
29 |         self.add_item(AllowSame())
30 |         self.add_item(DiscardButton())
31 |         self.add_item(SaveButton(ctx))
32 | 
33 |     def initial_message(self):
34 |         if not self.record:
35 |             self.record = SSVerify(guild_id=self.ctx.guild.id)
36 | 
37 |         _e = discord.Embed(color=0x00FFB3, title="Enter details & Press Save", url=config.SERVER_LINK)
38 | 
39 |         fields = {
40 |             "Channel": getattr(self.record.channel, "mention", "`Not-Set`"),
41 |             "Role": getattr(self.record.role, "mention", "`Not-Set`"),
42 |             "Required ss": f"`{self.record.required_ss}`",
43 |             "Screenshot Type": "`Not-Set`" if not self.record.ss_type else f"`{self.record.ss_type.value.title()}`",
44 |             "Page Name": f"`{self.record.channel_name or '`Not-Set`'}`",
45 |             "Page URL": "`Not-Set (Not Required)`"
46 |             if self.record.channel_link == config.SERVER_LINK
47 |             else f"[Click Here]({self.record.channel_link})",
48 |             "Allow Same SS": "`Yes`" if self.record.allow_same else "`No`",
49 |         }
50 | 
51 |         for _idx, (name, value) in enumerate(fields.items(), start=1):
52 |             _e.add_field(
53 |                 name=f"{kd(_idx)} {name}:",
54 |                 value=value,
55 |             )
56 | 
57 |         return _e
58 | 
59 |     async def refresh_view(self):
60 |         _e = self.initial_message()
61 | 
62 |         if all(
63 |             (
64 |                 self.record.channel_id,
65 |                 self.record.role_id,
66 |                 self.record.required_ss,
67 |                 self.record.ss_type,
68 |                 self.record.channel_name,
69 |             )
70 |         ):
71 |             self.children[-1].disabled = False
72 | 
73 |         try:
74 |             self.message = await self.message.edit(embed=_e, view=self)
75 |         except discord.HTTPException:
76 |             await self.on_timeout()
77 | 


--------------------------------------------------------------------------------
/cogs/esports/views/tagcheck/__init__.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from typing import TYPE_CHECKING
 4 | 
 5 | from ...views.base import EsportsBaseView
 6 | 
 7 | if TYPE_CHECKING:
 8 |     from core import Quotient
 9 | 
10 | import discord
11 | 
12 | from core import Context
13 | from models import TagCheck
14 | 
15 | 
16 | class TagCheckView(EsportsBaseView):
17 |     def __init__(self, ctx: Context):
18 |         super().__init__(ctx)
19 | 
20 |         self.ctx = ctx
21 |         self.bot: Quotient = ctx.bot
22 | 
23 |     async def initial_embed(self):
24 |         records = await TagCheck.filter(guild_id=self.ctx.guild.id)
25 |         to_show = [f"`{idx}.` {_.__str__()}" for idx, _ in enumerate(records, start=1)]
26 |         _m = "\n".join(to_show) if to_show else "```No TagCheck channels found.```"
27 |         _e = discord.Embed(color=0x00FFB3, title="TagCheck Editor")
28 |         _e.description = "**Current TagCheck channels:**\n" + _m
29 |         _e.set_footer(text="Click Add Channel to set up a new TagCheck channel.")
30 |         return _e
31 | 
32 |     @discord.ui.button(label="Add Channel", custom_id="add_tc_channel")
33 |     async def add_tc_channel(self, interaction: discord.Interaction, button: discord.Button):
34 |         await interaction.response.defer()
35 | 
36 |     @discord.ui.button(label="Remove Channel", custom_id="remove_tc_channel")
37 |     async def remove_tc_channel(self, interaction: discord.Interaction, button: discord.Button):
38 |         await interaction.response.defer()
39 | 


--------------------------------------------------------------------------------
/cogs/esports/views/tourney/__init__.py:
--------------------------------------------------------------------------------
1 | from .groups import *
2 | from .slotm import *
3 | 


--------------------------------------------------------------------------------
/cogs/esports/views/tourney/_base.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import discord
 4 | 
 5 | from models import Tourney
 6 | 
 7 | from ...views.base import EsportsBaseView
 8 | 
 9 | 
10 | class TourneyView(EsportsBaseView):
11 |     record: Tourney
12 | 
13 |     def __init__(self, ctx, **kwargs):
14 |         super().__init__(ctx, **kwargs)
15 | 
16 | 
17 | class TourneyButton(discord.ui.Button):
18 |     view: TourneyView
19 | 
20 |     def __init__(self, **kwargs):
21 |         super().__init__(**kwargs)
22 | 


--------------------------------------------------------------------------------
/cogs/esports/views/tourney/_buttons.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from contextlib import suppress
  4 | 
  5 | import discord
  6 | 
  7 | from core import Context
  8 | from models import Tourney
  9 | from utils import emote, inputs
 10 | from utils import regional_indicator as ri
 11 | from utils import truncate_string
 12 | 
 13 | from ._base import TourneyButton
 14 | 
 15 | #! increase success message limit to 500
 16 | #! fake tags maybe
 17 | #! disable tourney slotm in delete
 18 | 
 19 | 
 20 | class SetTourneyname(TourneyButton):
 21 |     def __init__(self, ctx: Context, letter: str):
 22 |         super().__init__(emoji=ri(letter))
 23 | 
 24 |         self.ctx = ctx
 25 | 
 26 |     async def callback(self, interaction: discord.Interaction):
 27 |         await interaction.response.defer()
 28 |         m = await self.ctx.simple("Enter the new name of the tournament. (`Max 30 characters`)")
 29 |         name = await inputs.string_input(self.ctx, delete_after=True)
 30 |         await self.ctx.safe_delete(m)
 31 |         self.view.record.name = truncate_string(name, 30)
 32 | 
 33 |         await self.view.refresh_view()
 34 | 
 35 | 
 36 | class RegChannel(TourneyButton):
 37 |     def __init__(self, ctx: Context, letter: str):
 38 |         super().__init__(emoji=ri(letter))
 39 | 
 40 |         self.ctx = ctx
 41 | 
 42 |     async def callback(self, interaction: discord.Interaction):
 43 |         await interaction.response.defer()
 44 | 
 45 |         m = await self.ctx.simple("Mention the channel where you want to take registrations.")
 46 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
 47 |         await self.ctx.safe_delete(m)
 48 | 
 49 |         if await Tourney.filter(registration_channel_id=channel.id).exists():
 50 |             return await self.ctx.error(f"Another tourney is running in {channel.mention}.", 4)
 51 |         self.view.record.registration_channel_id = channel.id
 52 | 
 53 |         self.ctx.bot.cache.tourney_channels.add(channel.id)
 54 | 
 55 |         if not self.view.record.confirm_channel_id:
 56 |             with suppress(StopIteration, AttributeError):
 57 |                 self.view.record.confirm_channel_id = next(
 58 |                     (c.id for c in channel.category.text_channels if "confirm" in c.name.lower())
 59 |                 )
 60 | 
 61 |         if not self.view.record.role_id:
 62 |             for r in channel.guild.roles:
 63 |                 if "confirm" in r.name and not await Tourney.get(role_id=r.id).exists():
 64 |                     self.view.record.role_id = r.id
 65 |                     break
 66 | 
 67 |         await self.view.refresh_view()
 68 | 
 69 | 
 70 | class ConfirmChannel(TourneyButton):
 71 |     def __init__(self, ctx: Context, letter: str):
 72 |         super().__init__(emoji=ri(letter))
 73 | 
 74 |         self.ctx = ctx
 75 | 
 76 |     async def callback(self, interaction: discord.Interaction):
 77 |         await interaction.response.defer()
 78 | 
 79 |         m = await self.ctx.simple("Mention the channel where you want me to post registration confirm messages.")
 80 |         channel = await inputs.channel_input(self.ctx, delete_after=True)
 81 |         await self.ctx.safe_delete(m)
 82 | 
 83 |         self.view.record.confirm_channel_id = channel.id
 84 | 
 85 |         await self.view.refresh_view()
 86 | 
 87 | 
 88 | class SetRole(TourneyButton):
 89 |     def __init__(self, ctx: Context, letter: str):
 90 |         super().__init__(emoji=ri(letter))
 91 | 
 92 |         self.ctx = ctx
 93 | 
 94 |     async def callback(self, interaction: discord.Interaction):
 95 |         await interaction.response.defer()
 96 | 
 97 |         m = await self.ctx.simple("Mention the role you want to give for correct registration.")
 98 |         role = await inputs.role_input(self.ctx, delete_after=True)
 99 |         await self.ctx.safe_delete(m)
100 | 
101 |         self.view.record.role_id = role.id
102 | 
103 |         await self.view.refresh_view()
104 | 
105 | 
106 | class SetMentions(TourneyButton):
107 |     def __init__(self, ctx: Context, letter: str):
108 |         super().__init__(emoji=ri(letter))
109 | 
110 |         self.ctx = ctx
111 | 
112 |     async def callback(self, interaction: discord.Interaction):
113 |         await interaction.response.defer()
114 | 
115 |         m = await self.ctx.simple("How many mentions are required for registration? (Max `10`)")
116 |         mentions = await inputs.integer_input(self.ctx, delete_after=True, limits=(0, 10))
117 |         await self.ctx.safe_delete(m)
118 | 
119 |         self.view.record.required_mentions = mentions
120 | 
121 |         await self.view.refresh_view()
122 | 
123 | 
124 | class MinLines(TourneyButton):
125 |     def __init__(self, ctx: Context, letter: str):
126 |         super().__init__(emoji=ri(letter))
127 |         self.ctx = ctx
128 | 
129 |     async def callback(self, interaction: discord.Interaction):
130 |         await interaction.response.defer()
131 |         if not await self.ctx.is_premium_guild():
132 |             return await self.ctx.error(
133 |                 "**Quotient Premium is required to use this feature.**\n\n`Use qpro command to activate Premium.`", 5
134 |             )
135 | 
136 |         m = await self.ctx.simple("How many lines in registration message are required for registration? (Max `100`)")
137 |         self.view.record.required_lines = await inputs.integer_input(self.ctx, delete_after=True, limits=(0, 10))
138 |         await self.ctx.safe_delete(m)
139 | 
140 |         await self.view.refresh_view()
141 | 
142 | 
143 | class SetPingRole(TourneyButton):
144 |     def __init__(self, ctx: Context, letter: str):
145 |         super().__init__(emoji=ri(letter))
146 | 
147 |         self.ctx = ctx
148 | 
149 |     async def callback(self, interaction: discord.Interaction):
150 |         await interaction.response.defer()
151 | 
152 |         m = await self.ctx.simple("Mention the role you want to ping with registration open message.")
153 |         role = await inputs.role_input(self.ctx, delete_after=True)
154 |         await self.ctx.safe_delete(m)
155 | 
156 |         self.view.record.ping_role_id = role.id
157 | 
158 |         await self.view.refresh_view()
159 | 
160 | 
161 | class SetSlots(TourneyButton):
162 |     def __init__(self, ctx: Context, letter: str):
163 |         super().__init__(emoji=ri(letter))
164 | 
165 |         self.ctx = ctx
166 | 
167 |     async def callback(self, interaction: discord.Interaction):
168 |         await interaction.response.defer()
169 | 
170 |         m = await self.ctx.simple("How many total slots are there? (Max `15000`)")
171 |         slots = await inputs.integer_input(self.ctx, delete_after=True, limits=(1, 15000))
172 |         await self.ctx.safe_delete(m)
173 | 
174 |         self.view.record.total_slots = slots
175 | 
176 |         await self.view.refresh_view()
177 | 
178 | 
179 | class SetEmojis(TourneyButton):
180 |     def __init__(self, ctx: Context, letter: str):
181 |         super().__init__(emoji=ri(letter))
182 | 
183 |         self.ctx = ctx
184 | 
185 |     async def callback(self, interaction: discord.Interaction):
186 |         await interaction.response.defer()
187 |         if not await self.ctx.is_premium_guild():
188 |             return await self.ctx.error(
189 |                 "[Quotient Premium](https://quotientbot.xyz/premium) is required to use this feature.", 4
190 |             )
191 | 
192 |         e = discord.Embed(color=self.ctx.bot.color, title="Edit tourney emojis")
193 |         e.description = (
194 |             "Which emojis do you want to use for tick and cross in tournament registrations?\n\n"
195 |             "`Please enter two emojis and separate them with a comma`"
196 |         )
197 |         e.set_image(url="https://cdn.discordapp.com/attachments/851846932593770496/888097255607906354/unknown.png")
198 |         e.set_footer(text="The first emoji must be the emoji for tick mark.")
199 | 
200 |         m = await interaction.followup.send(embed=e)
201 |         emojis = await inputs.string_input(self.ctx, delete_after=True)
202 | 
203 |         await self.ctx.safe_delete(m)
204 | 
205 |         emojis = emojis.strip().split(",")
206 |         if not len(emojis) == 2:
207 |             return await interaction.followup.send("You didn't enter the correct format.", ephemeral=True)
208 | 
209 |         check, cross = emojis
210 | 
211 |         for emoji in emojis:
212 |             try:
213 |                 await self.view.message.add_reaction(emoji.strip())
214 |                 await self.view.message.clear_reactions()
215 |             except discord.HTTPException:
216 |                 return await interaction.followup.send("One of the emojis you entered is invalid.", ephemeral=True)
217 | 
218 |         self.view.record.emojis = {"tick": check.strip(), "cross": cross.strip()}
219 |         await self.view.refresh_view()
220 | 
221 | 
222 | class OpenRole(TourneyButton):
223 |     def __init__(self, ctx: Context, letter: str):
224 |         super().__init__(emoji=ri(letter))
225 | 
226 |         self.ctx = ctx
227 | 
228 |     async def callback(self, interaction: discord.Interaction):
229 |         await interaction.response.defer()
230 | 
231 |         m = await self.ctx.simple("Mention the role for which you want to open/close registrations.")
232 |         role = await inputs.role_input(self.ctx, delete_after=True)
233 |         await self.ctx.safe_delete(m)
234 | 
235 |         self.view.record.open_role_id = role.id
236 | 
237 |         await self.view.refresh_view()
238 | 
239 | 
240 | class SetGroupSize(TourneyButton):
241 |     def __init__(self, ctx: Context, letter: str):
242 |         super().__init__(emoji=ri(letter))
243 | 
244 |         self.ctx = ctx
245 | 
246 |     async def callback(self, interaction: discord.Interaction):
247 |         await interaction.response.defer()
248 | 
249 |         m = await self.ctx.simple("How many teams will there be per group? (Max `25`)")
250 |         n = await inputs.integer_input(self.ctx, limits=(2, 25), delete_after=True)
251 |         await self.ctx.safe_delete(m)
252 |         self.view.record.group_size = n
253 |         await self.view.refresh_view()
254 | 
255 | 
256 | class MultiReg(TourneyButton):
257 |     def __init__(self, ctx: Context, letter: str):
258 |         super().__init__(emoji=ri(letter))
259 | 
260 |         self.ctx = ctx
261 | 
262 |     async def callback(self, interaction: discord.Interaction):
263 |         await interaction.response.defer()
264 | 
265 |         self.view.record.multiregister = not self.view.record.multiregister
266 |         await self.ctx.success(
267 |             f"Now users **{'can' if self.view.record.multiregister else 'can not'}** register more than once.", 3
268 |         )
269 |         await self.view.refresh_view()
270 | 
271 | 
272 | class TeamCompulsion(TourneyButton):
273 |     def __init__(self, ctx: Context, letter: str):
274 |         super().__init__(emoji=ri(letter))
275 | 
276 |         self.ctx = ctx
277 | 
278 |     async def callback(self, interaction: discord.Interaction):
279 |         await interaction.response.defer()
280 | 
281 |         self.view.record.teamname_compulsion = not self.view.record.teamname_compulsion
282 |         await self.ctx.success(
283 |             f"Now Team Name **{'is' if self.view.record.teamname_compulsion else 'is not'}** required to register.", 3
284 |         )
285 |         await self.view.refresh_view()
286 | 
287 | 
288 | class DuplicateTags(TourneyButton):
289 |     def __init__(self, ctx: Context, letter: str):
290 |         super().__init__(emoji=ri(letter))
291 | 
292 |         self.ctx = ctx
293 | 
294 |     async def callback(self, interaction: discord.Interaction):
295 |         await interaction.response.defer()
296 | 
297 |         if not await self.ctx.is_premium_guild():
298 |             return await self.ctx.error(
299 |                 "[Quotient Premium](https://quotientbot.xyz/premium) is required to use this feature.", 4
300 |             )
301 | 
302 |         self.view.record.allow_duplicate_tags = not self.view.record.allow_duplicate_tags
303 |         await self.ctx.success(
304 |             f"Registrations with fake / duplicate mentions are now **{'allowed' if self.view.record.allow_duplicate_tags else 'not allowed'}**.",
305 |             3,
306 |         )
307 |         await self.view.refresh_view()
308 | 
309 | 
310 | class DuplicateTeamName(TourneyButton):
311 |     def __init__(self, ctx: Context, letter: str):
312 |         super().__init__(emoji=ri(letter))
313 | 
314 |         self.ctx = ctx
315 | 
316 |     async def callback(self, interaction: discord.Interaction):
317 |         await interaction.response.defer()
318 | 
319 |         self.view.record.no_duplicate_name = not self.view.record.no_duplicate_name
320 |         await self.ctx.success(
321 |             f"Duplicate team names are now **{'not allowed' if self.view.record.no_duplicate_name else 'allowed'}**.", 3
322 |         )
323 |         await self.view.refresh_view()
324 | 
325 | 
326 | class AutodeleteRejected(TourneyButton):
327 |     def __init__(self, ctx: Context, letter: str):
328 |         super().__init__(emoji=ri(letter))
329 | 
330 |         self.ctx = ctx
331 | 
332 |     async def callback(self, interaction: discord.Interaction):
333 |         await interaction.response.defer()
334 | 
335 |         self.view.record.autodelete_rejected = not self.view.record.autodelete_rejected
336 |         await self.ctx.success(
337 |             f"Rejected registrations will **{'be' if self.view.record.autodelete_rejected else 'not be'}** deleted automatically.",
338 |             3,
339 |         )
340 |         await self.view.refresh_view()
341 | 
342 | 
343 | class SuccessMessage(TourneyButton):
344 |     def __init__(self, ctx: Context, letter: str):
345 |         super().__init__(emoji=ri(letter))
346 | 
347 |         self.ctx = ctx
348 | 
349 |     async def callback(self, interaction: discord.Interaction):
350 |         await interaction.response.defer()
351 | 
352 |         m = await self.ctx.simple(
353 |             "What message do you want me to show for successful registration? This message will be sent to "
354 |             "DM of players who register successfully.\n\n**Current Success Message:**"
355 |             f"```{self.view.record.success_message if self.view.record.success_message else 'Not Set Yet.'}```"
356 |             "\n`Kindly keep it under 500 characters. Enter none to remove it.`",
357 |             image="https://cdn.discordapp.com/attachments/851846932593770496/900977642382163988/unknown.png",
358 |         )
359 | 
360 |         msg = await inputs.string_input(self.ctx, delete_after=True)
361 |         await self.ctx.safe_delete(m)
362 | 
363 |         msg = truncate_string(msg, 500)
364 |         if msg.lower().strip() == "none":
365 |             msg = None
366 |             await self.ctx.success("Removed Success Message.", 3)
367 | 
368 |         elif msg.lower().strip() == "cancel":
369 |             return
370 | 
371 |         if msg != None:
372 |             await self.ctx.success("Success Message Updated.", 3)
373 | 
374 |         self.view.record.success_message = msg
375 |         await self.view.refresh_view()
376 | 
377 | 
378 | class DeleteTourney(TourneyButton):
379 |     def __init__(self, ctx: Context):
380 |         super().__init__(emoji=emote.trash)
381 | 
382 |         self.ctx = ctx
383 | 
384 |     async def callback(self, interaction: discord.Interaction):
385 |         await interaction.response.defer()
386 | 
387 |         prompt = await self.ctx.prompt(
388 |             "Are you sure you want to delete this tourney?\n\n`This action is not reversible.`"
389 |         )
390 |         if not prompt:
391 |             return await self.ctx.simple("Okay, not deleting.", 3)
392 | 
393 |         await self.view.record.full_delete(interaction.user)
394 |         await self.ctx.success("Successfully deleted tourney.", 3)
395 | 
396 |         from .main import TourneyManager as TM
397 | 
398 |         self.view.stop()
399 |         v = TM(self.ctx)
400 |         v.message = await self.view.message.edit(embed=await v.initial_embed(), view=v)
401 | 
402 | 
403 | class DiscardButton(TourneyButton):
404 |     def __init__(self, ctx: Context, label: str = "Go Back", row: int = None):
405 |         super().__init__(label=label, style=discord.ButtonStyle.red, row=row)
406 |         self.ctx = ctx
407 | 
408 |     async def callback(self, interaction: discord.Interaction):
409 |         await interaction.response.defer()
410 | 
411 |         from .main import TourneyManager as TM
412 | 
413 |         self.view.stop()
414 |         v = TM(self.ctx)
415 |         v.message = await self.view.message.edit(embed=await v.initial_embed(), view=v)
416 | 
417 | 
418 | class SaveTourney(TourneyButton):
419 |     def __init__(self, ctx: Context):
420 |         super().__init__(style=discord.ButtonStyle.green, label="Save", disabled=True)
421 |         self.ctx = ctx
422 | 
423 |     async def callback(self, interaction: discord.Interaction):
424 |         await interaction.response.defer()
425 | 
426 |         message = await self.view.record.setup_slotm()
427 |         self.view.record.slotm_channel_id = message.channel.id
428 |         self.view.record.slotm_message_id = message.id
429 | 
430 |         await self.view.record.save()
431 |         self.ctx.bot.loop.create_task(self.view.record.setup_logs())
432 | 
433 |         self.view.stop()
434 | 
435 |         await self.ctx.success("Successfully saved tourney.\n\n`Click start button to start registrations.`", 4)
436 |         from .main import TourneyManager
437 | 
438 |         v = TourneyManager(self.ctx)
439 |         v.message = await self.view.message.edit(embed=await v.initial_embed(), view=v)
440 | 


--------------------------------------------------------------------------------
/cogs/esports/views/tourney/_editor.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from string import ascii_uppercase
  4 | from typing import List
  5 | 
  6 | import discord
  7 | 
  8 | from core import Context
  9 | from models import Tourney
 10 | from utils import regional_indicator as ri
 11 | 
 12 | from ..paginator import NextButton, PrevButton, StopButton
 13 | from ._base import TourneyView
 14 | from ._buttons import (
 15 |     AutodeleteRejected,
 16 |     ConfirmChannel,
 17 |     DeleteTourney,
 18 |     DiscardButton,
 19 |     DuplicateTags,
 20 |     DuplicateTeamName,
 21 |     MinLines,
 22 |     MultiReg,
 23 |     OpenRole,
 24 |     RegChannel,
 25 |     SetEmojis,
 26 |     SetGroupSize,
 27 |     SetMentions,
 28 |     SetPingRole,
 29 |     SetRole,
 30 |     SetSlots,
 31 |     SetTourneyname,
 32 |     SuccessMessage,
 33 |     TeamCompulsion,
 34 | )
 35 | 
 36 | 
 37 | class TourneyEditor(TourneyView):
 38 |     record: Tourney
 39 | 
 40 |     def __init__(self, ctx: Context, records):
 41 |         super().__init__(ctx, timeout=60, name="Tourney Editor")
 42 | 
 43 |         self.ctx = ctx
 44 | 
 45 |         self.records: List[Tourney] = records
 46 | 
 47 |         self.record = records[0]
 48 | 
 49 |         self.current_page = 1
 50 | 
 51 |     async def refresh_view(self):
 52 |         self.record = self.records[self.current_page - 1]
 53 | 
 54 |         _d = dict(self.record)
 55 | 
 56 |         del _d["id"]
 57 |         del _d["banned_users"]
 58 | 
 59 |         await Tourney.filter(pk=self.record.pk).update(**_d)
 60 | 
 61 |         _e = await self.initial_message()
 62 | 
 63 |         await self._add_buttons(self.ctx)
 64 | 
 65 |         try:
 66 |             self.message = await self.message.edit(embed=_e, view=self)
 67 |         except discord.HTTPException:
 68 |             await self.on_timeout()
 69 | 
 70 |     async def initial_message(self):
 71 |         tourney = self.record
 72 |         _e = discord.Embed(color=self.ctx.bot.color, url=self.ctx.config.SERVER_LINK)
 73 |         _e.title = "Tournament Editor - Edit Settings"
 74 | 
 75 |         fields = {
 76 |             "Name": f"`{tourney.name}`",
 77 |             "Registration Channel": getattr(tourney.registration_channel, "mention", "`channel-deleted`"),
 78 |             "Confirm Channel": getattr(tourney.confirm_channel, "mention", "`channel-deleted`"),
 79 |             "Success Role": getattr(tourney.role, "mention", "`role-deleted`"),
 80 |             "Mentions": f"`{tourney.required_mentions}`",
 81 |             "Slots": f"`{tourney.total_slots:,}`",
 82 |             f"Reactions {self.bot.config.PRIME_EMOJI}": f"{tourney.check_emoji},{tourney.cross_emoji}",
 83 |             "Ping Role": getattr(tourney.ping_role, "mention", "`Not-Set`"),
 84 |             "Open Role": getattr(tourney.open_role, "mention", "`role-deleted`"),
 85 |             "Multi-Register": ("`Not allowed!`", "`Allowed`")[tourney.multiregister],
 86 |             "Team-Name Compulsion": ("`No!`", "`Yes!`")[tourney.teamname_compulsion],
 87 |             "Duplicate Team Name": ("`Allowed`", "`Not allowed!`")[tourney.no_duplicate_name],
 88 |             "Autodelete Rejected": ("`No!`", "`Yes!`")[tourney.autodelete_rejected],
 89 |             "Success Message": f"`Click to view / edit`",
 90 |             "Teams per Group": f"`{self.record.group_size or 'Not set'}`",
 91 |             f"Required Lines {self.bot.config.PRIME_EMOJI}": ("`Not set`", f"`{tourney.required_lines}`")[
 92 |                 bool(tourney.required_lines)
 93 |             ],
 94 |             f"Duplicate / Fake Tags {self.bot.config.PRIME_EMOJI}": ("`Not allowed!`", "`Allowed`")[
 95 |                 tourney.allow_duplicate_tags
 96 |             ],
 97 |         }
 98 | 
 99 |         for idx, (name, value) in enumerate(fields.items()):
100 |             _e.add_field(
101 |                 name=f"{ri(ascii_uppercase[idx])} {name}:",
102 |                 value=value,
103 |             )
104 | 
105 |         _e.add_field(name="\u200b", value="\u200b")
106 |         _e.set_footer(text=f"Page {self.current_page}/{len(self.records)}")
107 |         return _e
108 | 
109 |     async def _add_buttons(self, ctx: Context):
110 |         self.clear_items()
111 | 
112 |         cur_page = self.current_page - 1
113 | 
114 |         if cur_page > 0:
115 |             self.add_item(PrevButton())
116 | 
117 |         self.add_item(StopButton())
118 | 
119 |         if len(self.records) > 1 and cur_page < len(self.records) - 1:
120 |             self.add_item(NextButton())
121 | 
122 |         self.add_item(SetTourneyname(ctx, "a"))
123 |         self.add_item(RegChannel(ctx, "b"))
124 |         self.add_item(ConfirmChannel(ctx, "c"))
125 |         self.add_item(SetRole(ctx, "d"))
126 |         self.add_item(SetMentions(ctx, "e"))
127 |         self.add_item(SetSlots(ctx, "f"))
128 |         self.add_item(SetEmojis(ctx, "g"))
129 |         self.add_item(SetPingRole(ctx, "h"))
130 |         self.add_item(OpenRole(ctx, "i"))
131 |         self.add_item(MultiReg(ctx, "j"))
132 |         self.add_item(TeamCompulsion(ctx, "k"))
133 |         self.add_item(DuplicateTeamName(ctx, "l"))
134 |         self.add_item(AutodeleteRejected(ctx, "m"))
135 |         self.add_item(SuccessMessage(ctx, "n"))
136 |         self.add_item(SetGroupSize(ctx, "o"))
137 |         self.add_item(MinLines(ctx, "p"))
138 |         self.add_item(DuplicateTags(ctx, "q"))
139 |         self.add_item(DeleteTourney(ctx))
140 |         self.add_item(DiscardButton(ctx))
141 | 


--------------------------------------------------------------------------------
/cogs/esports/views/tourney/_partner.py:
--------------------------------------------------------------------------------
  1 | import discord
  2 | 
  3 | from core import Context
  4 | from models import MediaPartner, Tourney
  5 | from utils import aenumerate, channel_input, integer_input
  6 | 
  7 | from ..base import EsportsBaseView
  8 | 
  9 | 
 10 | class MediaPartnerView(EsportsBaseView):
 11 |     def __init__(self, ctx: Context, *, tourney: Tourney):
 12 |         super().__init__(ctx, timeout=30, title="Tourney Media Partner")
 13 |         self.tourney = tourney
 14 |         self.ctx = ctx
 15 | 
 16 |     async def initial_embed(self):
 17 |         embed = discord.Embed(title="Tournament Media Partnership", url=self.ctx.config.SERVER_LINK)
 18 |         embed.color = self.bot.color
 19 |         embed.description = (
 20 |             "With media-partnership you can make Quotient handle media partner registrations "
 21 |             "that means in Quotient will check if the user have registered in the partner server "
 22 |             "and if they have, their registration will be accepted and slot will be given to them.\n\n"
 23 |         )
 24 | 
 25 |         async for idx, partner in aenumerate(self.tourney.media_partners.all(), start=1):
 26 |             embed.description += f"`{idx:02}.` {getattr(partner.channel,'mention','deleted-channel')} - **{await partner.slots.all().count()} players**\n"
 27 | 
 28 |         embed.description += "\n`Click Add New to create a new media partner.`"
 29 |         return embed
 30 | 
 31 |     async def __refresh_embed(self):
 32 |         await self.tourney.refresh_from_db()
 33 |         try:
 34 |             self.message = await self.message.edit(embed=await self.initial_embed(), view=self)
 35 |         except discord.HTTPException:
 36 |             await self.on_timeout()
 37 | 
 38 |     @discord.ui.button(label="Add New", style=discord.ButtonStyle.green)
 39 |     async def add_partner(self, interaction: discord.Interaction, button: discord.Button):
 40 |         await interaction.response.defer(ephemeral=True)
 41 | 
 42 |         if await self.tourney.media_partners.all().count() >= 1 and not await self.ctx.is_premium_guild():
 43 |             return await self.ctx.error(
 44 |                 "You need Quotient Premium to download Ms Excel file containing all the "
 45 |                 f"registration data of your tourneys.\n\n"
 46 |                 "Buy Premium for just ₹29 here: https://quotientbot.xyz/premium",
 47 |                 6,
 48 |             )
 49 | 
 50 |         m = await self.ask_embed("Enter the tourney ID of the tournament you want to partner with.")
 51 | 
 52 |         tourney_id = await integer_input(self.ctx, self.check, delete_after=True)
 53 | 
 54 |         await self.ctx.safe_delete(m)
 55 | 
 56 |         tourney = await Tourney.get_or_none(pk=tourney_id)
 57 |         if tourney is None or not (guild := tourney.guild):
 58 |             return await self.error_embed(
 59 |                 "The tourney ID you entered is invalid. \n\nKindly use `qt` in the partner server"
 60 |                 "to get the correct ID."
 61 |             )
 62 | 
 63 |         if guild == self.ctx.guild:
 64 |             return await self.error_embed("You can't partner with a tournament running in your server.")
 65 | 
 66 |         if tourney_id in (p.tourney_id for p in await self.tourney.media_partners.all()):
 67 |             return await self.error_embed(f"The tourney you entered is already partnered with {tourney}.")
 68 | 
 69 |         if not guild.chunked:
 70 |             self.bot.loop.create_task(guild.chunk())
 71 | 
 72 |         if not await self.bot.get_or_fetch_member(guild, self.ctx.author.id):
 73 |             return await self.error_embed(
 74 |                 "You are not even in the server you are trying to media partner with.\n\n"
 75 |                 "Kindly join the server first or gimme right ID."
 76 |             )
 77 | 
 78 |         m = await self.ask_embed(
 79 |             "Which channel do you want to use for Media-Partner?\n\n" "`Mention the channel or enter its ID.`"
 80 |         )
 81 |         channel = await channel_input(self.ctx, self.check, delete_after=True)
 82 | 
 83 |         await self.ctx.safe_delete(m)
 84 | 
 85 |         channel_check = await MediaPartner.get(channel_id=channel.id).exists()
 86 |         if channel_check:
 87 |             return await self.error_embed(f"{channel.mention} is already a media partner channel")
 88 | 
 89 |         tourney_check = await MediaPartner.get(tourney_id=tourney_id).exists()
 90 |         if tourney_check:
 91 |             return await self.error_embed(f"{str(tourney)} is already media-partnered in other channel.")
 92 | 
 93 |         partner = await MediaPartner.create(tourney_id=tourney.id, channel_id=channel.id)
 94 |         await self.tourney.media_partners.add(partner)
 95 |         self.bot.cache.media_partner_channels.add(channel.id)
 96 |         await self.__refresh_embed()
 97 | 
 98 |     @discord.ui.button(style=discord.ButtonStyle.red, label="Remove")
 99 |     async def remove_partner(self, interaction: discord.Interaction, button: discord.Button):
100 |         await interaction.response.defer(ephemeral=True)
101 | 
102 |         m = await self.ask_embed(
103 |             "Which channel do you want to remove from media partner?\n\n"
104 |             "`Note that this will not impact slots in anyway.`"
105 |         )
106 | 
107 |         _channel = await channel_input(self.ctx, self.check, delete_after=True)
108 |         await self.ctx.safe_delete(m)
109 | 
110 |         if not await self.tourney.media_partners.filter(pk=_channel.id).exists():
111 |             return await self.error_embed("This is not a media-partner channel of {0}".format(self.tourney))
112 | 
113 |         self.bot.cache.media_partner_channels.discard(_channel.id)
114 |         await MediaPartner.filter(pk=_channel.id).delete()
115 |         await self.ctx.success(f"Removed {_channel.mention} from Media-Partner Channels.", 4)
116 |         await self.__refresh_embed()
117 | 


--------------------------------------------------------------------------------
/cogs/esports/views/tourney/_select.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing as T
 4 | 
 5 | import discord
 6 | 
 7 | from core import QuotientView
 8 | from models import TMSlot, Tourney
 9 | from utils import emote
10 | 
11 | 
12 | class TourneySelector(discord.ui.Select):
13 |     view: QuotientView
14 | 
15 |     def __init__(self, placeholder: str, tourneys: T.List[Tourney]):
16 |         _options = []
17 |         for tourney in tourneys:
18 |             _options.append(
19 |                 discord.SelectOption(
20 |                     label=f"{getattr(tourney.registration_channel,'name','channel-deleted')} - (ID:{tourney.id})",
21 |                     emoji=emote.TextChannel,
22 |                     value=tourney.id,
23 |                 )
24 |             )
25 | 
26 |         super().__init__(placeholder=placeholder, options=_options)
27 | 
28 |     async def callback(self, interaction: discord.Interaction):
29 |         await interaction.response.defer()
30 |         self.view.custom_id = self.values[0]
31 | 
32 |         self.view.stop()
33 | 
34 | 
35 | class TourneySlotSelec(discord.ui.Select):
36 |     view: QuotientView
37 | 
38 |     def __init__(self, slots: T.List[TMSlot], placeholder: str = "Select a slot to cancel"):
39 |         _options = []
40 | 
41 |         for slot in slots:
42 |             _options.append(
43 |                 discord.SelectOption(
44 |                     emoji=emote.TextChannel,
45 |                     label=f"Slot {slot.num} - {slot.team_name}",
46 |                     description=f"#{getattr(slot.tourney.registration_channel,'name','channel-deleted')} - (ID:{slot.tourney.id})",
47 |                     value=f"{slot.id}:{slot.tourney.id}",
48 |                 )
49 |             )
50 | 
51 |         super().__init__(options=_options, placeholder=placeholder, max_values=len(_options))
52 | 
53 |     async def callback(self, interaction: discord.Interaction):
54 |         await interaction.response.defer()
55 |         self.view.stop()
56 |         self.view.custom_id = interaction.data["values"]
57 | 


--------------------------------------------------------------------------------
/cogs/esports/views/tourney/_wiz.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from string import ascii_uppercase
 4 | 
 5 | from core import Context
 6 | from models import Tourney
 7 | 
 8 | from ._base import TourneyView
 9 | from ._buttons import *
10 | 
11 | 
12 | class TourneySetupWizard(TourneyView):
13 |     record: Tourney
14 | 
15 |     def __init__(self, ctx: Context):
16 |         super().__init__(ctx)
17 | 
18 |         self.ctx = ctx
19 |         self.record = None
20 | 
21 |         self.add_item(RegChannel(ctx, "a"))
22 |         self.add_item(ConfirmChannel(ctx, "b"))
23 |         self.add_item(SetRole(ctx, "c"))
24 |         self.add_item(SetMentions(ctx, "d"))
25 |         self.add_item(SetGroupSize(ctx, "e"))
26 |         self.add_item(SetSlots(ctx, "f"))
27 |         self.add_item(SetEmojis(ctx, "g"))
28 |         self.add_item(DiscardButton(ctx))
29 |         self.add_item(SaveTourney(ctx))
30 | 
31 |     def initial_message(self):
32 |         if not self.record:
33 |             self.record = Tourney(guild_id=self.ctx.guild.id, host_id=self.ctx.author.id)
34 | 
35 |         fields = {
36 |             "Registration Channel": getattr(self.record.registration_channel, "mention", "`Not-Set`"),
37 |             "Confirm Channel": getattr(self.record.confirm_channel, "mention", "`Not-Set`"),
38 |             "Success Role": getattr(self.record.role, "mention", "`Not-Set`"),
39 |             "Required Mentions": f"`{self.record.required_mentions}`",
40 |             "Teams per Group": f"`{self.record.group_size or 'Not-Set'}`",
41 |             "Total Slots": f"`{self.record.total_slots or 'Not-Set'}`",
42 |             f"Reactions {self.bot.config.PRIME_EMOJI}": f"{self.record.check_emoji},{self.record.cross_emoji}",
43 |         }
44 | 
45 |         _e = discord.Embed(color=0x00FFB3, title="Enter details & Press Save", url=self.bot.config.SERVER_LINK)
46 | 
47 |         for idx, (name, value) in enumerate(fields.items()):
48 |             _e.add_field(
49 |                 name=f"{ri(ascii_uppercase[idx])} {name}:",
50 |                 value=value,
51 |             )
52 | 
53 |         return _e
54 | 
55 |     async def refresh_view(self):
56 |         _e = self.initial_message()
57 | 
58 |         if all(
59 |             (
60 |                 self.record.registration_channel_id,
61 |                 self.record.role_id,
62 |                 self.record.confirm_channel_id,
63 |                 self.record.total_slots,
64 |                 self.record.group_size,
65 |             )
66 |         ):
67 |             self.children[-1].disabled = False
68 | 
69 |         try:
70 |             self.message = await self.message.edit(embed=_e, view=self)
71 |         except discord.HTTPException:
72 |             await self.on_timeout()
73 | 


--------------------------------------------------------------------------------
/cogs/esports/views/tourney/groups.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from datetime import datetime
  4 | from typing import TYPE_CHECKING, List
  5 | 
  6 | from models import Guild, Tourney
  7 | 
  8 | from ...views.base import EsportsBaseView
  9 | 
 10 | if TYPE_CHECKING:
 11 |     from core import Quotient
 12 | 
 13 | import asyncio
 14 | 
 15 | import discord
 16 | from discord.ext import commands
 17 | from humanize import precisedelta
 18 | 
 19 | import config
 20 | from core import Context
 21 | from utils import QuoRole, emote, get_chunks, inputs, truncate_string
 22 | 
 23 | 
 24 | class TourneyGroupManager(EsportsBaseView):
 25 |     def __init__(self, ctx: Context, *, tourney: Tourney, size: int = 20):
 26 |         super().__init__(ctx, timeout=60, title="Tourney Group Manager")
 27 | 
 28 |         self.ctx = ctx
 29 |         self.tourney = tourney
 30 |         self.size = size
 31 |         self.bot: Quotient = ctx.bot
 32 | 
 33 |     @staticmethod
 34 |     def initial_embed(tourney: Tourney, size: int) -> discord.Embed:
 35 |         e = discord.Embed(color=0x00FFB3, title="Tourney Group Manager")
 36 |         e.description = (
 37 |             f"**[Tourney Slot Manager]({config.SERVER_LINK})** ─ {tourney}\n"
 38 |             f"**Group Size: `{size}`**\n\n"
 39 |             "• Click `Publish` to send group embeds in a channel.\n"
 40 |             "• Click `Give Roles` to provide group roles to team leaders.\n"
 41 |         )
 42 | 
 43 |         return e
 44 | 
 45 |     @discord.ui.button(custom_id="publish_groups", label="Publish Group List")
 46 |     async def publish_tourney_groups(self, interaction: discord.Interaction, button: discord.Button):
 47 |         await interaction.response.defer(ephemeral=True)
 48 | 
 49 |         m = await self.ask_embed(
 50 |             "Kindly mention the channel where you want me to send group list.\n\n"
 51 |             "`Make sure I have embed_links and manage_webhooks permission there.`"
 52 |         )
 53 | 
 54 |         _channel = await inputs.channel_input(self.ctx, self.check, delete_after=True)
 55 |         await self.ctx.maybe_delete(m)
 56 | 
 57 |         if not _channel.permissions_for(self.ctx.guild.me).manage_webhooks:
 58 |             return await self.error_embed(f"Make sure I have `manage_webhooks` permission in {_channel.mention}.")
 59 | 
 60 |         _list = []
 61 | 
 62 |         for idx, _chunk in enumerate(await self.tourney.get_groups(self.size), start=1):
 63 |             e = discord.Embed(color=self.bot.color, title=f"{self.tourney.name} Group {idx}")
 64 |             e.set_footer(text=self.ctx.guild.name, icon_url=getattr(self.ctx.guild.icon, "url", None))
 65 |             e.description = ""
 66 |             for count, _slot in enumerate(_chunk, start=1):
 67 |                 e.description += f"`{count:02}` • **{truncate_string(_slot.team_name,30)}** (<@{_slot.leader_id}>)\n"
 68 | 
 69 |             _list.append(e)
 70 | 
 71 |         _view = GroupListView(self.ctx, tourney=self.tourney, size=self.size, channel=_channel, embeds=_list)
 72 |         _view.message = await interaction.followup.send(embed=GroupListView.initial_embed(self.tourney), view=_view)
 73 | 
 74 |     @discord.ui.button(custom_id="give_group_roles", label="Give Roles")
 75 |     async def give_group_roles(self, interaction: discord.Interaction, button: discord.Button):
 76 |         await interaction.response.defer(ephemeral=True)
 77 |         if not len(self.ctx.guild.roles) < 235:
 78 |             return await self.error_embed(
 79 |                 "Your server is about to hit the max roles limit (250 roles), please delete some first."
 80 |             )
 81 | 
 82 |         if not self.ctx.guild.me.guild_permissions.manage_roles:
 83 |             return await self.error_embed(
 84 |                 "Kindly give me `manage_roles` permission and move my role above your group roles."
 85 |             )
 86 | 
 87 |         # TODO: check manager roles , total roles less than 195
 88 |         m = await self.ask_embed(
 89 |             f"Write the group number and the name of group role.\n"
 90 |             "**Format:** `Group Number, Name of Group Role`\n\n"
 91 |             "Note that you can also mention the role instead of name to give it to users, "
 92 |             "or just write its name, if there is no role of that name, Quotient "
 93 |             "will create the role and give it to group leaders.\n\n"
 94 |             "**Example:**```1, @group_role\n2, Group role\n3, @3rd_group```\n"
 95 |             "*Enter upto 15 roles at a time.*",
 96 |             image="https://cdn.discordapp.com/attachments/851846932593770496/901862381473374299/unknown.png",
 97 |         )
 98 | 
 99 |         _roleinfo = await inputs.string_input(self.ctx, self.check, delete_after=True)
100 |         await self.ctx.safe_delete(m)
101 | 
102 |         if (_roleinfo := _roleinfo.strip()) == "cancel":
103 |             return
104 | 
105 |         _split = _roleinfo.split("\n")
106 | 
107 |         if len(_split) > 15:
108 |             return await self.error_embed(f"Group Roles can be given to upto 15 groups at a time.")
109 | 
110 |         for _group in _split:
111 |             try:
112 |                 group, role = _group.strip().strip(",").split(",")
113 |                 group = int(group)
114 | 
115 |             except ValueError:
116 |                 return await self.error_embed(
117 |                     f"Invalid format given in `line {_split.index(_group) + 1}`.```{_roleinfo}```",
118 |                     footer="Auto-deleting this message in 10s.",
119 |                     delete_after=10,
120 |                 )
121 | 
122 |         _e = discord.Embed(
123 |             color=self.bot.color,
124 |             title="Giving Group Roles:",
125 |             description=f"{emote.check} Starting the role distribution!\n",
126 |         )
127 | 
128 |         m: discord.Message = await self.ctx.send(embed=_e)
129 | 
130 |         _t = datetime.now()
131 | 
132 |         for _group in _split:
133 |             group, role = _group.strip().strip(",").split(",")
134 |             group = int(group)
135 | 
136 |             try:
137 |                 role = await QuoRole().convert(self.ctx, role := role.strip())
138 |                 _e.description += f"{emote.check} {role.mention} Found...\n"
139 |                 await m.edit(embed=_e)
140 | 
141 |                 if not role < self.ctx.guild.me.top_role:
142 |                     _e.description += f"{emote.error} Skipping {role.mention}, because it is above my highest role ({self.ctx.guild.me.top_role.mention}).\n"
143 |                     await m.edit(embed=_e)
144 |                     continue
145 | 
146 |             except commands.RoleNotFound:
147 |                 _e.description += f"{emote.xmark} {role} Not Found, Creating new role..\n"
148 |                 role = await self.ctx.guild.create_role(name=role, reason=f"Created by {self.ctx.author} for grouping")
149 | 
150 |             _e.description += f"{emote.check} {role.mention} Assigning to team leaders of Group {group}\n"
151 |             await m.edit(embed=_e)
152 | 
153 |             actual_group = await self.tourney.get_group(group, self.size)
154 | 
155 |             try:
156 |                 counter = 0
157 |                 for _slot in actual_group:
158 |                     member = self.ctx.guild.get_member(_slot.leader_id)
159 |                     if member:
160 |                         counter += 1
161 |                         if not role in member.roles:
162 |                             self.bot.loop.create_task(
163 |                                 member.add_roles(role, reason=f"Given by {self.ctx.author} for tourney grouping")
164 |                             )
165 | 
166 |                 _e.description += f"{emote.check} {counter} people are given {role.mention}\n"
167 |                 await m.edit(embed=_e)
168 |                 counter = 0
169 | 
170 |             except TypeError:
171 |                 _e.description += f"{emote.xmark} Group {group} is empty.\n"
172 |                 await m.edit(embed=_e)
173 |                 continue
174 | 
175 |             await asyncio.sleep(0.6)
176 | 
177 |         _e.description += f"{emote.check} Done! (Time taken: `{precisedelta(datetime.now()-_t)}`)\n"
178 |         await m.edit(embed=_e)
179 |         await self.ctx.safe_delete(m, 10)
180 | 
181 | 
182 | class GroupListView(EsportsBaseView):
183 |     def __init__(
184 |         self,
185 |         ctx: Context,
186 |         *,
187 |         tourney: Tourney,
188 |         size: int,
189 |         channel: discord.TextChannel,
190 |         embeds: List[discord.Embed],
191 |     ):
192 |         super().__init__(ctx, timeout=30, title="Group List Publisher")
193 | 
194 |         self.ctx = ctx
195 |         self.bot: Quotient = ctx.bot
196 |         self.tourney = tourney
197 |         self.size = size
198 |         self.channel = channel
199 |         self.embeds = embeds
200 | 
201 |     @staticmethod
202 |     def initial_embed(tourney: Tourney) -> discord.Embed:
203 |         _e = discord.Embed(
204 |             color=0x00FFB3,
205 |             description=(
206 |                 f"**How would you like to publish the group list of {tourney}?**\n\n"
207 |                 "• `Webhook` will create a webhook in the channel and will send group embeds with your server's logo and name.\n"
208 |                 "• `Bot Option` will just make Quotient send the embeds.\n\n"
209 |                 "*Webhook Option is more cool.*"
210 |             ),
211 |         )
212 | 
213 |         return _e
214 | 
215 |     @discord.ui.button(custom_id="publish_g_hook", emoji="<a:diamond:899295009289949235>", label="Webhook (Recommended)")
216 |     async def publish_groups_webhook(self, interaction: discord.Interaction, button: discord.Button):
217 |         await interaction.response.defer(ephemeral=True)
218 | 
219 |         if not await self.ctx.is_premium_guild():
220 |             from cogs.premium.views import PremiumView
221 | 
222 |             _view = PremiumView()
223 |             return await interaction.followup.send(embed=_view.premium_embed, view=_view)
224 | 
225 |         try:
226 |             _webhook = await self.channel.create_webhook(
227 |                 name="Quotient Group List", reason=f"Created by {self.ctx.author} to send group list"
228 |             )
229 |         except Exception as e:
230 |             return await self.error_embed(e)
231 | 
232 |         m = await self.ctx.simple(f"Publishing, please wait {emote.loading}")
233 |         for _chunk in get_chunks(self.embeds, 2):
234 |             await _webhook.send(
235 |                 embeds=_chunk,
236 |                 username=self.ctx.guild.name,
237 |                 avatar_url=getattr(self.ctx.guild.icon, "url", None),
238 |             )
239 | 
240 |         await _webhook.delete()
241 |         await self.ctx.safe_delete(m)
242 |         await self.ctx.success("Group list published.", 4)
243 | 
244 |     @discord.ui.button(custom_id="publish_g_bot", emoji="<:pain:837567768106238002>", label="With Bot")
245 |     async def publish_groups_bot(self, interaction: discord.Interaction, button: discord.Button):
246 |         await interaction.response.defer(ephemeral=True)
247 | 
248 |         m = await self.ctx.simple(f"Publishing, please wait {emote.loading}")
249 |         for _chunk in get_chunks(self.embeds, 2):
250 |             await self.channel.send(embeds=_chunk)
251 | 
252 |         await self.ctx.safe_delete(m)
253 |         await self.ctx.success("Group list published.", 4)
254 | 
255 |     @discord.ui.button(custom_id="publish_g_delete", emoji=emote.trash)
256 |     async def publish_groups_delete(self, interaction: discord.Interaction, button: discord.Button):
257 |         await interaction.response.defer(ephemeral=True)
258 |         await interaction.delete_original_message()
259 | 


--------------------------------------------------------------------------------
/cogs/esports/views/tourney/main.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from typing import TYPE_CHECKING
  4 | 
  5 | from models.esports.tourney import TMSlot
  6 | 
  7 | if TYPE_CHECKING:
  8 |     from core import Quotient
  9 | 
 10 | import asyncio
 11 | import re
 12 | from contextlib import suppress
 13 | 
 14 | import discord
 15 | from discord import ButtonStyle
 16 | from tortoise.expressions import Q
 17 | 
 18 | from core import Context, QuotientView
 19 | from models import Tourney
 20 | from utils import emote, member_input, plural, truncate_string
 21 | 
 22 | from ..base import EsportsBaseView
 23 | from ..groupm import TourneyGroupManager
 24 | from ._buttons import DiscardButton
 25 | from ._editor import TourneyEditor
 26 | from ._partner import MediaPartnerView
 27 | from ._select import TourneySlotSelec
 28 | from ._wiz import TourneySetupWizard
 29 | from .slotm import TourneySlotManager
 30 | 
 31 | 
 32 | class TourneyManager(EsportsBaseView):
 33 |     def __init__(self, ctx: Context):
 34 |         super().__init__(ctx, timeout=100, name="Tourney Manager")
 35 |         self.ctx = ctx
 36 |         self.bot: Quotient = ctx.bot
 37 | 
 38 |     async def initial_embed(self) -> discord.Embed:
 39 |         to_show = [
 40 |             f"`{idx}.` {str(_r)} — Slots: `{await _r.assigned_slots.all().count()}/{_r.total_slots}`"
 41 |             for idx, _r in enumerate(await Tourney.filter(guild_id=self.ctx.guild.id).order_by("id"), start=1)
 42 |         ]
 43 | 
 44 |         _e = discord.Embed(
 45 |             color=self.bot.color, title="Quotient Smart Tournament Manager", url=self.bot.config.SERVER_LINK
 46 |         )
 47 |         _e.description = "\n".join(to_show) if to_show else "```Click Create button for new tourney.```"
 48 |         _e.set_thumbnail(url=self.ctx.guild.me.display_avatar.url)
 49 |         _e.set_footer(
 50 |             text="Quotient Prime allows unlimited tournaments.",
 51 |             icon_url=getattr(self.ctx.author.display_avatar, "url", None),
 52 |         )
 53 | 
 54 |         if not to_show:
 55 |             for _ in self.children[1:]:
 56 |                 _.disabled = True
 57 | 
 58 |         return _e
 59 | 
 60 |     @discord.ui.button(style=ButtonStyle.blurple, label="Create Tournament")
 61 |     async def create_tournament(self, interaction: discord.Interaction, button: discord.Button):
 62 |         await interaction.response.defer()
 63 |         if not await self.ctx.is_premium_guild():
 64 |             if await Tourney.filter(guild_id=self.ctx.guild.id).count() >= 1:
 65 |                 return await self.ctx.error(
 66 |                     f"You need [Quotient Premium](https://quotientbot.xyz/premium) to create more than one tournament.\n"
 67 |                     "\nBuy Prime for just ₹29 here: https://quotientbot.xyz/premium",
 68 |                     7,
 69 |                 )
 70 | 
 71 |         self.stop()
 72 |         _v = TourneySetupWizard(self.ctx)
 73 |         _v.message = await self.message.edit(embed=_v.initial_message(), view=_v)
 74 | 
 75 |     @discord.ui.button(style=ButtonStyle.blurple, label="Edit Settings")
 76 |     async def edit_tournament(self, interaction: discord.Interaction, button: discord.Button):
 77 |         await interaction.response.defer()
 78 |         self.stop()
 79 |         records = await Tourney.filter(guild_id=self.ctx.guild.id).order_by("id")
 80 | 
 81 |         _v = TourneyEditor(self.ctx, records)
 82 |         await _v._add_buttons(self.ctx)
 83 | 
 84 |         _v.message = await self.message.edit(embed=await _v.initial_message(), view=_v)
 85 | 
 86 |     @discord.ui.button(style=discord.ButtonStyle.green, label="Start/Pause Reg")
 87 |     async def start_or_pause(self, interaction: discord.Interaction, button: discord.Button):
 88 |         await interaction.response.defer()
 89 | 
 90 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to start/pause")
 91 |         if tourney:
 92 |             p = await self.ctx.prompt(
 93 |                 f"Are you sure you want to {'pause' if tourney.started_at else 'start'} the registrations of {tourney}?"
 94 |             )
 95 |             if not p:
 96 |                 return await self.ctx.error("Ok, Aborting", 4)
 97 | 
 98 |             b, r = await tourney.toggle_registrations()
 99 |             if not b:
100 |                 return await self.ctx.error(r, 4)
101 | 
102 |             return await self.ctx.success(f"Done! Check {tourney.registration_channel.mention}", 4)
103 | 
104 |     @discord.ui.button(style=ButtonStyle.red, label="Ban/Unban")
105 |     async def ban_or_unban(self, interaction: discord.Interaction, btn: discord.Button):
106 |         await interaction.response.defer()
107 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to ban/unban users.")
108 |         if tourney:
109 |             m = await self.ctx.simple("Mention the users you want to ban or unban.")
110 | 
111 |             msg = None
112 |             with suppress(asyncio.TimeoutError):
113 |                 msg: discord.Message = await self.ctx.bot.wait_for(
114 |                     "message", check=lambda m: m.author == self.ctx.author and m.channel == self.ctx.channel, timeout=60
115 |                 )
116 | 
117 |             await m.delete()
118 | 
119 |             if not msg or not msg.mentions:
120 |                 return await self.ctx.error("You need to mention at least one user.", 4)
121 | 
122 |             await msg.delete()
123 |             banned, unbanned = [], []
124 |             for m in msg.mentions:
125 |                 if m.id in tourney.banned_users:
126 |                     await tourney.unban_user(m)
127 |                     unbanned.append(m.mention)
128 | 
129 |                 else:
130 |                     await tourney.ban_user(m)
131 |                     banned.append(m.mention)
132 | 
133 |         await self.ctx.simple(
134 |             f"{emote.check} | Banned: {', '.join(banned) if banned else 'None'}\n"
135 |             f"{emote.check} | Unbanned: {', '.join(unbanned) if unbanned else 'None'}",
136 |             10,
137 |         )
138 | 
139 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="tourney_groups_send", label="Manage Groups")
140 |     async def send_tourney_group(self, interaction: discord.Interaction, button: discord.Button):
141 |         await interaction.response.defer()
142 | 
143 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to manage groups.")
144 |         if tourney:
145 |             self.stop()
146 |             _v = TourneyGroupManager(self.ctx, tourney, timeout=100)
147 |             _v.add_item(DiscardButton(self.ctx))
148 |             _v.message = await self.message.edit(embed=_v.initial_embed, view=_v)
149 | 
150 |     @discord.ui.button(style=discord.ButtonStyle.red, label="Cancel Slots")
151 |     async def remove_user_slots(self, interaction: discord.Interaction, button: discord.Button):
152 |         await interaction.response.defer()
153 | 
154 |         m = await self.ctx.simple("Mention the user whose slot you want to remove.")
155 |         member = await member_input(self.ctx, delete_after=True)
156 |         await m.delete()
157 | 
158 |         if not member:
159 |             return await self.ctx.error("You need to mention a user.", 4)
160 | 
161 |         _slots = []
162 |         async for tourney in Tourney.filter(guild_id=self.ctx.guild.id).order_by("id"):
163 |             async for slot in tourney.assigned_slots.filter(
164 |                 Q(Q(leader_id=member.id), Q(members__contains=member.id), join_type="OR")
165 |             ).order_by("num"):
166 |                 setattr(slot, "tourney", tourney)
167 |                 _slots.append(slot)
168 | 
169 |         if not _slots:
170 |             return await self.ctx.error(f"{member.mention} don't have any slot in any tourney of this server.", 4)
171 | 
172 |         _v = QuotientView(self.ctx)
173 |         _v.add_item(TourneySlotSelec(_slots))
174 |         _v.message = await interaction.followup.send("select the slots you want to cancel", view=_v, ephemeral=True)
175 | 
176 |         await _v.wait()
177 | 
178 |         if _v.custom_id:
179 |             p = await self.ctx.prompt(
180 |                 f"{plural(_v.custom_id):slot|slots} of {member.mention} will be permanently removed.",
181 |                 title="Are you sure you want to continue?",
182 |             )
183 |             if not p:
184 |                 return await self.ctx.success("Ok, Aborting", 4)
185 | 
186 |             c = 0
187 |             for _ in _v.custom_id:
188 |                 slot_id, tourney_id = _.split(":")
189 |                 tourney = await Tourney.get_or_none(id=tourney_id)
190 |                 slot = await TMSlot.get_or_none(id=slot_id)
191 | 
192 |                 if not tourney or not slot:
193 |                     continue
194 | 
195 |                 await tourney.remove_slot(slot)
196 |                 c += 1
197 | 
198 |             return await self.ctx.success(f"Done! {c} slot(s) of {member.mention} removed.", 6)
199 | 
200 |     @discord.ui.button(style=discord.ButtonStyle.green, label="Manually Add Slot")
201 |     async def reserve_user_slot(self, interaction: discord.Interaction, button: discord.Button):
202 |         await interaction.response.defer()
203 |         m = await self.ctx.simple("Mention the team leader and Enter the team name.")
204 | 
205 |         try:
206 |             msg: discord.Message = await self.bot.wait_for(
207 |                 "message", check=lambda x: x.author == self.ctx.author and x.channel == interaction.channel, timeout=100
208 |             )
209 | 
210 |         except asyncio.TimeoutError:
211 |             await self.ctx.safe_delete(m)
212 |             return await self.ctx.error("You didn't reply in time.", 3)
213 | 
214 |         await self.ctx.safe_delete(m)
215 |         await self.ctx.safe_delete(msg)
216 | 
217 |         if not msg.mentions:
218 |             return await self.ctx.error("You need to mention team leader.", 4)
219 | 
220 |         leader = msg.mentions[0]
221 | 
222 |         team_name = truncate_string(re.sub(r"<@*!*&*\d+>", "", msg.content), 22)
223 |         if not team_name:
224 |             return await self.ctx.error("You need to enter a team name.", 4)
225 | 
226 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to add slot.")
227 |         if tourney:
228 |             last_slot = await tourney.assigned_slots.order_by("-num").first()
229 |             slot = TMSlot(leader_id=leader.id, team_name=team_name, num=last_slot.num + 1 if last_slot else 1)
230 | 
231 |             _e = discord.Embed(color=0x00FFB3)
232 |             _e.description = f"**{slot.num}) NAME: {slot.team_name.upper()}**\n"
233 | 
234 |             _e.set_footer(
235 |                 text="Added by: {}".format(self.ctx.author),
236 |                 icon_url=getattr(self.ctx.author.display_avatar, "url", None),
237 |             )
238 | 
239 |             m = await tourney.confirm_channel.send(leader.mention, embed=_e)
240 |             slot.confirm_jump_url = m.jump_url
241 | 
242 |             await slot.save()
243 |             await tourney.assigned_slots.add(slot)
244 | 
245 |             await leader.add_roles(tourney.role)
246 | 
247 |             await self.ctx.success(f"Added slot successfully, [Click Here]({m.jump_url}) ", 4)
248 | 
249 |             if tourney.total_slots <= await tourney.assigned_slots.all().count():
250 |                 await tourney.end_process()
251 | 
252 |     @discord.ui.button(style=discord.ButtonStyle.blurple, label="Slot-Manager channel")
253 |     async def tourney_slotmanager(self, interaction: discord.Interaction, button: discord.Button):
254 |         await interaction.response.defer()
255 | 
256 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to add cancel-claim...")
257 |         if tourney:
258 |             if _channel := tourney.slotm_channel:
259 |                 await tourney.refresh_slotlm()
260 |                 return await self.ctx.simple(f"Current slotmanager channel for {tourney} is {_channel.mention}.", 7)
261 | 
262 |         _view = TourneySlotManager(self.bot, tourney=tourney)
263 | 
264 |         _category = tourney.registration_channel.category
265 |         overwrites = {
266 |             self.ctx.guild.default_role: discord.PermissionOverwrite(
267 |                 read_messages=True, send_messages=False, read_message_history=True
268 |             ),
269 |             self.ctx.guild.me: discord.PermissionOverwrite(
270 |                 manage_channels=True, manage_permissions=True, manage_messages=True
271 |             ),
272 |         }
273 |         slotm_channel = await _category.create_text_channel(name="tourney-slotmanager", overwrites=overwrites)
274 | 
275 |         _e = TourneySlotManager.initial_embed(tourney)
276 |         slotm_message = await slotm_channel.send(embed=_e, view=_view)
277 | 
278 |         await Tourney.get(pk=tourney.id).update(slotm_channel_id=slotm_channel.id, slotm_message_id=slotm_message.id)
279 |         await self.ctx.success(f"Slotmanager channel for {tourney} created successfully. ({slotm_channel.mention})", 7)
280 | 
281 |     @discord.ui.button(style=discord.ButtonStyle.green, label="Media-Partner")
282 |     async def manage_media_partner(self, interaction: discord.Interaction, button: discord.ui.Button):
283 |         await interaction.response.defer()
284 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to set media-partner..")
285 |         if tourney:
286 |             view = MediaPartnerView(self.ctx, tourney=tourney)
287 |             view.add_item(DiscardButton(self.ctx))
288 |             self.stop()
289 |             view.message = await self.message.edit(embed=await view.initial_embed(), view=view)
290 | 
291 |     @discord.ui.button(style=discord.ButtonStyle.blurple, label="MS Excel File")
292 |     async def download_excel_data(self, interaction: discord.Interaction, button: discord.Button):
293 |         await interaction.response.defer()
294 |         # if not await self.ctx.is_premium_guild():
295 |         #     return await self.ctx.error(
296 |         #         "You need Quotient Premium to download Ms Excel file containing all the "
297 |         #         f"registration data of your tourneys.\n\n"
298 |         #         "Buy Premium for just ₹29 here: https://quotientbot.xyz/premium",
299 |         #         6,
300 |         #     )
301 | 
302 |         tourney = await Tourney.prompt_selector(self.ctx, placeholder="Select a tournament to download data...")
303 |         if tourney:
304 |             _m = await self.ctx.simple(f"Crunching the data for you.... {emote.loading}")
305 |             await asyncio.sleep(1)
306 | 
307 |             _log_chan = await self.bot.getch(self.bot.get_channel, self.bot.fetch_channel, 899185364500099083)
308 |             m: discord.Message = await _log_chan.send(file=await tourney.get_csv())
309 | 
310 |             e = discord.Embed(
311 |                 color=self.bot.color,
312 |                 description=(
313 |                     f"**[Click Here]({m.attachments[0].url})** to download `.csv` file "
314 |                     f"containing all the registration records of {tourney}\n\n"
315 |                     "*`To Open`: Use Microsoft Excel, Libre Office or any other softwares that is compatible with .csv files.*"
316 |                 ),
317 |             )
318 | 
319 |             with suppress(discord.HTTPException):
320 |                 await _m.edit(embed=e, delete_after=10)
321 | 


--------------------------------------------------------------------------------
/cogs/esports/views/tourney/slotm.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from contextlib import suppress
  4 | from typing import TYPE_CHECKING, Any, List
  5 | 
  6 | from models import TMSlot, Tourney
  7 | from utils import BaseSelector, Prompt, emote, truncate_string
  8 | 
  9 | if TYPE_CHECKING:
 10 |     from core import Quotient
 11 | 
 12 | import asyncio
 13 | 
 14 | import discord
 15 | from tortoise.expressions import Q
 16 | 
 17 | import config
 18 | 
 19 | from ...helpers import update_confirmed_message
 20 | 
 21 | 
 22 | class TCancelSlotSelector(discord.ui.Select):
 23 |     def __init__(self, bot: Quotient, slots: List[TMSlot], placeholder: str = "Select a slot to cancel"):
 24 |         _options = []
 25 |         for slot in slots:
 26 |             slot.members.append(slot.leader_id)
 27 | 
 28 |             description = f"Team: {', '.join((str(m) for m in map(bot.get_user, set(slot.members))))}"
 29 |             _options.append(
 30 |                 discord.SelectOption(
 31 |                     label=f"Number {slot.num} ─ {slot.team_name.title()}",
 32 |                     description=truncate_string(description, 100),
 33 |                     value=slot.id,
 34 |                     emoji="<:text:815827264679706624>",
 35 |                 )
 36 |             )
 37 | 
 38 |         super().__init__(placeholder=placeholder, options=_options)
 39 | 
 40 |     async def callback(self, interaction: discord.Interaction):
 41 |         await interaction.response.defer()
 42 |         self.view.stop()
 43 |         self.view.custom_id = interaction.data["values"][0]
 44 | 
 45 | 
 46 | class TourneySlotManager(discord.ui.View):
 47 |     def __init__(self, bot: Quotient, *, tourney: Tourney):
 48 |         self.tourney = tourney
 49 |         self.bot = bot
 50 |         self.title = "Tourney Slot Manager"
 51 |         super().__init__(timeout=None)
 52 | 
 53 |     def red_embed(self, description: str) -> discord.Embed:
 54 |         return discord.Embed(color=discord.Color.red(), title=self.title, description=description)
 55 | 
 56 |     async def update_channel_for(self, channel: discord.TextChannel, user, allow=True):
 57 |         if allow:
 58 |             return await channel.set_permissions(user, send_messages=True)
 59 | 
 60 |         return await channel.set_permissions(user, overwrite=None)
 61 | 
 62 |     async def on_error(self, interaction: discord.Interaction, error: Exception, item: discord.ui.Item[Any]) -> None:
 63 |         if isinstance(error, discord.NotFound):
 64 |             return
 65 |         print("Tourney Slotm Error:", error)
 66 | 
 67 |     @staticmethod
 68 |     def initial_embed(tourney: Tourney) -> discord.Embed:
 69 |         embed = discord.Embed(
 70 |             color=config.COLOR,
 71 |             description=(
 72 |                 f"**[Tourney Slot Manager]({config.SERVER_LINK})** ─ {tourney}\n\n"
 73 |                 "• Click `Cancel My Slot` below to cancel your slot.\n"
 74 |                 "• Click `My Slots` to get info about all your slots.\n"
 75 |                 "• Click `Change Team Name` if you want to update your team's name.\n\n"
 76 |                 "*Note that slot cancel is irreversible.*"
 77 |             ),
 78 |         )
 79 |         return embed
 80 | 
 81 |     @discord.ui.button(style=discord.ButtonStyle.danger, custom_id="tourney-cancel-slot", label="Cancel My Slot")
 82 |     async def cancel_slot(self, interaction: discord.Interaction, button: discord.ui.Button):
 83 |         await interaction.response.defer(ephemeral=True)
 84 | 
 85 |         _slots = await self.tourney.assigned_slots.filter(
 86 |             Q(leader_id=interaction.user.id) | Q(members__contains=interaction.user.id)
 87 |         ).order_by("num")
 88 | 
 89 |         if not _slots:
 90 |             return await interaction.followup.send(
 91 |                 embed=self.red_embed(f"You don't have any slot, because you haven't registered in {self.tourney} yet."),
 92 |                 ephemeral=True,
 93 |             )
 94 | 
 95 |         cancel_view = BaseSelector(interaction.user.id, TCancelSlotSelector, bot=self.bot, slots=_slots)
 96 |         await interaction.followup.send("Kindly choose one of the following slots", view=cancel_view, ephemeral=True)
 97 | 
 98 |         await cancel_view.wait()
 99 | 
100 |         if _id := cancel_view.custom_id:
101 |             prompt = Prompt(interaction.user.id)
102 |             await interaction.followup.send("Are you sure you want to cancel your slot?", view=prompt, ephemeral=True)
103 |             await prompt.wait()
104 | 
105 |             if not prompt.value:
106 |                 return await interaction.followup.send("Alright, Aborting.", ephemeral=True)
107 | 
108 |             slot = await TMSlot.get_or_none(pk=_id)
109 |             if not slot:
110 |                 return await interaction.followup.send(embed=self.red_embed("Slot is already deleted."), ephemeral=True)
111 | 
112 |             if slot.confirm_jump_url:
113 |                 self.bot.loop.create_task(update_confirmed_message(self.tourney, slot.confirm_jump_url))
114 | 
115 |             if len(_slots) == 1:
116 |                 member = interaction.guild.get_member(slot.leader_id)
117 |                 if member:
118 |                     self.bot.loop.create_task(member.remove_roles(self.tourney.role))
119 | 
120 |             await TMSlot.filter(pk=slot.id).delete()
121 |             return await interaction.followup.send(f"{emote.check} | Your slot was removed.", ephemeral=True)
122 | 
123 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="tourney-slot-info", label="My Groups")
124 |     async def _slots_info(self, interaction: discord.Interaction, button: discord.ui.Button):
125 |         await interaction.response.defer(ephemeral=True)
126 | 
127 |         _slots = await self.tourney.assigned_slots.filter(
128 |             Q(leader_id=interaction.user.id) | Q(members__contains=interaction.user.id)
129 |         ).order_by("num")
130 | 
131 |         if not _slots:
132 |             return await interaction.followup.send(
133 |                 embed=self.red_embed(f"You don't have any slot, because you haven't registered in {self.tourney} yet."),
134 |                 ephemeral=True,
135 |             )
136 | 
137 |         embed = discord.Embed(color=config.COLOR)
138 |         embed.description = f"Your have the following slots in {self.tourney}:\n\n"
139 | 
140 |         for idx, slot in enumerate(_slots, start=1):
141 |             embed.description += (
142 |                 f"`{idx}.` **{slot.team_name.title()}** (**[Slot {slot.num}]({slot.confirm_jump_url})**)\n"
143 |             )
144 | 
145 |         return await interaction.followup.send(embed=embed, ephemeral=True)
146 | 
147 |     @discord.ui.button(style=discord.ButtonStyle.blurple, custom_id="tourney-slot_name", label="Change Team Name")
148 |     async def _change_slot_name(self, interaction: discord.Interaction, button: discord.ui.Button):
149 |         await interaction.response.defer(ephemeral=True)
150 | 
151 |         _slots = await self.tourney.assigned_slots.filter(
152 |             Q(leader_id=interaction.user.id) | Q(members__contains=interaction.user.id)
153 |         ).order_by("num")
154 | 
155 |         if not _slots:
156 |             return await interaction.followup.send(
157 |                 embed=self.red_embed(f"You don't have any slot, because you haven't registered in {self.tourney} yet."),
158 |                 ephemeral=True,
159 |             )
160 | 
161 |         cancel_view = BaseSelector(
162 |             interaction.user.id,
163 |             TCancelSlotSelector,
164 |             bot=self.bot,
165 |             slots=_slots,
166 |             placeholder="Select a slot to change Name",
167 |         )
168 |         await interaction.followup.send("Kindly choose one of the following slots", view=cancel_view, ephemeral=True)
169 | 
170 |         await cancel_view.wait()
171 | 
172 |         if _id := cancel_view.custom_id:
173 |             await interaction.followup.send("Enter the new name for your team.", ephemeral=True)
174 | 
175 |             await self.update_channel_for(interaction.channel, interaction.user)
176 | 
177 |             try:
178 |                 team_name: discord.Message = await self.bot.wait_for(
179 |                     "message",
180 |                     check=lambda msg: msg.author.id == interaction.user.id and msg.channel.id == interaction.channel.id,
181 |                     timeout=30,
182 |                 )
183 |             except asyncio.TimeoutError:
184 |                 await self.update_channel_for(interaction.channel, interaction.user, False)
185 |                 return await interaction.followup.send("Timed out. Please try again later.", ephemeral=True)
186 | 
187 |             with suppress(discord.HTTPException):
188 |                 await self.update_channel_for(interaction.channel, interaction.user, False)
189 | 
190 |                 await team_name.delete()
191 | 
192 |                 await TMSlot.filter(pk=_id).update(team_name=truncate_string(team_name.content, 30))
193 |                 return await interaction.followup.send(f"{emote.check} | Your team name was changed.", ephemeral=True)
194 | 
195 |     @discord.ui.button(emoji="<:swap:954022423542509598>", label="Swap Groups", custom_id="tourney-swap-groups")
196 |     async def tourney_group_swap(self, inter: discord.Interaction, button: discord.Button):
197 |         await inter.response.defer()
198 | 
199 |         if not inter.user.guild_permissions.manage_guild and not Tourney.is_ignorable(inter.user):
200 |             return await inter.followup.send(
201 |                 "You need either `@tourney-mod` role or `manage-server` permissions to swap groups.", ephemeral=True
202 |             )
203 | 
204 |         m = await inter.followup.send("Mention first user.", ephemeral=True)
205 |         try:
206 |             first_msg: discord.Message = await self.bot.wait_for(
207 |                 "message", check=lambda msg: msg.author.id == inter.user.id, timeout=30
208 |             )
209 |             await first_msg.delete()
210 | 
211 |         except asyncio.TimeoutError:
212 |             return await m.edit(content="Timed out. Please try again later.")
213 | 
214 |         if not first_msg.mentions:
215 |             await m.edit(content="You didn't mention first user.")
216 | 
217 |         first_user: discord.User = first_msg.mentions[0]
218 | 
219 |         _slots = await self.tourney.assigned_slots.filter(
220 |             Q(leader_id=first_user.id) | Q(members__contains=first_user.id)
221 |         ).order_by("num")
222 | 
223 |         if not _slots:
224 |             return await inter.followup.send(
225 |                 f"{first_user.mention} don't have any slot in {self.tourney}.", ephemeral=True
226 |             )
227 | 
228 |         first_slot = None
229 |         if len(_slots) == 1:
230 |             first_slot = _slots[0]
231 | 
232 |         else:
233 |             cancel_view = BaseSelector(
234 |                 inter.user.id,
235 |                 TCancelSlotSelector,
236 |                 bot=self.bot,
237 |                 slots=_slots,
238 |                 placeholder=f"Select a slot of {str(first_user)}",
239 |             )
240 | 
241 |             await inter.followup.send(
242 |                 f"{first_user.mention} has the following slots in {self.tourney}:", view=cancel_view, ephemeral=True
243 |             )
244 |             await cancel_view.wait()
245 | 
246 |             if cancel_view.custom_id:
247 |                 first_slot = await TMSlot.get(pk=cancel_view.custom_id)
248 | 
249 |         if not first_slot:
250 |             return
251 | 
252 |         m = await inter.followup.send("Mention second user.", ephemeral=True)
253 |         try:
254 |             second_msg: discord.Message = await self.bot.wait_for(
255 |                 "message", check=lambda msg: msg.author.id == inter.user.id, timeout=30
256 |             )
257 |             await second_msg.delete()
258 | 
259 |         except asyncio.TimeoutError:
260 |             return await m.edit(content="Timed out. Please try again later.")
261 | 
262 |         if not second_msg.mentions:
263 |             await m.edit(content="You didn't mention second user.")
264 | 
265 |         second_user: discord.User = second_msg.mentions[0]
266 |         if second_user == first_user:
267 |             return await inter.followup.send("You can't mention the same user twice.")
268 | 
269 |         _slots = await self.tourney.assigned_slots.filter(
270 |             Q(leader_id=second_user.id) | Q(members__contains=second_user.id)
271 |         ).order_by("num")
272 | 
273 |         if not _slots:
274 |             return await inter.followup.send(
275 |                 f"{second_user.mention} don't have any slot in {self.tourney}.", ephemeral=True
276 |             )
277 | 
278 |         second_slot = None
279 |         if len(_slots) == 1:
280 |             second_slot = _slots[0]
281 | 
282 |         else:
283 |             cancel_view = BaseSelector(
284 |                 inter.user.id,
285 |                 TCancelSlotSelector,
286 |                 bot=self.bot,
287 |                 slots=_slots,
288 |                 placeholder=f"Select a slot of {str(second_user)}",
289 |             )
290 | 
291 |             await inter.followup.send(
292 |                 f"{second_user.mention} has the following slots in {self.tourney}:", view=cancel_view, ephemeral=True
293 |             )
294 |             await cancel_view.wait()
295 | 
296 |             if cancel_view.custom_id:
297 |                 second_slot = await TMSlot.get(pk=cancel_view.custom_id)
298 | 
299 |         if not second_slot:
300 |             return
301 | 
302 |         await TMSlot.get(pk=first_slot.id).update(num=second_slot.num)
303 |         await TMSlot.get(pk=second_slot.id).update(num=first_slot.num)
304 | 
305 |         await inter.followup.send(
306 |             f"{emote.check} | Groups were swapped. Press 'Refresh' button under grouplist.", ephemeral=True
307 |         )
308 | 


--------------------------------------------------------------------------------
/cogs/events/__init__.py:
--------------------------------------------------------------------------------
 1 | from .cmds import CmdEvents
 2 | from .errors import Errors
 3 | from .interaction import InteractionErrors
 4 | from .logs import LogEvents
 5 | from .main import MainEvents
 6 | from .tasks import QuoTasks
 7 | from .votes import VotesCog
 8 | 
 9 | 
10 | async def setup(bot):
11 |     await bot.add_cog(MainEvents(bot))
12 |     await bot.add_cog(QuoTasks(bot))
13 |     await bot.add_cog(CmdEvents(bot))
14 |     await bot.add_cog(VotesCog(bot))
15 |     await bot.add_cog(Errors(bot))
16 |     await bot.add_cog(InteractionErrors(bot))
17 |     await bot.add_cog(LogEvents(bot))
18 | 


--------------------------------------------------------------------------------
/cogs/events/cmds.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | 
  5 | if typing.TYPE_CHECKING:
  6 |     from core import Quotient
  7 | 
  8 | import asyncio
  9 | from collections import defaultdict
 10 | from contextlib import suppress
 11 | from datetime import timedelta
 12 | 
 13 | import discord
 14 | 
 15 | from core import Cog, Context, cooldown
 16 | from models import ArrayRemove, Autorole, Commands
 17 | 
 18 | 
 19 | class UserCommandLimits(defaultdict):
 20 |     def __missing__(self, key):
 21 |         r = self[key] = cooldown.QuotientRatelimiter(2, 10)
 22 |         return r
 23 | 
 24 | 
 25 | class CmdEvents(Cog):
 26 |     def __init__(self, bot: Quotient):
 27 |         self.bot = bot
 28 | 
 29 |         self.command_ratelimited_users = {}
 30 |         self.command_ratelimiter = UserCommandLimits(cooldown.QuotientRatelimiter)
 31 | 
 32 |     async def bot_check(self, ctx: Context):
 33 |         author = ctx.author
 34 |         message = ctx.message
 35 | 
 36 |         if author.id in self.bot.config.DEVS:
 37 |             return True
 38 | 
 39 |         if not ctx.guild:
 40 |             return False
 41 | 
 42 |         if author.id in self.bot.cache.blocked_ids or ctx.guild.id in self.bot.cache.blocked_ids:
 43 |             return False
 44 | 
 45 |         if retry_after := self.command_ratelimiter[message.author].is_ratelimited(message.author):
 46 |             if author.id in self.command_ratelimited_users:
 47 |                 return
 48 | 
 49 |             self.command_ratelimited_users[author.id] = self.bot.current_time + timedelta(seconds=retry_after)
 50 |             self.bot.loop.create_task(self.remove_from_ratelimited_users(author.id, retry_after))
 51 | 
 52 |             await ctx.error(
 53 |                 f"You are being ratelimited for using commands too fast. \n\n**Try again after `{retry_after:.2f} seconds`**."
 54 |             )
 55 |             return False
 56 | 
 57 |         if self.bot.lockdown is True:
 58 |             t = (
 59 |                 "**Quotient is getting new features** 🥳\n"
 60 |                 "Dear user, Quotient is updating and is not accepting any commands.\n"
 61 |                 "It will back within **2 minutes**.\n"
 62 |             )
 63 | 
 64 |             if self.bot.lockdown_msg:
 65 |                 t += f"\n\n**Message from developer:**\n{self.bot.lockdown_msg} ~ deadshot#7999"
 66 | 
 67 |             await ctx.error(t)
 68 |             return False
 69 | 
 70 |         return True
 71 | 
 72 |     async def remove_from_ratelimited_users(self, user_id: int, after: int):
 73 |         await asyncio.sleep(after)
 74 |         self.command_ratelimited_users.pop(user_id, None)
 75 | 
 76 |     @Cog.listener()
 77 |     async def on_command_completion(self, ctx: Context):
 78 |         if not ctx.command or not ctx.guild:
 79 |             return
 80 | 
 81 |         cmd = ctx.command.qualified_name
 82 | 
 83 |         await Commands.create(
 84 |             guild_id=ctx.guild.id,
 85 |             channel_id=ctx.channel.id,
 86 |             user_id=ctx.author.id,
 87 |             cmd=cmd,
 88 |             prefix=ctx.prefix,
 89 |             failed=ctx.command_failed,
 90 |         )
 91 | 
 92 |     @Cog.listener(name="on_member_join")
 93 |     async def on_autorole(self, member: discord.Member):
 94 |         guild = member.guild
 95 | 
 96 |         with suppress(discord.HTTPException):
 97 |             record = await Autorole.get_or_none(guild_id=guild.id)
 98 |             if not record:
 99 |                 return
100 | 
101 |             if not member.bot and record.humans:
102 |                 for role in record.humans:
103 |                     try:
104 |                         await member.add_roles(discord.Object(id=role), reason="Quotient's autorole")
105 |                     except (discord.NotFound, discord.Forbidden):
106 |                         await Autorole.filter(guild_id=guild.id).update(humans=ArrayRemove("humans", role))
107 |                         continue
108 | 
109 |             elif member.bot and record.bots:
110 |                 for role in record.bots:
111 |                     try:
112 |                         await member.add_roles(discord.Object(id=role), reason="Quotient's autorole")
113 |                     except (discord.Forbidden, discord.NotFound):
114 |                         await Autorole.filter(guild_id=guild.id).update(bots=ArrayRemove("bots", role))
115 |                         continue
116 |             else:
117 |                 return
118 | 


--------------------------------------------------------------------------------
/cogs/events/errors.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | 
  5 | if typing.TYPE_CHECKING:
  6 |     from core import Quotient
  7 | 
  8 | import discord
  9 | from discord.ext import commands
 10 | 
 11 | from constants import random_greeting
 12 | from core import Cog, Context
 13 | from utils import exceptions
 14 | 
 15 | 
 16 | class Errors(Cog):
 17 |     def __init__(self, bot: Quotient):
 18 |         self.bot = bot
 19 | 
 20 |     @Cog.listener()
 21 |     async def on_command_error(self, ctx: Context, err):
 22 |         ignored = (
 23 |             commands.CommandNotFound,
 24 |             commands.NoPrivateMessage,
 25 |             discord.Forbidden,
 26 |             discord.NotFound,
 27 |         )
 28 | 
 29 |         if isinstance(err, ignored):
 30 |             return
 31 | 
 32 |         if isinstance(err, commands.NotOwner):
 33 |             return await ctx.send("Hmmm!😷")
 34 | 
 35 |         if not hasattr(ctx, "error"):
 36 |             ctx.error = ctx.reply
 37 | 
 38 |         if isinstance(err, exceptions.QuotientError):
 39 |             return await ctx.error(err.__str__().format(ctx=ctx), ephemeral=True)
 40 | 
 41 |         if isinstance(err, commands.MissingRequiredArgument):
 42 |             return await ctx.send(
 43 |                 f"{random_greeting()}, You missed the `{err.param.name}` argument.\n\nDo it like: `{ctx.prefix}{ctx.command.qualified_name} {ctx.command.signature}`"
 44 |             )
 45 | 
 46 |         if isinstance(err, commands.BadArgument):
 47 |             if isinstance(err, commands.MessageNotFound):
 48 |                 return await ctx.error("Try the command again, and this time with a real message.")
 49 |             if isinstance(err, commands.MemberNotFound):
 50 |                 return await ctx.error("Use the command again, and this time mention a real user.")
 51 |             if isinstance(err, commands.ChannelNotFound):
 52 |                 return await ctx.error("Use the command again, and this time mention a real channel/category.")
 53 |             if isinstance(err, commands.RoleNotFound):
 54 |                 await ctx.error("Try again and this time use a real role.")
 55 |             elif isinstance(err, commands.EmojiNotFound):
 56 |                 await ctx.error("Try again and this time use a real emoji.")
 57 |             elif isinstance(err, commands.ChannelNotReadable):
 58 |                 await ctx.error(
 59 |                     f"It looks like I do not have permissions to read the channel `{err.argument}`\n\nYou can fix it by going to channel settings and giving me permissions to view channel."
 60 |                 )
 61 |             elif isinstance(err, commands.PartialEmojiConversionFailure):
 62 |                 await ctx.error(f"The argument `{err.argument}` did not match the partial emoji format.")
 63 |             elif isinstance(err, commands.BadInviteArgument):
 64 |                 await ctx.error(f"The invite that matched that argument was not valid or is expired.")
 65 |             elif isinstance(err, commands.BadBoolArgument):
 66 |                 await ctx.error(f"The argument `{err.argument}` was not a valid True/False value.")
 67 |             elif isinstance(err, commands.BadColourArgument):
 68 |                 await ctx.error(f"The argument `{err.argument}` was not a valid colour.")
 69 | 
 70 |             else:
 71 |                 return await ctx.error(err)
 72 | 
 73 |         elif isinstance(err, commands.MissingRole):
 74 |             return await ctx.error(f"You need `{err.missing_role}` role to use this command.")
 75 | 
 76 |         elif isinstance(err, commands.MaxConcurrencyReached):
 77 |             return await ctx.error(f"This command is already running in this server. You have wait for it to finish.")
 78 | 
 79 |         elif isinstance(err, commands.CommandOnCooldown):
 80 |             if await ctx.bot.is_owner(ctx.author):
 81 |                 return await ctx.reinvoke()
 82 |             return await ctx.send(f"You are in cooldown.\n\nTry again in `{err.retry_after:.2f}` seconds.")
 83 | 
 84 |         elif isinstance(err, commands.MissingPermissions):
 85 |             permissions = ", ".join(
 86 |                 [
 87 |                     f"{permission.replace('_', ' ').replace('guild', 'server').title()}"
 88 |                     for permission in err.missing_permissions
 89 |                 ]
 90 |             )
 91 |             await ctx.error(f"You lack **`{permissions}`** permissions to run this command.")
 92 | 
 93 |         elif isinstance(err, commands.BotMissingPermissions):
 94 |             permissions = ", ".join(
 95 |                 [
 96 |                     f"{permission.replace('_', ' ').replace('guild', 'server').title()}"
 97 |                     for permission in err.missing_permissions
 98 |                 ]
 99 |             )
100 |             message = f"Unfortunately I am missing **`{permissions}`** permissions to run the command `{ctx.command}`.\nThis can be fixed by going to server settings > roles > Quotient and granting Quotient role **`{permissions}`** there."
101 |             try:
102 |                 await ctx.send(message)
103 |             except discord.Forbidden:
104 |                 try:
105 |                     await ctx.author.send(
106 |                         "Hey It looks like, I can't send messages in that channel.",
107 |                         view=ctx.get_dm_view(f"Sent from {ctx.guild.name}"),
108 |                     )
109 |                 except discord.Forbidden:
110 |                     pass
111 | 
112 |             return
113 | 
114 |         else:  # will setup logging later
115 |             raise err
116 | 


--------------------------------------------------------------------------------
/cogs/events/interaction.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing as T
 4 | 
 5 | if T.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | import discord
 9 | from discord.app_commands import AppCommandError
10 | 
11 | from core import Cog
12 | 
13 | __all__ = ("InteractionErrors",)
14 | 
15 | 
16 | class InteractionErrors(Cog):
17 |     def __init__(self, bot: Quotient):
18 |         self.bot = bot
19 |         self.bot.tree.interaction_check = self.global_interaction_check
20 |         self.bot.tree.on_error = self.on_app_command_error
21 | 
22 |     async def global_interaction_check(self, interaction: discord.Interaction) -> bool:
23 |         if not interaction.guild_id:
24 |             await interaction.response.send_message(
25 |                 embed=discord.Embed(
26 |                     color=discord.Color.red(),
27 |                     description="Application commands can not be used in Private Messages.",
28 |                 ),
29 |                 ephemeral=True,
30 |             )
31 | 
32 |             return False
33 | 
34 |         return True
35 | 
36 |     async def on_app_command_error(self, interaction: discord.Interaction, error: AppCommandError):
37 |         if isinstance(error, discord.NotFound):
38 |             return  # these unknown interactions are annoying :pain:
39 | 
40 |         # rest later
41 | 


--------------------------------------------------------------------------------
/cogs/events/logs.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | import discord
 9 | 
10 | from core import Cog
11 | 
12 | 
13 | class LogEvents(Cog):
14 |     def __init__(self, bot: Quotient) -> None:
15 |         self.bot = bot
16 |         # self.guild_log = discord.Webhook.from_url(self.bot.config.GUILD_LOGS, session=self.bot.session)
17 | 
18 |     # @Cog.listener()
19 |     # async def on_guild_join(self, guild: discord.Guild):
20 |     #     if not guild:
21 |     #         return  # we get these during the boot up
22 | 
23 |     #     await self.guild_log.send(
24 |     #         "```diff\n"
25 |     #         f"+ [Joined] {guild.name} ({guild.id})\n"
26 |     #         f"+ Owner: {guild.owner} ({guild.owner_id})\n"
27 |     #         f"+ Members: {guild.member_count}\n"
28 |     #         f"+ Created at: {guild.created_at.strftime('%d/%m/%Y, %H:%M') if guild.created_at else 'Unknown'}\n"
29 |     #         "```"
30 |     #     )
31 | 
32 |     # @Cog.listener()
33 |     # async def on_guild_remove(self, guild: discord.Guild):
34 |     #     if not guild:
35 |     #         return
36 | 
37 |     #     await self.guild_log.send(
38 |     #         "```diff\n"
39 |     #         f"- [Left] {guild.name} ({guild.id})\n"
40 |     #         f"- Owner: {guild.owner} ({guild.owner_id})\n"
41 |     #         f"- Members: {guild.member_count}\n"
42 |     #         f"- Created at: {guild.created_at.strftime('%d/%m/%Y, %H:%M')}\n"
43 |     #         f"- Joined at: {guild.me.joined_at.strftime('%d/%m/%Y, %H:%M') if guild.me.joined_at else 'Unknown'}\n"
44 |     #         "```"
45 |     #     )
46 | 


--------------------------------------------------------------------------------
/cogs/events/main.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | from collections import defaultdict
 5 | 
 6 | if typing.TYPE_CHECKING:
 7 |     from core import Quotient
 8 | 
 9 | import re
10 | from contextlib import suppress
11 | 
12 | import discord
13 | 
14 | import config
15 | from constants import random_greeting
16 | from core import Cog, Context, cooldown
17 | from models import Guild
18 | 
19 | 
20 | class MentionLimits(defaultdict):
21 |     def __missing__(self, key):
22 |         r = self[key] = cooldown.QuotientRatelimiter(2, 12)
23 |         return r
24 | 
25 | 
26 | class MainEvents(Cog, name="Main Events"):
27 |     def __init__(self, bot: Quotient) -> None:
28 |         self.bot = bot
29 |         self.mentions_limiter = MentionLimits(cooldown.QuotientRatelimiter)
30 | 
31 |     # incomplete?, I know
32 |     @Cog.listener()
33 |     async def on_guild_join(self, guild: discord.Guild) -> None:
34 |         with suppress(AttributeError):
35 |             g, b = await Guild.get_or_create(guild_id=guild.id)
36 |             self.bot.cache.guild_data[guild.id] = {
37 |                 "prefix": g.prefix,
38 |                 "color": g.embed_color or self.bot.color,
39 |                 "footer": g.embed_footer or config.FOOTER,
40 |             }
41 |             self.bot.loop.create_task(guild.chunk())
42 | 
43 |     @Cog.listener()
44 |     async def on_message(self, message: discord.Message) -> None:
45 |         if message.author.bot or message.guild is None:
46 |             return
47 | 
48 |         if re.match(f"^<@!?{self.bot.user.id}>
quot;, message.content):
49 |             if self.mentions_limiter[message.author].is_ratelimited(message.author):
50 |                 return
51 | 
52 |             ctx: Context = await self.bot.get_context(message)
53 |             self.bot.dispatch("mention", ctx)
54 | 
55 |     @Cog.listener()
56 |     async def on_mention(self, ctx: Context) -> None:
57 |         prefix: str = self.bot.cache.guild_data[ctx.guild.id].get("prefix", "q")
58 |         await ctx.send(
59 |             f"{random_greeting()} You seem lost. Are you?\n"
60 |             f"Current prefix for this server is: `{prefix}`.\n\nUse it like: `{prefix}help`"
61 |         )
62 | 


--------------------------------------------------------------------------------
/cogs/events/tasks.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from typing import TYPE_CHECKING
 4 | 
 5 | if TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from discord.ext import tasks
 9 | 
10 | import config
11 | from core import Cog
12 | 
13 | 
14 | class QuoTasks(Cog):
15 |     def __init__(self, bot: Quotient):
16 |         self.bot = bot
17 | 
18 |         self.insert_guilds.start()
19 | 
20 |     @tasks.loop(count=1)
21 |     async def insert_guilds(self):
22 |         query = "INSERT INTO guild_data (guild_id , prefix , embed_color , embed_footer) VALUES ($1 , $2 , $3, $4) ON CONFLICT DO NOTHING"
23 |         for guild in self.bot.guilds:
24 |             await self.bot.db.execute(query, guild.id, config.PREFIX, config.COLOR, config.FOOTER)
25 | 
26 |     @insert_guilds.before_loop
27 |     async def before_loops(self):
28 |         await self.bot.wait_until_ready()
29 | 


--------------------------------------------------------------------------------
/cogs/events/votes.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | import discord
 9 | from discord import Webhook
10 | 
11 | import constants
12 | from core import Cog
13 | from models import Timer, User, Votes
14 | 
15 | 
16 | class VotesCog(Cog):
17 |     def __init__(self, bot: Quotient):
18 |         self.bot = bot
19 |         self.hook = Webhook.from_url(self.bot.config.PUBLIC_LOG, session=self.bot.session)
20 | 
21 |     @Cog.listener()
22 |     async def on_member_join(self, member: discord.Member):
23 |         """we grant users voter, premium role if they join later."""
24 | 
25 |         if not member.guild or not member.guild.id == self.bot.config.SERVER_ID:
26 |             return
27 | 
28 |         if await Votes.get(user_id=member.id, is_voter=True).exists():
29 |             await member.add_roles(discord.Object(id=self.bot.config.VOTER_ROLE))
30 | 
31 |         if await User.get(pk=member.id, is_premium=True).exists():
32 |             await member.add_roles(discord.Object(id=self.bot.config.PREMIUM_ROLE))
33 | 
34 |     @Cog.listener()
35 |     async def on_vote_timer_complete(self, timer: Timer):
36 |         user_id = timer.kwargs["user_id"]
37 |         vote = await Votes.get(user_id=user_id)
38 | 
39 |         await Votes.get(pk=user_id).update(is_voter=False, notified=False)
40 | 
41 |         member = self.bot.server.get_member(user_id)
42 |         if member is not None:
43 |             await member.remove_roles(discord.Object(id=self.bot.config.VOTER_ROLE), reason="Their vote expired.")
44 | 
45 |         else:
46 |             member = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, user_id)
47 | 
48 |         if vote.reminder:
49 |             embed = discord.Embed(
50 |                 color=self.bot.color,
51 |                 description=f"{constants.random_greeting()}, You asked me to remind you to vote.",
52 |                 title="Vote Expired!",
53 |                 url="https://quotientbot.xyz/vote",
54 |             )
55 |             try:
56 |                 await member.send(embed=embed)
57 |             except discord.Forbidden:
58 |                 pass
59 | 


--------------------------------------------------------------------------------
/cogs/mod/__init__.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from typing import TYPE_CHECKING, List, Optional, Union
  4 | 
  5 | if TYPE_CHECKING:
  6 |     from core import Quotient
  7 | 
  8 | import re
  9 | 
 10 | import discord
 11 | from discord.ext import commands
 12 | 
 13 | from constants import LockType
 14 | from core import Cog, Context, QuotientView, role_command_check
 15 | from models import Lockdown
 16 | from utils import ActionReason, BannedMember, FutureTime, MemberID, QuoUser, emote, human_timedelta, plural
 17 | 
 18 | from .events import *
 19 | from .utils import _complex_cleanup_strategy, _self_clean_system, do_removal
 20 | from .views import *
 21 | 
 22 | 
 23 | class Mod(Cog):
 24 |     def __init__(self, bot: Quotient):
 25 |         self.bot = bot
 26 | 
 27 |     @commands.command()
 28 |     @commands.has_permissions(manage_guild=True)
 29 |     @commands.cooldown(5, 1, type=commands.BucketType.user)
 30 |     async def selfclean(self, ctx: Context, search=100):
 31 |         """
 32 |         Clean Quotient's messages,
 33 |         Note: If bot has `manage_messages` permissions then it will delete the command messages too.
 34 |         """
 35 |         strategy = _self_clean_system
 36 |         if ctx.channel.permissions_for(ctx.me).manage_messages:
 37 |             strategy = _complex_cleanup_strategy
 38 | 
 39 |         search = min(max(2, search), 1000)
 40 | 
 41 |         spammers = await strategy(ctx, search)
 42 |         deleted = sum(spammers.values())
 43 |         messages = [f'{deleted} message{" was" if deleted == 1 else "s were"} removed.']
 44 |         if deleted:
 45 |             messages.append("")
 46 |             spammers = sorted(spammers.items(), key=lambda t: t[1], reverse=True)
 47 |             messages.extend(f"- **{author}**: {count}" for author, count in spammers)
 48 | 
 49 |         await ctx.send("\n".join(messages), delete_after=10)
 50 | 
 51 |     @commands.group(invoke_without_command=True, aliases=["purge"])
 52 |     @commands.has_permissions(manage_messages=True)
 53 |     @commands.cooldown(7, 1, type=commands.BucketType.guild)
 54 |     async def clear(self, ctx: Context, Choice: Union[discord.Member, int], amount: int = 5):
 55 |         """
 56 |         An all in one purge command.
 57 |         Choice can be a Member or a number
 58 |         """
 59 |         if isinstance(Choice, discord.Member):
 60 |             await do_removal(ctx, amount, lambda e: e.author == Choice)
 61 | 
 62 |         elif isinstance(Choice, int):
 63 |             await do_removal(ctx, Choice, lambda e: not e.pinned)
 64 | 
 65 |         await ctx.message.delete()
 66 | 
 67 |     @clear.command()
 68 |     @commands.has_permissions(manage_messages=True)
 69 |     async def embeds(self, ctx, search=100):
 70 |         """Removes messages that have embeds in them."""
 71 |         await do_removal(ctx, search, lambda e: len(e.embeds))
 72 | 
 73 |     @clear.command()
 74 |     @commands.has_permissions(manage_messages=True)
 75 |     async def files(self, ctx, search=100):
 76 |         """Removes messages that have attachments in them."""
 77 |         await do_removal(ctx, search, lambda e: len(e.attachments))
 78 | 
 79 |     @clear.command()
 80 |     @commands.has_permissions(manage_messages=True)
 81 |     async def images(self, ctx, search=100):
 82 |         """Removes messages that have embeds or attachments."""
 83 |         await do_removal(ctx, search, lambda e: len(e.embeds) or len(e.attachments))
 84 | 
 85 |     @clear.command(name="all")
 86 |     @commands.has_permissions(manage_messages=True)
 87 |     async def _remove_all(self, ctx, search=100):
 88 |         """Removes all messages."""
 89 |         await do_removal(ctx, search, lambda e: not e.pinned)
 90 | 
 91 |     @clear.command()
 92 |     @commands.has_permissions(manage_messages=True)
 93 |     async def user(self, ctx, member: QuoUser, search=100):
 94 |         """Removes all messages by the member."""
 95 |         await do_removal(ctx, search, lambda e: e.author == member)
 96 | 
 97 |     @clear.command()
 98 |     @commands.has_permissions(manage_messages=True)
 99 |     async def contains(self, ctx, *, substr: str):
100 |         """Removes all messages containing a substring.
101 |         The substring must be at least 3 characters long.
102 |         """
103 |         if len(substr) < 3:
104 |             await ctx.error("The substring length must be at least 3 characters.")
105 |         else:
106 |             await do_removal(ctx, 100, lambda e: substr in e.content)
107 | 
108 |     @clear.command(name="bot", aliases=["bots"])
109 |     @commands.has_permissions(manage_messages=True)
110 |     async def _bot(self, ctx, prefix=None, search=100):
111 |         """Removes a bot user's messages and messages with their optional prefix."""
112 | 
113 |         def predicate(m):
114 |             return (m.webhook_id is None and m.author.bot) or (prefix and m.content.startswith(prefix))
115 | 
116 |         await do_removal(ctx, search, predicate)
117 | 
118 |     @clear.command(name="emoji", aliases=["emojis"])
119 |     @commands.has_permissions(manage_messages=True)
120 |     async def _emoji(self, ctx, search=100):
121 |         """Removes all messages containing custom emoji."""
122 |         custom_emoji = re.compile(r"<a?:[a-zA-Z0-9\_]+:([0-9]+)>")
123 | 
124 |         def predicate(m):
125 |             return custom_emoji.search(m.content)
126 | 
127 |         await do_removal(ctx, search, predicate)
128 | 
129 |     @clear.command(name="reactions")
130 |     @commands.has_permissions(manage_messages=True)
131 |     async def _reactions(self, ctx, search=100):
132 |         """Removes all reactions from messages that have them."""
133 |         if search > 2000:
134 |             return await ctx.send(f"Too many messages to search for ({search}/2000)")
135 | 
136 |         total_reactions = 0
137 |         async for message in ctx.history(limit=search, before=ctx.message):
138 |             if message.reactions:
139 |                 total_reactions += sum(r.count for r in message.reactions)
140 |                 await message.clear_reactions()
141 | 
142 |         await ctx.success(f"Successfully removed {total_reactions} reactions.")
143 | 
144 |     @commands.command()
145 |     @commands.has_permissions(kick_members=True)
146 |     @commands.bot_has_guild_permissions(kick_members=True)
147 |     @commands.cooldown(3, 1, type=commands.BucketType.user)
148 |     async def kick(self, ctx, member: MemberID, *, reason: ActionReason = None):
149 |         """Kicks a member from the server.
150 |         In order for this to work, the bot must have Kick Member permissions.
151 |         To use this command you must have Kick Members permission.
152 |         """
153 |         if reason is None:
154 |             reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
155 | 
156 |         await ctx.guild.kick(member, reason=reason)
157 |         await ctx.success(f"{str(member)} has been successfully kicked out!")
158 | 
159 |     @commands.command()
160 |     @commands.has_permissions(ban_members=True)
161 |     @commands.cooldown(3, 1, type=commands.BucketType.user)
162 |     @commands.bot_has_guild_permissions(ban_members=True)
163 |     async def ban(self, ctx, member: MemberID, *, reason: ActionReason = None):
164 |         """Bans a member from the server.
165 |         You can also ban from ID to ban regardless whether they're
166 |         in the server or not.
167 |         In order for this to work, the bot must have Ban Member permissions.
168 |         To use this command you must have Ban Members permission.
169 |         """
170 |         if reason is None:
171 |             reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
172 | 
173 |         await ctx.guild.ban(member, reason=reason)
174 |         await ctx.success(f"{str(member)} has been successfully banned!")
175 | 
176 |     @commands.command()
177 |     @commands.has_permissions(ban_members=True)
178 |     @commands.bot_has_guild_permissions(ban_members=True)
179 |     @commands.cooldown(3, 1, type=commands.BucketType.user)
180 |     async def unban(self, ctx: Context, member: BannedMember, *, reason: ActionReason = None):
181 |         """Unbans a member from the server.
182 |         You can pass either the ID of the banned member or the Name#Discrim
183 |         combination of the member. Typically the ID is easiest to use.
184 |         In order for this to work, the bot must have Ban Member permissions.
185 |         To use this command you must have Ban Members permissions.
186 |         """
187 |         if reason is None:
188 |             reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
189 | 
190 |         await ctx.guild.unban(member.user, reason=reason)
191 |         if member.reason:
192 |             await ctx.send(f"Unbanned {member.user} (ID: {member.user.id}), previously banned for {member.reason}.")
193 |         else:
194 |             await ctx.success(f"Unbanned {member.user} (ID: {member.user.id}).")
195 | 
196 |     @commands.group(
197 |         invoke_without_command=True,
198 |         aliases=["addrole", "giverole"],
199 |         extras={"examples": ["role @role @user1 @user2 @user3 ..."]},
200 |     )
201 |     @commands.has_guild_permissions(manage_roles=True)
202 |     @commands.bot_has_guild_permissions(manage_roles=True)
203 |     @commands.cooldown(4, 1, type=commands.BucketType.guild)
204 |     @role_command_check()
205 |     async def role(self, ctx: Context, role: discord.Role, members: commands.Greedy[discord.Member]):
206 |         """
207 |         Add a role to one or multiple users.
208 |         """
209 | 
210 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
211 | 
212 |         if not members:
213 |             members = ctx.guild.members
214 | 
215 |             prompt = await ctx.prompt("No members were specified, do you want to add the role to all members?")
216 |             if not prompt:
217 |                 return await ctx.simple(
218 |                     f"Alright, Aborting. If you wish to add the role to limited users, do:\n\n`{ctx.prefix}role @role @user1 @user2 @user3 ...`"
219 |                 )
220 | 
221 |         m = await ctx.simple(f"{emote.loading} Adding {role.mention} to {plural(members):member|members}.")
222 | 
223 |         for member in members:
224 |             if role not in member.roles:
225 |                 await member.add_roles(role, reason=reason)
226 | 
227 |         _view = QuotientView(ctx)
228 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members))
229 | 
230 |         await ctx.safe_delete(m)
231 |         _view.message = await ctx.success(
232 |             f"Added {role.mention} to {plural(members):member|members}.\n\n"
233 |             "```If you cannot see the role in any of the user's profile, just restart your discord app or check audit log.```",
234 |             view=_view,
235 |         )
236 | 
237 |     @role.command(name="humans", extras={"examples": ["role humans @role", "role humans role_id"]})
238 |     @commands.has_guild_permissions(manage_roles=True)
239 |     @commands.bot_has_guild_permissions(manage_roles=True)
240 |     @commands.cooldown(5, 1, type=commands.BucketType.guild)
241 |     @role_command_check()
242 |     async def role_humans(self, ctx: Context, role: discord.Role):
243 |         """Add a role to all human users."""
244 | 
245 |         members = [m for m in ctx.guild.members if all([not role in m.roles, not m.bot])]
246 | 
247 |         prompt = await ctx.prompt(
248 |             title="Are you sure you want to continue?",
249 |             message=f"{role.mention} will be added to all {plural(members):human|humans} in the server.",
250 |         )
251 | 
252 |         if not prompt:
253 |             return await ctx.success("Alright, Aborting.")
254 | 
255 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
256 |         m = await ctx.simple(f"{emote.loading} Adding {role.mention} to {plural(members):human|humans}.")
257 | 
258 |         success, failed = 0, 0
259 | 
260 |         for member in members:
261 |             try:
262 |                 await member.add_roles(role, reason=reason)
263 |                 success += 1
264 |             except discord.HTTPException:
265 |                 failed += 1
266 | 
267 |         _view = QuotientView(ctx)
268 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members))
269 | 
270 |         await ctx.safe_delete(m)
271 |         _view.message = await ctx.success(
272 |             f"Successfully added {role.mention} to {plural(success):human|humans}. (Failed: {failed})", view=_view
273 |         )
274 | 
275 |     @role.command(name="bots", extras={"examples": ["role bots @role", "role bots role_id"]})
276 |     @commands.has_guild_permissions(manage_roles=True)
277 |     @commands.bot_has_guild_permissions(manage_roles=True)
278 |     @role_command_check()
279 |     async def role_bots(self, ctx: Context, role: discord.Role):
280 |         """Add a role to all bot users."""
281 |         members = [m for m in ctx.guild.members if all([not role in m.roles, m.bot])]
282 | 
283 |         prompt = await ctx.prompt(
284 |             title="Are you sure you want to continue?",
285 |             message=f"{role.mention} will be added to all {plural(members):bot|bots} in the server.",
286 |         )
287 | 
288 |         if not prompt:
289 |             return await ctx.success("Alright, Aborting.")
290 | 
291 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
292 |         m = await ctx.simple(f"{emote.loading} Adding {role.mention} to {plural(members):bot|bots}.")
293 | 
294 |         success, failed = 0, 0
295 | 
296 |         for member in members:
297 |             try:
298 |                 await member.add_roles(role, reason=reason)
299 |                 success += 1
300 |             except discord.HTTPException:
301 |                 failed += 1
302 | 
303 |         _view = QuotientView(ctx)
304 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members))
305 | 
306 |         await ctx.safe_delete(m)
307 |         _view.message = await ctx.success(
308 |             f"Successfully added {role.mention} to {plural(success):bot|bots}. (Failed: {failed})", view=_view
309 |         )
310 | 
311 |     @role.command(name="all", extras={"examples": ["role all @role", "role all role_id"]})
312 |     @commands.has_guild_permissions(manage_roles=True)
313 |     @commands.bot_has_guild_permissions(manage_roles=True)
314 |     @role_command_check()
315 |     async def role_all(self, ctx: Context, role: discord.Role):
316 |         """Add a role to everyone on the server"""
317 | 
318 |         members = [m for m in ctx.guild.members if not role in m.roles]
319 | 
320 |         prompt = await ctx.prompt(
321 |             title="Are you sure you want to continue?",
322 |             message=f"{role.mention} will be added to all {plural(members):user|users} in the server.",
323 |         )
324 | 
325 |         if not prompt:
326 |             return await ctx.success("Alright, Aborting.")
327 | 
328 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
329 |         m = await ctx.simple(f"{emote.loading} Adding {role.mention} to {plural(members):user|users}.")
330 | 
331 |         success, failed = 0, 0
332 | 
333 |         for member in members:
334 |             try:
335 |                 await member.add_roles(role, reason=reason)
336 |                 success += 1
337 |             except discord.HTTPException:
338 |                 failed += 1
339 | 
340 |         _view = QuotientView(ctx)
341 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members))
342 | 
343 |         await ctx.safe_delete(m)
344 |         _view.message = await ctx.success(
345 |             f"Successfully added {role.mention} to {plural(success):user|users}. (Failed: {failed})", view=_view
346 |         )
347 | 
348 |     @commands.group(invoke_without_command=True, aliases=["removerole", "takerole"])
349 |     @commands.has_guild_permissions(manage_roles=True)
350 |     @commands.bot_has_guild_permissions(manage_roles=True)
351 |     @role_command_check()
352 |     async def rrole(self, ctx: Context, role: discord.Role, members: commands.Greedy[discord.Member]):
353 |         """Remove a role from one or multiple users."""
354 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
355 |         if not members:
356 |             members = [m for m in ctx.guild.members if role in m.roles]
357 | 
358 |             prompt = await ctx.prompt("No members were specified, do you want to remove the role from all members?")
359 |             if not prompt:
360 |                 return await ctx.simple(
361 |                     f"Alright, Aborting. If you wish to remove the role from limited users, do:\n\n`{ctx.prefix}rrole @role @user1 @user2 @user3 ...`"
362 |                 )
363 | 
364 |         m = await ctx.simple(f"{emote.loading} Removing {role.mention} from {plural(members):member|members}.")
365 | 
366 |         for member in members:
367 |             await member.remove_roles(role, reason=reason)
368 | 
369 |         _view = QuotientView(ctx)
370 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members, take_role=False))
371 | 
372 |         await ctx.safe_delete(m)
373 |         _view.message = await ctx.success(
374 |             f"Removed {role.mention} from {plural(members):member|members}.",
375 |             view=_view,
376 |         )
377 | 
378 |     @rrole.command(name="humans")
379 |     @commands.has_guild_permissions(manage_roles=True)
380 |     @commands.bot_has_guild_permissions(manage_roles=True)
381 |     @role_command_check()
382 |     async def rrole_humans(self, ctx: Context, role: discord.Role):
383 |         """Remove a role from all human users."""
384 | 
385 |         members = [m for m in ctx.guild.members if all([role in m.roles, not m.bot])]
386 | 
387 |         prompt = await ctx.prompt(
388 |             title="Are you sure you want to continue?",
389 |             message=f"{role.mention} will be removed from all {plural(members):human|humans} in the server.",
390 |         )
391 | 
392 |         if not prompt:
393 |             return await ctx.success("Alright, Aborting.")
394 | 
395 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
396 |         m = await ctx.simple(f"{emote.loading} Remove {role.mention} from {plural(members):human|humans}.")
397 | 
398 |         success, failed = 0, 0
399 | 
400 |         for member in members:
401 |             try:
402 |                 await member.remove_roles(role, reason=reason)
403 |                 success += 1
404 |             except discord.HTTPException:
405 |                 failed += 1
406 | 
407 |         _view = QuotientView(ctx)
408 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members, take_role=False))
409 | 
410 |         await ctx.safe_delete(m)
411 |         _view.message = await ctx.success(
412 |             f"Successfully removed {role.mention} from {plural(success):human|humans}. (Failed: {failed})", view=_view
413 |         )
414 | 
415 |     @rrole.command(name="bots")
416 |     @commands.has_guild_permissions(manage_roles=True)
417 |     @commands.bot_has_guild_permissions(manage_roles=True)
418 |     @role_command_check()
419 |     async def rrole_bots(self, ctx: Context, role: discord.Role):
420 |         """Remove a role from all the bots."""
421 |         members = [m for m in ctx.guild.members if all([role in m.roles, m.bot])]
422 | 
423 |         prompt = await ctx.prompt(
424 |             title="Are you sure you want to continue?",
425 |             message=f"{role.mention} will be removed from all {plural(members):bot|bots} in the server.",
426 |         )
427 | 
428 |         if not prompt:
429 |             return await ctx.success("Alright, Aborting.")
430 | 
431 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
432 |         m = await ctx.simple(f"{emote.loading} Remove {role.mention} from {plural(members):bot|bots}.")
433 | 
434 |         success, failed = 0, 0
435 | 
436 |         for member in members:
437 |             try:
438 |                 await member.remove_roles(role, reason=reason)
439 |                 success += 1
440 |             except discord.HTTPException:
441 |                 failed += 1
442 | 
443 |         _view = QuotientView(ctx)
444 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members, take_role=False))
445 | 
446 |         await ctx.safe_delete(m)
447 |         _view.message = await ctx.success(
448 |             f"Successfully removed {role.mention} from {plural(success):bot|bots}. (Failed: {failed})", view=_view
449 |         )
450 | 
451 |     @rrole.command(name="all")
452 |     @commands.has_guild_permissions(manage_roles=True)
453 |     @commands.bot_has_guild_permissions(manage_roles=True)
454 |     @role_command_check()
455 |     async def rrole_all(self, ctx: Context, role: discord.Role):
456 |         """Remove a role from everyone on the server."""
457 |         members = [m for m in ctx.guild.members if role in m.roles]
458 | 
459 |         prompt = await ctx.prompt(
460 |             title="Are you sure you want to continue?",
461 |             message=f"{role.mention} will be removed from all {plural(members):user|users} in the server.",
462 |         )
463 | 
464 |         if not prompt:
465 |             return await ctx.success("Alright, Aborting.")
466 | 
467 |         reason = f"Action done by {ctx.author} (ID: {ctx.author.id})"
468 |         m = await ctx.simple(f"{emote.loading} Removing {role.mention} from {plural(members):user|users}.")
469 | 
470 |         success, failed = 0, 0
471 | 
472 |         for member in members:
473 |             try:
474 |                 await member.remove_roles(role, reason=reason)
475 |                 success += 1
476 |             except discord.HTTPException:
477 |                 failed += 1
478 | 
479 |         _view = QuotientView(ctx)
480 |         _view.add_item(RoleRevertButton(ctx, role=role, members=members, take_role=False))
481 | 
482 |         await ctx.safe_delete(m)
483 |         _view.message = await ctx.success(
484 |             f"Successfully removed {role.mention} from {plural(success):user|users}. (Failed: {failed})", view=_view
485 |         )
486 | 
487 |     @commands.group(invoke_without_command=True, aliases=("lockdown",))
488 |     async def lock(self, ctx: Context, channel: Optional[discord.TextChannel], duration: Optional[FutureTime]):
489 |         """Lock a channel , category or the whole server."""
490 |         channel = channel or ctx.channel
491 |         check = await Lockdown.filter(guild_id=ctx.guild.id, channel_id=channel.id, type=LockType.channel).first()
492 | 
493 |         if check is not None:
494 |             return await ctx.error(
495 |                 f"**{channel}** is already locked.\n\nTime Remaining: {human_timedelta(check.expire_time)}"
496 |             )
497 | 
498 |         if not channel.permissions_for(ctx.me).manage_channels:
499 |             return await ctx.error(f"I need `manage_channels` permission in **{channel}**")
500 | 
501 |         if not channel.permissions_for(ctx.author).manage_channels:
502 |             return await ctx.error(f"You need `manage channels` permission in **{channel}** to use this.")
503 | 
504 |         perms = channel.overwrites_for(ctx.guild.default_role)
505 |         perms.send_messages = False
506 |         await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
507 | 
508 |         if duration is None:  # we don't want to store if duration is None.
509 |             return await ctx.success(f"Locked down **{channel.name}**")
510 | 
511 |         await Lockdown.create(
512 |             guild_id=ctx.guild.id,
513 |             type=LockType.channel,
514 |             expire_time=duration.dt,
515 |             channel_id=channel.id,
516 |             author_id=ctx.author.id,
517 |         )
518 |         timer = await self.bot.reminders.create_timer(
519 |             duration.dt, "lockdown", _type=LockType.channel.value, channel_id=channel.id
520 |         )
521 |         await ctx.success(f"Locked down **{channel}** for {human_timedelta(duration.dt,source= timer.created)}")
522 | 
523 |     @lock.command(name="server", aliases=("guild",))
524 |     @commands.bot_has_guild_permissions(manage_channels=True)
525 |     @commands.has_permissions(manage_guild=True)
526 |     async def lock_server(self, ctx, duration: Optional[FutureTime]):
527 |         check = await Lockdown.filter(guild_id=ctx.guild.id, type=LockType.guild).first()
528 |         if check is not None:
529 |             text = f"Server is already locked."
530 |             if check.expire_time:
531 |                 text += f"\n\nTime Remaining: {human_timedelta(check.expire_time)}"
532 |             return await ctx.error(text)
533 | 
534 |         channels = list(filter(lambda x: x.overwrites_for(ctx.guild.default_role).send_messages, ctx.guild.channels))
535 |         mine = sum(1 for i in filter(lambda x: x.permissions_for(ctx.me).manage_channels, (channels)))
536 |         # len list would use additional memory so : )
537 | 
538 |         if not (channels):
539 |             return await ctx.error(f"@everyone doesn't have `send_messages` enabled in any channel.")
540 | 
541 |         if not mine:
542 |             return await ctx.error(
543 |                 f"`{sum(1 for i in channels)} channels` have send messages enabled. But unfortunately I don't permission to edit any of them."
544 |             )
545 | 
546 |         prompt = await ctx.prompt(
547 |             f"`{sum(1 for i in channels)} channels` have send messages enabled for @everyone,\nI have permissions to modify `{mine} channels`.",
548 |             title="Do you want me to continue?",
549 |         )
550 |         if not prompt:
551 |             return await ctx.success(f"Alright, aborting.")
552 | 
553 |         await ctx.send(f"Kindly wait.. {emote.loading}", delete_after=3)
554 | 
555 |         success, failed = [], 0
556 |         reason = f"Action done by -> {str(ctx.author)} ({ctx.author.id})"
557 |         for channel in channels:
558 |             overwrite = channel.overwrites_for(ctx.guild.default_role)
559 |             overwrite.send_messages = False
560 | 
561 |             try:
562 |                 await channel.set_permissions(ctx.guild.default_role, overwrite=overwrite, reason=reason)
563 |                 success.append(channel.id)
564 |             except:
565 |                 failed += 1
566 |                 continue
567 | 
568 |         await Lockdown.create(
569 |             guild_id=ctx.guild.id,
570 |             type=LockType.guild,
571 |             channel_id=ctx.channel.id,
572 |             author_id=ctx.author.id,
573 |             channel_ids=success,
574 |             expire_time=duration.dt,
575 |         )
576 | 
577 |         if duration is None:
578 |             return await ctx.success(f"Locked down `{len(success)} channels` (Failed: `{failed}`)")
579 | 
580 |         timer = await self.bot.reminders.create_timer(
581 |             duration.dt, "lockdown", _type=LockType.guild.value, guild_id=ctx.guild.id
582 |         )
583 |         await ctx.success(
584 |             f"Locked down `{len(success)} channels` (Failed: `{failed}`) for {human_timedelta(duration.dt, source=timer.created)}"
585 |         )
586 | 
587 |     @commands.group(aliases=("unlockdown",), invoke_without_command=True)
588 |     async def unlock(self, ctx, *, channel: Optional[discord.TextChannel]):
589 |         channel = channel or ctx.channel
590 | 
591 |         if not channel.permissions_for(ctx.me).manage_channels:
592 |             return await ctx.error(f"I need `manage_channels` permission in **{channel}**")
593 | 
594 |         if not channel.permissions_for(ctx.author).manage_channels:
595 |             return await ctx.error(f"You need `manage channels` permission in **{channel}** to use this.")
596 | 
597 |         perms = channel.overwrites_for(ctx.guild.default_role)
598 |         perms.send_messages = True
599 |         await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
600 | 
601 |         await ctx.success(f"Unlocked **{channel}**")
602 | 
603 |         await Lockdown.filter(channel_id=channel.id, type=LockType.channel).delete()
604 | 
605 |     @unlock.command(name="server", aliases=("guild",))
606 |     @commands.has_permissions(manage_guild=True)
607 |     @commands.bot_has_guild_permissions(manage_channels=True)
608 |     async def unlock_guild(self, ctx):
609 |         check = await Lockdown.get_or_none(guild_id=ctx.guild.id, type=LockType.guild).first()
610 |         if not check:
611 |             return await ctx.error(f"The server is not locked.")
612 | 
613 |         success = 0
614 |         for channel in check.channels:
615 |             if channel is not None and channel.permissions_for(channel.guild.me).manage_channels:
616 |                 perms = channel.overwrites_for(channel.guild.default_role)
617 |                 perms.send_messages = True
618 |                 await channel.set_permissions(
619 |                     channel.guild.default_role, overwrite=perms, reason="Lockdown timer complete!"
620 |                 )
621 |                 success += 1
622 | 
623 |         await ctx.success(
624 |             f"Successfully unlocked `{success}` channels. (`{sum(1 for i in check.channels)}` were locked.)"
625 |         )
626 |         await Lockdown.filter(guild_id=ctx.guild.id, type=LockType.guild).delete()
627 | 
628 |     @commands.group(invoke_without_command=True)
629 |     async def maintenance(self, ctx: Context):
630 |         """Maintenance ON/ OFF for the server."""
631 |         await ctx.send_help(ctx.command)
632 | 
633 |     @maintenance.command(name="on")
634 |     @commands.has_permissions(administrator=True)
635 |     @commands.bot_has_guild_permissions(manage_channels=True)
636 |     async def maintenace_on(self, ctx: Context, *, role: discord.Role = None):
637 |         """
638 |         Turn ON maintenance mode.
639 |         You can turn on maintenance for a specific role too , the default role is everyone.
640 |         This will hide all the channels where `role` has `read_messages` permission enabled.
641 |         """
642 |         role = role or ctx.guild.default_role
643 |         check = await Lockdown.filter(type=LockType.maintenance, guild_id=ctx.guild.id, role_id=role.id).first()
644 |         if check:
645 |             return await ctx.error(f"The server is already under maintenance for **{role}**")
646 | 
647 |         channels = list(filter(lambda x: x.overwrites_for(role).read_messages, ctx.guild.channels))
648 |         mine = sum(1 for i in filter(lambda x: x.permissions_for(ctx.me).manage_channels, (channels)))
649 |         # len list would use additional memory so : )
650 | 
651 |         if not (channels):
652 |             return await ctx.error(f"**{role}** doesn't have `read_messages` enabled in any channel.")
653 | 
654 |         if not mine:
655 |             return await ctx.error(
656 |                 f"`{sum(1 for i in channels)} channels` have read messages enabled. But unfortunately I don't permission to edit any of them."
657 |             )
658 | 
659 |         prompt = await ctx.prompt(
660 |             f"`{sum(1 for i in channels)} channels` have read messages enabled for **{role}**,\nI have permissions to modify `{mine} channels`.",
661 |             title="Do you want me to continue?",
662 |         )
663 |         if not prompt:
664 |             return await ctx.success(f"Alright, aborting.")
665 | 
666 |         await ctx.send(f"Kindly wait.. {emote.loading}", delete_after=3)
667 | 
668 |         success, failed = [], 0
669 |         reason = f"Action done by -> {str(ctx.author)} ({ctx.author.id})"
670 |         for channel in channels:
671 |             overwrite = channel.overwrites_for(role)
672 |             overwrite.read_messages = False
673 | 
674 |             try:
675 |                 await channel.set_permissions(role, overwrite=overwrite, reason=reason)
676 |                 success.append(channel.id)
677 |             except:
678 |                 failed += 1
679 |                 continue
680 | 
681 |         await ctx.success(f"Updated settings for `{len(success)} channels`.(`{failed}` failed)")
682 |         if success:
683 |             await Lockdown.create(
684 |                 guild_id=ctx.guild.id,
685 |                 type=LockType.maintenance,
686 |                 channel_id=ctx.channel.id,
687 |                 author_id=ctx.author.id,
688 |                 role_id=role.id,
689 |                 channel_ids=success,
690 |             )
691 | 
692 |         prompt = await ctx.prompt(f"Do you want me to make maintenance channels?")
693 | 
694 |         if prompt:
695 |             overwrites = {
696 |                 role: discord.PermissionOverwrite(read_messages=True, send_messages=True, read_message_history=True),
697 |                 ctx.guild.me: discord.PermissionOverwrite(
698 |                     read_messages=True, send_messages=True, read_message_history=True
699 |                 ),
700 |             }
701 |             await ctx.guild.create_text_channel("maintenance-chat", overwrites=overwrites, reason=reason)
702 |             await ctx.guild.create_voice_channel("maintenance-vc", overwrites=overwrites, reason=reason)
703 |             await ctx.success(f"Done")
704 | 
705 |         else:
706 |             await ctx.success(f"Ok! Aborting")
707 | 
708 |     @maintenance.command(name="off")
709 |     @commands.bot_has_guild_permissions(manage_channels=True)
710 |     @commands.has_permissions(administrator=True)
711 |     async def maintenance_off(self, ctx: Context, *, role: discord.Role = None):
712 |         """
713 |         Turn OFF maintenance mode.
714 |         If you turned ON maintenance mode for a specific role , you need to mention it here too.
715 |         """
716 |         role = role or ctx.guild.default_role
717 | 
718 |         check = await Lockdown.filter(type=LockType.maintenance, guild_id=ctx.guild.id, role_id=role.id).first()
719 |         if not check:
720 |             return await ctx.error(f"The server not under maintenance for **{role}**")
721 | 
722 |         success = 0
723 |         for channel in check.channels:
724 |             if channel is not None and channel.permissions_for(channel.guild.me).manage_channels:
725 |                 perms = channel.overwrites_for(role)
726 |                 perms.read_messages = True
727 |                 await channel.set_permissions(role, overwrite=perms, reason="Lockdown timer complete!")
728 |                 success += 1
729 | 
730 |         await ctx.success(
731 |             f"Successfully changed settings for `{success}` channels. (`{sum(1 for i in check.channels)}` were hidden.)"
732 |         )
733 | 
734 |         await Lockdown.filter(type=LockType.maintenance, guild_id=ctx.guild.id, role_id=role.id).delete()
735 | 
736 |         tc = discord.utils.get(ctx.guild.channels, name="maintenance-chat")
737 |         vc = discord.utils.get(ctx.guild.channels, name="maintenance-vc")
738 | 
739 |         if tc and vc:
740 |             prompt = await ctx.prompt(message=f"Do you want me to delete maintenance channels?")
741 |             if prompt:
742 |                 await tc.delete()
743 |                 await vc.delete()
744 |                 await ctx.success(f"Success")
745 |             else:
746 |                 await ctx.success(f"OK!")
747 | 
748 | 
749 | async def setup(bot: Quotient) -> None:
750 |     await bot.add_cog(Mod(bot))
751 |     await bot.add_cog(LockEvents(bot))
752 |     await bot.add_cog(RoleEvents(bot))
753 | 


--------------------------------------------------------------------------------
/cogs/mod/events/__init__.py:
--------------------------------------------------------------------------------
1 | from .lockdown import LockEvents
2 | from .roles import RoleEvents
3 | 


--------------------------------------------------------------------------------
/cogs/mod/events/lockdown.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from constants import LockType
 9 | from core import Cog
10 | from models import Lockdown, Timer
11 | 
12 | 
13 | class LockEvents(Cog):
14 |     def __init__(self, bot: Quotient):
15 |         self.bot = bot
16 | 
17 |     @Cog.listener()
18 |     async def on_lockdown_timer_complete(self, timer: Timer):
19 |         _type = timer.kwargs["_type"]
20 | 
21 |         if _type == LockType.channel.value:
22 |             channel_id = timer.kwargs["channel_id"]
23 | 
24 |             check = await Lockdown.get_or_none(channel_id=channel_id, type=LockType.channel)
25 |             if not check or check.expire_time != timer.expires:
26 |                 return
27 | 
28 |             channel = self.bot.get_channel(channel_id)
29 |             if not channel or not channel.permissions_for(channel.guild.me).manage_channels:
30 |                 return
31 | 
32 |             perms = channel.overwrites_for(channel.guild.default_role)
33 |             perms.send_messages = True
34 |             await channel.set_permissions(channel.guild.default_role, overwrite=perms, reason="Lockdown timer complete!")
35 |             await Lockdown.filter(channel_id=channel.id).delete()
36 |             await channel.send(f"Unlocked **{channel}**")
37 | 
38 |         elif _type == LockType.guild.value:
39 |             guild_id = timer.kwargs["guild_id"]
40 | 
41 |             check = await Lockdown.get_or_none(guild_id=guild_id, type=LockType.guild)
42 |             if not check or check.expire_time != timer.expires:
43 |                 return
44 | 
45 |             for channel in check.channels:
46 |                 if channel is not None and channel.permissions_for(channel.guild.me).manage_channels:
47 |                     perms = channel.overwrites_for(channel.guild.default_role)
48 |                     perms.send_messages = True
49 |                     await channel.set_permissions(
50 |                         channel.guild.default_role,
51 |                         overwrite=perms,
52 |                         reason="Lockdown timer complete!",
53 |                     )
54 |             await Lockdown.filter(guild_id=guild_id, type=LockType.guild).delete()
55 |             channel = self.bot.get_channel(check.channel_id)
56 |             if channel is not None and channel.permissions_for(channel.guild.me).send_messages:
57 |                 await channel.send(f"Unlocked **server**.")
58 | 


--------------------------------------------------------------------------------
/cogs/mod/events/roles.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from core import Cog
 9 | 
10 | 
11 | class RoleEvents(Cog):
12 |     def __init__(self, bot: Quotient):
13 |         self.bot = bot
14 | 


--------------------------------------------------------------------------------
/cogs/mod/utils.py:
--------------------------------------------------------------------------------
 1 | from collections import Counter
 2 | 
 3 | import discord
 4 | 
 5 | from core import Context
 6 | 
 7 | 
 8 | async def _self_clean_system(ctx: Context, search: int) -> dict:
 9 |     count = 0
10 |     async for msg in ctx.history(limit=search, before=ctx.message):
11 |         if msg.author == ctx.me:
12 |             await msg.delete()
13 |             count += 1
14 |     return {"Bot": count}
15 | 
16 | 
17 | async def _complex_cleanup_strategy(ctx: Context, search) -> Counter:
18 |     def check(m: discord.Message):
19 |         return m.author == ctx.me or m.content.startswith(ctx.prefix)
20 | 
21 |     deleted = await ctx.channel.purge(limit=search, check=check, before=ctx.message)
22 |     return Counter(m.author.display_name for m in deleted)
23 | 
24 | 
25 | async def do_removal(ctx: Context, limit, predicate, *, before=None, after=None):
26 |     if limit > 2000:
27 |         return await ctx.error(f"Too many messages to search given ({limit}/2000)")
28 | 
29 |     if before is None:
30 |         before = ctx.message
31 |     else:
32 |         before = discord.Object(id=before)
33 | 
34 |     if after is not None:
35 |         after = discord.Object(id=after)
36 | 
37 |     try:
38 |         deleted = await ctx.channel.purge(limit=limit, before=before, after=after, check=predicate)
39 |     except discord.Forbidden as e:
40 |         return await ctx.error("I do not have permissions to delete messages.")
41 |     except discord.HTTPException as e:
42 |         return await ctx.error(f"Error: {e} (try a smaller search?)")
43 | 
44 |     spammers = Counter(m.author.display_name for m in deleted)
45 |     deleted = len(deleted)
46 |     messages = [f'{deleted} message{" was" if deleted == 1 else "s were"} removed.']
47 |     if deleted:
48 |         messages.append("")
49 |         spammers = sorted(spammers.items(), key=lambda t: t[1], reverse=True)
50 |         messages.extend(f"**{name}**: {count}" for name, count in spammers)
51 | 
52 |     to_send = "\n".join(messages)
53 | 
54 |     if len(to_send) > 2000:
55 |         await ctx.send(f"Successfully removed {deleted} messages.", delete_after=10)
56 |     else:
57 |         await ctx.send(to_send, delete_after=10)
58 | 


--------------------------------------------------------------------------------
/cogs/mod/views/__init__.py:
--------------------------------------------------------------------------------
1 | from .role import *  # noqa: F401, F403
2 | 


--------------------------------------------------------------------------------
/cogs/mod/views/role.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from contextlib import suppress
 9 | 
10 | import discord
11 | 
12 | from core import Context
13 | from utils import emote
14 | 
15 | 
16 | class RoleRevertButton(discord.ui.Button):
17 |     def __init__(self, ctx: Context, *, role: discord.Role, members: typing.List[discord.Member], take_role=True):
18 |         super().__init__()
19 | 
20 |         self.emoji = emote.exit
21 |         self.label = "Take Back" if take_role else "Give Back"
22 |         self.custom_id = "role_revert_action_button"
23 | 
24 |         self.ctx = ctx
25 |         self.role = role
26 |         self.members = members
27 |         self.take_role = take_role
28 | 
29 |     async def callback(self, interaction: discord.Interaction):
30 |         await interaction.response.defer()
31 |         await self.view.on_timeout()
32 | 
33 |         for _ in self.members:
34 |             with suppress(discord.HTTPException):
35 |                 await _.remove_roles(self.role) if self.take_role else await _.add_roles(self.role)
36 | 
37 |         return await self.ctx.success("Succesfully reverted the action.")
38 | 
39 | 
40 | class RoleCancelButton(discord.ui.Button):
41 |     def __init__(self, ctx: Context, *, role: discord.Role, members: typing.List[discord.Member]):
42 |         super().__init__()
43 |         self.ctx = ctx
44 |         self.role = role
45 |         self.members = members
46 | 


--------------------------------------------------------------------------------
/cogs/premium/__init__.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import asyncio
  4 | import typing
  5 | 
  6 | if typing.TYPE_CHECKING:
  7 |     from core import Quotient
  8 | 
  9 | from contextlib import suppress
 10 | from datetime import datetime, timedelta
 11 | 
 12 | import discord
 13 | from discord.ext import commands, tasks
 14 | from tortoise.expressions import Q
 15 | 
 16 | import config
 17 | from constants import random_greeting, random_thanks
 18 | from core import Cog, Context
 19 | from models import Guild, PremiumTxn, Timer, User
 20 | from utils import IST, discord_timestamp, emote, strtime
 21 | 
 22 | from .expire import deactivate_premium, extra_guild_perks, remind_guild_to_pay, remind_user_to_pay
 23 | from .views import PremiumPurchaseBtn, PremiumView
 24 | 
 25 | 
 26 | class PremiumCog(Cog, name="Premium"):
 27 |     def __init__(self, bot: Quotient):
 28 |         self.bot = bot
 29 |         self.remind_peeps_to_pay.start()
 30 |         self.hook = discord.Webhook.from_url(self.bot.config.PUBLIC_LOG, session=self.bot.session)
 31 | 
 32 |     @commands.command()
 33 |     @commands.bot_has_permissions(embed_links=True)
 34 |     async def pstatus(self, ctx: Context):
 35 |         """Get your Quotient Premium status and the current server's."""
 36 |         user = await User.get_or_none(user_id=ctx.author.id)
 37 |         guild = await Guild.filter(guild_id=ctx.guild.id).first()
 38 | 
 39 |         if not user.is_premium:
 40 |             atext = "\n> Activated: No!"
 41 | 
 42 |         else:
 43 |             atext = f"\n> Activated: Yes!\n> Ending: {discord_timestamp(user.premium_expire_time,'f')}"
 44 | 
 45 |         if not guild.is_premium:
 46 |             btext = "\n> Activated: No!"
 47 | 
 48 |         else:
 49 |             booster = guild.booster or await self.bot.fetch_user(guild.made_premium_by)
 50 |             btext = f"\n> Activated: Yes!\n> Ending: {discord_timestamp(guild.premium_end_time,'f')}\n> Upgraded by: **{booster}**"
 51 | 
 52 |         embed = self.bot.embed(ctx, title="Quotient Premium", url=f"{self.bot.config.WEBSITE}")
 53 |         embed.add_field(name="User", value=atext, inline=False)
 54 |         embed.add_field(name="Server", value=btext, inline=False)
 55 |         embed.set_thumbnail(url=ctx.guild.me.display_avatar.url)
 56 |         return await ctx.send(embed=embed)
 57 | 
 58 |     @commands.hybrid_command(aliases=("perks", "pro"))
 59 |     async def premium(self, ctx: Context):
 60 |         """Checkout Quotient Premium Plans."""
 61 |         _e = discord.Embed(
 62 |             color=self.bot.color,
 63 |             description=f"[**Features of Quotient Pro -**]({self.bot.config.SERVER_LINK})\n\n"
 64 |             f"{emote.check} Access to `Quotient Pro` bot.\n"
 65 |             f"{emote.check} Unlimited Scrims.\n"
 66 |             f"{emote.check} Unlimited Tournaments.\n"
 67 |             f"{emote.check} Custom Reactions for Regs.\n"
 68 |             f"{emote.check} Smart SSverification.\n"
 69 |             f"{emote.check} Cancel-Claim Panel.\n"
 70 |             f"{emote.check} Premium Role + more...\n",
 71 |         )
 72 | 
 73 |         v = discord.ui.View(timeout=None)
 74 |         v.add_item(PremiumPurchaseBtn())
 75 |         await ctx.send(embed=_e, view=v)
 76 | 
 77 |     @tasks.loop(hours=48)
 78 |     async def remind_peeps_to_pay(self):
 79 |         await self.bot.wait_until_ready()
 80 | 
 81 |         await asyncio.sleep(900)
 82 |         async for user in User.filter(is_premium=True, premium_expire_time__lte=datetime.now(tz=IST) + timedelta(days=4)):
 83 |             _u = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, user.pk)
 84 |             if _u:
 85 |                 if not await self.ensure_reminders(user.pk, user.premium_expire_time):
 86 |                     await self.bot.reminders.create_timer(user.premium_expire_time, "user_premium", user_id=user.pk)
 87 | 
 88 |                 await remind_user_to_pay(_u, user)
 89 | 
 90 |         async for guild in Guild.filter(is_premium=True, premium_end_time__lte=datetime.now(IST) + timedelta(days=4)):
 91 |             _g = self.bot.get_guild(guild.pk)
 92 | 
 93 |             if not await self.ensure_reminders(guild.pk, guild.premium_end_time):
 94 |                 await self.bot.reminders.create_timer(guild.premium_end_time, "guild_premium", guild_id=guild.pk)
 95 | 
 96 |             if _g:
 97 |                 await remind_guild_to_pay(_g, guild)
 98 | 
 99 |     async def ensure_reminders(self, _id: int, _time: datetime) -> bool:
100 |         return await Timer.filter(
101 |             Q(event="guild_premium", extra={"args": [], "kwargs": {"guild_id": _id}})
102 |             | Q(event="user_premium", extra={"args": [], "kwargs": {"user_id": _id}}),
103 |             expires=_time,
104 |         ).exists()
105 | 
106 |     def cog_unload(self):
107 |         self.remind_peeps_to_pay.stop()
108 | 
109 |     @Cog.listener()
110 |     async def on_guild_premium_timer_complete(self, timer: Timer):
111 |         guild_id = timer.kwargs["guild_id"]
112 | 
113 |         _g = await Guild.get_or_none(pk=guild_id)
114 |         if not _g:
115 |             return
116 | 
117 |         if not _g.premium_end_time == timer.expires:
118 |             return
119 | 
120 |         _perks = "\n".join(await extra_guild_perks(guild_id))
121 | 
122 |         await deactivate_premium(guild_id)
123 | 
124 |         if (_ch := _g.private_ch) and _ch.permissions_for(_ch.guild.me).embed_links:
125 |             _e = discord.Embed(
126 |                 color=discord.Color.red(), title="⚠️__**Quotient Pro Subscription Ended**__⚠️", url=config.SERVER_LINK
127 |             )
128 |             _e.description = (
129 |                 "This is to inform you that your subscription of Quotient Pro has been ended.\n\n"
130 |                 "*Following is a list of perks or data you lost:*"
131 |             )
132 | 
133 |             _e.description += f"```diff\n{_perks}```"
134 | 
135 |             _roles = [
136 |                 role.mention
137 |                 for role in _ch.guild.roles
138 |                 if all((role.permissions.administrator, not role.managed, role.members))
139 |             ]
140 | 
141 |             _view = PremiumView()
142 |             await _ch.send(
143 |                 embed=_e,
144 |                 view=_view,
145 |                 content=", ".join(_roles[:2]) if _roles else _ch.guild.owner.mention,
146 |                 allowed_mentions=discord.AllowedMentions(roles=True),
147 |             )
148 | 
149 |     @Cog.listener()
150 |     async def on_user_premium_timer_complete(self, timer: Timer):
151 |         user_id = timer.kwargs["user_id"]
152 |         _user = await User.get(pk=user_id)
153 | 
154 |         if not _user.premium_expire_time == timer.expires:
155 |             return
156 | 
157 |         _q = "UPDATE user_data SET is_premium = FALSE ,premiums=0 ,made_premium = '{}' WHERE user_id = $1"
158 |         await self.bot.db.execute(_q, user_id)
159 | 
160 |         member = await self.bot.get_or_fetch_member(self.bot.server, _user.pk)
161 |         if member:
162 |             await member.remove_roles(discord.Object(id=config.PREMIUM_ROLE))
163 | 
164 |     @Cog.listener()
165 |     async def on_premium_purchase(self, txnId: str):
166 |         record = await PremiumTxn.get(txnid=txnId)
167 | 
168 |         member = self.bot.server.get_member(record.user_id)
169 |         if member is not None:
170 |             await member.add_roles(discord.Object(id=self.bot.config.PREMIUM_ROLE), reason="They purchased premium.")
171 | 
172 |         else:
173 |             member = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, record.user_id)
174 | 
175 |         with suppress(discord.HTTPException, AttributeError):
176 |             _e = discord.Embed(
177 |                 color=discord.Color.gold(), description=f"Thanks **{member}** for purchasing Quotient Premium."
178 |             )
179 |             _e.set_image(url=random_thanks())
180 |             await self.hook.send(embed=_e, username="premium-logs", avatar_url=self.bot.config.PREMIUM_AVATAR)
181 | 
182 |         upgraded_guild = self.bot.get_guild(record.guild_id)
183 |         _guild = await Guild.get_or_none(pk=record.guild_id)
184 | 
185 |         _e = discord.Embed(
186 |             color=self.bot.color,
187 |             title="Quotient Pro Purchase Successful!",
188 |             url=self.bot.config.SERVER_LINK,
189 |             description=(
190 |                 f"{random_greeting()} {member.mention},\n"
191 |                 f"Thanks for purchasing Quotient Premium. Your server **{upgraded_guild}** has access to Quotient Pro features until `{_guild.premium_end_time.strftime('%d-%b-%Y %I:%M %p')}`.\n\n"
192 |                 "[Click me to Invite Quotient Pro Bot to your server](https://discord.com/oauth2/authorize?client_id=902856923311919104&scope=applications.commands%20bot&permissions=21175985838)\n"
193 |             ),
194 |         )
195 | 
196 |         if member not in self.bot.server.members:
197 |             _e.description += f"\n\n[To claim your Premium Role, Join Quotient HQ]({self.bot.config.SERVER_LINK})."
198 | 
199 |         _view = discord.ui.View(timeout=None)
200 | 
201 |         try:
202 |             await member.send(embed=_e, view=_view)
203 |         except discord.HTTPException:
204 |             pass
205 | 
206 | 
207 | async def setup(bot: Quotient) -> None:
208 |     await bot.add_cog(PremiumCog(bot))
209 | 


--------------------------------------------------------------------------------
/cogs/premium/expire.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | from contextlib import suppress
  5 | 
  6 | import discord
  7 | 
  8 | import config
  9 | from models import EasyTag, Guild, Scrim, ScrimsSlotManager, SSVerify, TagCheck, Tourney, User
 10 | from utils import discord_timestamp, plural
 11 | 
 12 | from .views import PremiumView
 13 | 
 14 | 
 15 | async def deactivate_premium(guild_id: int):
 16 |     await Guild.filter(guild_id=guild_id).update(embed_color=config.COLOR, embed_footer=config.FOOTER, is_premium=False)
 17 | 
 18 |     _s: typing.List[Scrim] = (await Scrim.filter(guild_id=guild_id).order_by("id"))[3:]
 19 |     await Scrim.filter(id__in=(s.pk for s in _s)).delete()
 20 | 
 21 |     _t: typing.List[Tourney] = (await Tourney.filter(guild_id=guild_id).order_by("id"))[1:]
 22 |     await Tourney.filter(id__in=(t.pk for t in _t)).delete()
 23 | 
 24 |     _tc: typing.List[TagCheck] = (await TagCheck.filter(guild_id=guild_id).order_by("id"))[1:]
 25 |     await TagCheck.filter(id__in=(t.pk for t in _tc)).delete()
 26 | 
 27 |     _ez: typing.List[EasyTag] = (await EasyTag.filter(guild_id=guild_id).order_by("id"))[1:]
 28 |     await EasyTag.filter(id__in=(e.pk for e in _ez)).delete()
 29 | 
 30 |     await Tourney.filter(guild_id=guild_id).update(emojis={})
 31 | 
 32 |     ssverify = await SSVerify.filter(guild_id=guild_id)
 33 |     for _ in ssverify:
 34 |         await _.full_delete()
 35 | 
 36 |     _slotm = (await ScrimsSlotManager.filter(guild_id=guild_id).order_by("id"))[1:]
 37 |     for _ in _slotm:
 38 |         await _.full_delete()
 39 | 
 40 |     return
 41 | 
 42 | 
 43 | async def extra_guild_perks(guild_id: int):
 44 |     _list = [
 45 |         "- Can't use Quotient Pro bot.",
 46 |         "- Tourney reactions emojis will be changed to default.",
 47 |         "- No more than 1 Media Partner Channel per tourney.",
 48 |     ]
 49 | 
 50 |     if (_s := await Scrim.filter(guild_id=guild_id).order_by("id"))[3:]:
 51 |         _list.append(f"- {plural(len(_s)):scrim|scrims} will be deleted. (ID: {', '.join((str(s.pk) for s in _s))})")
 52 | 
 53 |     if (_t := await Tourney.filter(guild_id=guild_id).order_by("id"))[1:]:
 54 |         _list.append(f"- {plural(len(_t)):tourney|tourneys} will be deleted. (ID: {', '.join(str(t.pk) for t in _t)})")
 55 | 
 56 |     if (_tc := await TagCheck.filter(guild_id=guild_id).order_by("id"))[1:]:
 57 |         _list.append(
 58 |             f"- {len(_tc)} tagcheck setup will be removed. (Channels: {', '.join((str(ch.channel) for ch in _tc))})"
 59 |         )
 60 | 
 61 |     if (_ez := await EasyTag.filter(guild_id=guild_id).order_by("id"))[1:]:
 62 |         _list.append(
 63 |             f"- {len(_ez)} easytag setup will be removed. (Channels: {', '.join((str(ch.channel) for ch in _ez))})"
 64 |         )
 65 | 
 66 |     if (_slotm := await ScrimsSlotManager.filter(guild_id=guild_id).order_by("id"))[1:]:
 67 |         _list.append(
 68 |             f"- {len(_slotm)} scrims slot manager setup will be removed. (Channels: {', '.join((str(ch.main_channel) for ch in _slotm))})"
 69 |         )
 70 | 
 71 |     if _ss := await SSVerify.filter(guild_id=guild_id).order_by("id"):
 72 |         _list.append(
 73 |             f"- {len(_ss)} SSVerify setup will be removed. (Channels: {', '.join((str(ch.channel) for ch in _ss))})"
 74 |         )
 75 | 
 76 |     return _list
 77 | 
 78 | 
 79 | async def remind_guild_to_pay(guild: discord.Guild, model: Guild):
 80 |     if (_ch := model.private_ch) and _ch.permissions_for(_ch.guild.me).embed_links:
 81 |         _e = discord.Embed(
 82 |             color=discord.Color.red(),
 83 |             title="⚠️__**Quotient Pro Ending Soon**__⚠️",
 84 |             url=config.SERVER_LINK,
 85 |         )
 86 | 
 87 |         _e.description = (
 88 |             f"This is to inform you that your subscription of **Quotient Pro** is ending soon "
 89 |             f"({discord_timestamp(model.premium_end_time,'D')})"
 90 |             "\n\n*Kindly renew your subscription to continue using Quotient Premium features.*"
 91 |         )
 92 | 
 93 |         _roles = [
 94 |             role.mention for role in guild.roles if all((role.permissions.administrator, not role.managed, role.members))
 95 |         ]
 96 | 
 97 |         _view = PremiumView(label="Renew Quotient Pro")
 98 |         await _ch.send(
 99 |             embed=_e,
100 |             view=_view,
101 |             content=", ".join(_roles[:2]) if _roles else getattr(guild.owner, "mention", ""),
102 |             allowed_mentions=discord.AllowedMentions(roles=True),
103 |         )
104 | 
105 | 
106 | async def remind_user_to_pay(user: discord.User, model: User):
107 |     _e = discord.Embed(color=discord.Color.red(), title="⚠️__**IMPORTANT**__⚠️")
108 |     _e.description = (
109 |         f"This is to remind you that your subscription of **Quotient Pro** is ending {discord_timestamp(model.premium_expire_time)}"
110 |         f"\n[*Click Me To Continue Enjoying Quotient Pro*](https://quotientbot.xyz/premium)"
111 |     )
112 |     with suppress(discord.HTTPException):
113 |         await user.send(embed=_e)
114 | 


--------------------------------------------------------------------------------
/cogs/premium/views.py:
--------------------------------------------------------------------------------
 1 | from typing import List
 2 | 
 3 | import discord
 4 | 
 5 | import config
 6 | from models import PremiumPlan, PremiumTxn
 7 | from utils import emote
 8 | 
 9 | 
10 | class PlanSelector(discord.ui.Select):
11 |     def __init__(self, plans: List[PremiumPlan]):
12 |         super().__init__(placeholder="Select a Quotient Premium Plan... ")
13 | 
14 |         for _ in plans:
15 |             self.add_option(label=f"{_.name} - ₹{_.price}", description=_.description, value=_.id)
16 | 
17 |     async def callback(self, interaction: discord.Interaction):
18 |         await interaction.response.defer()
19 |         self.view.plan = self.values[0]
20 |         self.view.stop()
21 | 
22 | 
23 | class PremiumPurchaseBtn(discord.ui.Button):
24 |     def __init__(self, label="Get Quotient Pro", emoji=emote.diamond, style=discord.ButtonStyle.grey):
25 |         super().__init__(style=style, label=label, emoji=emoji)
26 | 
27 |     async def callback(self, interaction: discord.Interaction):
28 |         await interaction.response.defer()
29 |         v = discord.ui.View(timeout=100)
30 |         v.plan: str = None
31 | 
32 |         v.add_item(PlanSelector(await PremiumPlan.all().order_by("id")))
33 |         await interaction.followup.send("Please select the Quotient Pro plan, you want to opt:", view=v, ephemeral=True)
34 |         await v.wait()
35 | 
36 |         if not v.plan:
37 |             return
38 | 
39 |         txn = await PremiumTxn.create(
40 |             txnid=await PremiumTxn.gen_txnid(),
41 |             user_id=interaction.user.id,
42 |             guild_id=interaction.guild.id,
43 |             plan_id=v.plan,
44 |         )
45 |         _link = config.PAY_LINK + "getpremium" + "?txnId=" + txn.txnid
46 | 
47 |         await interaction.followup.send(
48 |             f"You are about to purchase Quotient Premium for **{interaction.guild.name}**.\n"
49 |             "If you want to purchase for another server, use `qpremium` or `/premium` command in that server.\n\n"
50 |             f"[*Click Me to Complete the Payment*]({_link})",
51 |             ephemeral=True,
52 |         )
53 | 
54 | 
55 | class PremiumView(discord.ui.View):
56 |     def __init__(self, text="This feature requires Quotient Premium.", *, label="Get Quotient Pro"):
57 |         super().__init__(timeout=None)
58 |         self.text = text
59 |         self.add_item(PremiumPurchaseBtn(label=label))
60 | 
61 |     @property
62 |     def premium_embed(self) -> discord.Embed:
63 |         _e = discord.Embed(
64 |             color=0x00FFB3, description=f"**You discovered a premium feature <a:premium:807911675981201459>**"
65 |         )
66 |         _e.description = (
67 |             f"\n*`{self.text}`*\n\n"
68 |             "__Perks you get with Quotient Pro:__\n"
69 |             f"{emote.check} Access to `Quotient Pro` bot.\n"
70 |             f"{emote.check} Unlimited Scrims.\n"
71 |             f"{emote.check} Unlimited Tournaments.\n"
72 |             f"{emote.check} Custom Reactions for Regs.\n"
73 |             f"{emote.check} Smart SSverification.\n"
74 |             f"{emote.check} Cancel-Claim Panel.\n"
75 |             f"{emote.check} Premium Role + more...\n"
76 |         )
77 |         return _e
78 | 


--------------------------------------------------------------------------------
/cogs/quomisc/__init__.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | 
  5 | if typing.TYPE_CHECKING:
  6 |     from core import Quotient
  7 | 
  8 | import inspect
  9 | import itertools
 10 | import os
 11 | from collections import Counter
 12 | from datetime import datetime, timedelta, timezone
 13 | 
 14 | import discord
 15 | import pkg_resources
 16 | import psutil
 17 | import pygit2
 18 | from discord.ext import commands
 19 | 
 20 | from cogs.quomisc.helper import format_relative
 21 | from core import Cog, Context, QuotientView
 22 | from models import Commands, Guild, User, Votes
 23 | from utils import LinkButton, LinkType, QuoColor, checks, get_ipm, human_timedelta, truncate_string
 24 | 
 25 | from .alerts import *
 26 | from .dev import *
 27 | from .views import MoneyButton, SetupButtonView, VoteButton
 28 | 
 29 | 
 30 | class Quomisc(Cog, name="quomisc"):
 31 |     def __init__(self, bot: Quotient):
 32 |         self.bot = bot
 33 | 
 34 |     @commands.command(aliases=("src",))
 35 |     async def source(self, ctx: Context, *, search: typing.Optional[str]):
 36 |         """Refer to the source code of the bot commands."""
 37 |         source_url = "https://github.com/quotientbot/Quotient-Bot"
 38 | 
 39 |         if search is None:
 40 |             return await ctx.send(f"<{source_url}>")
 41 | 
 42 |         command = ctx.bot.get_command(search)
 43 | 
 44 |         if not command:
 45 |             return await ctx.send("Couldn't find that command.")
 46 | 
 47 |         src = command.callback.__code__
 48 |         filename = src.co_filename
 49 |         lines, firstlineno = inspect.getsourcelines(src)
 50 | 
 51 |         location = os.path.relpath(filename).replace("\\", "/")
 52 | 
 53 |         final_url = f"<{source_url}/blob/main/{location}#L{firstlineno}-L{firstlineno + len(lines) - 1}>"
 54 |         await ctx.send(final_url)
 55 | 
 56 |     @commands.command(aliases=("inv",))
 57 |     async def invite(self, ctx: Context):
 58 |         """Quotient Invite Links."""
 59 |         v = discord.ui.View(timeout=None)
 60 |         v.add_item(
 61 |             discord.ui.Button(
 62 |                 style=discord.ButtonStyle.link, label="Invite Quotient (Me)", url=self.bot.config.BOT_INVITE, row=1
 63 |             )
 64 |         )
 65 |         v.add_item(
 66 |             discord.ui.Button(
 67 |                 style=discord.ButtonStyle.link, label="Invite Quotient Pro", url=self.bot.config.PRO_LINK, row=2
 68 |             )
 69 |         )
 70 |         v.add_item(
 71 |             discord.ui.Button(
 72 |                 style=discord.ButtonStyle.link, label="Join Support Server", url=self.bot.config.SERVER_LINK, row=3
 73 |             )
 74 |         )
 75 | 
 76 |         await ctx.reply(view=v)
 77 | 
 78 |     async def make_private_channel(self, ctx: Context) -> discord.TextChannel:
 79 |         support_link = f"[Support Server]({ctx.config.SERVER_LINK})"
 80 |         invite_link = f"[Invite Me]({ctx.config.BOT_INVITE})"
 81 |         vote_link = f"[Vote]({ctx.config.WEBSITE}/vote)"
 82 |         source = f"[Source]({ctx.config.REPOSITORY})"
 83 | 
 84 |         guild = ctx.guild
 85 |         overwrites = {
 86 |             guild.default_role: discord.PermissionOverwrite(read_messages=False),
 87 |             guild.me: discord.PermissionOverwrite(
 88 |                 read_messages=True,
 89 |                 send_messages=True,
 90 |                 read_message_history=True,
 91 |                 embed_links=True,
 92 |                 attach_files=True,
 93 |                 manage_channels=True,
 94 |             ),
 95 |             ctx.author: discord.PermissionOverwrite(read_messages=True, send_messages=True, read_message_history=True),
 96 |         }
 97 |         channel = await guild.create_text_channel(
 98 |             "quotient-private", overwrites=overwrites, reason=f"Made by {str(ctx.author)}"
 99 |         )
100 |         await Guild.filter(guild_id=ctx.guild.id).update(private_channel=channel.id)
101 | 
102 |         e = self.bot.embed(ctx)
103 |         e.add_field(
104 |             name="**What is this channel for?**",
105 |             inline=False,
106 |             value="This channel is made for Quotient to send important announcements and activities that need your attention. If anything goes wrong with any of my functionality I will notify you here. Important announcements from the developer will be sent directly here too.\n\nYou can test my commands in this channel if you like. Kindly don't delete it , some of my commands won't work without this channel.",
107 |         )
108 |         e.add_field(
109 |             name="**__Important Links__**", value=f"{support_link} | {invite_link} | {vote_link} | {source}", inline=False
110 |         )
111 | 
112 |         links = [LinkType("Support Server", ctx.config.SERVER_LINK)]
113 |         view = LinkButton(links)
114 |         m = await channel.send(embed=e, view=view)
115 |         await m.pin()
116 | 
117 |         return channel
118 | 
119 |     @commands.command(name="setup")
120 |     @commands.has_permissions(manage_guild=True)
121 |     @commands.bot_has_guild_permissions(manage_channels=True, manage_webhooks=True)
122 |     async def setup_cmd(self, ctx: Context):
123 |         """
124 |         Setup Quotient in the current server.
125 |         This creates a private channel in the server. You can rename that if you like.
126 |         Quotient requires manage channels and manage wehooks permissions for this to work.
127 |         You must have manage server permission.
128 |         """
129 | 
130 |         _view = SetupButtonView(ctx)
131 |         _view.add_item(QuotientView.tricky_invite_button())
132 |         record = await Guild.get(guild_id=ctx.guild.id)
133 | 
134 |         if record.private_ch is not None:
135 |             return await ctx.error(f"You already have a private channel ({record.private_ch.mention})", view=_view)
136 |         channel = await self.make_private_channel(ctx)
137 |         await ctx.success(f"Created {channel.mention}", view=_view)
138 | 
139 |     def get_bot_uptime(self, *, brief=False):
140 |         return human_timedelta(self.bot.start_time, accuracy=None, brief=brief, suffix=False)
141 | 
142 |     @staticmethod
143 |     def format_commit(commit):  # source: R danny
144 |         short, _, _ = commit.message.partition("\n")
145 |         short_sha2 = commit.hex[0:6]
146 |         commit_tz = timezone(timedelta(minutes=commit.commit_time_offset))
147 |         commit_time = datetime.fromtimestamp(commit.commit_time).astimezone(commit_tz)
148 | 
149 |         # [`hash`](url) message (offset)
150 |         offset = format_relative(commit_time.astimezone(timezone.utc))
151 |         return f"[`{short_sha2}`](https://github.com/quotientbot/Quotient-Bot/commit/{commit.hex}) {truncate_string(short,40)} ({offset})"
152 | 
153 |     def get_last_commits(self, count=3):
154 |         repo = pygit2.Repository(".git")
155 |         commits = list(itertools.islice(repo.walk(repo.head.target, pygit2.GIT_SORT_TOPOLOGICAL), count))
156 |         return "\n".join(self.format_commit(c) for c in commits)
157 | 
158 |     @commands.command(aliases=("stats",))
159 |     @commands.cooldown(1, 10, commands.BucketType.guild)
160 |     async def about(self, ctx: Context):
161 |         """Statistics of Quotient."""
162 |         db_latency = await self.bot.db_latency
163 | 
164 |         version = pkg_resources.get_distribution("discord.py").version
165 |         revision = self.get_last_commits()
166 | 
167 |         total_memory = psutil.virtual_memory().total >> 20
168 |         used_memory = psutil.virtual_memory().used >> 20
169 |         cpu_used = str(psutil.cpu_percent())
170 | 
171 |         total_members = sum(g.member_count for g in self.bot.guilds)
172 |         cached_members = len(self.bot.users)
173 | 
174 |         total_command_uses = await Commands.all().count()
175 |         user_invokes = await Commands.filter(user_id=ctx.author.id, guild_id=ctx.guild.id).count() or 0
176 |         server_invokes = await Commands.filter(guild_id=ctx.guild.id).count() or 0
177 | 
178 |         chnl_count = Counter(map(lambda ch: ch.type, self.bot.get_all_channels()))
179 | 
180 |         owner = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, 548163406537162782)
181 | 
182 |         msges = self.bot.seen_messages
183 | 
184 |         embed = discord.Embed(description="Latest Changes:\n" + revision)
185 |         embed.title = "Quotient Official Support Server"
186 |         embed.url = ctx.config.SERVER_LINK
187 |         embed.colour = self.bot.color
188 |         embed.set_author(name=str(owner), icon_url=owner.display_avatar.url)
189 | 
190 |         guild_value = len(self.bot.guilds)
191 | 
192 |         embed.add_field(name="Servers", value=f"{guild_value:,} total\n{len(self.bot.shards)} shards")
193 |         embed.add_field(name="Uptime", value=f"{self.get_bot_uptime(brief=True)}\n{msges:,} messages seen")
194 |         embed.add_field(name="Members", value=f"{total_members:,} Total\n{cached_members:,} cached")
195 |         embed.add_field(
196 |             name="Channels",
197 |             value=f"{chnl_count[discord.ChannelType.text] + chnl_count[discord.ChannelType.voice]:,} total\n{chnl_count[discord.ChannelType.text]:,} text\n{chnl_count[discord.ChannelType.voice]:,} voice",
198 |         )
199 |         embed.add_field(
200 |             name="Total Commands Used",
201 |             value=f"{total_command_uses:,} globally\n{server_invokes:,} in this server\n{user_invokes:,} by you.",
202 |         )
203 |         embed.add_field(
204 |             name="Stats",
205 |             value=f"Ping: {round(self.bot.latency * 1000, 2)}ms\nDatabase: {db_latency}\nIPM: {round(get_ipm(ctx.bot), 2)}",
206 |         )
207 |         embed.add_field(name="System", value=f"**RAM**: {used_memory}/{total_memory} MB\n**CPU:** {cpu_used}% used."),
208 |         embed.set_footer(text=f"Made with discord.py v{version}", icon_url="http://i.imgur.com/5BFecvA.png")
209 | 
210 |         links = [LinkType("Support Server", ctx.config.SERVER_LINK), LinkType("Invite Me", ctx.config.BOT_INVITE)]
211 |         await ctx.send(embed=embed, embed_perms=True, view=LinkButton(links))
212 | 
213 |     @commands.command()
214 |     async def ping(self, ctx: Context):
215 |         """Check how the bot is doing"""
216 |         await ctx.send(f"Bot: `{round(self.bot.latency*1000, 2)} ms`, Database: `{await self.bot.db_latency}`")
217 | 
218 |     @commands.command()
219 |     async def voteremind(self, ctx: Context):
220 |         """Get a reminder when your vote expires"""
221 |         check = await Votes.get_or_none(user_id=ctx.author.id)
222 |         if check:
223 |             await Votes.filter(user_id=ctx.author.id).update(reminder=not (check.reminder))
224 |             await ctx.success(f"Turned vote-reminder {'ON' if not check.reminder else 'OFF'}!")
225 |         else:
226 |             await Votes.create(user_id=ctx.author.id, reminder=True)
227 |             await ctx.success(f"Turned vote-reminder ON!")
228 | 
229 |     @commands.command()
230 |     @commands.has_permissions(manage_guild=True)
231 |     async def prefix(self, ctx: Context, *, new_prefix: str = None):
232 |         """Change your server's prefix"""
233 | 
234 |         if not new_prefix:
235 |             prefix = self.bot.cache.guild_data[ctx.guild.id].get("prefix", "q")
236 |             return await ctx.simple(f"Prefix for this server is `{prefix}`")
237 | 
238 |         if len(new_prefix) > 5:
239 |             return await ctx.error(f"Prefix cannot contain more than 5 characters.")
240 | 
241 |         self.bot.cache.guild_data[ctx.guild.id]["prefix"] = new_prefix
242 |         await Guild.filter(guild_id=ctx.guild.id).update(prefix=new_prefix)
243 |         await ctx.success(f"Updated server prefix to: `{new_prefix}`")
244 | 
245 |     @commands.command()
246 |     @commands.has_permissions(manage_guild=True)
247 |     @checks.is_premium_guild()
248 |     async def color(self, ctx: Context, *, new_color: QuoColor):
249 |         """Change color of Quotient's embeds"""
250 |         color = int(str(new_color).replace("#", ""), 16)  # The hex value of a color.
251 | 
252 |         self.bot.cache.guild_data[ctx.guild.id]["color"] = color
253 |         await Guild.filter(guild_id=ctx.guild.id).update(embed_color=color)
254 |         await ctx.success(f"Updated server color.")
255 | 
256 |     @commands.command()
257 |     @checks.is_premium_guild()
258 |     @commands.has_permissions(manage_guild=True)
259 |     async def footer(self, ctx: Context, *, new_footer: str):
260 |         """Change footer of embeds sent by Quotient"""
261 |         if len(new_footer) > 50:
262 |             return await ctx.success(f"Footer cannot contain more than 50 characters.")
263 | 
264 |         self.bot.cache.guild_data[ctx.guild.id]["footer"] = new_footer
265 |         await Guild.filter(guild_id=ctx.guild.id).update(embed_footer=new_footer)
266 |         await ctx.send(f"Updated server footer.")
267 | 
268 |     @commands.command()
269 |     async def money(self, ctx: Context):
270 |         user = await User.get(user_id=ctx.author.id)
271 | 
272 |         e = self.bot.embed(ctx, title="Your Quo Coins")
273 |         e.set_thumbnail(url=self.bot.user.display_avatar.url)
274 | 
275 |         e.description = (
276 |             f"💰 | You have a total of `{user.money} Quo Coins`.\n"
277 |             f"*Quo Coins can be earned by voting [here]({ctx.config.WEBSITE}/vote)*"
278 |         )
279 | 
280 |         _view = MoneyButton(ctx)
281 |         if not user.money >= 120:
282 |             _view.children[0] = discord.ui.Button(
283 |                 label=f"Claim Prime (120 coins)", custom_id="claim_prime", style=discord.ButtonStyle.grey, disabled=True
284 |             )
285 | 
286 |         _view.message = await ctx.send(embed=e, embed_perms=True, view=_view)
287 | 
288 |     @commands.command()
289 |     async def vote(self, ctx: Context):
290 |         e = self.bot.embed(ctx, title="Vote for Quotient")
291 |         e.description = (
292 |             "**Rewards**\n"
293 |             "<a:roocool:962749077831942276> Voter Role `12 hrs`\n"
294 |             f"{self.bot.config.PRIME_EMOJI} Quo Coin `x1`"
295 |         )
296 |         e.set_thumbnail(url=self.bot.user.display_avatar.url)
297 | 
298 |         _view = VoteButton(ctx)
299 | 
300 |         vote = await Votes.get_or_none(pk=ctx.author.id)
301 |         if vote and vote.is_voter:
302 |             _b: discord.ui.Button = discord.ui.Button(
303 |                 disabled=True,
304 |                 style=discord.ButtonStyle.grey,
305 |                 custom_id="vote_quo",
306 |                 label=f"Vote in {human_timedelta(vote.expire_time,accuracy=1,suffix=False)}",
307 |             )
308 |             _view.children[0] = _b
309 | 
310 |         e.set_footer(
311 |             text=f"Your votes: {vote.total_votes if vote else 0}",
312 |             icon_url=getattr(ctx.author.display_avatar, "url", self.bot.user.display_avatar.url),
313 |         )
314 |         _view.message = await ctx.send(embed=e, view=_view, embed_perms=True)
315 | 
316 |     @commands.command()
317 |     async def dashboard(self, ctx: Context):
318 |         await ctx.send(
319 |             f"Here is the direct link to this server's dashboard:\n<https://quotientbot.xyz/dashboard/{ctx.guild.id}>"
320 |         )
321 | 
322 |     @commands.hybrid_command()
323 |     @commands.cooldown(1, 5, commands.BucketType.user)
324 |     async def contributors(self, ctx):
325 |         """People who made Quotient Possible."""
326 |         url = f"https://api.github.com/repos/quotientbot/Quotient-Bot/contributors"
327 | 
328 |         e = discord.Embed(title=f"Project Contributors", color=self.bot.color, timestamp=self.bot.current_time)
329 |         e.description = ""
330 |         async with self.bot.session.get(url) as response:
331 |             data = await response.json()
332 |             for idx, contributor in enumerate(data, start=1):
333 |                 if contributor["type"] == "Bot":
334 |                     continue
335 | 
336 |                 e.description += (
337 |                     f"`{idx:02}.` [{contributor['login']} ({contributor['contributions']})]({contributor['html_url']})\n"
338 |                 )
339 | 
340 |         await ctx.send(embed=e)
341 | 
342 | 
343 | async def setup(bot: Quotient) -> None:
344 |     await bot.add_cog(Quomisc(bot))
345 |     await bot.add_cog(Dev(bot))
346 |     await bot.add_cog(QuoAlerts(bot))
347 | 


--------------------------------------------------------------------------------
/cogs/quomisc/alerts.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | from os import truncate
  5 | 
  6 | if T.TYPE_CHECKING:
  7 |     from core import Quotient
  8 | 
  9 | from datetime import timedelta
 10 | 
 11 | import discord
 12 | from discord.ext import commands
 13 | 
 14 | from core import Cog, Context, QuotientView, embeds
 15 | from models import Alert, Prompt, Read, Timer
 16 | from utils import QuoPaginator, discord_timestamp
 17 | 
 18 | __all__ = ("QuoAlerts",)
 19 | 
 20 | 
 21 | class PromptView(QuotientView):
 22 |     def __init__(self, ctx: Context, alert: Alert):
 23 |         super().__init__(ctx, timeout=300)
 24 |         self.ctx = ctx
 25 |         self.alert = alert
 26 | 
 27 |     @discord.ui.button(style=discord.ButtonStyle.green, label="Read Now")
 28 |     async def read_now(self, inter: discord.Interaction, btn: discord.Button):
 29 |         _e = discord.Embed.from_dict(self.alert.message)
 30 |         await inter.response.send_message(embed=_e, ephemeral=True)
 31 | 
 32 |         self.stop()
 33 |         await self.message.delete(delay=0)
 34 | 
 35 |         await self.alert.refresh_from_db()
 36 |         read = await Read.create(user_id=inter.user.id)
 37 |         await self.alert.reads.add(read)
 38 | 
 39 |     @discord.ui.button(style=discord.ButtonStyle.red, label="Dismiss")
 40 |     async def dismiss(self, inter: discord.Interaction, btn: discord.Button):
 41 |         self.stop()
 42 |         await self.message.delete(delay=0)
 43 | 
 44 | 
 45 | class CreateAlert(discord.ui.Button):
 46 |     view: embeds.EmbedBuilder
 47 | 
 48 |     def __init__(self, ctx: Context):
 49 |         super().__init__(label="Create Alert", style=discord.ButtonStyle.green)
 50 |         self.ctx = ctx
 51 | 
 52 |     async def callback(self, interaction: discord.Interaction):
 53 |         await interaction.response.defer()
 54 | 
 55 |         await Alert.filter(active=True).update(active=False)
 56 |         record = await Alert.create(author_id=interaction.user.id, message=self.view.formatted)
 57 |         await self.ctx.bot.reminders.create_timer(record.created_at + timedelta(days=10), "alert", alert_id=record.id)
 58 | 
 59 |         await self.ctx.success("Created a new alert with `ID: {}`".format(record.id))
 60 | 
 61 | 
 62 | class QuoAlerts(Cog):
 63 |     def __init__(self, bot: Quotient):
 64 |         self.bot = bot
 65 | 
 66 |     def cog_check(self, ctx: Context):
 67 |         return ctx.author.id in ctx.config.DEVS
 68 | 
 69 |     @Cog.listener()
 70 |     async def on_command_completion(self, ctx: Context):
 71 |         record = await Alert.filter(active=True).order_by("-created_at").first()
 72 |         if not record:
 73 |             return
 74 | 
 75 |         if await record.reads.filter(user_id=ctx.author.id).exists():
 76 |             return
 77 | 
 78 |         user_prompts = await record.prompts.filter(user_id=ctx.author.id).order_by("-prompted_at")
 79 |         if len(user_prompts) >= 3:
 80 |             return
 81 | 
 82 |         if user_prompts and user_prompts[0].prompted_at > (ctx.bot.current_time - timedelta(minutes=5)):
 83 |             return
 84 | 
 85 |         _e = discord.Embed(
 86 |             color=self.bot.color, title="You have an unread alert!", description="Click `Read Now` to read it."
 87 |         )
 88 |         _e.set_thumbnail(url="https://cdn.discordapp.com/attachments/851846932593770496/1031240353489109112/alert.gif")
 89 |         v = PromptView(ctx, record)
 90 |         v.message = await ctx.message.reply(embed=_e, view=v)
 91 | 
 92 |         prompt = await Prompt.create(user_id=ctx.author.id)
 93 |         await record.prompts.add(prompt)
 94 | 
 95 |     @Cog.listener()
 96 |     async def on_alert_timer_complete(self, timer: Timer):
 97 |         record_id = timer.kwargs["alert_id"]
 98 |         await Alert.filter(pk=record_id).update(active=False)
 99 | 
100 |     @commands.group(hidden=True, invoke_without_command=True)
101 |     async def alr(self, ctx: Context):
102 |         await ctx.send_help(ctx.command)
103 | 
104 |     @alr.command(name="list")
105 |     async def alr_list(self, ctx: Context):
106 |         records = await Alert.all().order_by("created_at")
107 |         if not records:
108 |             return await ctx.error("No alerts present at the moment, create one.")
109 | 
110 |         paginator = QuoPaginator(ctx, title="List of Alerts")
111 |         for idx, record in enumerate(records, start=1):
112 |             paginator.add_line(f"`{idx:02}` Created: {discord_timestamp(record.created_at)} (ID: `{record.pk}`)")
113 | 
114 |         await paginator.start()
115 | 
116 |     @alr.command(name="create")
117 |     async def alr_create(self, ctx: Context):
118 |         _v = embeds.EmbedBuilder(ctx, items=[CreateAlert(ctx)])
119 | 
120 |         await _v.rendor()
121 | 


--------------------------------------------------------------------------------
/cogs/quomisc/dev.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | 
  5 | if T.TYPE_CHECKING:
  6 |     from core import Quotient
  7 | 
  8 | import asyncio
  9 | import datetime
 10 | 
 11 | import discord
 12 | from discord.ext import commands
 13 | from prettytable import PrettyTable
 14 | 
 15 | from core import Cog, Context
 16 | from models import BlockIdType, BlockList, Commands
 17 | from utils import get_ipm
 18 | 
 19 | from .helper import tabulate_query
 20 | 
 21 | __all__ = ("Dev",)
 22 | 
 23 | 
 24 | class Dev(Cog):
 25 |     def __init__(self, bot: Quotient):
 26 |         self.bot = bot
 27 | 
 28 |     def cog_check(self, ctx: Context):
 29 |         return ctx.author.id in ctx.config.DEVS
 30 | 
 31 |     @commands.group(hidden=True, invoke_without_command=True)
 32 |     async def bl(self, ctx: Context):
 33 |         """Blocklist commands."""
 34 |         await ctx.send_help(ctx.command)
 35 | 
 36 |     @bl.command(name="add")
 37 |     async def bl_add(self, ctx: Context, item: discord.User | int, *, reason: str = None):
 38 |         """Block a user or guild from using the bot."""
 39 |         block_id_type = BlockIdType.USER if isinstance(item, discord.User) else BlockIdType.GUILD
 40 |         block_id = item.id if isinstance(item, discord.User) else item
 41 | 
 42 |         record = await BlockList.get_or_none(block_id=block_id, block_id_type=block_id_type)
 43 |         if record:
 44 |             return await ctx.error(f"{item} is already blocked.")
 45 | 
 46 |         await BlockList.create(block_id=block_id, block_id_type=block_id_type, reason=reason)
 47 |         self.bot.cache.blocked_ids.add(block_id)
 48 |         await ctx.success(f"{item} has been blocked.")
 49 | 
 50 |     @bl.command(name="remove")
 51 |     async def bl_remove(self, ctx: Context, item: discord.User | int):
 52 |         """Unblock a user or guild from using the bot."""
 53 |         block_id = item.id if isinstance(item, discord.User) else item
 54 | 
 55 |         record = await BlockList.get_or_none(block_id=block_id)
 56 |         if not record:
 57 |             return await ctx.error(f"{item} is not blocked.")
 58 | 
 59 |         await record.delete()
 60 |         self.bot.cache.blocked_ids.remove(block_id)
 61 |         await ctx.success(f"{item} has been unblocked.")
 62 | 
 63 |     @commands.command(hidden=True)
 64 |     async def sync(
 65 |         self,
 66 |         ctx: commands.Context,
 67 |         guilds: commands.Greedy[discord.Object],
 68 |         spec: T.Optional[T.Literal["~", "*", "^"]] = None,
 69 |     ) -> None:
 70 |         if not guilds:
 71 |             if spec == "~":
 72 |                 synced = await self.bot.tree.sync(guild=ctx.guild)
 73 |             elif spec == "*":
 74 |                 self.bot.tree.copy_global_to(guild=ctx.guild)
 75 |                 synced = await self.bot.tree.sync(guild=ctx.guild)
 76 |             elif spec == "^":
 77 |                 self.bot.tree.clear_commands(guild=ctx.guild)
 78 |                 await self.bot.tree.sync(guild=ctx.guild)
 79 |                 synced = []
 80 |             else:
 81 |                 synced = await self.bot.tree.sync()
 82 | 
 83 |             await ctx.send(f"Synced {len(synced)} commands {'globally' if spec is None else 'to the current guild.'}")
 84 |             return
 85 | 
 86 |         ret = 0
 87 |         for guild in guilds:
 88 |             try:
 89 |                 await self.bot.tree.sync(guild=guild)
 90 |             except discord.HTTPException:
 91 |                 pass
 92 |             else:
 93 |                 ret += 1
 94 | 
 95 |         await ctx.send(f"Synced the tree to {ret}/{len(guilds)}.")
 96 | 
 97 |     @commands.group(hidden=True, invoke_without_command=True)
 98 |     async def botupdate(self, ctx: Context):
 99 |         await ctx.send_help(ctx.command)
100 | 
101 |     @botupdate.command(name="on")
102 |     async def botmaintenance_on(self, ctx: Context, *, msg: str = None):
103 |         self.bot.lockdown = True
104 |         self.bot.lockdown_msg = msg
105 |         await ctx.success("Now in maintenance mode")
106 |         await asyncio.sleep(120)
107 | 
108 |         if not self.bot.lockdown:
109 |             return await ctx.error("Lockdown mode has been cancelled")
110 | 
111 |         await ctx.success("Reloading...")
112 |         self.bot.reboot()
113 | 
114 |     @botupdate.command(name="off")
115 |     async def botmaintenance_off(self, ctx: Context):
116 |         self.bot.lockdown, self.bot.lockdown_msg = False, None
117 |         await ctx.success("Okay, stopped reload.")
118 | 
119 |     @commands.command(hidden=True)
120 |     async def cmds(self, ctx: Context):
121 |         total_uses = await Commands.all().count()
122 | 
123 |         records = await ctx.db.fetch(
124 |             "SELECT cmd, COUNT(*) AS uses FROM commands GROUP BY cmd ORDER BY uses DESC LIMIT 15 "
125 |         )
126 | 
127 |         table = PrettyTable()
128 |         table.field_names = ["Command", "Invoke Count"]
129 |         for record in records:
130 |             table.add_row([record["cmd"], record["uses"]])
131 | 
132 |         table = table.get_string()
133 |         embed = self.bot.embed(ctx, title=f"Command Usage ({total_uses})")
134 |         embed.description = f"```{table}```"
135 | 
136 |         cmds = sum(1 for i in self.bot.walk_commands())
137 | 
138 |         embed.set_footer(text="Total Commands: {}  | Invoke rate per minute: {}".format(cmds, round(get_ipm(ctx.bot), 2)))
139 | 
140 |         await ctx.send(embed=embed)
141 | 
142 |     @commands.group(hidden=True, invoke_without_command=True, name="history")
143 |     async def command_history(self, ctx):
144 |         """Command history."""
145 |         query = """SELECT
146 |                         CASE failed
147 |                             WHEN TRUE THEN cmd || ' [!]'
148 |                             ELSE cmd
149 |                         END AS "cmd",
150 |                         to_char(used_at, 'Mon DD HH12:MI:SS AM') AS "invoked",
151 |                         user_id,
152 |                         guild_id
153 |                    FROM commands
154 |                    ORDER BY used_at DESC
155 |                    LIMIT 15;
156 |                 """
157 |         await tabulate_query(ctx, query)
158 | 
159 |     @command_history.command(name="for")
160 |     async def command_history_for(self, ctx, days: T.Optional[int] = 7, *, command: str):
161 |         """Command history for a command."""
162 |         query = """SELECT *, t.success + t.failed AS "total"
163 |                    FROM (
164 |                        SELECT guild_id,
165 |                               SUM(CASE WHEN failed THEN 0 ELSE 1 END) AS "success",
166 |                               SUM(CASE WHEN failed THEN 1 ELSE 0 END) AS "failed"
167 |                        FROM commands
168 |                        WHERE cmd=$1
169 |                        AND used_at > (CURRENT_TIMESTAMP - $2::interval)
170 |                        GROUP BY guild_id
171 |                    ) AS t
172 |                    ORDER BY "total" DESC
173 |                    LIMIT 30;
174 |                 """
175 | 
176 |         await tabulate_query(ctx, query, command, datetime.timedelta(days=days))
177 | 
178 |     @command_history.command(name="guild", aliases=["server"])
179 |     async def command_history_guild(self, ctx, guild_id: int):
180 |         """Command history for a guild."""
181 |         query = """SELECT
182 |                         CASE failed
183 |                             WHEN TRUE THEN cmd || ' [!]'
184 |                             ELSE cmd
185 |                         END AS "cmd",
186 |                         channel_id,
187 |                         user_id,
188 |                         used_at
189 |                    FROM commands
190 |                    WHERE guild_id=$1
191 |                    ORDER BY used_at DESC
192 |                    LIMIT 15;
193 |                 """
194 |         await tabulate_query(ctx, query, guild_id)
195 | 
196 |     @command_history.command(name="user", aliases=["member"])
197 |     async def command_history_user(self, ctx, user_id: int):
198 |         """Command history for a user."""
199 |         query = """SELECT
200 |                         CASE failed
201 |                             WHEN TRUE THEN cmd || ' [!]'
202 |                             ELSE cmd
203 |                         END AS "cmd",
204 |                         guild_id,
205 |                         used_at
206 |                    FROM commands
207 |                    WHERE user_id=$1
208 |                    ORDER BY used_at DESC
209 |                    LIMIT 20;
210 |                 """
211 |         await tabulate_query(ctx, query, user_id)
212 | 
213 |     @command_history.command(name="cog")
214 |     async def command_history_cog(self, ctx, days: T.Optional[int] = 7, *, cog: str = None):
215 |         """Command history for a cog or grouped by a cog."""
216 |         interval = datetime.timedelta(days=days)
217 |         if cog is not None:
218 |             cog = self.bot.get_cog(cog)
219 |             if cog is None:
220 |                 return await ctx.send(f"Unknown cog: {cog}")
221 | 
222 |             query = """SELECT *, t.success + t.failed AS "total"
223 |                        FROM (
224 |                            SELECT command,
225 |                                   SUM(CASE WHEN failed THEN 0 ELSE 1 END) AS "success",
226 |                                   SUM(CASE WHEN failed THEN 1 ELSE 0 END) AS "failed"
227 |                            FROM commands
228 |                            WHERE cmd = any($1::text[])
229 |                            AND used_at > (CURRENT_TIMESTAMP - $2::interval)
230 |                            GROUP BY cmd
231 |                        ) AS t
232 |                        ORDER BY "total" DESC
233 |                        LIMIT 30;
234 |                     """
235 |             return await tabulate_query(ctx, query, [c.qualified_name for c in cog.walk_commands()], interval)
236 | 


--------------------------------------------------------------------------------
/cogs/quomisc/helper.py:
--------------------------------------------------------------------------------
 1 | import datetime
 2 | import io
 3 | 
 4 | import discord
 5 | 
 6 | 
 7 | class TabularData:
 8 |     def __init__(self):
 9 |         self._widths = []
10 |         self._columns = []
11 |         self._rows = []
12 | 
13 |     def set_columns(self, columns):
14 |         self._columns = columns
15 |         self._widths = [len(c) + 2 for c in columns]
16 | 
17 |     def add_row(self, row):
18 |         rows = [str(r) for r in row]
19 |         self._rows.append(rows)
20 |         for index, element in enumerate(rows):
21 |             width = len(element) + 2
22 |             if width > self._widths[index]:
23 |                 self._widths[index] = width
24 | 
25 |     def add_rows(self, rows):
26 |         for row in rows:
27 |             self.add_row(row)
28 | 
29 |     def render(self):
30 |         """Renders a table in rST format.
31 |         Example:
32 |         +-------+-----+
33 |         | Name  | Age |
34 |         +-------+-----+
35 |         | Alice | 24  |
36 |         |  Bob  | 19  |
37 |         +-------+-----+
38 |         """
39 |         sep = "+".join("-" * w for w in self._widths)
40 |         sep = f"+{sep}+"
41 | 
42 |         to_draw = [sep]
43 | 
44 |         def get_entry(d):
45 |             elem = "|".join(f"{e:^{self._widths[i]}}" for i, e in enumerate(d))
46 |             return f"|{elem}|"
47 | 
48 |         to_draw.append(get_entry(self._columns))
49 |         to_draw.append(sep)
50 | 
51 |         for row in self._rows:
52 |             to_draw.append(get_entry(row))
53 | 
54 |         to_draw.append(sep)
55 |         return "\n".join(to_draw)
56 | 
57 | 
58 | async def tabulate_query(ctx, query, *args):
59 |     records = await ctx.db.fetch(query, *args)
60 | 
61 |     if len(records) == 0:
62 |         return await ctx.send("No results found.")
63 | 
64 |     headers = list(records[0].keys())
65 |     table = TabularData()
66 |     table.set_columns(headers)
67 |     table.add_rows(list(r.values()) for r in records)
68 |     render = table.render()
69 | 
70 |     fmt = f"```\n{render}\n```"
71 |     if len(fmt) > 2000:
72 |         fp = io.BytesIO(fmt.encode("utf-8"))
73 |         await ctx.send("Too many results...", file=discord.File(fp, "results.txt"))
74 |     else:
75 |         await ctx.send(fmt)
76 | 
77 | 
78 | def format_dt(dt, style=None):
79 |     if dt.tzinfo is None:
80 |         dt = dt.replace(tzinfo=datetime.timezone.utc)
81 | 
82 |     if style is None:
83 |         return f"<t:{int(dt.timestamp())}>"
84 |     return f"<t:{int(dt.timestamp())}:{style}>"
85 | 
86 | 
87 | def format_relative(dt):
88 |     return format_dt(dt, "R")
89 | 
90 | 
91 | # async def find_query(ctx, query):
92 | #     record = await FAQ.filter(aliases__icontains=query).all().first()
93 | #     if record:
94 | #         return record
95 | 
96 | #     return "\n".join(get_close_matches(query, (faq.aliases for faq in await FAQ.all())))
97 | 


--------------------------------------------------------------------------------
/cogs/quomisc/views.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | from datetime import datetime, timedelta
  5 | 
  6 | from models import User
  7 | 
  8 | if typing.TYPE_CHECKING:
  9 |     from core import Quotient
 10 | 
 11 | from contextlib import suppress
 12 | 
 13 | import discord
 14 | 
 15 | from constants import IST
 16 | from core import Context, QuotientView
 17 | from utils import emote
 18 | 
 19 | 
 20 | class BaseView(discord.ui.View):
 21 |     def __init__(self, ctx: Context, *, timeout=30.0):
 22 |         self.ctx = ctx
 23 |         self.message: typing.Optional[discord.Message] = None
 24 |         self.bot: Quotient = ctx.bot
 25 | 
 26 |         super().__init__(timeout=timeout)
 27 | 
 28 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
 29 |         if interaction.user.id != self.ctx.author.id:
 30 |             await interaction.response.send_message(
 31 |                 "Sorry, you can't use this interaction as it is not started by you.",
 32 |                 ephemeral=True,
 33 |             )
 34 |             return False
 35 |         return True
 36 | 
 37 |     async def on_timeout(self) -> None:
 38 |         if hasattr(self, "message"):
 39 |             for b in self.children:
 40 |                 if isinstance(b, discord.ui.Button) and not b.style == discord.ButtonStyle.link:
 41 |                     b.style, b.disabled = discord.ButtonStyle.grey, True
 42 | 
 43 |             with suppress(discord.HTTPException):
 44 |                 if self.message is not None:
 45 |                     await self.message.edit(view=self)
 46 | 
 47 | 
 48 | class VoteButton(BaseView):
 49 |     def __init__(self, ctx: Context):
 50 |         super().__init__(ctx, timeout=None)
 51 | 
 52 |         self.add_item(
 53 |             discord.ui.Button(
 54 |                 style=discord.ButtonStyle.link,
 55 |                 url="https://quotientbot.xyz/vote",
 56 |                 label="Click Here",
 57 |             )
 58 |         )
 59 | 
 60 | 
 61 | class MoneyButton(BaseView):
 62 |     def __init__(self, ctx: Context):
 63 |         super().__init__(ctx)
 64 | 
 65 |         self.ctx = ctx
 66 |         self.bot: Quotient = ctx.bot
 67 | 
 68 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="claim_prime", label="Claim Prime (120 coins)")
 69 |     async def claim_premium(self, interaction: discord.Interaction, button: discord.Button):
 70 |         await interaction.response.defer(ephemeral=True)
 71 | 
 72 |         self.children[0].disabled = True
 73 |         await self.message.edit(view=self)
 74 | 
 75 |         _u = await User.get(pk=self.ctx.author.id)
 76 |         if not _u.money >= 120:
 77 |             return await interaction.followup.send(
 78 |                 f"{emote.error} Insufficient Quo Coins in your account.", ephemeral=True
 79 |             )
 80 | 
 81 |         end_time = (
 82 |             _u.premium_expire_time + timedelta(days=30) if _u.is_premium else datetime.now(tz=IST) + timedelta(days=30)
 83 |         )
 84 | 
 85 |         await User.get(pk=self.ctx.author.id).update(
 86 |             is_premium=True,
 87 |             premium_expire_time=end_time,
 88 |             money=_u.money - 120,
 89 |             premiums=_u.premiums + 1,
 90 |         )
 91 | 
 92 |         member = self.bot.server.get_member(self.ctx.author.id)
 93 |         if member is not None:
 94 |             await member.add_roles(discord.Object(id=self.bot.config.PREMIUM_ROLE), reason="They purchased premium.")
 95 | 
 96 |         await self.ctx.success(
 97 |             "Credited Quotient Prime for 1 Month to your account,\n\n"
 98 |             "Use `qboost` in any server to upgrade it with Prime."
 99 |         )
100 | 
101 | 
102 | class SetupButtonView(QuotientView):
103 |     def __init__(self, ctx: Context):
104 |         super().__init__(ctx, timeout=None)
105 |         self.ctx = ctx
106 | 
107 |     @discord.ui.button(label="setup scrims", custom_id="setup_scrims_button")
108 |     async def setup_scrims_button(self, interaction: discord.Interaction, button: discord.Button):
109 |         await interaction.response.defer()
110 |         return await self.ctx.simple(f"Kindly use `{self.ctx.prefix}sm setup` to setup a scrim.")
111 | 
112 |     @discord.ui.button(label="setup tourney", custom_id="setup_tourney_button")
113 |     async def setup_tourney_button(self, interaction: discord.Interaction, button: discord.Button):
114 |         return await self.ctx.simple(f"Kindly use `{self.ctx.prefix}t setup` to setup a tournament.")
115 | 


--------------------------------------------------------------------------------
/cogs/reminder/__init__.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | 
  5 | if typing.TYPE_CHECKING:
  6 |     from core import Quotient
  7 | 
  8 | import asyncio
  9 | from datetime import datetime, timedelta
 10 | 
 11 | import asyncpg
 12 | import discord
 13 | 
 14 | from core import Cog
 15 | from models import Timer
 16 | from utils import IST
 17 | 
 18 | 
 19 | class Reminders(Cog):
 20 |     """Reminders to do something."""
 21 | 
 22 |     def __init__(self, bot: Quotient):
 23 |         self.bot = bot
 24 |         self._have_data = asyncio.Event()
 25 |         self._current_timer = None
 26 |         self._task = bot.loop.create_task(self.dispatch_timers())
 27 | 
 28 |     def cog_unload(self):
 29 |         self._task.cancel()
 30 | 
 31 |     async def get_active_timer(self, *, days=7):
 32 |         return await Timer.filter(expires__lte=datetime.now(tz=IST) + timedelta(days=days)).order_by("expires").first()
 33 | 
 34 |     async def wait_for_active_timers(self, *, days=7):
 35 |         timer = await self.get_active_timer(days=days)
 36 |         if timer is not None:
 37 |             self._have_data.set()
 38 |             return timer
 39 | 
 40 |         self._have_data.clear()
 41 |         self._current_timer = None
 42 |         await self._have_data.wait()
 43 |         return await self.get_active_timer(days=days)
 44 | 
 45 |     async def call_timer(self, timer: Timer):
 46 |         # delete the timer
 47 |         deleted = await Timer.filter(pk=timer.id, expires=timer.expires).delete()
 48 | 
 49 |         if deleted == 0:  # Probably a task is already deleted or its expire time changed.
 50 |             return
 51 | 
 52 |         # dispatch the event
 53 |         event_name = f"{timer.event}_timer_complete"
 54 |         self.bot.dispatch(event_name, timer)
 55 | 
 56 |     async def dispatch_timers(self):
 57 |         try:
 58 |             while not self.bot.is_closed():
 59 |                 timer = self._current_timer = await self.wait_for_active_timers(days=40)
 60 | 
 61 |                 now = datetime.now(tz=IST)
 62 | 
 63 |                 # print(now, timer.expires)
 64 | 
 65 |                 if timer.expires >= now:
 66 |                     to_sleep = (timer.expires - now).total_seconds()
 67 |                     # print(to_sleep)
 68 |                     await asyncio.sleep(to_sleep)
 69 | 
 70 |                 await self.call_timer(timer)
 71 |         except (OSError, discord.ConnectionClosed, asyncpg.PostgresConnectionError):
 72 |             self._task.cancel()
 73 |             self._task = self.bot.loop.create_task(self.dispatch_timers())
 74 | 
 75 |     async def short_timer_optimisation(self, seconds, timer: Timer):
 76 |         await asyncio.sleep(seconds)
 77 |         event_name = f"{timer.event}_timer_complete"
 78 |         self.bot.dispatch(event_name, timer)
 79 | 
 80 |     async def create_timer(self, *args, **kwargs):
 81 |         when, event, *args = args
 82 | 
 83 |         try:
 84 |             now = kwargs.pop("created")
 85 |         except KeyError:
 86 |             now = datetime.now(tz=IST)
 87 | 
 88 |         delta = (when - now).total_seconds()
 89 | 
 90 |         timer = await Timer.create(
 91 |             expires=when,
 92 |             created=now,
 93 |             event=event,
 94 |             extra={"kwargs": kwargs, "args": args},
 95 |         )
 96 | 
 97 |         # only set the data check if it can be waited on
 98 |         if delta <= (86400 * 40):  # 40 days
 99 |             self._have_data.set()
100 | 
101 |         # check if this timer is earlier than our currently run timer
102 |         if self._current_timer and when < self._current_timer.expires:
103 |             # cancel the task and re-run it
104 |             self._task.cancel()
105 |             self._task = self.bot.loop.create_task(self.dispatch_timers())
106 | 
107 |         return timer
108 | 
109 | 
110 | async def setup(bot: Quotient):
111 |     await bot.add_cog(Reminders(bot))
112 | 


--------------------------------------------------------------------------------
/cogs/utility/__init__.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing
  4 | 
  5 | from discord.utils import escape_markdown, escape_mentions
  6 | 
  7 | from cogs.utility.events import AutoPurgeEvents, ReminderEvents
  8 | 
  9 | if typing.TYPE_CHECKING:
 10 |     from core import Quotient
 11 | 
 12 | from ast import literal_eval as leval
 13 | from contextlib import suppress
 14 | from datetime import timedelta
 15 | from io import BytesIO
 16 | 
 17 | import discord
 18 | from discord.ext import commands
 19 | from humanize import precisedelta
 20 | 
 21 | from core import Cog, Context, embeds
 22 | from models import ArrayAppend, ArrayRemove, AutoPurge, Autorole, Snipe, Tag
 23 | from utils import (
 24 |     QuoCategory,
 25 |     QuoMember,
 26 |     QuoPaginator,
 27 |     QuoRole,
 28 |     QuoTextChannel,
 29 |     TimeText,
 30 |     checks,
 31 |     discord_timestamp,
 32 |     plural,
 33 |     simple_convert,
 34 |     strtime,
 35 |     truncate_string,
 36 | )
 37 | 
 38 | from .functions import TagConverter, TagName, guild_tag_stats, increment_usage, is_valid_name, member_tag_stats
 39 | from .views import *
 40 | 
 41 | 
 42 | class Utility(Cog, name="utility"):
 43 |     def __init__(self, bot: Quotient):
 44 |         self.bot = bot
 45 | 
 46 |     @commands.group(aliases=("timer", "remind"), invoke_without_command=True)
 47 |     async def reminder(self, ctx: Context, *, when: TimeText(commands.clean_content)):  # noqa: F722
 48 |         """Reminds you of something after a certain amount of time.
 49 | 
 50 |         The input can be any direct date (e.g. YYYY-MM-DD) or a human
 51 |         readable offset. Examples:
 52 | 
 53 |         - "next thursday at 3pm do something funny"
 54 |         - "do the dishes tomorrow"
 55 |         - "in 3 days do the thing"
 56 |         - "2d unmute someone"
 57 | 
 58 |         """
 59 |         expire = when.dt
 60 | 
 61 |         if not expire:
 62 |             return await ctx.error(
 63 |                 "I couldn't find time in your input. \n\nTry it like: `qremind me at 9pm to get laid.`"
 64 |             )
 65 | 
 66 |         await self.bot.reminders.create_timer(
 67 |             expire,
 68 |             "reminder",
 69 |             ctx.author.id,
 70 |             ctx.channel.id,
 71 |             when.arg,
 72 |             message_id=ctx.message.id,
 73 |         )
 74 | 
 75 |         await ctx.send(f"Alright **{ctx.author}**, I'll remind you {discord_timestamp(expire)}: {when.arg}")
 76 | 
 77 |     @reminder.command(name="all", ignore_extra=False)
 78 |     async def reminder_list(self, ctx: Context):
 79 |         """Shows the 10 latest currently running reminders."""
 80 |         query = """SELECT id, expires, extra #>> '{args,2}'
 81 |                    FROM timer
 82 |                    WHERE event = 'reminder'
 83 |                    AND extra #>> '{args,0}' = $1
 84 |                    ORDER BY expires;
 85 |                 """
 86 | 
 87 |         records = await ctx.db.fetch(query, str(ctx.author.id))
 88 | 
 89 |         if not records:
 90 |             return await ctx.error("No currently running reminders.")
 91 | 
 92 |         paginator = QuoPaginator(ctx, title=f"Total Reminders: {len(records)}", per_page=10)
 93 | 
 94 |         for _id, expires, message in records:
 95 |             paginator.add_line(f"`{_id}`: {truncate_string(message,40)}({discord_timestamp(expires)})")
 96 | 
 97 |         await paginator.start()
 98 | 
 99 |     @commands.group(invoke_without_command=True)
100 |     @checks.is_mod()
101 |     async def autorole(self, ctx: Context, off: typing.Optional[str]):
102 |         """
103 |         Manage Quotient's autoroles.
104 |         """
105 |         if not off or off.lower() != "off":
106 |             return await ctx.send_help(ctx.command)
107 | 
108 |         record = await Autorole.get_or_none(guild_id=ctx.guild.id)
109 | 
110 |         if not record:
111 |             return await ctx.send(
112 |                 f"You have not set any autorole yet.\n\nDo it like: `{ctx.prefix}autorole humans @role`"
113 |             )
114 | 
115 |         if not any([len(record.humans), len(record.bots)]):
116 |             return await ctx.error("Autoroles already OFF!")
117 |         prompt = await ctx.prompt("Are you sure you want to turn off autorole?")
118 |         if prompt:
119 |             # await Autorole.filter(guild_id=ctx.guild.id).update(humans=list, bots=list)
120 |             await ctx.db.execute("UPDATE autoroles SET humans = '{}' , bots = '{}' WHERE guild_id = $1", ctx.guild.id)
121 |             await ctx.success("Autoroles turned OFF!")
122 |         else:
123 |             await ctx.success("OK!")
124 | 
125 |     @autorole.command(name="humans")
126 |     @checks.is_mod()
127 |     @commands.bot_has_guild_permissions(manage_roles=True)
128 |     async def autorole_humans(self, ctx: Context, *, role: QuoRole):
129 |         """
130 |         Add/ Remove a role to human autoroles.
131 |         """
132 |         record = await Autorole.get_or_none(pk=ctx.guild.id)
133 |         if record is None:
134 |             await Autorole.create(guild_id=ctx.guild.id, humans=[role.id])
135 |             text = f"Added {role.mention} to human autoroles."
136 | 
137 |         else:
138 |             func = (ArrayAppend, ArrayRemove)[role.id in record.humans]
139 |             await Autorole.filter(guild_id=ctx.guild.id).update(humans=func("humans", role.id))
140 |             text = (
141 |                 f"Added {role.mention} to human autoroles."
142 |                 if func == ArrayAppend
143 |                 else f"Removed {role.mention} from human autoroles."
144 |             )
145 | 
146 |         await ctx.success(text)
147 | 
148 |     @autorole.command(name="bots")
149 |     @checks.is_mod()
150 |     @commands.bot_has_guild_permissions(manage_roles=True)
151 |     async def autorole_bots(self, ctx: Context, *, role: QuoRole):
152 |         """
153 |         Add/ Remove a role to bot autoroles.
154 |         """
155 |         record = await Autorole.get_or_none(pk=ctx.guild.id)
156 |         if record is None:
157 |             await Autorole.create(guild_id=ctx.guild.id, bots=[role.id])
158 |             text = f"Added {role.mention} to bot autoroles."
159 | 
160 |         else:
161 |             func = (ArrayAppend, ArrayRemove)[role.id in record.bots]
162 |             await Autorole.filter(guild_id=ctx.guild.id).update(bots=func("bots", role.id))
163 |             text = (
164 |                 f"Added {role.mention} to bot autoroles."
165 |                 if func == ArrayAppend
166 |                 else f"Removed {role.mention} from bot autoroles."
167 |             )
168 | 
169 |         await ctx.success(text)
170 | 
171 |     @autorole.command(name="config")
172 |     @checks.is_mod()
173 |     @commands.bot_has_guild_permissions(manage_roles=True)
174 |     async def autorole_config(self, ctx: Context):
175 |         """
176 |         Get autorole config
177 |         """
178 |         record = await Autorole.get_or_none(pk=ctx.guild.id)
179 |         if not record:
180 |             return await ctx.send(
181 |                 f"You have not set any autorole yet.\n\nDo it like: `{ctx.prefix}autorole humans @role`"
182 |             )
183 | 
184 |         humans = ", ".join(record.human_roles) if list(record.human_roles) else "Not Set!"
185 |         bots = ", ".join(record.bot_roles) if list(record.bot_roles) else "Not Set!"
186 | 
187 |         embed = self.bot.embed(ctx, title="Autorole Config")
188 |         embed.add_field(name="Humans", value=humans, inline=False)
189 |         embed.add_field(name="Bots", value=bots, inline=False)
190 |         await ctx.send(embed=embed)
191 | 
192 |     @commands.hybrid_command(name="embed")
193 |     @commands.has_permissions(manage_messages=True)
194 |     async def embed_send(self, ctx: Context, channel: discord.TextChannel):
195 |         """
196 |         Generate and send embed to specified channel.
197 |         """
198 |         if not channel.permissions_for(ctx.me).embed_links:
199 |             return await ctx.error(f"I need `embed_links` permission in {channel.mention}")
200 | 
201 |         view = embeds.EmbedBuilder(ctx, items=[EmbedSend(channel), EmbedCancel()])
202 |         await view.rendor()
203 | 
204 |     @commands.command(name="quickembed", aliases=["qe"])
205 |     @commands.has_permissions(manage_messages=True, embed_links=True)
206 |     @commands.bot_has_permissions(manage_messages=True, embed_links=True)
207 |     async def quick_embed_command(self, ctx: Context, *, text: str):
208 |         """
209 |         Generates quick embeds.
210 |         Tip: You can send hyperlinks too. Example: `[anytext](any link)`
211 |         """
212 |         embed = self.bot.embed(ctx, description=text)
213 |         if ctx.message.attachments and "image" in ctx.message.attachments[0].content_type:
214 |             embed.set_image(url=ctx.message.attachments[0].proxy_url)
215 |         await ctx.send(embed=embed)
216 |         await ctx.message.delete()
217 | 
218 |     @commands.command()
219 |     @commands.bot_has_permissions(embed_links=True)
220 |     async def snipe(self, ctx: Context, *, channel: typing.Optional[QuoTextChannel]):
221 |         """Snipe last deleted message of a channel."""
222 | 
223 |         channel = channel or ctx.channel
224 | 
225 |         snipe = await Snipe.get_or_none(channel_id=channel.id)
226 |         if not snipe:
227 |             return await ctx.error("There's nothing to snipe :c")
228 | 
229 |         elif snipe.nsfw and not ctx.channel.is_nsfw():
230 |             return await ctx.error("The snipe is marked NSFW but the current channel isn't.")
231 | 
232 |         embed = self.bot.embed(ctx, timestamp=snipe.delete_time)
233 |         embed.description = (
234 |             f"Message sent by **{snipe.author}** was deleted in **{channel}** \n{discord_timestamp(snipe.delete_time)}\n"
235 |             f"\n**__Message Content__**\n{snipe.content}"
236 |         )
237 | 
238 |         embed.set_footer(text="Deleted")
239 |         await ctx.send(embed=embed)
240 | 
241 |     @commands.group(invoke_without_command=True)
242 |     async def tag(self, ctx: Context, *, name: typing.Optional[TagConverter]):
243 |         """Call a tag with its name or id"""
244 |         if name is None:
245 |             return await ctx.send_help(ctx.command)
246 | 
247 |         if name.is_nsfw and not ctx.channel.is_nsfw():
248 |             return await ctx.error("This tag can only be used in NSFW channels.")
249 | 
250 |         if name.is_embed is True:
251 |             _dict = leval(name.content)
252 |             await ctx.send(embed=discord.Embed.from_dict(_dict), reference=ctx.replied_reference)
253 | 
254 |         if not name.content:
255 |             return await ctx.error("Tag doesn't have any content")
256 |         await ctx.send(name.content, reference=ctx.replied_reference)
257 |         await increment_usage(ctx, name.name)
258 | 
259 |     @tag.command(name="raw")
260 |     @commands.bot_has_permissions(attach_files=True)
261 |     async def raw_tag_content(self, ctx: Context, *, name: TagConverter):
262 |         """Get the raw content of the tag"""
263 |         if name.is_nsfw and not ctx.channel.is_nsfw():
264 |             return await ctx.error("This tag can only be used in NSFW channels.")
265 |         if not name.content:
266 |             return await ctx.error("Tag does not have any content")
267 |         temp = escape_markdown(name.content).replace("<", "\\<")  # why not!?
268 |         main = escape_mentions(temp)
269 |         if len(main) > 1990:  # for some reason exact `2000` do not work...
270 |             file_obj = BytesIO(main.encode())
271 |             return await ctx.send(file=discord.File(file_obj, filename="message_too_long.txt"))
272 |         await ctx.send(main, allowed_mentions=discord.AllowedMentions.none())
273 | 
274 |     @tag.command(name="all", aliases=("list",))
275 |     async def all_tags(self, ctx: Context, *, member: typing.Optional[QuoMember]):
276 |         """Get all tags owned by the server or a member"""
277 |         if not member:
278 |             tags = await Tag.filter(guild_id=ctx.guild.id)
279 | 
280 |             if not tags:
281 |                 return await ctx.error("This server doesn't have any tags.")
282 | 
283 |         else:
284 |             tags = await Tag.filter(guild_id=ctx.guild.id, owner_id=member.id)
285 |             if not tags:
286 |                 return await ctx.error(f"{member} doesn't own any tag.")
287 | 
288 |         paginator = QuoPaginator(ctx, title=f"Total Tags: {len(tags)}", per_page=12)
289 | 
290 |         for idx, tag in enumerate(tags, start=1):
291 |             paginator.add_line(f"`{idx:02}` {escape_markdown(tag.name)} (ID: {tag.id})")
292 | 
293 |         await paginator.start()
294 | 
295 |     @tag.command(name="info")
296 |     async def tag_info(self, ctx: Context, *, tag: TagConverter):
297 |         """Information about a tag"""
298 |         embed = self.bot.embed(ctx, title=f"Stats for tag {tag.name}")
299 | 
300 |         user = self.bot.get_user(tag.owner_id) or await self.bot.fetch_user(tag.owner_id)
301 | 
302 |         embed.set_author(name=str(user), icon_url=user.display_avatar.url)
303 | 
304 |         embed.add_field(name="Owner", value=getattr(user, "mention", "Invalid User!"))
305 |         embed.add_field(name="ID:", value=tag.id)
306 |         embed.add_field(name="Uses", value=tag.usage)
307 |         embed.add_field(name="NSFW", value="Yes" if tag.is_nsfw else "No")
308 |         embed.add_field(name="Embed", value="Yes" if tag.is_embed else "No")
309 |         embed.set_footer(text=f"Created At: {strtime(tag.created_at)}")
310 |         await ctx.send(embed=embed)
311 | 
312 |     @tag.command(name="claim")
313 |     async def claim_tag(self, ctx: Context, *, tag: TagConverter):
314 |         """Claims a tag if the original owner left the server."""
315 |         member = await self.bot.get_or_fetch_member(ctx.guild, tag.owner_id)
316 | 
317 |         if member is not None:
318 |             return await ctx.send(f"The owner of this tag ({tag.owner}) is still in the server.")
319 | 
320 |         await Tag.filter(name=tag.name, guild_id=ctx.guild.id).update(owner_id=ctx.author.id)
321 |         await ctx.success("Transfered tag ownership to you.")
322 | 
323 |     @tag.command(name="create")
324 |     async def create_tag_command(self, ctx: Context, name: TagName, *, content: typing.Optional[str] = ""):
325 |         """Create a new tag"""
326 |         if content == "" and not ctx.message.attachments:
327 |             return await ctx.error("Cannot make an empty tag.")
328 | 
329 |         if ctx.message.attachments:
330 |             content += f"\n{ctx.message.attachments[0].proxy_url}"
331 | 
332 |         if len(content) > 1990:
333 |             return await ctx.error("Tag content cannot contain more than 1990 characters.")
334 | 
335 |         if len(name) > 99:
336 |             return await ctx.error("Tag Name cannot contain more that 99 characters.")
337 | 
338 |         if await is_valid_name(ctx, name):
339 |             tag = await Tag.create(name=name, content=content, guild_id=ctx.guild.id, owner_id=ctx.author.id)
340 | 
341 |             await ctx.success(f"Created Tag (ID: `{tag.id}`)")
342 | 
343 |         else:
344 |             await ctx.error("Tag Name is already taken.")
345 | 
346 |     @tag.command(name="delete", aliases=["del"])
347 |     async def delete_tag(self, ctx: Context, *, tag: TagConverter):
348 |         """Delete a tag"""
349 |         tag = tag
350 |         if tag.owner_id != ctx.author.id and not ctx.author.guild_permissions.manage_guild:
351 |             return await ctx.error("This tag doesn't belong to you.")
352 | 
353 |         await Tag.filter(guild_id=ctx.guild.id, name=tag.name, owner_id=tag.owner_id).delete()
354 |         await ctx.success(f"Deleted {tag.name}")
355 | 
356 |     @tag.command(name="transfer")
357 |     async def transfer_tag(self, ctx: Context, member: QuoMember, *, tag: TagConverter):
358 |         """Transfer the ownership of a tag."""
359 |         if tag.owner_id != ctx.author.id:
360 |             return await ctx.error("This tag doesn't belong to you.")
361 | 
362 |         await Tag.filter(id=tag.id).update(owner_id=member.id)
363 |         await ctx.success("Transfer successful.")
364 | 
365 |     @tag.command("nsfw")
366 |     async def nsfw_status_toggle(self, ctx: Context, *, tag: TagConverter):
367 |         """Toggle NSFW for a tag."""
368 |         if tag.owner_id != ctx.author.id and not ctx.author.guild_permissions.manage_guild:
369 |             return await ctx.error("This tag doesn't belong to you.")
370 | 
371 |         await Tag.filter(id=tag.id).update(is_nsfw=not tag.is_nsfw)
372 |         await ctx.success(f"Tag NSFW toggled {'ON' if not tag.is_nsfw else 'OFF'}!")
373 | 
374 |     @tag.command("mine")
375 |     async def get_all_tags(self, ctx: Context):
376 |         """Get a list of all tags owned by you."""
377 |         tags = await Tag.filter(guild_id=ctx.guild.id, owner_id=ctx.author.id)
378 | 
379 |         if not tags:
380 |             return await ctx.error("You do not own any tag.")
381 | 
382 |         paginator = QuoPaginator(ctx, title=f"Tags you own: {len(tags)}", per_page=12)
383 | 
384 |         for idx, tag in enumerate(tags, start=1):
385 |             paginator.add_line(f"`{idx:02}` {escape_markdown(tag.name)} (ID: {tag.id})")
386 | 
387 |         await paginator.start()
388 | 
389 |     @tag.command(name="purge")
390 |     @commands.has_guild_permissions(manage_guild=True)
391 |     async def purge_tags(self, ctx: Context, *, member: QuoMember):
392 |         """Delete all the tags of a member"""
393 |         count = await Tag.filter(owner_id=member.id, guild_id=ctx.guild.id).count()
394 |         if not count:
395 |             return await ctx.error(f"{member} doesn't own any tag.")
396 | 
397 |         await Tag.filter(owner_id=member.id, guild_id=ctx.guild.id).delete()
398 |         await ctx.success(f"Deleted {plural(count): tag|tags} of **{member}**.")
399 | 
400 |     @tag.command(name="edit")
401 |     async def edit_tag(self, ctx: Context, name: TagName, *, content: typing.Optional[str] = ""):
402 |         """Edit a tag"""
403 |         tag = await Tag.get_or_none(name=name, guild_id=ctx.guild.id)
404 |         if not tag:
405 |             return await ctx.error("Tag name is invalid.")
406 | 
407 |         if tag.owner_id != ctx.author.id and not ctx.author.guild_permissions.manage_guild:
408 |             return await ctx.error("This tag doesn't belong to you.")
409 | 
410 |         if len(content) > 1990:
411 |             return await ctx.error("Tag content cannot exceed 1990 characters.")
412 | 
413 |         if content == "" and not ctx.message.attachments:
414 |             return await ctx.error("Cannot edit tag.")
415 | 
416 |         if ctx.message.attachments:
417 |             content += f"\n{ctx.message.attachments[0].proxy_url}"
418 | 
419 |         await Tag.filter(id=tag.id).update(content=content)
420 |         await ctx.success("Tag updated.")
421 | 
422 |     # @tag.command(name="make")
423 |     # async def tag_make(self, ctx: Context):
424 |     #     """Make tags interactively."""
425 | 
426 |     #     def check(message: discord.Message):
427 |     #         if message.content.strip().lower() == "cancel":
428 |     #             raise commands.BadArgument("Alright, reverting all process.")
429 | 
430 |     #         return message.author == ctx.author and ctx.channel == message.channel
431 | 
432 |     #     msg = await ctx.simple("What do you want the tag name to be?")
433 |     #     name = await inputs.string_input(ctx, check, delete_after=True)
434 |     #     await inputs.safe_delete(msg)
435 | 
436 |     #     embed = await ctx.simple(
437 |     #         f"What do you want the content to be?\n\n{keycap_digit(1)} | Simple Text\n{keycap_digit(2)} | Embed"
438 |     #     )
439 |     #     reactions = [keycap_digit(1), keycap_digit(2)]
440 |     #     for reaction in reactions:
441 |     #         await embed.add_reaction(reaction)
442 | 
443 |     @tag.command(name="search")
444 |     async def search_tag(self, ctx: Context, *, name: str):
445 |         """Search in all your tags."""
446 |         tags = await Tag.filter(guild_id=ctx.guild.id, name__icontains=name)
447 | 
448 |         if not tags:
449 |             return await ctx.error("No tags found.")
450 | 
451 |         paginator = QuoPaginator(ctx, title=f"Matching Tags: {len(tags)}", per_page=10)
452 |         for idx, tag in enumerate(tags, start=1):
453 |             paginator.add_line(f"`{idx:02}` {tag.name} (ID: {tag.id})")
454 | 
455 |         await paginator.start()
456 | 
457 |     @tag.command(name="stats")
458 |     async def tag_stats(self, ctx: Context, *, member: typing.Optional[QuoMember]):
459 |         """Tag statistics of the server or a member."""
460 |         if member:
461 |             await member_tag_stats(ctx, member)
462 |         else:
463 |             await guild_tag_stats(ctx)
464 | 
465 |     @commands.group(invoke_without_command=True)
466 |     async def category(self, ctx: Context):
467 |         """hide , delete , unhide or even nuke a category"""
468 |         await ctx.send_help(ctx.command)
469 | 
470 |     @category.command(name="delete")
471 |     @commands.has_permissions(manage_channels=True, manage_guild=True)
472 |     @commands.bot_has_permissions(manage_channels=True)
473 |     async def category_delete(self, ctx: Context, *, category: QuoCategory):
474 |         """Delete a category and all the channels under it."""
475 |         if not category.channels:
476 |             return await ctx.error(f"**{category}** doesn't have any channels.")
477 | 
478 |         prompt = await ctx.prompt(
479 |             message=f"All channels under the category `{category}` will be deleted.\nAre you sure you want to continue?"
480 |         )
481 |         if prompt:
482 |             failed, success = 0, 0
483 | 
484 |             for channel in category.channels:
485 |                 try:
486 |                     await channel.delete()
487 |                     success += 1
488 |                 except discord.HTTPException:
489 |                     failed += 1
490 |                     continue
491 | 
492 |             await category.delete()
493 | 
494 |             with suppress(
495 |                 discord.Forbidden, commands.ChannelNotFound, discord.NotFound, commands.CommandInvokeError
496 |             ):  # yes all these will be raised if the channel is from ones we deleted earlier.
497 |                 await ctx.success(f"Successfully deleted **{category}**. (Deleted: `{success}`, Failed: `{failed}`)")
498 | 
499 |         else:
500 |             await ctx.simple("Ok Aborting.")
501 | 
502 |     @category.command(name="hide")
503 |     @commands.has_permissions(manage_channels=True, manage_guild=True)
504 |     @commands.bot_has_permissions(manage_channels=True)
505 |     async def category_hide(self, ctx: Context, *, category: QuoCategory):
506 |         """Hide a category and all its channels"""
507 |         if not category.channels:
508 |             return await ctx.error(f"**{category}** doesn't have any channels.")
509 | 
510 |         prompt = await ctx.prompt(
511 |             message=f"All channels under the category `{category}` will be hidden.\nAre you sure you want to continue?"
512 |         )
513 |         if prompt:
514 |             failed, success = 0, 0
515 | 
516 |             for channel in category.channels:
517 |                 try:
518 |                     perms = channel.overwrites_for(ctx.guild.default_role)
519 |                     perms.read_messages = False
520 |                     await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
521 |                     success += 1
522 |                 except discord.HTTPException:
523 |                     failed += 1
524 |                     continue
525 | 
526 |             await ctx.success(f"Successfully hidden category. (Hidden: `{success}`, Failed: `{failed}`)")
527 | 
528 |         else:
529 |             await ctx.simple("Ok Aborting.")
530 | 
531 |     @category.command(name="unhide")
532 |     @commands.has_permissions(manage_channels=True, manage_guild=True)
533 |     @commands.bot_has_permissions(manage_channels=True)
534 |     async def category_unhide(self, ctx: Context, *, category: QuoCategory):
535 |         """Unhide a hidden category and all its channels."""
536 |         if not category.channels:
537 |             return await ctx.error(f"**{category}** doesn't have any channels.")
538 | 
539 |         prompt = await ctx.prompt(
540 |             message=f"All channels under the category `{category}` will be unhidden.\nAre you sure you want to continue?"
541 |         )
542 |         if prompt:
543 |             failed, success = 0, 0
544 | 
545 |             for channel in category.channels:
546 |                 try:
547 |                     perms = channel.overwrites_for(ctx.guild.default_role)
548 |                     perms.read_messages = True
549 |                     await channel.set_permissions(ctx.guild.default_role, overwrite=perms)
550 |                     success += 1
551 |                 except discord.HTTPException:
552 |                     failed += 1
553 |                     continue
554 | 
555 |             await ctx.success(f"Successfully unhidden **{category}**. (Unhidden: `{success}`, Failed: `{failed}`)")
556 | 
557 |         else:
558 |             await ctx.simple("Ok Aborting.")
559 | 
560 |     @category.command(name="nuke")
561 |     @commands.has_permissions(manage_channels=True, manage_guild=True)
562 |     @commands.bot_has_permissions(manage_channels=True)
563 |     async def category_nuke(self, ctx: Context, *, category: QuoCategory):
564 |         """
565 |         Delete a category completely and create a new one
566 |         This will delete all the channels under the category and will make a new one with same perms and channels.
567 |         """
568 |         if not category.channels:
569 |             return await ctx.error(f"**{category}** doesn't have any channels.")
570 | 
571 |         prompt = await ctx.prompt(
572 |             message=f"All channels under the category `{category}` will be cloned and deleted.\nAre you sure you want to continue?"
573 |         )
574 |         if prompt:
575 |             failed, success = 0, 0
576 |             for channel in category.channels:
577 |                 if channel.permissions_for(ctx.me).manage_channels:
578 |                     try:
579 |                         position = channel.position
580 |                         clone = await channel.clone(reason=f"Action done by {ctx.author}")
581 |                         await channel.delete()
582 |                         await clone.edit(position=position)
583 |                         success += 1
584 |                     except discord.HTTPException:
585 |                         failed += 1
586 |                         continue
587 | 
588 |             await ctx.success(f"Successfully nuked **{category}**. (Cloned: `{success}`, Failed: `{failed}`)")
589 | 
590 |         else:
591 |             await ctx.simple("Ok Aborting.")
592 | 
593 |     @commands.group(invoke_without_command=True)
594 |     async def autopurge(self, ctx: Context):
595 |         """
596 |         Set Quotient to delete every new message in a channel after  a specific interval.
597 |         """
598 |         await ctx.send_help(ctx.command)
599 | 
600 |     @autopurge.command(name="set")
601 |     @commands.has_permissions(manage_messages=True)
602 |     async def autopurge_set(self, ctx: Context, channel: QuoTextChannel, delete_after: str):
603 |         """
604 |         Set the autopurge for a channel
605 |         `delete_after` should be in this format: s|m|h|d
606 |         """
607 |         if not channel.permissions_for(ctx.me).manage_messages:
608 |             return await ctx.error("I don't have `manage messages` permission in {0}".format(channel.mention))
609 | 
610 |         seconds = simple_convert(delete_after)
611 | 
612 |         if seconds <= 5 or seconds > 604800:
613 |             return await ctx.error("Delete Time must be more than 5s and less than 7d.")
614 | 
615 |         if (count := await AutoPurge.filter(guild_id=ctx.guild.id).count()) >= 1 and not await ctx.is_premium_guild():
616 |             return await ctx.error(
617 |                 "You cannot set autopurge in more than 1 channel in free tier."
618 |                 f"\nHowever [Quotient Premium]({ctx.bot.prime_link}) allows you to set autopurge in unlimited channels."
619 |             )
620 | 
621 |         if channel.id in self.bot.cache.autopurge_channels:
622 |             return await ctx.error(f"**{channel}** is already an autopurge channel.")
623 | 
624 |         await AutoPurge.create(guild_id=ctx.guild.id, channel_id=channel.id, delete_after=seconds)
625 |         self.bot.cache.autopurge_channels.add(channel.id)
626 |         await ctx.success(f"**{channel}** added to autopurge channels.")
627 | 
628 |     @autopurge.command(name="list")
629 |     @commands.has_permissions(manage_messages=True)
630 |     async def autopurge_config(self, ctx: Context):
631 |         """Get a list of all autopurge channels"""
632 |         records = await AutoPurge.filter(guild_id=ctx.guild.id)
633 |         if not records:
634 |             return await ctx.error("This server doesn't have any autopurge channels.")
635 | 
636 |         text = "".join(
637 |             f"`{idx:02}` | {getattr(record.channel, 'mention', 'Deleted Channel')} ({precisedelta(timedelta(seconds=record.delete_after))})\n"
638 |             for idx, record in enumerate(records, start=1)
639 |         )
640 |         await ctx.send(embed=self.bot.embed(ctx, description=text, title="AutoPurge List"), embed_perms=True)
641 | 
642 |     @autopurge.command(name="remove")
643 |     @commands.has_permissions(manage_messages=True)
644 |     async def autopurge_remove(self, ctx: Context, *, channel: QuoTextChannel):
645 |         """Remove a channel from autopurge"""
646 |         if channel.id not in self.bot.cache.autopurge_channels:
647 |             return await ctx.error(f"{channel} is not an autopurge channel.")
648 | 
649 |         self.bot.cache.autopurge_channels.discard(channel.id)
650 |         await AutoPurge.filter(channel_id=channel.id, guild_id=ctx.guild.id).delete()
651 |         await ctx.success(f"**{channel}** removed from autopurge channels.")
652 | 
653 | 
654 | async def setup(bot: Quotient) -> None:
655 |     await bot.add_cog(Utility(bot))
656 |     await bot.add_cog(AutoPurgeEvents(bot))
657 |     await bot.add_cog(ReminderEvents(bot))
658 | 


--------------------------------------------------------------------------------
/cogs/utility/events/__init__.py:
--------------------------------------------------------------------------------
1 | from .autopurge import AutoPurgeEvents
2 | from .reminder import ReminderEvents
3 | 


--------------------------------------------------------------------------------
/cogs/utility/events/autopurge.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from contextlib import suppress
 9 | from datetime import datetime, timedelta
10 | 
11 | import discord
12 | 
13 | from constants import IST
14 | from core import Cog
15 | from models import AutoPurge, Snipe, Timer
16 | 
17 | 
18 | class AutoPurgeEvents(Cog):
19 |     def __init__(self, bot: Quotient):
20 |         self.bot = bot
21 |         self.bot.loop.create_task(self.delete_older_snipes())
22 | 
23 |     async def delete_older_snipes(self):  # we delete snipes that are older than 10 days
24 |         await self.bot.wait_until_ready()
25 |         await Snipe.filter(delete_time__lte=(datetime.now(tz=IST) - timedelta(days=10))).delete()
26 | 
27 |     @Cog.listener()
28 |     async def on_message_delete(self, message: discord.Message):
29 |         if not message.guild or message.author.bot:
30 |             return
31 | 
32 |         channel = message.channel
33 |         content = message.content if message.content else "*[Content Unavailable]*"
34 | 
35 |         if not channel.type in (
36 |             discord.ChannelType.text,
37 |             discord.ChannelType.private_thread,
38 |             discord.ChannelType.public_thread,
39 |         ):
40 |             return
41 | 
42 |         await Snipe.update_or_create(
43 |             channel_id=channel.id,
44 |             defaults={
45 |                 "author_id": message.author.id,
46 |                 "content": content,
47 |                 "nsfw": channel.is_nsfw(),
48 |             },
49 |         )
50 | 
51 |     @Cog.listener()
52 |     async def on_message(self, message: discord.Message):
53 |         if not message.guild or not message.channel.id in self.bot.cache.autopurge_channels:
54 |             return
55 | 
56 |         record = await AutoPurge.get_or_none(channel_id=message.channel.id)
57 |         if not record:
58 |             return self.bot.cache.autopurge_channels.discard(message.channel.id)
59 | 
60 |         await self.bot.reminders.create_timer(
61 |             datetime.now(tz=IST) + timedelta(seconds=record.delete_after),
62 |             "autopurge",
63 |             message_id=message.id,
64 |             channel_id=message.channel.id,
65 |         )
66 | 
67 |     @Cog.listener()
68 |     async def on_autopurge_timer_complete(self, timer: Timer):
69 |         message_id, channel_id = timer.kwargs["message_id"], timer.kwargs["channel_id"]
70 | 
71 |         check = await AutoPurge.get_or_none(channel_id=channel_id)
72 |         if not check:
73 |             return
74 | 
75 |         channel = check.channel
76 |         if not channel:
77 |             return
78 | 
79 |         message = channel.get_partial_message(message_id)
80 |         with suppress(discord.NotFound, discord.Forbidden, discord.HTTPException):
81 |             msg = await message.fetch()
82 |             if not msg.pinned:
83 |                 await msg.delete()
84 | 
85 |     @Cog.listener()
86 |     async def on_guild_channel_delete(self, channel: discord.TextChannel):
87 |         if channel.id in self.bot.cache.autopurge_channels:
88 |             await AutoPurge.filter(channel_id=channel.id).delete()
89 |             self.bot.cache.autopurge_channels.discard(channel.id)
90 | 


--------------------------------------------------------------------------------
/cogs/utility/events/reminder.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from contextlib import suppress
 9 | 
10 | import discord
11 | 
12 | from core import Cog
13 | from models import Timer
14 | from utils import discord_timestamp
15 | 
16 | 
17 | class ReminderEvents(Cog):
18 |     def __init__(self, bot: Quotient):
19 |         self.bot = bot
20 | 
21 |     @Cog.listener()
22 |     async def on_reminder_timer_complete(self, timer: Timer):
23 |         author_id, channel_id, message = timer.args
24 | 
25 |         try:
26 |             channel = self.bot.get_channel(channel_id) or (await self.bot.fetch_channel(channel_id))
27 |         except discord.HTTPException:
28 |             return
29 | 
30 |         guild_id = channel.guild.id if isinstance(channel, (discord.TextChannel, discord.Thread)) else "@me"
31 |         message_id = timer.kwargs["message_id"]
32 |         msg = f"{discord_timestamp(timer.created)}: {message}"
33 | 
34 |         jump_url = f"https://discord.com/channels/{guild_id}/{channel.id}/{message_id}"
35 | 
36 |         v = discord.ui.View(timeout=None)
37 |         v.add_item(discord.ui.Button(label="Jump to Original Message", url=jump_url, style=discord.ButtonStyle.link))
38 | 
39 |         embed = discord.Embed(
40 |             color=self.bot.color,
41 |             title=f"Reminder #{timer.id}",
42 |             description=msg,
43 |             url=jump_url,
44 |             timestamp=self.bot.current_time,
45 |         )
46 | 
47 |         with suppress(discord.HTTPException, discord.Forbidden, AttributeError):
48 |             await channel.send(f"<@{author_id}>", embed=embed, view=v)
49 | 


--------------------------------------------------------------------------------
/cogs/utility/functions.py:
--------------------------------------------------------------------------------
  1 | from discord.ext import commands
  2 | 
  3 | from core import Context
  4 | from models import Tag
  5 | from utils.converters import QuoMember
  6 | 
  7 | 
  8 | class TagName(commands.clean_content):
  9 |     def __init__(self, *, lower=False):
 10 |         self.lower = lower
 11 |         super().__init__()
 12 | 
 13 |     async def convert(self, ctx, argument):
 14 |         converted = await super().convert(ctx, argument)
 15 |         lower = converted.lower().strip()
 16 | 
 17 |         if not lower:
 18 |             raise commands.BadArgument("Missing tag name.")
 19 | 
 20 |         if len(lower) > 100:
 21 |             raise commands.BadArgument("Tag name is a maximum of 100 characters.")
 22 | 
 23 |         first_word, _, _ = lower.partition(" ")
 24 | 
 25 |         root = ctx.bot.get_command("tag")
 26 |         if first_word in root.all_commands:
 27 |             raise commands.BadArgument("This tag name starts with a reserved word.")
 28 | 
 29 |         return converted if not self.lower else lower
 30 | 
 31 | 
 32 | class TagConverter(commands.Converter):
 33 |     async def convert(self, ctx, argument: str):
 34 |         try:
 35 |             argument = int(argument)
 36 |             tag = await Tag.get_or_none(id=argument, guild_id=ctx.guild.id)
 37 | 
 38 |         except ValueError:
 39 |             tag = await Tag.get_or_none(guild_id=ctx.guild.id, name=argument)
 40 | 
 41 |         if not tag:
 42 |             search = await Tag.filter(guild_id=ctx.guild.id, name__icontains=argument).limit(3)
 43 |             text = f"**{argument}** is not a valid Tag Name or ID."
 44 |             if search:
 45 |                 tags = "\n".join((f"- {tag.name}" for tag in search))
 46 |                 text += f"\n\nMaybe you were looking for:\n{tags}"
 47 |             raise commands.BadArgument(text)
 48 | 
 49 |         return tag
 50 | 
 51 | 
 52 | async def is_valid_name(ctx: Context, name: str) -> bool:
 53 |     tag = await Tag.get_or_none(name=name, guild_id=ctx.guild.id)
 54 | 
 55 |     return not tag
 56 | 
 57 | 
 58 | async def increment_usage(ctx: Context, name) -> None:
 59 |     query = "UPDATE tags SET usage = usage + 1 WHERE guild_id = $1 AND name = $2"
 60 |     await ctx.db.execute(query, ctx.guild.id, name)
 61 | 
 62 | 
 63 | def emojize(seq):
 64 |     emoji = 129351
 65 |     for index, value in enumerate(seq):
 66 |         yield chr(emoji + index), value
 67 | 
 68 | 
 69 | async def guild_tag_stats(ctx: Context):
 70 |     e = ctx.bot.embed(ctx, title="Tag Stats")
 71 |     e.set_footer(text="These statistics are server-specific.")
 72 | 
 73 |     records = await Tag.filter(guild_id=ctx.guild.id).all().order_by("-usage").only("id", "name", "usage").limit(3)
 74 | 
 75 |     if not records:
 76 |         e.description = "No tag statistics here."
 77 | 
 78 |     else:
 79 |         e.description = f"{len(records)} tags, {sum(t.usage for t in records)} tag uses"
 80 | 
 81 |     value = "\n".join(f"{emoji}: {tag.name} ({tag.usage} uses)" for (emoji, (tag)) in emojize(records))
 82 | 
 83 |     e.add_field(name="Top Tags", value=value, inline=False)
 84 | 
 85 |     query = """SELECT
 86 |                     COUNT(*) AS tag_uses,
 87 |                     user_id
 88 |                    FROM commands
 89 |                    WHERE guild_id=$1 AND cmd='tag'
 90 |                    GROUP BY user_id
 91 |                    ORDER BY COUNT(*) DESC
 92 |                    LIMIT 3;
 93 |                 """
 94 | 
 95 |     records = await ctx.db.fetch(query, ctx.guild.id)
 96 | 
 97 |     if len(records) < 3:
 98 |         records.extend((None, None) for _ in range(3 - len(records)))
 99 | 
100 |     value = "\n".join(
101 |         f"{emoji}: <@{author_id}> ({uses} times)" if author_id else f"{emoji}: No one!"
102 |         for (emoji, (uses, author_id)) in emojize(records)
103 |     )
104 | 
105 |     e.add_field(name="Top Tag Users", value=value, inline=False)
106 | 
107 |     query = """SELECT
108 |                        COUNT(*) AS "Tags",
109 |                        owner_id
110 |                    FROM tags
111 |                    WHERE guild_id=$1
112 |                    GROUP BY owner_id
113 |                    ORDER BY COUNT(*) DESC
114 |                    LIMIT 3;
115 |                 """
116 |     # I don't think they made group_by clause in tortoise
117 |     records = await ctx.db.fetch(query, ctx.guild.id)
118 |     if not records:
119 |         text = "No statistics to show here."
120 |     else:
121 |         value = "\n".join(f"{emoji}: <@{owner_id}> ({count} tags)" for (emoji, (count, owner_id)) in emojize(records))
122 | 
123 |     e.add_field(name="Top Tag Creators", value=value, inline=False)
124 |     await ctx.send(embed=e, embed_perms=True)
125 | 
126 | 
127 | async def member_tag_stats(ctx: Context, member: QuoMember):
128 |     e = ctx.bot.embed(ctx)
129 |     e.set_author(name=str(member), icon_url=member.display_avatar.url)
130 | 
131 |     e.set_footer(text="These statistics are server-specific.")
132 | 
133 |     query = """SELECT COUNT(*)
134 |                    FROM commands
135 |                    WHERE guild_id=$1 AND cmd='tag' AND user_id=$2
136 |                 """
137 | 
138 |     count = await ctx.db.fetchrow(query, ctx.guild.id, member.id)
139 | 
140 |     query = """SELECT
141 |                     name,
142 |                     usage,
143 |                     COUNT(*) OVER() AS "Count",
144 |                     SUM(usage) OVER () AS "Uses"
145 |                 FROM tags
146 |                 WHERE guild_id=$1 AND owner_id=$2
147 |                 ORDER BY usage DESC
148 |                 LIMIT 3;
149 |                 """
150 | 
151 |     records = await ctx.db.fetch(query, ctx.guild.id, member.id)
152 | 
153 |     if len(records) > 1:
154 |         owned = records[0]["Count"]
155 |         uses = records[0]["Uses"]
156 |     else:
157 |         owned = "None"
158 |         uses = 0
159 | 
160 |     e.add_field(name="Owned Tags", value=owned)
161 |     e.add_field(name="Owned Tag Uses", value=uses)
162 |     e.add_field(name="Tag Command Uses", value=count[0])
163 | 
164 |     if len(records) < 3:
165 |         records.extend((None, None, None, None) for _ in range(3 - len(records)))
166 | 
167 |     emoji = 129351
168 | 
169 |     for offset, (name, uses, _, _) in enumerate(records):
170 |         value = f"{name} ({uses} uses)" if name else "Nothing!"
171 |         e.add_field(name=f"{chr(emoji + offset)} Owned Tag", value=value)
172 | 
173 |     await ctx.send(embed=e, embed_perms=True)
174 | 


--------------------------------------------------------------------------------
/cogs/utility/views/__init__.py:
--------------------------------------------------------------------------------
1 | from .embeds import *
2 | 


--------------------------------------------------------------------------------
/cogs/utility/views/embeds.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing as T
 4 | 
 5 | import discord
 6 | 
 7 | from core.embeds import EmbedBuilder
 8 | from utils import emote
 9 | 
10 | __all__ = ("EmbedSend", "EmbedCancel")
11 | 
12 | 
13 | class EmbedSend(discord.ui.Button):
14 |     view: EmbedBuilder
15 | 
16 |     def __init__(self, channel: discord.TextChannel):
17 |         self.channel = channel
18 |         super().__init__(label="Send to #{0}".format(channel.name), style=discord.ButtonStyle.green)
19 | 
20 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
21 |         user = interaction.user
22 |         if not self.channel.permissions_for(user).send_messages:
23 |             return await interaction.response.send_message(
24 |                 f"You do not have the `send_messages` permission for the {self.channel.mention} channel."
25 |             )
26 | 
27 |         try:
28 |             m: T.Optional[discord.Message] = await self.channel.send(embed=self.view.embed)
29 | 
30 |         except Exception as e:
31 |             await interaction.response.send_message(f"An error occured: {e}", ephemeral=True)
32 | 
33 |         else:
34 |             await interaction.response.send_message(
35 |                 f"{emote.check} | Embed was sent to {self.channel.mention} ([Jump URL](<{m.jump_url}>))", ephemeral=True
36 |             )
37 |             await self.view.on_timeout()
38 | 
39 | 
40 | class EmbedCancel(discord.ui.Button):
41 |     view: EmbedBuilder
42 | 
43 |     def __init__(self):
44 |         super().__init__(label="Cancel", style=discord.ButtonStyle.red)
45 | 
46 |     async def callback(self, interaction: discord.Interaction) -> T.Any:
47 |         await interaction.response.send_message(f"{emote.xmark} | Embed sending cancelled.", ephemeral=True)
48 |         await self.view.on_timeout()
49 | 


--------------------------------------------------------------------------------
/config.py:
--------------------------------------------------------------------------------
 1 | # for tortoise-orm
 2 | 
 3 | TORTOISE = {}
 4 | 
 5 | 
 6 | POSTGRESQL = {}
 7 | 
 8 | EXTENSIONS = ()
 9 | 
10 | DISCORD_TOKEN = ""
11 | 
12 | COLOR = 0x00FFB3
13 | 
14 | FOOTER = "quo is lub!"
15 | 
16 | PREFIX = "q"
17 | 
18 | SERVER_LINK = ""
19 | 
20 | BOT_INVITE = ""
21 | 
22 | WEBSITE = ""
23 | 
24 | REPOSITORY = ""
25 | 
26 | DEVS = ()
27 | 
28 | # LOGS
29 | SHARD_LOG = ""
30 | ERROR_LOG = ""
31 | PUBLIC_LOG = ""
32 | 


--------------------------------------------------------------------------------
/constants.py:
--------------------------------------------------------------------------------
  1 | import random
  2 | from contextlib import suppress
  3 | from datetime import datetime, timedelta
  4 | from enum import Enum
  5 | 
  6 | import discord
  7 | import pytz
  8 | 
  9 | import config
 10 | 
 11 | 
 12 | class _Sentinel:
 13 |     def __repr__(self):
 14 |         return "<MISSING>"
 15 | 
 16 | 
 17 | class Day(Enum):
 18 |     monday = "monday"
 19 |     tuesday = "tuesday"
 20 |     wednesday = "wednesday"
 21 |     thursday = "thursday"
 22 |     friday = "friday"
 23 |     saturday = "saturday"
 24 |     sunday = "sunday"
 25 | 
 26 | 
 27 | class PremiumPurchase(Enum):
 28 |     GIFT = "gift"
 29 |     PARTNERSHIP = "partner"
 30 |     SHOP = "shop"
 31 |     REGULAR = "regular"
 32 | 
 33 | 
 34 | class PartnerRequest(Enum):
 35 |     pending = "1"
 36 |     approved = "2"
 37 |     denied = "3"
 38 | 
 39 | 
 40 | class EsportsType(Enum):
 41 |     tourney = "tourney"
 42 |     scrim = "scrim"
 43 | 
 44 | 
 45 | class AutocleanType(Enum):
 46 |     channel = "channel"
 47 |     role = "role"
 48 | 
 49 | 
 50 | class SSType(Enum):
 51 |     yt = "youtube"
 52 |     insta = "instagram"
 53 |     rooter = "rooter"
 54 |     loco = "loco"
 55 |     anyss = "Any SS"
 56 |     custom = "custom"
 57 | 
 58 | 
 59 | class EsportsLog(Enum):
 60 |     open = "open"
 61 |     closed = "closed"
 62 |     success = "reg_success"
 63 | 
 64 | 
 65 | class EsportsRole(Enum):
 66 |     ping = "ping_role"
 67 |     open = "open_role"
 68 | 
 69 | 
 70 | class RegDeny(Enum):
 71 |     botmention = "mentioned bots"
 72 |     nomention = "insufficient mentions"
 73 |     banned = "banned"
 74 |     multiregister = "multiregister"
 75 |     noteamname = "no_team_name"
 76 |     reqperms = "lack_permissions"
 77 |     duplicate = "duplicate_name"
 78 |     bannedteammate = "banned_teammate"
 79 |     nolines = "no_lines"
 80 |     faketag = "fake_tag"
 81 | 
 82 | 
 83 | class RegMsg(Enum):
 84 |     sopen = "Scrim Registration Open"
 85 |     sclose = "Scrim Registration Close"
 86 |     topen = "Tourney Registration Open"
 87 |     tclose = "Tourney Registration Close"
 88 | 
 89 | 
 90 | class LockType(Enum):
 91 |     channel = "channel"
 92 |     guild = "guild"
 93 |     category = "category"
 94 |     maintenance = "maintenance"
 95 | 
 96 | 
 97 | class ScrimBanType(Enum):
 98 |     ban = "banned"
 99 |     unban = "unbanned"
100 | 
101 | 
102 | bot_colors = {
103 |     746348747918934096: 0x00FFB3,
104 |     744990850064580660: 0xF3B82B,
105 |     846339012607082506: 0x87EA5C,
106 |     902856923311919104: 0xFF4E4A,
107 |     902857046574129172: 0x5F6FFA,
108 |     902857418390765569: 0xFFFFFF,
109 | }
110 | 
111 | perks = {
112 |     "Premium Role": ["❌", "✅"],
113 |     "Scrims": ["3", "Unlimited"],
114 |     "Tourneys": ["2", "Unlimited"],
115 |     "TagCheck": ["1", "Unlimited"],
116 |     "EasyTags": ["1", "Unlimited"],
117 |     "Autorole": ["1", "Unlimited"],
118 |     "Custom Footer": ["❌", "✅"],
119 |     "Custom Color": ["❌", "✅"],
120 |     "Giveaway": ["5", "Unlimited"],
121 |     "Edit Ptable Watermark": ["❌", "✅"],
122 |     "Autopurge": ["1", "Unlimited"],
123 | }
124 | 
125 | 
126 | def random_greeting():
127 |     greetings = [
128 |         "Hello, sunshine!",
129 |         "Peek-a-boo!",
130 |         "Howdy-doody!",
131 |         "Ahoy, matey!",
132 |         "Hiya!",
133 |         "What’s crackin’?",
134 |         "Howdy, howdy ,howdy!",
135 |         "Yo!",
136 |         "I like your face.",
137 |         "Bonjour!",
138 |         "Yo! You know who this is.",
139 |     ]
140 |     return random.choice(greetings)
141 | 
142 | 
143 | def random_thanks():
144 |     msges = (
145 |         "https://cdn.discordapp.com/attachments/877888851241238548/877890130478784532/unknown.png",
146 |         "https://cdn.discordapp.com/attachments/877888851241238548/877890377426821140/unknown.png",
147 |         "https://cdn.discordapp.com/attachments/877888851241238548/877890550399918122/unknown.png",
148 |         "https://cdn.discordapp.com/attachments/877888851241238548/877891011349725194/unknown.png",
149 |         "https://cdn.discordapp.com/attachments/877888851241238548/877891209421549628/unknown.png",
150 |         "https://cdn.discordapp.com/attachments/877888851241238548/877891348869550100/unknown.png",
151 |         "https://cdn.discordapp.com/attachments/877888851241238548/877891767058444359/unknown.png",
152 |         "https://cdn.discordapp.com/attachments/877888851241238548/877891874671706162/unknown.png",
153 |         "https://cdn.discordapp.com/attachments/877888851241238548/877892011720572988/unknown.png",
154 |         "https://cdn.discordapp.com/attachments/829953427336593429/878898567509573652/unknown.png",
155 |         "https://cdn.discordapp.com/attachments/877888851241238548/881575840578695178/unknown.png",
156 |         "https://cdn.discordapp.com/attachments/877888851241238548/881576005498732625/unknown.png",
157 |         "https://cdn.discordapp.com/attachments/877888851241238548/881576299137761350/unknown.png",
158 |         "https://cdn.discordapp.com/attachments/851846932593770496/886275684304044142/unknown.png",
159 |     )
160 |     return random.choice(msges)
161 | 
162 | 
163 | tips = (
164 |     "We have an awesome support server:\ndiscord.gg/aBM5xz6",
165 |     "You can set custom reactions for tourneys & scrims with Quotient Pro.",
166 |     "I like your face : )",  # I really do
167 |     "You can add a role to multiple users with `role @role @user @user2...` command.",
168 |     "Quotient can detect and verify youtube/insta/loco,etc. screenshots (`ssverify` cmd).",
169 |     "You can buy Quotient Pro for 29INR only at <https://quotientbot.xyz/premium>",
170 |     "You can send customized embeds with `/embed` command.",
171 |     "Scrims Slot Cancel-Claim is available for free with `slotm` command.",
172 |     "You can create tourney groups with `tourney` command.",
173 |     "Scrims Open & Close messages can be designed with `sm` command.",
174 |     "With Quotient Pro you can set custom DM message.",
175 |     "We also make custom bots, checkout: https://discord.gg/7bKA8kZd44 ",
176 | )
177 | 
178 | 
179 | async def show_tip(ctx):
180 |     if ctx.author.id in config.DEVS:
181 |         return
182 | 
183 |     if random.randint(45, 69) == 69:
184 |         with suppress(discord.HTTPException, discord.Forbidden):
185 |             await ctx.send(f"**Did You Know?:** {random.choice(tips)}")
186 | 
187 | 
188 | async def remind_premium(ctx):
189 |     if random.randint(1, 3) != 1:
190 |         return
191 | 
192 |     from cogs.premium.views import PremiumPurchaseBtn
193 |     from models import Guild
194 |     from utils import discord_timestamp
195 | 
196 |     guild = await Guild.get_or_none(
197 |         pk=ctx.guild.id, is_premium=True, premium_end_time__lte=ctx.bot.current_time + timedelta(days=5)
198 |     )
199 |     if not guild:
200 |         return
201 | 
202 |     if guild.premium_end_time < ctx.bot.current_time:
203 |         return
204 | 
205 |     _e = discord.Embed(color=discord.Color.red(), title="Premium Ending Soon....")
206 |     _e.description = (
207 |         f"Your Quotient Premium subscription is ending {discord_timestamp(guild.premium_end_time)}\n\n"
208 |         "*Click the button to renew your subscription.*"
209 |     )
210 |     v = discord.ui.View(timeout=None)
211 |     v.add_item(PremiumPurchaseBtn(label="Renew Premium"))
212 | 
213 |     try:
214 |         await ctx.reply(embed=_e, view=v)
215 |     except discord.HTTPException:
216 |         return
217 | 
218 | 
219 | class HelpGIF(Enum):
220 |     pass
221 | 
222 | 
223 | MISSING = _Sentinel()
224 | IST = pytz.timezone("Asia/Kolkata")
225 | 


--------------------------------------------------------------------------------
/core/Bot.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from typing import TYPE_CHECKING, Any, AsyncGenerator, Callable, Coroutine, Dict, Iterable, List, Optional, Union
  4 | 
  5 | if TYPE_CHECKING:
  6 |     from ..cogs.reminder import Reminders
  7 | 
  8 | import asyncio
  9 | import itertools
 10 | import os
 11 | import time
 12 | from datetime import datetime, timedelta
 13 | 
 14 | import aiohttp
 15 | import discord
 16 | from aiocache import cached
 17 | from discord import AllowedMentions, Intents
 18 | from discord.ext import commands
 19 | from lru import LRU
 20 | from tortoise import Tortoise
 21 | 
 22 | import config as cfg
 23 | import constants as csts
 24 | from models import Guild, Timer
 25 | 
 26 | from .cache import CacheManager
 27 | from .Context import Context
 28 | from .Help import HelpCommand
 29 | 
 30 | intents = Intents.default()
 31 | intents.members = True
 32 | intents.message_content = True
 33 | 
 34 | 
 35 | os.environ["JISHAKU_HIDE"] = "True"
 36 | os.environ["JISHAKU_NO_UNDERSCORE"] = "True"
 37 | os.environ["JISHAKU_NO_DM_TRACEBACK"] = "True"
 38 | os.environ["OMP_THREAD_LIMIT"] = "1"
 39 | 
 40 | __all__ = ("Quotient", "bot")
 41 | 
 42 | 
 43 | on_startup: List[Callable[["Quotient"], Coroutine]] = []
 44 | 
 45 | 
 46 | class Quotient(commands.AutoShardedBot):
 47 |     def __init__(self, **kwargs: Any) -> None:
 48 |         super().__init__(
 49 |             command_prefix=self.get_prefix,
 50 |             intents=intents,
 51 |             max_messages=1000,
 52 |             strip_after_prefix=True,
 53 |             case_insensitive=True,
 54 |             help_command=HelpCommand(),
 55 |             chunk_guilds_at_startup=False,
 56 |             allowed_mentions=AllowedMentions(everyone=False, roles=False, replied_user=True, users=True),
 57 |             activity=discord.Activity(type=discord.ActivityType.listening, name="qsetup | qhelp"),
 58 |             proxy=getattr(cfg, "PROXY_URI", None),
 59 |             **kwargs,
 60 |         )
 61 | 
 62 |         self.loop = asyncio.get_event_loop()
 63 |         self.start_time = datetime.now(tz=csts.IST)
 64 |         self.cmd_invokes = 0
 65 |         self.seen_messages = 0
 66 | 
 67 |         self.persistent_views_added = False
 68 |         self.sio = None
 69 | 
 70 |         self.lockdown: bool = False
 71 |         self.lockdown_msg: Optional[str] = None
 72 |         self._BotBase__cogs = commands.core._CaseInsensitiveDict()
 73 | 
 74 |         self.message_cache: Dict[int, Any] = LRU(1024)  # type: ignore
 75 | 
 76 |     @on_startup.append
 77 |     async def __load_extensions(self):
 78 |         for ext in self.config.EXTENSIONS:
 79 |             await self.load_extension(ext)
 80 |             print(f"Loaded extension: {ext}")
 81 | 
 82 |     @on_startup.append
 83 |     async def __load_presistent_views(self):
 84 |         from cogs.esports.views import GroupRefresh, ScrimsSlotmPublicView, SlotlistEditButton, TourneySlotManager
 85 |         from models import Scrim, ScrimsSlotManager, TGroupList, Tourney
 86 | 
 87 |         # Persistent views
 88 |         async for record in ScrimsSlotManager.all():
 89 |             self.add_view(ScrimsSlotmPublicView(record), message_id=record.message_id)
 90 | 
 91 |         async for tourney in Tourney.filter(slotm_message_id__isnull=False):
 92 |             self.add_view(
 93 |                 TourneySlotManager(self, tourney=tourney),
 94 |                 message_id=tourney.slotm_message_id,
 95 |             )
 96 | 
 97 |         async for scrim in Scrim.filter(slotlist_message_id__isnull=False):
 98 |             self.add_view(SlotlistEditButton(self, scrim), message_id=scrim.slotlist_message_id)
 99 | 
100 |         async for record in TGroupList.all():
101 |             self.add_view(GroupRefresh(), message_id=record.message_id)
102 | 
103 |         print("Persistent views: Loaded them too ")
104 | 
105 |     @on_startup.append
106 |     async def __chunk_prime_guilds(self):
107 |         from models import Guild
108 | 
109 |         async for g in Guild.filter(is_premium=True):
110 |             if (_guild := self.get_guild(g.pk)) and not _guild.chunked:
111 |                 self.loop.create_task(_guild.chunk())
112 | 
113 |     @property
114 |     def config(self) -> cfg:
115 |         """import and return config.py"""
116 |         return __import__("config")
117 | 
118 |     @property
119 |     def db(self):
120 |         """to execute raw queries"""
121 |         return Tortoise.get_connection("default")._pool
122 | 
123 |     @property
124 |     def prime_link(self):
125 |         return "https://quotientbot.xyz/premium"
126 | 
127 |     @property
128 |     def color(self):
129 |         return self.config.COLOR
130 | 
131 |     def reboot(self):
132 |         return os.system("pm2 reload quotient")
133 | 
134 |     async def init_quo(self):
135 |         """Instantiating aiohttps ClientSession and telling tortoise to create relations"""
136 |         self.session = aiohttp.ClientSession(loop=self.loop)
137 |         await Tortoise.init(cfg.TORTOISE)
138 |         await Tortoise.generate_schemas(safe=True)
139 | 
140 |         self.cache = CacheManager(self)
141 |         await self.cache.fill_temp_cache()
142 | 
143 |         # Initializing Models (Assigning Bot attribute to all models)
144 |         for mname, model in Tortoise.apps.get("models").items():
145 |             model.bot = self
146 | 
147 |     async def setup_hook(self) -> None:
148 |         await self.init_quo()
149 |         for coro_func in on_startup:
150 |             self.loop.create_task(coro_func(self))
151 | 
152 |     async def get_prefix(self, message: discord.Message) -> Union[str, Callable, List[str]]:
153 |         """Get a guild's prefix"""
154 |         if not message.guild:
155 |             return commands.when_mentioned_or("q")(self, message)
156 | 
157 |         prefix = None
158 |         guild = self.cache.guild_data.get(message.guild.id)
159 |         if guild:
160 |             prefix = guild.get("prefix")
161 | 
162 |         else:
163 |             self.cache.guild_data[message.guild.id] = {
164 |                 "prefix": "q",
165 |                 "color": self.color,
166 |                 "footer": cfg.FOOTER,
167 |             }
168 | 
169 |         prefix = prefix or "q"
170 | 
171 |         return commands.when_mentioned_or(
172 |             *tuple("".join(chars) for chars in itertools.product(*zip(prefix.lower(), prefix.upper())))
173 |         )(self, message)
174 | 
175 |     async def close(self) -> None:
176 |         await super().close()
177 | 
178 |         if hasattr(self, "session"):
179 |             await self.session.close()
180 | 
181 |         await Tortoise.close_connections()
182 | 
183 |     def get_message(self, message_id: int) -> Optional[discord.Message]:
184 |         """Gets the message from the cache"""
185 |         return self._connection._get_message(message_id)
186 | 
187 |     async def process_commands(self, message: discord.Message):
188 |         if message.content and message.guild is not None:
189 |             ctx = await self.get_context(message, cls=Context)
190 | 
191 |             if ctx.command is None:
192 |                 return
193 | 
194 |             await self.invoke(ctx)
195 | 
196 |     async def on_message(self, message: discord.Message):
197 |         self.seen_messages += 1
198 | 
199 |         if message.guild is None or message.author.bot:
200 |             return
201 | 
202 |         await self.process_commands(message)
203 | 
204 |     async def on_command(self, ctx: Context):
205 |         self.cmd_invokes += 1
206 |         await csts.show_tip(ctx)
207 |         await csts.remind_premium(ctx)
208 |         await self.db.execute(
209 |             "INSERT INTO user_data (user_id) VALUES ($1) ON CONFLICT DO NOTHING",
210 |             ctx.author.id,
211 |         )
212 | 
213 |     async def on_ready(self):
214 |         print(f"[Quotient] Logged in as {self.user.name}({self.user.id})")
215 | 
216 |     async def wait_and_delete(self, message: discord.Message, delay: int = 10):
217 |         """Waits for `delay` seconds and deletes the message"""
218 |         return await self.reminders.create_timer(
219 |             self.current_time + timedelta(seconds=delay),
220 |             "msg_delete",
221 |             message_id=message.id,
222 |             channel_id=message.channel.id,
223 |         )
224 | 
225 |     async def on_msg_delete_timer_complete(self, timer: Timer):
226 |         """Deletes the message"""
227 |         channel_id, message_id = timer.kwargs["channel_id"], timer.kwargs["message_id"]
228 | 
229 |         channel: discord.TextChannel = await self.getch(self.get_channel, self.fetch_channel, channel_id)
230 |         if channel is None:
231 |             return
232 | 
233 |         message = channel.get_partial_message(message_id)
234 |         await message.delete(delay=0)
235 | 
236 |     def embed(self, ctx: Context, **kwargs: Any) -> discord.Embed:
237 |         """This is how we deliver features like custom footer and custom color :)"""
238 |         embed_color = self.cache.guild_data[ctx.guild.id]["color"]
239 |         embed_footer = self.cache.guild_data[ctx.guild.id]["footer"]
240 | 
241 |         if embed_footer.strip().lower() == "none":
242 |             embed_footer = None
243 | 
244 |         embed = discord.Embed(**kwargs, color=embed_color).set_footer(text=embed_footer)
245 |         return embed
246 | 
247 |     async def is_owner(self, user: Union[discord.Member, discord.User]) -> bool:
248 |         if await super().is_owner(user):
249 |             return True
250 | 
251 |         return user.id in cfg.DEVS
252 | 
253 |     async def get_or_fetch_member(self, guild: discord.Guild, member_id: int) -> Optional[discord.Member]:
254 |         """Looks up a member in cache or fetches if not found."""
255 |         member = guild.get_member(member_id)
256 |         if member is not None:
257 |             return member
258 | 
259 |         shard = self.get_shard(guild.shard_id)
260 | 
261 |         if shard.is_ws_ratelimited():
262 |             try:
263 |                 member = await guild.fetch_member(member_id)
264 |             except discord.HTTPException:
265 |                 return None
266 |             else:
267 |                 return member
268 | 
269 |         members = await guild.query_members(limit=1, user_ids=[member_id], cache=True)
270 | 
271 |         if len(members) > 0:
272 |             return members[0]
273 | 
274 |         return None
275 | 
276 |     async def resolve_member_ids(
277 |         self, guild: discord.Guild, member_ids: Iterable[int]
278 |     ) -> AsyncGenerator[discord.Member, None]:
279 |         """Bulk resolves member IDs to member instances, if possible."""
280 | 
281 |         needs_resolution = []
282 |         for member_id in member_ids:
283 |             member = guild.get_member(member_id)
284 |             if member is not None:
285 |                 yield member
286 |             else:
287 |                 needs_resolution.append(member_id)
288 | 
289 |         if not needs_resolution:
290 |             return
291 | 
292 |         total_need_resolution = len(needs_resolution)
293 |         if total_need_resolution == 1:
294 |             shard: discord.ShardInfo = self.get_shard(guild.shard_id)  # type: ignore  # will never be None
295 |             if shard.is_ws_ratelimited():
296 |                 try:
297 |                     member = await guild.fetch_member(needs_resolution[0])
298 |                 except discord.HTTPException:
299 |                     pass
300 |                 else:
301 |                     yield member
302 |             else:
303 |                 members = await guild.query_members(limit=1, user_ids=needs_resolution, cache=True)
304 |                 if members:
305 |                     yield members[0]
306 |         elif total_need_resolution <= 100:
307 |             # Only a single resolution call needed here
308 |             resolved = await guild.query_members(limit=100, user_ids=needs_resolution, cache=True)
309 |             for member in resolved:
310 |                 yield member
311 |         else:
312 |             # We need to chunk these in bits of 100...
313 |             for index in range(0, total_need_resolution, 100):
314 |                 to_resolve = needs_resolution[index : index + 100]
315 |                 members = await guild.query_members(limit=100, user_ids=to_resolve, cache=True)
316 |                 for member in members:
317 |                     yield member
318 | 
319 |     @staticmethod
320 |     @cached(ttl=60)
321 |     async def is_premium_guild(guild_id: int) -> bool:
322 |         return await Guild.filter(pk=guild_id, is_premium=True).exists()
323 | 
324 |     @property
325 |     def server(self) -> Optional[discord.Guild]:
326 |         return self.get_guild(746337818388987967)
327 | 
328 |     @property
329 |     def invite_url(self) -> str:
330 |         return discord.utils.oauth_url(
331 |             self.user.id,
332 |             permissions=discord.Permissions(536737213566),
333 |             scopes=("bot", "applications.commands"),
334 |             disable_guild_select=False,
335 |         )
336 | 
337 |     @property
338 |     def reminders(self) -> Reminders:  # since we use it a lot
339 |         return self.get_cog("Reminders")
340 | 
341 |     @property
342 |     def current_time(self):
343 |         return datetime.now(tz=csts.IST)
344 | 
345 |     @property
346 |     async def db_latency(self):
347 |         t1 = time.perf_counter()
348 |         await self.db.fetchval("SELECT 1;")
349 |         t2 = time.perf_counter() - t1
350 |         return f"{t2*1000:.2f} ms"
351 | 
352 |     @staticmethod
353 |     async def getch(get_method: Callable, fetch_method: Callable, _id: int) -> Any:  # why does c have all the fun?
354 |         try:
355 |             _result = get_method(_id) or await fetch_method(_id)
356 |         except (discord.HTTPException, discord.NotFound):
357 |             return None
358 |         else:
359 |             return _result
360 | 
361 |     async def get_or_fetch_message(
362 |         self,
363 |         channel: discord.TextChannel,
364 |         message_id: int,
365 |         *,
366 |         cache: bool = True,
367 |         fetch: bool = True,
368 |     ) -> Optional[discord.Message]:
369 |         # caching cause, due to rate limiting 50/1
370 |         if cache and (msg := self.get_message(message_id)):
371 |             return msg
372 |         try:
373 |             return self.message_cache[message_id]
374 |             # scripting is always faster than `.get()`
375 |         except KeyError:
376 |             pass
377 |         before = discord.Object(message_id + 1)
378 |         after = discord.Object(message_id - 1)
379 |         if fetch:
380 |             async for msg in channel.history(limit=1, before=before, after=after):
381 |                 self.message_cache[msg.id] = msg
382 |                 return msg
383 | 
384 |         return None
385 | 
386 |     async def send_message(self, channel_id: discord.abc.Snowflake, content, **kwargs: Any):
387 |         await self.http.send_message(channel_id, content, **kwargs)
388 | 
389 |     async def convey_important_message(
390 |         self,
391 |         guild: discord.Guild,
392 |         text: str,
393 |         *,
394 |         view=None,
395 |         title="\N{WARNING SIGN}__**IMPORTANT**__\N{WARNING SIGN}",
396 |     ):
397 |         _e = discord.Embed(title=title, description=text)
398 | 
399 |         from models import Guild
400 | 
401 |         _g = await Guild.get(pk=guild.id)
402 |         if (_c := _g.private_ch) and _c.permissions_for(guild.me).embed_links:
403 |             _roles = [
404 |                 role.mention
405 |                 for role in guild.roles
406 |                 if all((role.permissions.administrator, not role.managed, role.members))
407 |             ]
408 |             await _c.send(
409 |                 embed=_e,
410 |                 content=", ".join(_roles[:2]) if _roles else getattr(guild.owner, "mention"),
411 |                 allowed_mentions=AllowedMentions(roles=True),
412 |                 view=view,
413 |             )
414 | 
415 |         if guild.owner is not None:  # there is very little chance that `guild.owner` is None
416 |             try:
417 |                 await guild.owner.send(embed=_e, view=view)
418 |             except discord.Forbidden:
419 |                 return
420 | 
421 | 
422 | bot = Quotient()
423 | 
424 | 
425 | @bot.before_invoke
426 | async def bot_before_invoke(ctx: Context):
427 |     if ctx.guild is not None and not ctx.guild.chunked:
428 |         bot.loop.create_task(ctx.guild.chunk())
429 | 


--------------------------------------------------------------------------------
/core/Cog.py:
--------------------------------------------------------------------------------
 1 | from discord.ext import commands
 2 | 
 3 | __all__ = ("Cog",)
 4 | 
 5 | 
 6 | class Cog(commands.Cog):
 7 |     """A custom implementation of commands.Cog class."""
 8 | 
 9 |     def __init__(self, *args, **kwargs):
10 |         super().__init__(*args, **kwargs)
11 | 
12 |     def __str__(self):
13 |         return "{0.__class__.__name__}".format(self)
14 | 


--------------------------------------------------------------------------------
/core/Context.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import asyncio
  4 | import io
  5 | from contextlib import suppress
  6 | from typing import TYPE_CHECKING, Any, Callable, Generic, Optional, TypeVar, Union
  7 | 
  8 | import aiohttp
  9 | import discord
 10 | from discord.ext import commands
 11 | 
 12 | import config as cfg
 13 | import utils
 14 | 
 15 | BotT = TypeVar("BotT", bound=commands.Bot)
 16 | 
 17 | 
 18 | __all__ = ("Context",)
 19 | 
 20 | 
 21 | class Context(commands.Context["commands.Bot"], Generic[BotT]):
 22 |     if TYPE_CHECKING:
 23 |         from .Bot import Quotient
 24 | 
 25 |     bot: Quotient
 26 | 
 27 |     def __init__(self, *args: Any, **kwargs: Any) -> None:
 28 |         super().__init__(*args, **kwargs)
 29 | 
 30 |     @property
 31 |     def db(self):
 32 |         return self.bot.db
 33 | 
 34 |     @property
 35 |     def session(self) -> aiohttp.ClientSession:
 36 |         return self.bot.session
 37 | 
 38 |     @property
 39 |     def guild_color(self):
 40 |         return self.bot.cache.guild_color(self.guild.id)
 41 | 
 42 |     @property
 43 |     def config(self) -> cfg:
 44 |         return self.bot.config
 45 | 
 46 |     @property
 47 |     async def banlog_channel(self):
 48 |         from models import BanLog
 49 | 
 50 |         record = await BanLog.get_or_none(guild_id=self.guild.id)
 51 |         if record:
 52 |             return record.channel
 53 | 
 54 |     @discord.utils.cached_property
 55 |     def replied_reference(self) -> Optional[discord.MessageReference]:
 56 |         ref = self.message.reference
 57 |         if ref and isinstance(ref.resolved, discord.Message):
 58 |             return ref.resolved.to_reference()
 59 |         return None
 60 | 
 61 |     async def prompt(self, message: str, title: Optional[str] = None, delete_after=True):
 62 |         """
 63 |         An interactive reaction confirmation dialog.
 64 |         """
 65 | 
 66 |         embed = discord.Embed(description=message, color=self.bot.color)
 67 |         if title is not None:
 68 |             embed.title = title
 69 | 
 70 |         view = utils.Prompt(self.author.id)
 71 |         msg: Optional[discord.Message] = await self.send(embed=embed, view=view)
 72 |         await view.wait()
 73 | 
 74 |         try:
 75 |             if delete_after and msg is not None:
 76 |                 await msg.delete(delay=0)
 77 |         finally:
 78 |             return view.value
 79 | 
 80 |     async def error(self, message: str, delete_after: bool = None, **kwargs: Any) -> Optional[discord.Message]:
 81 |         with suppress(discord.HTTPException):
 82 |             msg: Optional[discord.Message] = await self.reply(
 83 |                 embed=discord.Embed(description=message, color=discord.Color.red()),
 84 |                 delete_after=delete_after,
 85 |                 **kwargs,
 86 |             )
 87 |             try:
 88 |                 await self.bot.wait_for("message_delete", check=lambda m: m.id == self.message.id, timeout=30)
 89 |             except asyncio.TimeoutError:
 90 |                 pass
 91 |             else:
 92 |                 if msg is not None:
 93 |                     await msg.delete(delay=0)
 94 |             finally:
 95 |                 return msg
 96 | 
 97 |         return None
 98 | 
 99 |     async def safe_delete(self, msg: discord.Message, sleep_for: Union[int, float] = 0) -> None:
100 |         if sleep_for:
101 |             await asyncio.sleep(sleep_for)
102 | 
103 |         await msg.delete(delay=0)
104 | 
105 |     async def success(
106 |         self, message: str, delete_after: Union[int, float] = None, **kwargs: Any
107 |     ) -> Optional[discord.Message]:
108 |         with suppress(discord.HTTPException):
109 |             return await self.reply(
110 |                 embed=discord.Embed(
111 |                     description=f"{utils.check} | {message}",
112 |                     color=self.bot.color,
113 |                 ),
114 |                 delete_after=delete_after,
115 |                 **kwargs,
116 |             )
117 |         return None
118 | 
119 |     async def simple(
120 |         self, message: str, delete_after: Union[int, float] = None, **kwargs: Any
121 |     ) -> Optional[discord.Message]:
122 |         with suppress(discord.HTTPException):
123 |             image = kwargs.pop("image", None)
124 |             footer = kwargs.pop("footer", None)
125 | 
126 |             embed = discord.Embed(description=message, color=self.bot.color)
127 |             if image:
128 |                 embed.set_image(url=image)
129 |             if footer:
130 |                 embed.set_footer(text=footer)
131 | 
132 |             return await self.reply(
133 |                 embed=embed,
134 |                 delete_after=delete_after,
135 |                 **kwargs,
136 |             )
137 |         return None
138 | 
139 |     async def is_premium_guild(self) -> bool:
140 |         from models import Guild
141 | 
142 |         with suppress(AttributeError):
143 |             return (await Guild.get(guild_id=self.guild.id)).is_premium
144 | 
145 |         return False
146 | 
147 |     async def send_file(
148 |         self,
149 |         content: str,
150 |         *,
151 |         name: str = "Message.txt",
152 |         escape_mentions: bool = True,
153 |         **kwargs: Any,
154 |     ) -> Optional[discord.Message]:
155 |         """sends the file containg content"""
156 |         if escape_mentions:
157 |             content = discord.utils.escape_mentions(content)
158 | 
159 |         fp = io.BytesIO(content.encode())
160 |         kwargs.pop("file", None)
161 | 
162 |         return await self.send(file=discord.File(fp, filename=name), **kwargs)
163 | 
164 |     async def maybe_delete(self, message: Optional[discord.Message] = None):
165 |         if message is not None:
166 |             await message.delete(delay=0)
167 | 
168 |     async def send(self, content: Any = None, **kwargs: Any) -> Optional[discord.Message]:
169 |         if not (_perms := self.channel.permissions_for(self.me)).send_messages:
170 |             try:
171 |                 await self.author.send(
172 |                     "I can't send any messages in that channel. \nPlease give me sufficient permissions to do so.",
173 |                     view=self.get_dm_view(f"Sent from #{self.channel.name} in {self.guild.name}"),
174 |                 )
175 |             except discord.Forbidden:
176 |                 pass
177 |             return None
178 | 
179 |         require_embed_perms = kwargs.pop("embed_perms", False)
180 |         if require_embed_perms and not _perms.embed_links:
181 |             kwargs = {}
182 |             content = (
183 |                 "Oops! I need **Embed Links** permission to work properly. \n"
184 |                 "Please tell a server admin to grant me that permission."
185 |             )
186 |         if isinstance(content, discord.Embed):
187 |             kwargs["embed"] = content
188 |             content = None
189 |         if isinstance(content, discord.File):
190 |             kwargs["file"] = content
191 |             content = None
192 | 
193 |         return await super().send(content, **kwargs)
194 | 
195 |     async def wait_and_purge(
196 |         self,
197 |         channel: Union[discord.TextChannel, discord.Thread],
198 |         *,
199 |         limit: int = 100,
200 |         wait_for: Union[int, float] = 10,
201 |         check: Callable = lambda m: True,
202 |     ):
203 |         await asyncio.sleep(wait_for)
204 | 
205 |         with suppress(discord.HTTPException):
206 |             await channel.purge(limit=limit, check=check)
207 | 
208 |     async def premium_mango(self, msg: str = "This feature requires Quotient Premium.") -> Optional[discord.Message]:
209 |         from cogs.premium.views import PremiumView
210 | 
211 |         _view = PremiumView(msg)
212 |         return await self.send(embed=_view.premium_embed, view=_view, embed_perms=True)
213 | 
214 |     @staticmethod
215 |     def get_dm_view(msg: str) -> discord.ui.View:
216 |         from .views import QuoDMView
217 | 
218 |         return QuoDMView(label=msg)
219 | 


--------------------------------------------------------------------------------
/core/Help.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from difflib import get_close_matches
  4 | from typing import List, Mapping
  5 | 
  6 | import discord
  7 | from discord.ext import commands
  8 | 
  9 | import config
 10 | from models import Guild
 11 | from utils import LinkButton, LinkType, QuoPaginator, discord_timestamp, truncate_string
 12 | 
 13 | from .Cog import Cog
 14 | 
 15 | 
 16 | class HelpCommand(commands.HelpCommand):
 17 |     def __init__(self) -> None:
 18 |         super().__init__(
 19 |             verify_checks=False,
 20 |             command_attrs={
 21 |                 "cooldown": commands.CooldownMapping.from_cooldown(1, 8.0, commands.BucketType.member),
 22 |                 "help": "Shows help about the bot, a command, or a category",
 23 |             },
 24 |         )
 25 | 
 26 |     @property
 27 |     def color(self):
 28 |         return self.context.bot.color
 29 | 
 30 |     async def send_bot_help(self, mapping: Mapping[Cog, List[commands.Command]]):
 31 |         ctx = self.context
 32 | 
 33 |         hidden = ("HelpCog", "Dev")
 34 | 
 35 |         embed = discord.Embed(color=self.color)
 36 | 
 37 |         server = f"[Support Server]({config.SERVER_LINK})"
 38 |         invite = f"[Invite Me]({config.BOT_INVITE})"
 39 |         dashboard = f"[Privacy Policy](https://github.com/quotientbot/Quotient-Bot/wiki/privacy-policy)"
 40 | 
 41 |         embed.description = f"{server} **|** {invite} **|** {dashboard}\n\n"
 42 | 
 43 |         guild = await Guild.get_or_none(pk=ctx.guild.id)
 44 |         if guild and guild.is_premium:
 45 |             embed.description += f"<a:top_user:807911932299837460> [__Server Premium ending:__]({config.SERVER_LINK}) {discord_timestamp(guild.premium_end_time)}"
 46 | 
 47 |         for cog, cmds in mapping.items():
 48 |             if cog and cog.qualified_name not in hidden and await self.filter_commands(cmds, sort=True):
 49 |                 embed.add_field(
 50 |                     inline=False,
 51 |                     name=cog.qualified_name.title(),
 52 |                     value=", ".join(map(lambda x: f"`{x}`", cog.get_commands())),
 53 |                 )
 54 | 
 55 |         slash_cmds = await ctx.bot.tree.fetch_commands()
 56 |         slash_cmds = [f"{i.mention}" for i in slash_cmds]
 57 |         embed.add_field(name="Slash Commands", value=", ".join(slash_cmds), inline=False)
 58 | 
 59 |         links = [
 60 |             LinkType("Support Server", config.SERVER_LINK),
 61 |             LinkType("Invite Me", config.BOT_INVITE),
 62 |         ]
 63 |         await ctx.send(embed=embed, embed_perms=True, view=LinkButton(links))
 64 | 
 65 |     async def send_group_help(self, group: commands.Group):
 66 |         prefix = self.context.prefix
 67 | 
 68 |         if not group.commands:
 69 |             return await self.send_command_help(group)
 70 | 
 71 |         embed = discord.Embed(color=discord.Color(self.color))
 72 | 
 73 |         embed.title = f"{group.qualified_name} {group.signature}"
 74 |         _help = group.help or "No description provided..."
 75 | 
 76 |         _cmds = "\n".join(f"`{prefix}{c.qualified_name}` : {truncate_string(c.short_doc,60)}" for c in group.commands)
 77 | 
 78 |         embed.description = f"> {_help}\n\n**Subcommands**\n{_cmds}"
 79 | 
 80 |         embed.set_footer(text=f'Use "{prefix}help <command>" for more information.')
 81 | 
 82 |         if group.aliases:
 83 |             embed.add_field(
 84 |                 name="Aliases",
 85 |                 value=", ".join(f"`{aliases}`" for aliases in group.aliases),
 86 |                 inline=False,
 87 |             )
 88 | 
 89 |         examples = []
 90 |         if group.extras:
 91 |             if _gif := group.extras.get("gif"):
 92 |                 embed.set_image(url=_gif)
 93 | 
 94 |             if _ex := group.extras.get("examples"):
 95 |                 examples = [f"{self.context.prefix}{i}" for i in _ex]
 96 | 
 97 |         if examples:
 98 |             examples: str = "\n".join(examples)  # type: ignore
 99 |             embed.add_field(name="Examples", value=f"```{examples}```")
100 | 
101 |         await self.context.send(embed=embed, embed_perms=True)
102 | 
103 |     async def send_cog_help(self, cog: Cog):
104 |         paginator = QuoPaginator(self.context, per_page=14)
105 |         c = 0
106 |         for cmd in cog.get_commands():
107 |             if not cmd.hidden:
108 |                 _brief = "No Information..." if not cmd.short_doc else truncate_string(cmd.short_doc, 60)
109 |                 paginator.add_line(f"`{cmd.qualified_name}` : {_brief}")
110 |                 c += 1
111 | 
112 |         paginator.title = f"{cog.qualified_name.title()} ({c})"
113 |         await paginator.start()
114 | 
115 |     async def send_command_help(self, cmd: commands.Command):
116 |         embed = discord.Embed(color=self.color)
117 |         embed.title = "Command: " + cmd.qualified_name
118 | 
119 |         examples = []
120 | 
121 |         alias = ",".join((f"`{alias}`" for alias in cmd.aliases)) if cmd.aliases else "No aliases"
122 |         _text = (
123 |             f"**Description:** {cmd.help or 'No help found...'}\n"
124 |             f"**Usage:** `{self.get_command_signature(cmd)}`\n"
125 |             f"**Aliases:** {alias}\n"
126 |             f"**Examples:**"
127 |         )
128 | 
129 |         if cmd.extras:
130 |             if _gif := cmd.extras.get("gif"):
131 |                 embed.set_image(url=_gif)
132 | 
133 |             if _ex := cmd.extras.get("examples"):
134 |                 examples = [f"{self.context.prefix}{i}" for i in _ex]
135 | 
136 |         examples: str = "\n".join(examples) if examples else "Command has no examples"  # type: ignore
137 | 
138 |         _text += f"```{examples}```"
139 | 
140 |         embed.description = _text
141 | 
142 |         await self.context.send(embed=embed, embed_perms=True)
143 | 
144 |     async def command_not_found(self, string: str):
145 |         message = f"Could not find the `{string}` command. "
146 |         commands_list = (str(cmd) for cmd in self.context.bot.walk_commands())
147 | 
148 |         if dym := "\n".join(get_close_matches(string, commands_list)):
149 |             message += f"Did you mean...\n{dym}"
150 | 
151 |         return message
152 | 


--------------------------------------------------------------------------------
/core/__init__.py:
--------------------------------------------------------------------------------
1 | from .Bot import Quotient, bot
2 | from .Cog import Cog
3 | from .Context import Context
4 | from .cooldown import *
5 | from .decorators import *
6 | from .views import *
7 | 


--------------------------------------------------------------------------------
/core/__pycache__/Bot.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/core/__pycache__/Bot.cpython-312.pyc


--------------------------------------------------------------------------------
/core/__pycache__/Cog.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/core/__pycache__/Cog.cpython-312.pyc


--------------------------------------------------------------------------------
/core/__pycache__/Context.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/core/__pycache__/Context.cpython-312.pyc


--------------------------------------------------------------------------------
/core/__pycache__/Help.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/core/__pycache__/Help.cpython-312.pyc


--------------------------------------------------------------------------------
/core/__pycache__/__init__.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/core/__pycache__/__init__.cpython-312.pyc


--------------------------------------------------------------------------------
/core/__pycache__/cache.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/core/__pycache__/cache.cpython-312.pyc


--------------------------------------------------------------------------------
/core/__pycache__/cooldown.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/core/__pycache__/cooldown.cpython-312.pyc


--------------------------------------------------------------------------------
/core/__pycache__/decorators.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/core/__pycache__/decorators.cpython-312.pyc


--------------------------------------------------------------------------------
/core/__pycache__/views.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/core/__pycache__/views.cpython-312.pyc


--------------------------------------------------------------------------------
/core/_pages.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import asyncio
  4 | import typing as T
  5 | 
  6 | import discord
  7 | 
  8 | from utils.default import split_list
  9 | 
 10 | from .Context import Context
 11 | from .views import QuotientView
 12 | 
 13 | 
 14 | class PageLine(T.NamedTuple):
 15 |     line: T.Optional[str] = None
 16 |     image: T.Optional[str] = None
 17 |     # embed: T.Optional[discord.Embed] = None
 18 | 
 19 | 
 20 | class QuoPages:
 21 |     def __init__(
 22 |         self,
 23 |         ctx: Context,
 24 |         *,
 25 |         per_page=10,
 26 |         timeout=60.0,
 27 |         title=None,
 28 |         show_page_count=True,
 29 |         embed_color=0x00FFB3,
 30 |         compact=False,
 31 |     ):
 32 |         self.ctx = ctx
 33 | 
 34 |         self.per_page = per_page
 35 |         self.timeout = timeout
 36 |         self.title = title or None
 37 |         self.show_page_count = show_page_count
 38 | 
 39 |         self.enteries: T.List[PageLine] = []
 40 | 
 41 |         self.items: T.List[discord.ui.Item] = []
 42 |         self.embed_color = embed_color
 43 | 
 44 |         self.compact = compact
 45 | 
 46 |         self.pages: T.List[PageLine] = []
 47 | 
 48 |         self.cur_page = 1
 49 | 
 50 |     def add_line(self, line: PageLine):
 51 |         self.enteries.append(line)
 52 | 
 53 |     @property
 54 |     def embed(self) -> discord.Embed:
 55 |         _p = self.pages[self.cur_page - 1]
 56 | 
 57 |         _e = discord.Embed(color=self.embed_color, title=self.title)
 58 |         _e.description = _p.line
 59 |         if _p.image:
 60 |             _e.set_image(url=_p.image)
 61 | 
 62 |         if self.show_page_count:
 63 |             _e.set_footer(text=f"Page {self.pages.index(_p) + 1} of {len(self.pages)}")
 64 |         return _e
 65 | 
 66 |     @property
 67 |     def current_page(self):
 68 |         ...
 69 | 
 70 |     async def paginate(self):
 71 |         if self.per_page <= 1:
 72 |             self.pages = self.enteries
 73 | 
 74 |         else:
 75 |             for _ in split_list(self.enteries, self.per_page):
 76 |                 _: T.List[PageLine]
 77 |                 self.pages.append(PageLine("".join(ent.line for ent in _), _[0].image))
 78 | 
 79 |         view = QuoPageView(
 80 |             self.ctx,
 81 |             pages=self.pages,
 82 |             items=self.items,
 83 |             embed=self.embed,
 84 |             show_count=self.show_page_count,
 85 |             need_skip=self.compact,
 86 |         )
 87 |         if len(self.pages) <= 1:
 88 |             view.message = await self.ctx.send(embed=self.embed)
 89 |             return
 90 | 
 91 |         view.message = await self.ctx.send(embed=self.embed, view=view)
 92 | 
 93 | 
 94 | class QuoPageView(QuotientView):
 95 |     def __init__(
 96 |         self,
 97 |         ctx: Context,
 98 |         *,
 99 |         pages: T.List[PageLine],
100 |         items: T.Optional[T.List[discord.ui.Item]] = None,
101 |         embed: discord.Embed,
102 |         show_count: bool,
103 |         need_skip: bool,
104 |     ):
105 |         super().__init__(ctx, timeout=40)
106 | 
107 |         self.pages = pages
108 |         self.items = items
109 |         self.current_page = 1
110 |         self.embed = embed
111 |         self.show_count = show_count
112 |         self.need_skip = need_skip
113 | 
114 |         self.__input_lock = asyncio.Lock()
115 | 
116 |         self.clear_items()
117 |         self.fill_items()
118 | 
119 |     def fill_items(self) -> None:
120 |         for item in self.items:  # Not sure about these item's positions
121 |             self.add_item(item)
122 | 
123 |         self.add_item(self.first_page)
124 |         self.add_item(self.previous_page)
125 | 
126 |         if self.need_skip:
127 |             self.add_item(self.skip_page)
128 | 
129 |         self.add_item(self.next_page)
130 |         self.add_item(self.last_page)
131 | 
132 |     def update_embed(self):
133 |         if self.show_count:
134 |             self.embed.set_footer(text=f"Page {self.current_page} of {len(self.pages)}")
135 | 
136 |         self.embed.description = self.pages[self.current_page - 1].line
137 | 
138 |         if self.pages[self.current_page - 1].image:
139 |             self.embed.set_image(url=self.pages[self.current_page - 1].image)
140 | 
141 |     @discord.ui.button(
142 |         style=discord.ButtonStyle.green,
143 |         custom_id="first",
144 |         emoji="<:double_left:878668594530099220>",
145 |     )
146 |     async def first_page(self, interaction: discord.Interaction, button: discord.Button):
147 |         self.current_page = 1
148 |         self.update_embed()
149 | 
150 |         await interaction.response.edit_message(embed=self.embed, view=self)
151 | 
152 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="previous", emoji="<:left:878668491660623872>")
153 |     async def previous_page(self, interaction: discord.Interaction, button: discord.Button):
154 |         if self.current_page == 1:
155 |             return
156 | 
157 |         self.current_page -= 1
158 |         self.update_embed()
159 | 
160 |         await interaction.response.edit_message(embed=self.embed, view=self)
161 | 
162 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="skipto", label="Skip to page ...")
163 |     async def skip_page(self, interaction: discord.Interaction, button: discord.Button):
164 |         if self.__input_lock.locked():
165 |             return await interaction.response.send_message("Already waiting for your response...", ephemeral=True)
166 | 
167 |         if self.message is None:
168 |             return
169 | 
170 |         async with self.__input_lock:
171 |             channel = self.message.channel
172 |             author_id = interaction.user and interaction.user.id
173 |             await interaction.response.send_message("Please enter the page number you want to skip to.", ephemeral=True)
174 | 
175 |             def _msg_check(m: discord.Message) -> bool:
176 |                 return m.author.id == author_id and channel == m.channel and m.content.isdigit()
177 | 
178 |             try:
179 |                 msg = await self.ctx.bot.wait_for("message", check=_msg_check, timeout=30.0)
180 |             except asyncio.TimeoutError:
181 |                 await interaction.followup.send("Took too long.", ephemeral=True)
182 |                 await asyncio.sleep(5)
183 |             else:
184 |                 page = int(msg.content)
185 |                 await msg.delete()
186 | 
187 |                 if page > len(self.pages):
188 |                     await interaction.followup.send("Page number too high.", ephemeral=True)
189 |                     return
190 | 
191 |                 self.current_page = page
192 |                 self.update_embed()
193 | 
194 |                 if interaction.response.is_done():
195 |                     if self.message:
196 |                         await self.message.edit(embed=self.embed, view=self)
197 |                 else:
198 |                     await interaction.response.edit_message(embed=self.embed, view=self)
199 | 
200 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="next", emoji="<:right:878668370331983913>")
201 |     async def next_page(self, interaction: discord.Interaction, button: discord.Button):
202 |         if self.current_page == len(self.pages):
203 |             return
204 | 
205 |         self.current_page += 1
206 |         self.update_embed()
207 | 
208 |         await interaction.response.edit_message(embed=self.embed, view=self)
209 | 
210 |     @discord.ui.button(
211 |         style=discord.ButtonStyle.green,
212 |         custom_id="last",
213 |         emoji="<:double_right:878668437193359392>",
214 |     )
215 |     async def last_page(self, interaction: discord.Interaction, button: discord.Button):
216 |         self.current_page = len(self.pages)
217 |         self.update_embed()
218 | 
219 |         await interaction.response.edit_message(embed=self.embed, view=self)
220 | 


--------------------------------------------------------------------------------
/core/cache.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from datetime import datetime
 4 | from typing import TYPE_CHECKING
 5 | 
 6 | import config
 7 | from constants import IST
 8 | from models import AutoPurge, BlockList, EasyTag, Guild, Scrim, SSVerify, TagCheck, Tourney
 9 | 
10 | 
11 | class CacheManager:
12 |     def __init__(self, bot):
13 |         if TYPE_CHECKING:
14 |             from .Bot import Quotient
15 | 
16 |         self.bot: Quotient = bot
17 | 
18 |         self.guild_data = {}
19 |         self.eztagchannels = set()
20 |         self.tagcheck = set()
21 |         self.scrim_channels = set()
22 |         self.tourney_channels = set()
23 |         self.autopurge_channels = set()
24 |         self.media_partner_channels = set()
25 |         self.ssverify_channels = set()
26 | 
27 |         self.blocked_ids = set()
28 | 
29 |     async def fill_temp_cache(self):
30 |         async for record in Guild.all():
31 |             self.guild_data[record.guild_id] = {
32 |                 "prefix": record.prefix,
33 |                 "color": record.embed_color or config.COLOR,
34 |                 "footer": record.embed_footer or config.FOOTER,
35 |             }
36 | 
37 |         async for record in EasyTag.all():
38 |             self.eztagchannels.add(record.channel_id)
39 | 
40 |         async for record in TagCheck.all():
41 |             self.tagcheck.add(record.channel_id)
42 | 
43 |         async for record in Scrim.filter(opened_at__lte=datetime.now(tz=IST)).all():
44 |             self.scrim_channels.add(record.registration_channel_id)
45 | 
46 |         async for record in Tourney.filter(started_at__not_isnull=True):
47 |             self.tourney_channels.add(record.registration_channel_id)
48 | 
49 |         async for record in AutoPurge.all():
50 |             self.autopurge_channels.add(record.channel_id)
51 | 
52 |         async for record in Tourney.all():
53 |             async for partner in record.media_partners.all():
54 |                 self.media_partner_channels.add(partner.channel_id)
55 | 
56 |         async for record in SSVerify.all():
57 |             self.ssverify_channels.add(record.channel_id)
58 | 
59 |         async for record in BlockList.all():
60 |             self.blocked_ids.add(record.block_id)
61 | 
62 |     def guild_color(self, guild_id: int):
63 |         return self.guild_data.get(guild_id, {}).get("color", config.COLOR)
64 | 
65 |     def guild_footer(self, guild_id: int):
66 |         return self.guild_data.get(guild_id, {}).get("footer", config.FOOTER)
67 | 
68 |     async def update_guild_cache(self, guild_id: int, *, set_default=False) -> None:
69 |         if set_default:
70 |             await Guild.get(pk=guild_id).update(
71 |                 prefix=config.PREFIX, embed_color=config.COLOR, embed_footer=config.FOOTER
72 |             )
73 | 
74 |         _g = await Guild.get(pk=guild_id)
75 |         self.guild_data[guild_id] = {
76 |             "prefix": _g.prefix,
77 |             "color": _g.embed_color or config.COLOR,
78 |             "footer": _g.embed_footer or config.FOOTER,
79 |         }
80 | 
81 |     # @staticmethod
82 |     # @cached(ttl=10, serializer=JsonSerializer())
83 |     # async def match_bot_guild(guild_id: int, bot_id: int) -> bool:
84 |     #     return await Guild.filter(pk=guild_id, bot_id=bot_id).exists()
85 | 


--------------------------------------------------------------------------------
/core/cooldown.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing as T
 4 | from collections import defaultdict
 5 | 
 6 | import discord
 7 | from discord.ext import commands
 8 | 
 9 | __all__ = ("QuotientRatelimiter",)
10 | 
11 | 
12 | class CooldownByMember(commands.CooldownMapping):
13 |     def _bucket_key(self, member: discord.Member):
14 |         return member.id
15 | 
16 | 
17 | class CooldownByGuild(commands.CooldownMapping):
18 |     def _bucket_key(self, member: discord.Guild):
19 |         return member.id
20 | 
21 | 
22 | class QuotientRatelimiter:
23 |     def __init__(self, rate: float, per: float):
24 |         self.by_member = CooldownByMember.from_cooldown(rate, per, commands.BucketType.member)
25 |         self.by_guild = CooldownByGuild.from_cooldown(rate, per, commands.BucketType.guild)
26 | 
27 |     def is_ratelimited(self, obj: T.Union[discord.Guild, discord.Member]) -> bool:
28 |         if isinstance(obj, discord.Guild):
29 |             return self.by_guild.get_bucket(obj).update_rate_limit()
30 | 
31 |         return self.by_member.get_bucket(obj).update_rate_limit()
32 | 


--------------------------------------------------------------------------------
/core/decorators.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from contextlib import suppress
 4 | from functools import wraps
 5 | from typing import TYPE_CHECKING, Any, Callable
 6 | 
 7 | import discord
 8 | 
 9 | from core.Context import Context
10 | 
11 | from .cache import CacheManager
12 | from .Cog import Cog
13 | 
14 | __all__ = ("right_bot_check", "event_bot_check", "role_command_check")
15 | 
16 | 
17 | class right_bot_check:
18 |     def __call__(self, fn: Callable) -> Callable:
19 |         @wraps(fn)
20 |         async def wrapper(*args: Any, **kwargs: Any):
21 |             if TYPE_CHECKING:
22 |                 from .Bot import Quotient
23 | 
24 |             if isinstance(args[0], Cog):
25 |                 bot: Quotient = args[0].bot
26 | 
27 |             else:
28 |                 bot: Quotient = args[0]  # type: ignore
29 | 
30 |             with suppress(AttributeError):
31 |                 for arg in args:
32 |                     # check for both guild and guild_id
33 |                     if hasattr(arg, "guild"):
34 |                         guild_id = arg.guild.id
35 |                         break
36 |                     elif hasattr(arg, "guild_id"):
37 |                         guild_id = arg.guild_id
38 |                         break
39 |                 else:
40 |                     _obj = kwargs.get("guild") or kwargs.get("guild_id")
41 |                     # guild id can be none here
42 |                     guild_id = _obj.id if isinstance(_obj, discord.Guild) else _obj
43 | 
44 |                 if guild_id is not None and not await CacheManager.match_bot_guild(guild_id, bot.user.id):
45 |                     return
46 | 
47 |             return await fn(*args, **kwargs)
48 | 
49 |         return wrapper
50 | 
51 | 
52 | class event_bot_check:
53 |     def __init__(self, bot_id: int):
54 |         self.bot_id = bot_id
55 | 
56 |     def __call__(self, fn: Callable) -> Callable:
57 |         @wraps(fn)
58 |         async def wrapper(*args: Any, **kwargs: Any):
59 |             bot_id: int = args[0].bot.user.id
60 |             return await fn(*args, **kwargs) if bot_id == self.bot_id else None
61 | 
62 |         return wrapper
63 | 
64 | 
65 | class role_command_check:
66 |     def __call__(self, fn: Callable) -> Callable:
67 |         @wraps(fn)
68 |         async def wrapper(*args: Any, **kwargs: Any):
69 |             _, ctx, *role = args
70 | 
71 |             role: discord.Role = role[0] if isinstance(role, list) else role  # type: ignore
72 |             ctx: Context  # type: ignore
73 | 
74 |             if role.managed:
75 |                 return await ctx.error(f"Role is an integrated role and cannot be added manually.")
76 | 
77 |             if ctx.me.top_role.position <= role.position:
78 |                 return await ctx.error(f"The position of {role.mention} is above my toprole ({ctx.me.top_role.mention})")
79 | 
80 |             if not ctx.author == ctx.guild.owner and ctx.author.top_role.position <= role.position:
81 |                 return await ctx.error(
82 |                     f"The position of {role.mention} is above your top role ({ctx.author.top_role.mention})"
83 |                 )
84 | 
85 |             if role.permissions > ctx.author.guild_permissions:
86 |                 return await ctx.error(f"{role.mention} has higher permissions than you.")
87 | 
88 |             if role.permissions.administrator:
89 |                 return await ctx.error(f"{role.mention} has administrator permissions.")
90 | 
91 |             return await fn(*args, **kwargs)
92 | 
93 |         return wrapper
94 | 


--------------------------------------------------------------------------------
/core/embeds.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | from contextlib import suppress
  5 | 
  6 | import discord
  7 | 
  8 | if T.TYPE_CHECKING:
  9 |     from core import Context
 10 | 
 11 | from .views import QuoInput, QuotientView
 12 | 
 13 | 
 14 | class EmbedOptions(discord.ui.Select):
 15 |     view: EmbedBuilder
 16 | 
 17 |     def __init__(self, ctx: Context):
 18 |         self.ctx = ctx
 19 |         super().__init__(
 20 |             placeholder="Select an option to design the message.",
 21 |             options=[
 22 |                 # discord.SelectOption(
 23 |                 #     label="Normal Text",
 24 |                 #     description="This is displayed above the embed.",
 25 |                 #     emoji="<:c_:972805722276524092>",
 26 |                 #     value="content",
 27 |                 # ),
 28 |                 discord.SelectOption(
 29 |                     label="Edit Message (Title, Description, Footer)",
 30 |                     emoji="<:add:844825523003850772>",
 31 |                     value="main",
 32 |                     description="Edit your embed title, description, and footer.",
 33 |                 ),
 34 |                 discord.SelectOption(
 35 |                     label="Edit Thumbnail Image",
 36 |                     description="Small Image on the right side of embed",
 37 |                     emoji="🖼️",
 38 |                     value="thumb",
 39 |                 ),
 40 |                 discord.SelectOption(
 41 |                     label="Edit Main Image",
 42 |                     description="Edit your embed Image",
 43 |                     emoji="🖼️",
 44 |                     value="image",
 45 |                 ),
 46 |                 discord.SelectOption(
 47 |                     label="Edit Footer Icon",
 48 |                     description="Small icon near footer message",
 49 |                     emoji="🖌️",
 50 |                     value="footer_icon",
 51 |                 ),
 52 |                 discord.SelectOption(
 53 |                     label="Edit Embed Color",
 54 |                     description="Change the color of the embed",
 55 |                     emoji="<:plant:1253293916724264981>",
 56 |                     value="color",
 57 |                 ),
 58 |             ],
 59 |         )
 60 | 
 61 |     async def callback(self, interaction: discord.Interaction):
 62 |         assert self.view is not None
 63 | 
 64 |         if (selected := self.values[0]) == "content":
 65 |             modal = Content()
 66 |             await interaction.response.send_modal(modal)
 67 |             await modal.wait()
 68 |             self.view.content = modal._content.value or ""
 69 | 
 70 |             await self.view.refresh_view()
 71 | 
 72 |         elif selected == "main":
 73 |             modal = QuoInput("Set Embed Message")
 74 |             modal.add_item(
 75 |                 discord.ui.TextInput(
 76 |                     label="Title",
 77 |                     placeholder="Enter text for title of embed here...",
 78 |                     max_length=256,
 79 |                     required=False,
 80 |                     style=discord.TextStyle.short,
 81 |                     default=self.view.embed.title,
 82 |                 )
 83 |             )
 84 |             modal.add_item(
 85 |                 discord.ui.TextInput(
 86 |                     label="Description",
 87 |                     placeholder="Enter text for description of embed here...",
 88 |                     max_length=4000,
 89 |                     required=False,
 90 |                     style=discord.TextStyle.long,
 91 |                     default=self.view.embed.description,
 92 |                 )
 93 |             )
 94 |             modal.add_item(
 95 |                 discord.ui.TextInput(
 96 |                     label="Footer Text",
 97 |                     placeholder="Enter text for footer of embed here...",
 98 |                     style=discord.TextStyle.long,
 99 |                     max_length=2048,
100 |                     required=False,
101 |                     default=self.view.embed.footer.text,
102 |                 )
103 |             )
104 |             await interaction.response.send_modal(modal)
105 |             await modal.wait()
106 | 
107 |             t, d, f = str(modal.children[0]), str(modal.children[1]), str(modal.children[2])
108 | 
109 |             self.view.embed.title = t or None
110 |             self.view.embed.description = d or None
111 |             self.view.embed.set_footer(text=f or None, icon_url=self.view.embed.footer.icon_url)
112 | 
113 |             await self.view.refresh_view()
114 | 
115 |         elif selected == "thumb":
116 |             modal = QuoInput("Edit Thumbnail Image")
117 |             modal.add_item(
118 |                 discord.ui.TextInput(
119 |                     label="Enter Image URL (Optional)",
120 |                     placeholder="Leave empty to remove Image.",
121 |                     required=False,
122 |                     default=getattr(self.view.embed.thumbnail, "url", None),
123 |                 )
124 |             )
125 |             await interaction.response.send_modal(modal)
126 |             await modal.wait()
127 |             url = str(modal.children[0]) or None
128 | 
129 |             if not url or not url.startswith("https"):
130 |                 self.view.embed.set_thumbnail(url=None)
131 | 
132 |             else:
133 |                 self.view.embed.set_thumbnail(url=url)
134 |             await self.view.refresh_view()
135 | 
136 |         elif selected == "image":
137 |             modal = QuoInput("Edit Main Image")
138 |             modal.add_item(
139 |                 discord.ui.TextInput(
140 |                     label="Enter Image URL (Optional)",
141 |                     placeholder="Leave empty to remove Image.",
142 |                     required=False,
143 |                     default=getattr(self.view.embed.image, "url", None),
144 |                 )
145 |             )
146 |             await interaction.response.send_modal(modal)
147 |             await modal.wait()
148 |             url = str(modal.children[0]) or None
149 | 
150 |             if not url or not url.startswith("https"):
151 |                 self.view.embed.set_image(url=None)
152 | 
153 |             else:
154 |                 self.view.embed.set_image(url=url)
155 | 
156 |             await self.view.refresh_view()
157 | 
158 |         elif selected == "footer_icon":
159 |             modal = QuoInput("Edit Footer Icon")
160 |             modal.add_item(
161 |                 discord.ui.TextInput(
162 |                     label="Enter Image URL (Optional)",
163 |                     placeholder="Leave empty to remove Icon.",
164 |                     required=False,
165 |                     default=getattr(self.view.embed.footer, "icon_url", None),
166 |                 )
167 |             )
168 |             await interaction.response.send_modal(modal)
169 |             await modal.wait()
170 |             url = str(modal.children[0]) or None
171 | 
172 |             if not url or not url.startswith("https"):
173 |                 self.view.embed.set_footer(icon_url=None, text=self.view.embed.footer.text)
174 | 
175 |             else:
176 |                 self.view.embed.set_footer(icon_url=url, text=self.view.embed.footer.text)
177 | 
178 |             await self.view.refresh_view()
179 | 
180 |         elif selected == "color":
181 |             from utils import QuoColor
182 | 
183 |             modal = QuoInput("Set Embed Color")
184 |             modal.add_item(
185 |                 discord.ui.TextInput(
186 |                     label="Enter a valid Color",
187 |                     placeholder="Examples: red, yellow, #00ffb3, etc.",
188 |                     required=False,
189 |                     max_length=7,
190 |                 )
191 |             )
192 |             await interaction.response.send_modal(modal)
193 |             await modal.wait()
194 | 
195 |             color = 0x36393E
196 | 
197 |             with suppress(ValueError):
198 |                 if c := str(modal.children[0]):
199 |                     color = int(str(await QuoColor.convert(self.ctx, c)).replace("#", ""), 16)
200 | 
201 |             self.view.embed.color = color
202 | 
203 |             await self.view.refresh_view()
204 | 
205 | 
206 | class EmbedBuilder(QuotientView):
207 |     def __init__(self, ctx: Context, **kwargs: T.Any):
208 |         super().__init__(ctx, timeout=100)
209 | 
210 |         self.ctx = ctx
211 |         self.add_item(EmbedOptions(self.ctx))
212 | 
213 |         for _ in kwargs.get("items", []):  # to add extra buttons and handle this view externally
214 |             self.add_item(_)
215 | 
216 |     @property
217 |     def formatted(self):
218 |         return self.embed.to_dict()
219 | 
220 |     async def refresh_view(self, to_del: T.Optional[discord.Message] = None):
221 |         if to_del is not None:
222 |             await self.ctx.safe_delete(to_del)
223 | 
224 |         with suppress(discord.HTTPException):
225 |             self.message = await self.message.edit(content=self.content, embed=self.embed, view=self)
226 | 
227 |     async def rendor(self, **kwargs: T.Any):
228 |         self.message: discord.Message = await self.ctx.send(
229 |             kwargs.get("content", ""),
230 |             embed=kwargs.get("embed", self.help_embed),
231 |             view=self,
232 |         )
233 | 
234 |         self.content = self.message.content
235 |         self.embed = self.message.embeds[0]
236 | 
237 |     @property
238 |     def help_embed(self):
239 |         return (
240 |             discord.Embed(color=self.bot.color, title="Title", description="Description")
241 |             .set_thumbnail(url="https://cdn.discordapp.com/attachments/853174868551532564/860464565338898472/embed_thumbnail.png")
242 |             .set_image(url="https://cdn.discordapp.com/attachments/853174868551532564/860462053063393280/embed_image.png")
243 |             .set_footer(
244 |                 text="Footer Message",
245 |                 icon_url="https://media.discordapp.net/attachments/853174868551532564/860464989164535828/embed_footer.png",
246 |             )
247 |         )
248 | 
249 | 
250 | class Content(discord.ui.Modal, title="Edit Message Content"):
251 |     _content: discord.ui.TextInput = discord.ui.TextInput(
252 |         label="Content",
253 |         placeholder="This text will be displayed over the embed",
254 |         required=False,
255 |         max_length=2000,
256 |         style=discord.TextStyle.long,
257 |     )
258 | 
259 |     async def on_submit(self, interaction: discord.Interaction) -> None:
260 |         await interaction.response.defer()
261 | 


--------------------------------------------------------------------------------
/core/views.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from contextlib import suppress
 4 | from typing import TYPE_CHECKING, Optional
 5 | 
 6 | import discord
 7 | 
 8 | import config
 9 | from utils import emote
10 | 
11 | if TYPE_CHECKING:
12 |     from .Context import Context
13 | 
14 | __all__ = ("QuotientView", "QuoInput", "QuoDMView")
15 | 
16 | 
17 | class QuotientView(discord.ui.View):
18 |     message: discord.Message
19 |     custom_id = None
20 | 
21 |     def __init__(self, ctx: Context, *, timeout: Optional[float] = 30):
22 |         super().__init__(timeout=timeout)
23 |         self.ctx = ctx
24 |         self.bot = ctx.bot
25 | 
26 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
27 |         if interaction.user.id != self.ctx.author.id:
28 |             await interaction.response.send_message(
29 |                 "Sorry, you can't use this interaction as it is not started by you.",
30 |                 ephemeral=True,
31 |             )
32 |             return False
33 |         return True
34 | 
35 |     async def on_timeout(self) -> None:
36 |         if hasattr(self, "message"):
37 |             for b in self.children:
38 |                 if isinstance(b, discord.ui.Button) and not b.style == discord.ButtonStyle.link:
39 |                     b.style, b.disabled = discord.ButtonStyle.grey, True
40 | 
41 |                 elif isinstance(b, discord.ui.Select):
42 |                     b.disabled = True
43 | 
44 |             with suppress(discord.HTTPException):
45 |                 await self.message.edit(view=self)
46 |                 return
47 | 
48 |     async def on_error(self, interaction: discord.Interaction, error: Exception, item) -> None:
49 |         print("Quotient View Error:", error)
50 |         self.ctx.bot.dispatch("command_error", self.ctx, error)
51 | 
52 |     @staticmethod
53 |     def tricky_invite_button():  # yes lmao
54 |         return discord.ui.Button(emoji=emote.info, url=config.SERVER_LINK)
55 | 
56 | 
57 | class QuoInput(discord.ui.Modal):
58 |     def __init__(self, title: str):
59 |         super().__init__(title=title)
60 | 
61 |     async def on_submit(self, interaction: discord.Interaction) -> None:
62 |         with suppress(discord.NotFound):
63 |             await interaction.response.defer()
64 | 
65 | 
66 | class QuoDMView(discord.ui.View):
67 |     def __init__(self, *, timeout: float = 180, label: Optional[str] = None):
68 |         super().__init__(timeout=timeout)
69 | 
70 |         self.add_item(
71 |             discord.ui.Button(
72 |                 style=discord.ButtonStyle.blurple,
73 |                 label=label,
74 |                 disabled=True,
75 |             )
76 |         )
77 | 


--------------------------------------------------------------------------------
/data/font/Ubuntu-Regular.ttf:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/font/Ubuntu-Regular.ttf


--------------------------------------------------------------------------------
/data/font/robo-bold.ttf:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/font/robo-bold.ttf


--------------------------------------------------------------------------------
/data/font/robo-italic.ttf:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/font/robo-italic.ttf


--------------------------------------------------------------------------------
/data/img/ptable1.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable1.jpg


--------------------------------------------------------------------------------
/data/img/ptable10.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable10.jpg


--------------------------------------------------------------------------------
/data/img/ptable11.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable11.jpg


--------------------------------------------------------------------------------
/data/img/ptable12.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable12.jpg


--------------------------------------------------------------------------------
/data/img/ptable13.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable13.jpg


--------------------------------------------------------------------------------
/data/img/ptable14.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable14.jpg


--------------------------------------------------------------------------------
/data/img/ptable15.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable15.jpg


--------------------------------------------------------------------------------
/data/img/ptable16.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable16.jpg


--------------------------------------------------------------------------------
/data/img/ptable17.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable17.jpg


--------------------------------------------------------------------------------
/data/img/ptable18.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable18.jpg


--------------------------------------------------------------------------------
/data/img/ptable19.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable19.jpg


--------------------------------------------------------------------------------
/data/img/ptable2.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable2.jpg


--------------------------------------------------------------------------------
/data/img/ptable20.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable20.jpg


--------------------------------------------------------------------------------
/data/img/ptable3.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable3.jpg


--------------------------------------------------------------------------------
/data/img/ptable4.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable4.jpg


--------------------------------------------------------------------------------
/data/img/ptable5.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable5.jpg


--------------------------------------------------------------------------------
/data/img/ptable6.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable6.jpg


--------------------------------------------------------------------------------
/data/img/ptable7.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable7.jpg


--------------------------------------------------------------------------------
/data/img/ptable8.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable8.jpg


--------------------------------------------------------------------------------
/data/img/ptable9.jpg:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/ptable9.jpg


--------------------------------------------------------------------------------
/data/img/rect2.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/rect2.png


--------------------------------------------------------------------------------
/data/img/rect3.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/rect3.png


--------------------------------------------------------------------------------
/data/img/rectangle.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/data/img/rectangle.png


--------------------------------------------------------------------------------
/example_config.py:
--------------------------------------------------------------------------------
 1 | # for tortoise-orm
 2 | 
 3 | TORTOISE = {}
 4 | 
 5 | 
 6 | POSTGRESQL = {}
 7 | 
 8 | EXTENSIONS = ()
 9 | 
10 | DISCORD_TOKEN = ""
11 | 
12 | COLOR = 0x00FFB3
13 | 
14 | FOOTER = "quo is lub!"
15 | 
16 | PREFIX = "q"
17 | 
18 | SERVER_LINK = ""
19 | 
20 | BOT_INVITE = ""
21 | 
22 | WEBSITE = ""
23 | 
24 | REPOSITORY = ""
25 | 
26 | DEVS = ()
27 | 
28 | # LOGS
29 | SHARD_LOG = ""
30 | ERROR_LOG = ""
31 | PUBLIC_LOG = ""
32 | 


--------------------------------------------------------------------------------
/models/__init__.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from tortoise import models
 9 | 
10 | 
11 | class BaseDbModel(models.Model):
12 |     """Base Model for all tortoise models"""
13 | 
14 |     class Meta:
15 |         abstract = True
16 | 
17 |     bot: Quotient
18 | 
19 | 
20 | from .esports import *
21 | from .helpers import *
22 | from .misc import *
23 | 


--------------------------------------------------------------------------------
/models/__pycache__/__init__.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/__pycache__/__init__.cpython-312.pyc


--------------------------------------------------------------------------------
/models/esports/__init__.py:
--------------------------------------------------------------------------------
1 | from .scrims import *
2 | from .slotm import *
3 | from .ssverify import *
4 | from .tagcheck import *
5 | from .tourney import *
6 | 


--------------------------------------------------------------------------------
/models/esports/__pycache__/__init__.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/esports/__pycache__/__init__.cpython-312.pyc


--------------------------------------------------------------------------------
/models/esports/__pycache__/scrims.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/esports/__pycache__/scrims.cpython-312.pyc


--------------------------------------------------------------------------------
/models/esports/__pycache__/slotm.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/esports/__pycache__/slotm.cpython-312.pyc


--------------------------------------------------------------------------------
/models/esports/__pycache__/ssverify.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/esports/__pycache__/ssverify.cpython-312.pyc


--------------------------------------------------------------------------------
/models/esports/__pycache__/tagcheck.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/esports/__pycache__/tagcheck.cpython-312.pyc


--------------------------------------------------------------------------------
/models/esports/__pycache__/tourney.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/esports/__pycache__/tourney.cpython-312.pyc


--------------------------------------------------------------------------------
/models/esports/ptable.py:
--------------------------------------------------------------------------------
 1 | from tortoise import fields, models
 2 | 
 3 | from models.helpers import *
 4 | 
 5 | 
 6 | class PtableTourney(models.Model):
 7 |     class Meta:
 8 |         table = "ptable_tourney"
 9 | 
10 |     id = fields.IntField(pk=True)
11 |     guild_id = fields.BigIntField()
12 |     associative_id = fields.CharField(max_length=10)
13 |     title = fields.CharField(max_length=100)
14 |     secondary_title = fields.CharField(max_length=100)
15 |     footer = fields.CharField(max_length=100)
16 | 
17 |     per_kill = fields.IntField(default=0)
18 |     postion_pts = fields.JSONField(default=dict)
19 | 
20 |     background_image = fields.CharField(max_length=200)
21 |     colors = fields.JSONField(default=dict)
22 | 
23 |     created_at = fields.DatetimeField(auto_now_add=True)
24 |     teams: fields.ManyToManyRelation["PtableTeam"] = fields.ManyToManyField("models.PtableTeam")
25 |     matches: fields.ManyToManyRelation["PtableMatch"] = fields.ManyToManyField("models.PtableMatch")
26 | 
27 | 
28 | class PtableTeam(models.Model):
29 |     class Meta:
30 |         table = "ptable_teams"
31 | 
32 |     id = fields.IntField(pk=True)
33 |     team_name = fields.CharField(max_length=100)
34 |     email = fields.CharField(max_length=100, null=True)
35 |     phone = fields.CharField(max_length=10, null=True)
36 |     logo = fields.CharField(max_length=200, null=True)
37 |     added_by = fields.BigIntField()
38 |     team_owner = fields.BigIntField()
39 |     players = ArrayField(fields.BigIntField(default=list))
40 |     last_used = fields.DatetimeField(auto_now=True)
41 | 
42 | 
43 | class PtableMatch(models.Model):
44 |     class Meta:
45 |         table = "ptable_match"
46 | 
47 |     id = fields.IntField(pk=True)
48 |     name = fields.CharField(max_length=100)
49 |     created_at = fields.DatetimeField(auto_now=True)
50 |     created_by = fields.BigIntField()
51 |     results = fields.JSONField()
52 | 


--------------------------------------------------------------------------------
/models/esports/reserve.py:
--------------------------------------------------------------------------------
 1 | from tortoise import fields, models
 2 | 
 3 | from models.helpers import *
 4 | 
 5 | 
 6 | class Subscriptions(models.Model):
 7 |     class Meta:
 8 |         table = "subscriptions"
 9 | 
10 |     guild_id = fields.BigIntField(pk=True)
11 |     log_channel_id = fields.BigIntField()
12 |     slug = fields.CharField(max_length=20)
13 |     balance = fields.IntField(default=0)
14 |     upi_id = fields.CharField(max_length=25)
15 | 
16 |     plans: fields.ManyToManyRelation["SubPlan"] = fields.ManyToManyField("models.SubPlan")
17 |     logs: fields.ManyToManyRelation["SubLog"] = fields.ManyToManyField("models.SubLog")
18 | 
19 | 
20 | class SubPlan(models.Model):
21 |     class Meta:
22 |         table = "subscription_plans"
23 | 
24 |     id = fields.IntField(pk=True)
25 |     name = fields.CharField(max_length=30)
26 |     theme_color = fields.CharField(max_length=7)
27 |     days = fields.IntField(default=1)
28 |     slots = fields.IntField(default=1)
29 |     perks = ArrayField(fields.CharField(max_length=100))
30 |     price = fields.IntField()
31 | 
32 | 
33 | class SubLog(models.Model):
34 |     class Meta:
35 |         table = "subscription_logs"
36 | 
37 |     id = fields.IntField(pk=True)
38 | 


--------------------------------------------------------------------------------
/models/esports/scrims.py:
--------------------------------------------------------------------------------
  1 | import asyncio
  2 | import io
  3 | from ast import literal_eval as leval
  4 | from contextlib import suppress
  5 | from datetime import timedelta
  6 | from pathlib import Path
  7 | from typing import List, Optional
  8 | 
  9 | import discord
 10 | import humanize
 11 | from aiocache import cached
 12 | from PIL import Image, ImageDraw, ImageFont
 13 | from tortoise import fields, models
 14 | 
 15 | import utils
 16 | from constants import AutocleanType, Day, EsportsLog, EsportsRole
 17 | from core import Context
 18 | from models import BaseDbModel
 19 | from models.helpers import *
 20 | from utils import discord_timestamp, plural, truncate_string
 21 | 
 22 | 
 23 | class Scrim(BaseDbModel):
 24 |     class Meta:
 25 |         table = "sm.scrims"
 26 | 
 27 |     id = fields.BigIntField(pk=True, index=True)
 28 |     guild_id = fields.BigIntField()
 29 |     name = fields.TextField(default="Quotient-Scrims")
 30 |     registration_channel_id = fields.BigIntField(index=True)
 31 |     slotlist_channel_id = fields.BigIntField()
 32 |     slotlist_message_id = fields.BigIntField(null=True)
 33 |     role_id = fields.BigIntField(null=True)
 34 |     required_mentions = fields.IntField(default=4)
 35 |     start_from = fields.IntField(default=1)
 36 |     available_slots = ArrayField(fields.IntField(), default=list)
 37 |     total_slots = fields.IntField()
 38 |     host_id = fields.BigIntField()
 39 |     open_time = fields.DatetimeField()
 40 |     opened_at = fields.DatetimeField(null=True)
 41 |     closed_at = fields.DatetimeField(null=True)
 42 | 
 43 |     autoclean = ArrayField(fields.CharEnumField(AutocleanType), default=lambda: list(AutocleanType))
 44 |     autoclean_done = fields.BooleanField(default=False)
 45 |     autoclean_time = fields.DatetimeField(null=True)
 46 | 
 47 |     autoslotlist = fields.BooleanField(default=True)
 48 |     ping_role_id = fields.BigIntField(null=True)
 49 |     multiregister = fields.BooleanField(default=False)
 50 |     stoggle = fields.BooleanField(default=True)
 51 |     open_role_id = fields.BigIntField(null=True)
 52 |     autodelete_rejects = fields.BooleanField(default=False)
 53 |     autodelete_extras = fields.BooleanField(default=True)
 54 |     teamname_compulsion = fields.BooleanField(default=False)
 55 | 
 56 |     time_elapsed = fields.CharField(null=True, max_length=100)
 57 |     show_time_elapsed = fields.BooleanField(default=True)
 58 | 
 59 |     open_days = ArrayField(fields.CharEnumField(Day), default=lambda: list(Day))
 60 |     slotlist_format = fields.JSONField(default=dict)  #!str > jsonb
 61 | 
 62 |     no_duplicate_name = fields.BooleanField(default=False)
 63 | 
 64 |     open_message = fields.JSONField(default=dict)
 65 |     close_message = fields.JSONField(default=dict)
 66 |     banlog_channel_id = fields.BigIntField(null=True)
 67 | 
 68 |     match_time = fields.DatetimeField(null=True)
 69 | 
 70 |     emojis = fields.JSONField(default=dict)  #!new
 71 |     cdn = fields.JSONField(default={"status": False, "countdown": 3, "msg": {}})  #!new
 72 | 
 73 |     required_lines = fields.SmallIntField(default=0)
 74 |     allow_duplicate_tags = fields.BooleanField(default=True)
 75 |     # require_drop_location = fields.BooleanField(default=False)
 76 | 
 77 |     assigned_slots: fields.ManyToManyRelation["AssignedSlot"] = fields.ManyToManyField("models.AssignedSlot")
 78 |     reserved_slots: fields.ManyToManyRelation["ReservedSlot"] = fields.ManyToManyField("models.ReservedSlot")
 79 |     banned_teams: fields.ManyToManyRelation["BannedTeam"] = fields.ManyToManyField("models.BannedTeam")
 80 |     slot_reminders: fields.ManyToManyRelation["ScrimsSlotReminder"] = fields.ManyToManyField("models.ScrimsSlotReminder")
 81 | 
 82 |     def __str__(self):
 83 |         return f"{getattr(self.registration_channel,'mention','deleted-channel')} (ID: {self.id})"
 84 | 
 85 |     @staticmethod
 86 |     def is_ignorable(member: discord.Member) -> bool:
 87 |         return "scrims-mod" in (role.name.lower() for role in member.roles)
 88 | 
 89 |     @property
 90 |     def guild(self) -> Optional[discord.Guild]:
 91 |         return self.bot.get_guild(self.guild_id)
 92 | 
 93 |     @property
 94 |     def role(self):
 95 |         if self.guild is not None:
 96 |             return self.guild.get_role(self.role_id)
 97 | 
 98 |     @property
 99 |     def logschan(self):
100 |         if self.guild is not None:
101 |             return discord.utils.get(self.guild.text_channels, name="quotient-scrims-logs")
102 | 
103 |     @property
104 |     def modrole(self):
105 |         if self.guild is not None:
106 |             return discord.utils.get(self.guild.roles, name="scrims-mod")
107 | 
108 |     @property
109 |     def registration_channel(self):
110 |         return self.bot.get_channel(self.registration_channel_id)
111 | 
112 |     @property
113 |     def banlog_channel(self):
114 |         return self.bot.get_channel(self.banlog_channel_id)
115 | 
116 |     @property
117 |     def slotlist_channel(self):
118 |         return self.bot.get_channel(self.slotlist_channel_id)
119 | 
120 |     @property
121 |     def host(self):
122 |         if self.guild is not None:
123 |             return self.guild.get_member(self.host_id)
124 | 
125 |         return self.bot.get_user(self.host_id)
126 | 
127 |     @property
128 |     def check_emoji(self):
129 |         return self.emojis.get("tick", "✅")
130 | 
131 |     @property
132 |     def cross_emoji(self):
133 |         return self.emojis.get("cross", "❌")
134 | 
135 |     @property
136 |     def available_to_reserve(self):
137 |         """
138 |         gives a range obj of available slots to reserve.
139 |         this isn't true because some slots might be already reserved , we will sort them later
140 |         """
141 |         return range(self.start_from, self.total_slots + self.start_from)
142 | 
143 |     @property
144 |     def opened(self):
145 |         if self.opened_at is None:
146 |             return False
147 | 
148 |         if self.closed_at is not None:
149 |             return self.closed_at < self.opened_at
150 | 
151 |         return True
152 | 
153 |     @property
154 |     def closed(self):
155 |         return not self.opened
156 | 
157 |     @property
158 |     def ping_role(self):
159 |         if self.guild is not None:
160 |             return self.guild.get_role(self.ping_role_id)
161 | 
162 |     @property
163 |     def open_role(self):
164 |         if self.guild is not None:
165 |             if self.open_role_id is not None:
166 |                 return self.guild.get_role(self.open_role_id)
167 |             return self.guild.default_role
168 | 
169 |     @property  # what? you think its useless , i know :)
170 |     def toggle(self):
171 |         return self.stoggle
172 | 
173 |     @property
174 |     def teams_registered(self):  # This should be awaited
175 |         return self.assigned_slots.order_by("num")
176 | 
177 |     async def reserved_user_ids(self):
178 |         return (i.user_id for i in await self.reserved_slots.all())
179 | 
180 |     async def banned_user_ids(self):
181 |         return (i.user_id for i in await self.banned_teams.all())
182 | 
183 |     async def cleaned_slots(self) -> List["AssignedSlot"]:
184 |         slots = await self.assigned_slots.order_by("num")
185 | 
186 |         _list = []
187 |         for _ in {slot.num for slot in slots}:
188 |             _list.append(next(i for i in slots if i.num == _))
189 | 
190 |         return _list
191 | 
192 |     async def add_tick(self, msg: discord.Message):
193 |         with suppress(discord.HTTPException):
194 |             await msg.add_reaction(self.check_emoji)
195 |             await msg.author.add_roles(self.role)
196 | 
197 |     @staticmethod
198 |     def default_slotlist_format():
199 |         return discord.Embed(color=0x00FFB3, title=f"<<name>> Slotlist", description="```\n<<slots>>\n```").set_footer(
200 |             text=f"Registration took: <<time_taken>>"
201 |         )
202 | 
203 |     async def create_slotlist(self):
204 |         _slots = await self.cleaned_slots()
205 | 
206 |         desc = "\n".join(f"Slot {slot.num:02}  ->  {slot.team_name}" for slot in _slots)
207 | 
208 |         if len(self.slotlist_format) <= 1:
209 |             text = str(self.default_slotlist_format().to_dict())
210 |         else:
211 |             text = str(self.slotlist_format)
212 | 
213 |         changes = [
214 |             ("<<name>>", self.name),
215 |             ("<<time_taken>>", self.time_elapsed or "N/A"),
216 |             ("<<open_time>>", discord_timestamp(self.open_time)),
217 |         ]
218 | 
219 |         for _ in changes:
220 |             text = text.replace(*_)
221 | 
222 |         embed = discord.Embed.from_dict(leval(text))
223 |         if embed.color == None:
224 |             embed.color = 0x2F3136
225 | 
226 |         embed.description = embed.description.replace("<<slots>>", desc)
227 | 
228 |         return embed, self.slotlist_channel
229 | 
230 |     async def refresh_slotlist_message(self, msg: discord.Message = None):
231 |         embed, channel = await self.create_slotlist()
232 | 
233 |         with suppress(discord.HTTPException, AttributeError):
234 |             if not msg:
235 |                 msg = await self.bot.get_or_fetch_message(channel, self.slotlist_message_id)
236 |                 # msg = await channel.fetch_message(self.slotlist_message_id)
237 | 
238 |             await msg.edit(embed=embed)
239 | 
240 |     async def send_slotlist(self, channel: discord.TextChannel = None) -> discord.Message:
241 |         from cogs.esports.views.smslotlist.button import SlotlistEditButton
242 | 
243 |         channel = channel or self.slotlist_channel
244 | 
245 |         _v = SlotlistEditButton(self.bot, self)
246 |         embed, schannel = await self.create_slotlist()
247 |         _v.message = await channel.send(embed=embed, view=_v)
248 | 
249 |         if channel == schannel:
250 |             await self.make_changes(slotlist_message_id=_v.message.id)
251 | 
252 |         return _v.message
253 | 
254 |     async def dispatch_reminders(self, channel: discord.TextChannel, link: str):
255 |         reminders = await self.slot_reminders.all().order_by("created_at")
256 | 
257 |         if not reminders:
258 |             return
259 | 
260 |         _e = discord.Embed(color=0x00FFB3, title=f"Slot Available to Claim - {channel.guild.name}", url=link)
261 |         _e.description = f"A slot of {self} is available to claim in {channel.mention}!\nClaim it before anyone else do."
262 | 
263 |         async for user in self.bot.resolve_member_ids(self.guild, [i.user_id for i in reminders]):
264 |             with suppress(discord.HTTPException):
265 |                 await user.send(embed=_e)
266 | 
267 |         await ScrimsSlotReminder.filter(pk__in=(i.pk for i in reminders)).delete()
268 | 
269 |     async def ensure_match_timer(self):
270 |         from models import Timer
271 | 
272 |         from .slotm import ScrimsSlotManager
273 | 
274 |         if not self.match_time:
275 |             self.match_time = self.bot.current_time.replace(hour=0, minute=0, microsecond=0, second=0)
276 | 
277 |         _time = self.match_time
278 |         while _time < self.bot.current_time:
279 |             _time = _time + timedelta(hours=24)
280 | 
281 |         if self.match_time != _time:
282 |             await Scrim.filter(pk=self.pk).update(match_time=_time)
283 | 
284 |         check = await Timer.filter(event="scrim_match", expires=_time, extra={"args": [], "kwargs": {"scrim_id": self.pk}}).exists()
285 |         if not check:
286 |             await self.bot.reminders.create_timer(_time, "scrim_match", scrim_id=self.pk)
287 | 
288 |         await ScrimsSlotManager.refresh_guild_message(self.guild_id, self.pk)
289 | 
290 |     async def make_changes(self, **kwargs):
291 |         await Scrim.filter(pk=self.pk).update(**kwargs)
292 |         return await self.refresh_from_db()
293 | 
294 |     async def get_text_slotlist(self):
295 |         _text = f"{self} Slot details:\n\n"
296 |         _slots = await self.cleaned_slots()
297 | 
298 |         for _ in _slots:
299 |             _text += f"{_.num}. {_.team_name} <@{_.user_id}>\n"
300 | 
301 |         return _text
302 | 
303 |     async def ban_slot(self, slot: "AssignedSlot", *, reason, mod: discord.Member, ban_type: str):
304 |         to_ban, scrims = [slot.user_id], [self]
305 | 
306 |         if ban_type == "2":
307 |             to_ban = [_ for _ in slot.members]
308 | 
309 |         elif ban_type == "3":
310 |             scrims = await Scrim.filter(guild_id=self.guild_id).order_by("open_time")
311 | 
312 |         elif ban_type == "4":
313 |             to_ban = [_ for _ in slot.members]
314 |             scrims = await Scrim.filter(guild_id=self.guild_id).order_by("open_time")
315 | 
316 |         for _ in to_ban:
317 |             for scrim in scrims:
318 |                 if _ in await scrim.banned_user_ids():
319 |                     continue
320 | 
321 |                 b = await BannedTeam.create(user_id=_, expires=reason.dt, reason=reason.arg)
322 |                 await scrim.banned_teams.add(b)
323 | 
324 |             if banlog := await BanLog.get_or_none(guild_id=self.guild_id):
325 |                 await banlog.log_ban(_, mod, scrims, reason.arg, reason.dt)
326 | 
327 |             if reason.dt:
328 |                 await self.bot.reminders.create_timer(
329 |                     reason.dt,
330 |                     "scrim_ban",
331 |                     scrims=[scrim.id for scrim in scrims],
332 |                     user_id=_,
333 |                     mod=mod.id,
334 |                     reason=reason.arg,
335 |                 )
336 | 
337 |         return f"Banned {utils.plural(to_ban):player|players} from {utils.plural(scrims):scrim|scrims}."
338 | 
339 |     async def create_slotlist_img(self):
340 |         """
341 |         This is done! Now do whatever you can : )
342 |         """
343 |         slots = await self.teams_registered
344 | 
345 |         def wrapper():
346 |             font = ImageFont.truetype(str(Path.cwd() / "src" / "data" / "font" / "Ubuntu-Regular.ttf"), 16)
347 |             rects = []
348 | 
349 |             for slot in slots:
350 |                 image = Image.new("RGBA", (290, 30), "#2e2e2e")
351 |                 draw = ImageDraw.Draw(image)
352 |                 draw.text((10, 5), f"Slot {slot.num:02}  |  {slot.team_name}", font=font, fill="white")
353 |                 rects.append(image)
354 | 
355 |             # We will add 10 slots in a image.
356 |             images = []
357 |             for group in utils.split_list(rects, 10):
358 |                 size = (
359 |                     290,
360 |                     len(group) * 40,
361 |                 )
362 |                 image = Image.new("RGBA", size)
363 |                 x = 0
364 |                 y = 0
365 | 
366 |                 for rect in group:
367 |                     image.paste(rect, (x, y))
368 |                     y += rect.size[1] + 10
369 | 
370 |                 img_bytes = io.BytesIO()
371 |                 image.save(img_bytes, "PNG")
372 |                 img_bytes.seek(0)
373 |                 images.append(discord.File(img_bytes, "slotlist.png"))
374 | 
375 |             return images
376 | 
377 |         return await asyncio.get_event_loop().run_in_executor(
378 |             None, wrapper
379 |         )  # As pillow is blocking, we will process image in executor
380 | 
381 |     async def reg_open_msg(self):
382 |         reserved_count = await self.reserved_slots.all().count()
383 | 
384 |         if len(self.open_message) <= 1:
385 |             return discord.Embed(
386 |                 color=self.bot.color,
387 |                 title="Registration is now open!",
388 |                 description=f"📣 **`{self.required_mentions}`** mentions required.\n"
389 |                 f"📣 Total slots: **`{self.total_slots}`** [`{reserved_count}` slots reserved]",
390 |             )
391 | 
392 |         changes = [
393 |             ("<<mentions>>", str(self.required_mentions)),
394 |             ("<<slots>>", str(self.total_slots)),
395 |             ("<<reserved>>", str(reserved_count)),
396 |             ("<<slotlist>>", getattr(self.slotlist_channel, "mention", "Not Found")),
397 |             ("<<multireg>>", "Enabled" if self.multiregister else "Not Enabled"),
398 |             ("<<teamname>>", "Yes" if self.teamname_compulsion else "No"),
399 |             (
400 |                 "<<mention_banned>>",
401 |                 ", ".join(map(lambda x: getattr(x, "mention", "Left"), map(self.guild.get_member, await self.banned_user_ids()))),
402 |             ),
403 |             (
404 |                 "<<mention_reserved>>",
405 |                 ", ".join(
406 |                     map(
407 |                         lambda x: getattr(x, "mention", "Left"),
408 |                         map(self.guild.get_member, await self.reserved_user_ids()),
409 |                     )
410 |                 ),
411 |             ),
412 |         ]
413 | 
414 |         text = str(self.open_message)
415 |         for _ in changes:
416 |             text = text.replace(*_)
417 | 
418 |         return discord.Embed.from_dict(leval(text))
419 | 
420 |     def reg_close_msg(self):
421 |         if len(self.close_message) <= 1:
422 |             return discord.Embed(color=self.bot.config.COLOR, description="**Registration is now Closed!**")
423 | 
424 |         changes = [
425 |             ("<<slots>>", str(self.total_slots)),
426 |             ("<<filled>>", str(self.total_slots - len(self.available_slots))),
427 |             ("<<time_taken>>", self.time_elapsed or "N/A"),
428 |             ("<<open_time>>", discord_timestamp(self.open_time)),
429 |         ]
430 | 
431 |         text = str(self.close_message)
432 |         for _ in changes:
433 |             text = text.replace(*_)
434 | 
435 |         return discord.Embed.from_dict(leval(text))
436 | 
437 |     async def setup_logs(self):
438 |         _reason = "Created for scrims management."
439 | 
440 |         guild = self.guild
441 | 
442 |         if not (scrims_mod := self.modrole):
443 |             scrims_mod = await guild.create_role(name="scrims-mod", color=self.bot.color, reason=_reason)
444 | 
445 |         overwrite = self.registration_channel.overwrites_for(guild.default_role)
446 |         overwrite.update(read_messages=True, send_messages=True, read_message_history=True)
447 |         await self.registration_channel.set_permissions(scrims_mod, overwrite=overwrite)
448 | 
449 |         if (scrims_log_channel := self.logschan) is None:
450 |             overwrites = {
451 |                 guild.default_role: discord.PermissionOverwrite(read_messages=False),
452 |                 guild.me: discord.PermissionOverwrite(read_messages=True),
453 |                 scrims_mod: discord.PermissionOverwrite(read_messages=True),
454 |             }
455 |             scrims_log_channel = await guild.create_text_channel(
456 |                 name="quotient-scrims-logs",
457 |                 overwrites=overwrites,
458 |                 reason=_reason,
459 |                 topic="**DO NOT RENAME THIS CHANNEL**",
460 |             )
461 | 
462 |             note = await scrims_log_channel.send(
463 |                 embed=discord.Embed(
464 |                     description=f"If events related to scrims i.e opening registrations or adding roles, "
465 |                     f"etc are triggered, then they will be logged in this channel. "
466 |                     f"Also I have created {scrims_mod.mention}, you can give that role to your "
467 |                     f"scrims-moderators. User with {scrims_mod.mention} can also send messages in "
468 |                     f"registration channels and they won't be considered as scrims-registration.\n\n"
469 |                     f"`Note`: **Do not rename this channel.**",
470 |                     color=0x00FFB3,
471 |                 )
472 |             )
473 |             await note.pin()
474 | 
475 |     async def full_delete(self):
476 |         from .slotm import ScrimsSlotManager
477 | 
478 |         _id = self.pk
479 |         self.bot.cache.scrim_channels.discard(self.registration_channel_id)
480 | 
481 |         slotm = await ScrimsSlotManager.filter(guild_id=self.guild_id, scrim_ids__contains=self.pk)
482 |         await ScrimsSlotManager.filter(pk__in=[_.pk for _ in slotm]).update(scrim_ids=ArrayRemove("scrim_ids", _id))
483 | 
484 |         _d = await self.assigned_slots.all()
485 |         await AssignedSlot.filter(pk__in=[_.pk for _ in _d]).delete()
486 |         _r = await self.slot_reminders.all()
487 |         await ScrimsSlotReminder.filter(pk__in=[_.pk for _ in _r]).delete()
488 |         _re = await self.reserved_slots.all()
489 |         await ReservedSlot.filter(pk__in=[_.pk for _ in _re]).delete()
490 |         await self.delete()
491 | 
492 |     async def confirm_all_scrims(self, ctx: Context, **kwargs):
493 |         if not await Scrim.scrim_count(ctx.guild.id) > 1:
494 |             return
495 | 
496 |         prompt = await ctx.prompt("Do you want to apply these changes to all scrims in this server?")
497 |         if not prompt:
498 |             return await ctx.simple("Alright, this scrim only.", 4)
499 | 
500 |         await Scrim.filter(guild_id=ctx.guild.id).update(**kwargs)
501 |         await ctx.simple("This change was applied to all your scrims.", 4)
502 | 
503 |     async def close_registration(self):
504 |         from cogs.esports.helpers.utils import toggle_channel, wait_and_purge
505 | 
506 |         from .slotm import ScrimsSlotManager
507 | 
508 |         closed_at = self.bot.current_time
509 |         registration_channel = self.registration_channel
510 |         open_role = self.open_role
511 | 
512 |         self.time_elapsed = humanize.precisedelta(closed_at - self.opened_at)
513 |         await self.make_changes(opened_at=None, time_elapsed=self.time_elapsed, closed_at=closed_at)
514 | 
515 |         channel_update = await toggle_channel(registration_channel, open_role, False)
516 |         _e = self.reg_close_msg()
517 |         await registration_channel.send(embed=_e)
518 | 
519 |         self.bot.dispatch("scrim_log", EsportsLog.closed, self, permission_updated=channel_update)
520 | 
521 |         registered = await self.teams_registered
522 | 
523 |         if self.autoslotlist and registered:
524 |             await self.send_slotlist()
525 | 
526 |         if self.autodelete_extras:
527 |             msg_ids = (i.message_id for i in registered)
528 | 
529 |             check = lambda x: all((not x.pinned, not x.reactions, not x.embeds, not x.author == self.bot.user, not x.id in msg_ids))
530 |             self.bot.loop.create_task(wait_and_purge(registration_channel, check=check, wait_for=60))
531 | 
532 |         slotm = await ScrimsSlotManager.get_or_none(guild_id=self.guild_id, scrim_ids__contains=self.id)
533 |         if slotm:
534 |             await slotm.refresh_public_message()
535 | 
536 |     async def __add_role_to_reserved_users(self, member_ids: set[int]):
537 |         role = discord.Object(id=self.role_id)
538 |         async for member in self.bot.resolve_member_ids(self.guild, member_ids):
539 |             try:
540 |                 if not member._roles.has(role.id):
541 |                     await member.add_roles(role, reason=f"Reserved Slot [{self.pk}]")
542 |                     await asyncio.sleep(0.2)
543 |             except discord.HTTPException:
544 |                 continue
545 | 
546 |     async def start_registration(self):
547 |         from cogs.esports.helpers.utils import (
548 |             available_to_reserve,
549 |             scrim_work_role,
550 |             toggle_channel,
551 |         )
552 | 
553 |         oldslots = await self.assigned_slots
554 |         await AssignedSlot.filter(id__in=(slot.id for slot in oldslots)).delete()
555 |         await self.assigned_slots.clear()
556 | 
557 |         # here we insert a list of slots we can give for the registration.
558 |         await self.bot.db.execute(
559 |             """
560 |             UPDATE public."sm.scrims" SET available_slots = $1 WHERE id = $2
561 |             """,
562 |             await available_to_reserve(self),
563 |             self.id,
564 |         )
565 | 
566 |         reserved_slots = await self.reserved_slots.all().order_by("num")
567 |         reserved_user_ids = {slot.user_id for slot in reserved_slots if slot.user_id is not None}
568 | 
569 |         for slot in reserved_slots:
570 |             assinged_slot = await AssignedSlot.create(
571 |                 num=slot.num,
572 |                 user_id=slot.user_id,
573 |                 team_name=slot.team_name,
574 |                 jump_url=None,
575 |             )
576 | 
577 |             await self.assigned_slots.add(assinged_slot)
578 | 
579 |         self.bot.loop.create_task(self.__add_role_to_reserved_users(reserved_user_ids))
580 | 
581 |         await Scrim.filter(pk=self.id).update(
582 |             opened_at=self.bot.current_time,
583 |             closed_at=None,
584 |             slotlist_message_id=None,
585 |         )
586 |         self.bot.loop.create_task(self.ensure_match_timer())
587 |         await asyncio.sleep(0.2)
588 | 
589 |         # Opening Channel for Normal Janta
590 |         registration_channel = self.registration_channel
591 |         open_role = self.open_role
592 | 
593 |         # check if countdown is on
594 | 
595 |         # if self.cdn.get("status", False):
596 |         #     ...
597 | 
598 |         _e = await self.reg_open_msg()
599 | 
600 |         await registration_channel.send(
601 |             content=scrim_work_role(self, EsportsRole.ping),
602 |             embed=_e,
603 |             allowed_mentions=discord.AllowedMentions(roles=True, everyone=True),
604 |         )
605 | 
606 |         self.bot.cache.scrim_channels.add(registration_channel.id)
607 | 
608 |         await toggle_channel(registration_channel, open_role, True)
609 |         self.bot.dispatch("scrim_log", EsportsLog.open, self)
610 | 
611 |     @staticmethod
612 |     async def show_selector(*args, **kwargs):
613 |         """
614 |         :param: ctx: Context
615 |         :param: scrims: List[Scrim]
616 |         :param: placeholder:str
617 |         :param: multi:bool=True
618 |         """
619 |         from cogs.esports.views.scrims.selector import prompt_selector
620 | 
621 |         return await prompt_selector(*args, **kwargs)
622 | 
623 |     async def scrim_posi(self):
624 |         from cogs.esports.views.scrims.selector import scrim_position
625 | 
626 |         return await scrim_position(self.pk, self.guild_id)
627 | 
628 |     @staticmethod
629 |     @cached(ttl=60 * 2)
630 |     async def scrim_count(guild_id: int):
631 |         return await Scrim.filter(guild_id=guild_id).count()
632 | 
633 |     async def check_fake_tags(self, message: discord.Message):
634 |         query = """
635 |         SELECT *
636 |             FROM PUBLIC."sm.scrims_sm.assigned_slots" AS ASSIGNED_SLOT
637 |             INNER JOIN PUBLIC."sm.assigned_slots" AS SLOTS ON SLOTS.ID = ASSIGNED_SLOT.ASSIGNEDSLOT_ID
638 |         WHERE ASSIGNED_SLOT."sm.scrims_id" = $1
639 |         AND $2 && SLOTS.MEMBERS;
640 | 
641 |         """
642 |         return await self.bot.db.fetch(query, self.id, [i.id for i in message.mentions])
643 | 
644 | 
645 | class BaseSlot(models.Model):
646 |     class Meta:
647 |         abstract = True
648 | 
649 |     id = fields.IntField(pk=True)
650 |     num = fields.IntField(null=True)  # this will never be null but there are already records in the table so
651 |     user_id = fields.BigIntField(null=True)
652 |     team_name = fields.TextField(null=True)
653 |     # drop_location = fields.CharField(max_length=30, null=True)
654 |     members = ArrayField(fields.BigIntField(), default=list)
655 | 
656 | 
657 | class AssignedSlot(BaseSlot):
658 |     class Meta:
659 |         table = "sm.assigned_slots"
660 | 
661 |     message_id = fields.BigIntField(null=True)
662 |     jump_url = fields.TextField(null=True)
663 | 
664 |     @property
665 |     def owner(self) -> discord.User:
666 |         return self.bot.get_user(self.user_id)
667 | 
668 | 
669 | class ReservedSlot(BaseSlot):
670 |     class Meta:
671 |         table = "sm.reserved_slots"
672 | 
673 |     expires = fields.DatetimeField(null=True)
674 | 
675 |     @property
676 |     def leader(self):
677 |         return self.bot.get_user(self.user_id)
678 | 
679 | 
680 | class BannedTeam(BaseSlot):
681 |     class Meta:
682 |         table = "sm.banned_teams"
683 | 
684 |     reason = fields.CharField(max_length=200, null=True)
685 |     expires = fields.DatetimeField(null=True)
686 | 
687 | 
688 | class BanLog(BaseDbModel):
689 |     class Meta:
690 |         table = "esports_bans"
691 | 
692 |     id = fields.IntField(pk=True)
693 |     guild_id = fields.BigIntField()
694 |     channel_id = fields.BigIntField()
695 | 
696 |     @property
697 |     def channel(self):
698 |         return self.bot.get_channel(self.channel_id)
699 | 
700 |     def __format_scrims(self, scrims: List[Scrim]):
701 |         _scrims = []
702 |         for idx, _ in enumerate(scrims, start=1):
703 |             if idx < 4:
704 |                 _scrims.append(getattr(_.registration_channel, "mention", "`deleted-channel`"))
705 | 
706 |             elif idx == 4:
707 |                 _scrims.append(f"**...{len(scrims) -  3} more**")
708 | 
709 |         return ", ".join(_scrims)
710 | 
711 |     async def log_ban(self, user_id: int, mod: discord.Member, scrims: List[Scrim], reason: str = None, dt: str = None):
712 |         user: discord.User = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, user_id)
713 | 
714 |         _e = discord.Embed(color=discord.Color.red(), title=f"🔨 Banned from {plural(scrims):scrim|scrims}")
715 |         _e.add_field(name="User", value=f"{user} ({getattr(user, 'mention','unknown-user')})")
716 |         _e.add_field(name="Moderator", value=mod)
717 |         _e.add_field(name="Effected Scrims", value=self.__format_scrims(scrims), inline=False)
718 |         _e.add_field(name="Reason", value=f"```{truncate_string(reason,100) if reason else 'No reason given'}```")
719 | 
720 |         _e.set_footer(text=f"Expiring: {'Never' if not dt else ''}")
721 |         if dt:
722 |             _e.timestamp = dt
723 | 
724 |         if user:
725 |             _e.set_thumbnail(url=getattr(user.display_avatar, "url", "https://cdn.discordapp.com/embed/avatars/0.png"))
726 | 
727 |         with suppress(discord.HTTPException, AttributeError):
728 |             await self.channel.send(getattr(user, "mention", ""), embed=_e)
729 | 
730 |     async def log_unban(self, user_id: int, mod: discord.Member, scrims: List[Scrim], reason: str = None):
731 |         user = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, user_id)
732 |         _e = discord.Embed(color=discord.Color.green(), title=f"🍃 Unbanned from {plural(scrims):Scrim|Scrims}")
733 |         _e.add_field(name="User", value=f"{user} ({getattr(user, 'mention','unknown-user')})")
734 |         _e.add_field(name="Moderator", value=mod)
735 |         _e.add_field(name="Effected Scrims", value=self.__format_scrims(scrims), inline=False)
736 |         _e.add_field(name="Reason", value=reason or "```No Reason given..```", inline=False)
737 |         _e.timestamp = self.bot.current_time
738 | 
739 |         if user:
740 |             _e.set_thumbnail(url=getattr(user.display_avatar, "url", "https://cdn.discordapp.com/embed/avatars/0.png"))
741 | 
742 |         with suppress(discord.HTTPException, AttributeError):
743 |             await self.channel.send(getattr(user, "mention", ""), embed=_e)
744 | 
745 | 
746 | class ScrimsSlotReminder(BaseDbModel):
747 |     class Meta:
748 |         table = "scrims_slot_reminders"
749 | 
750 |     id = fields.IntField(pk=True)
751 |     user_id = fields.BigIntField()
752 |     created_at = fields.DatetimeField(auto_now=True)
753 | 


--------------------------------------------------------------------------------
/models/esports/slotm.py:
--------------------------------------------------------------------------------
  1 | from contextlib import suppress
  2 | from typing import Any, List, Optional, Tuple
  3 | 
  4 | import discord
  5 | from tortoise import fields
  6 | 
  7 | from models import BaseDbModel
  8 | from models.helpers import ArrayField
  9 | from utils import aenumerate, plural
 10 | 
 11 | from .scrims import Scrim
 12 | 
 13 | __all__ = ("ScrimsSlotManager",)
 14 | 
 15 | 
 16 | class ScrimsSlotManager(BaseDbModel):
 17 |     class Meta:
 18 |         table = "slot_manager"
 19 | 
 20 |     id = fields.IntField(pk=True)
 21 |     guild_id = fields.BigIntField()
 22 |     main_channel_id = fields.BigIntField()
 23 | 
 24 |     message_id = fields.BigIntField()
 25 | 
 26 |     toggle = fields.BooleanField(default=True)
 27 |     allow_reminders = fields.BooleanField(default=True)
 28 |     multiple_slots = fields.BooleanField(default=False)
 29 | 
 30 |     scrim_ids = ArrayField(fields.BigIntField(), default=list)
 31 | 
 32 |     def __str__(self):
 33 |         return f"{getattr(self.main_channel,'mention','not-found')} - ({plural(self.scrim_ids):scrim|scrims})"
 34 | 
 35 |     @property
 36 |     def guild(self):
 37 |         return self.bot.get_guild(self.guild_id)
 38 | 
 39 |     async def scrims(self) -> List[Scrim]:
 40 |         return await Scrim.filter(pk__in=self.scrim_ids)
 41 | 
 42 |     @property
 43 |     def main_channel(self):
 44 |         return self.bot.get_channel(self.main_channel_id)
 45 | 
 46 |     @property
 47 |     def logschan(self):
 48 |         if (g := self.guild) is not None:
 49 |             return discord.utils.get(g.text_channels, name="quotient-scrims-logs")
 50 | 
 51 |     async def message(self):
 52 |         channel = await self.bot.getch(self.bot.get_channel, self.bot.fetch_channel, self.main_channel_id)
 53 |         if channel:
 54 |             _m = None
 55 |             with suppress(discord.HTTPException):
 56 |                 _m = await self.bot.get_or_fetch_message(channel, self.message_id)
 57 | 
 58 |             return _m
 59 | 
 60 |     @staticmethod
 61 |     async def from_guild(guild: discord.Guild):
 62 |         return await ScrimsSlotManager.filter(guild_id=guild.id)
 63 | 
 64 |     @staticmethod
 65 |     async def unavailable_scrims(guild: discord.Guild) -> List[int]:
 66 |         return [scrim for record in await ScrimsSlotManager.filter(guild_id=guild.id) for scrim in record.scrim_ids]
 67 | 
 68 |     @staticmethod
 69 |     async def available_scrims(guild: discord.Guild) -> List[Scrim]:
 70 |         return await Scrim.filter(pk__not_in=await ScrimsSlotManager.unavailable_scrims(guild), guild_id=guild.id)
 71 | 
 72 |     async def full_delete(self):
 73 |         """
 74 |         Delete a slotm record.
 75 |         """
 76 |         message = await self.message()
 77 | 
 78 |         if message:
 79 |             _embed, _view = await self.public_message()
 80 |             for b in _view.children:
 81 |                 if isinstance(b, discord.ui.Button):
 82 |                     b.disabled = True
 83 | 
 84 |             await message.edit(embed=_embed, view=_view)
 85 | 
 86 |         await self.delete()
 87 | 
 88 |     @property
 89 |     def claimable_slots(self):
 90 |         return (
 91 |             Scrim.filter(
 92 |                 pk__in=self.scrim_ids,
 93 |                 closed_at__gt=self.bot.current_time.replace(hour=0, minute=0, second=0, microsecond=0),
 94 |                 available_slots__not=[],
 95 |                 match_time__gt=self.bot.current_time,
 96 |                 opened_at__isnull=True,
 97 |             )
 98 |             .order_by("open_time")
 99 |             .limit(25)
100 |         )
101 | 
102 |     async def _formatted_claimable(self) -> List[str]:
103 |         """
104 |         Returns a list of slots that can be claimed
105 |         """
106 |         _list = []
107 | 
108 |         async for idx, _ in aenumerate(self.claimable_slots, start=1):
109 |             _list.append(
110 |                 f"`{idx}` {getattr(_.registration_channel,'mention','deleted-channel')}  ─  {plural(_.available_slots):Slot|Slots}"
111 |             )
112 | 
113 |         return _list
114 | 
115 |     async def public_message(self) -> Tuple[discord.Embed, discord.ui.View]:
116 |         """
117 |         Generate public message & view for slot manager.
118 |         """
119 | 
120 |         from cogs.esports.views.slotm import ScrimsSlotmPublicView
121 | 
122 |         _claimable = await self._formatted_claimable()
123 | 
124 |         _claimable_slots = (
125 |             ("\n" + "\n".join(_claimable))
126 |             if _claimable
127 |             else ("```No Slots Available at the time.\nPress 🔔 to set a reminder. ``` \n")
128 |         )
129 | 
130 |         _e = discord.Embed(color=0x00FFB3, title="Scrims Slot Management", url=self.bot.config.SERVER_LINK)
131 |         _e.description = (
132 |             f"● Press `cancel-slot` to cancel your slot.\n"
133 |             f"● Note that Id-Pass role can only be transferred to your teammates.\n\n"
134 |             f"● Available Slots: {_claimable_slots}"
135 |         )
136 | 
137 |         view = ScrimsSlotmPublicView(self)
138 | 
139 |         if not _claimable:
140 |             view.children[1].disabled = True
141 | 
142 |         if not self.allow_reminders:
143 |             view.children[2].disabled = True
144 | 
145 |         if not self.toggle:
146 |             for _ in view.children:
147 |                 _.disabled = True
148 | 
149 |         return _e, view
150 | 
151 |     async def refresh_public_message(self) -> Optional[discord.Message]:
152 |         """
153 |         Edit public slotm message to reflect current state.
154 |         """
155 |         m = await self.message()
156 |         if not m:
157 |             return await self.full_delete()
158 | 
159 |         _embed, _view = await self.public_message()
160 | 
161 |         with suppress(discord.HTTPException):
162 |             return await m.edit(embed=_embed, view=_view)
163 | 
164 |     @staticmethod
165 |     async def refresh_guild_message(guild_id: int, scrim_id: int) -> Optional[discord.Message]:
166 |         slotm = await ScrimsSlotManager.get_or_none(guild_id=guild_id, scrim_ids__contains=scrim_id)
167 |         if slotm:
168 |             return await slotm.refresh_public_message()
169 | 
170 |     async def setup(self, guild: discord.Guild, user: discord.Member):
171 |         """
172 |         Creates a new channel and setup slot-m.
173 |         """
174 | 
175 |         reason = f"Created for Scrims Slot Management by {user}"
176 | 
177 |         overwrites = {
178 |             guild.default_role: discord.PermissionOverwrite(
179 |                 read_messages=True, send_messages=False, read_message_history=True
180 |             ),
181 |             guild.me: discord.PermissionOverwrite(
182 |                 read_messages=True,
183 |                 send_messages=True,
184 |                 manage_channels=True,
185 |                 manage_messages=True,
186 |                 read_message_history=True,
187 |                 embed_links=True,
188 |             ),
189 |         }
190 | 
191 |         __channel = await guild.create_text_channel(name="cancel-claim-slot", overwrites=overwrites, reason=reason)
192 | 
193 |         self.main_channel_id = __channel.id
194 | 
195 |         _embed, _view = await self.public_message()
196 |         m = await __channel.send(embed=_embed, view=_view)
197 | 
198 |         self.message_id = m.id
199 |         await self.save()
200 |         return self
201 | 
202 |     async def user_slots(self, user_id: int) -> List[Any]:
203 |         query = """
204 |         (SELECT *
205 | 		    FROM
206 | 			(SELECT SCRIMS.ID AS SCRIM_ID,
207 | 					*
208 | 				FROM PUBLIC."sm.scrims" AS SCRIMS
209 | 				FULL OUTER JOIN
210 | 					(SELECT ID AS ASSIGNED_SLOT_ID,
211 | 							*
212 | 						FROM PUBLIC."sm.scrims_sm.assigned_slots" AS SCRIM_SLOT
213 | 						INNER JOIN PUBLIC."sm.assigned_slots" AS SLOTS ON SLOTS.ID = SCRIM_SLOT.ASSIGNEDSLOT_ID) AS SCRIM_SLOT ON SCRIMS.ID = SCRIM_SLOT."sm.scrims_id"
214 | 				WHERE (SCRIMS.ID = ANY ($1)
215 | 											AND MATCH_TIME > NOW()
216 | 											AND OPENED_AT IS NULL = TRUE
217 | 											AND CLOSED_AT > CURRENT_DATE + interval '1 minute'
218 | 											AND SCRIM_SLOT."sm.scrims_id" IS NOT NULL)) AS SM
219 | 		WHERE USER_ID = $2)        
220 |         """
221 | 
222 |         return await self.bot.db.fetch(query, self.scrim_ids, user_id)
223 | 


--------------------------------------------------------------------------------
/models/esports/ssverify.py:
--------------------------------------------------------------------------------
  1 | from typing import Tuple
  2 | 
  3 | import imagehash
  4 | from pydantic import BaseModel, HttpUrl
  5 | from tortoise import fields
  6 | 
  7 | import config
  8 | from constants import SSType
  9 | from core import Context
 10 | from models import BaseDbModel
 11 | from models.helpers import *
 12 | from utils import emote
 13 | 
 14 | 
 15 | class ImageResponse(BaseModel):
 16 |     url: HttpUrl
 17 |     dhash: str
 18 |     phash: str
 19 |     text: str
 20 | 
 21 |     @property
 22 |     def lower_text(self):
 23 |         return self.text.lower().replace(" ", "").replace("\n", "")
 24 | 
 25 | 
 26 | class SSData(BaseDbModel):
 27 |     class Meta:
 28 |         table = "ss_data"
 29 | 
 30 |     id = fields.IntField(pk=True)
 31 |     author_id = fields.BigIntField()
 32 |     channel_id = fields.BigIntField()
 33 |     message_id = fields.BigIntField()
 34 |     dhash = fields.CharField(max_length=1024, null=True)
 35 |     phash = fields.CharField(max_length=1024, null=True)
 36 |     submitted_at = fields.DatetimeField(auto_now=True)
 37 | 
 38 |     @property
 39 |     def author(self):
 40 |         return self.bot.get_user(self.author_id)
 41 | 
 42 |     @property
 43 |     def jump_url(self):
 44 |         return "https://discord.com/channels/{}/" + f"{self.channel_id}/{self.message_id}"
 45 | 
 46 | 
 47 | class SSVerify(BaseDbModel):
 48 |     class Meta:
 49 |         table = "ss_info"
 50 | 
 51 |     id = fields.IntField(pk=True)
 52 |     channel_id = fields.BigIntField(index=True)
 53 |     guild_id = fields.BigIntField()
 54 |     role_id = fields.BigIntField()
 55 |     required_ss = fields.IntField(default=4)
 56 |     channel_name = fields.CharField(max_length=50)
 57 |     channel_link = fields.CharField(max_length=150, default=config.SERVER_LINK)
 58 | 
 59 |     keywords = ArrayField(fields.CharField(max_length=50), default=list)
 60 |     allow_same = fields.BooleanField(default=False)
 61 | 
 62 |     ss_type = fields.CharEnumField(SSType)
 63 | 
 64 |     success_message = fields.CharField(null=True, max_length=500)
 65 | 
 66 |     data: fields.ManyToManyRelation["SSData"] = fields.ManyToManyField("models.SSData", index=True)
 67 | 
 68 |     @property
 69 |     def _guild(self):
 70 |         return self.bot.get_guild(self.guild_id)
 71 | 
 72 |     @property
 73 |     def channel(self):
 74 |         return self.bot.get_channel(self.channel_id)
 75 | 
 76 |     @property
 77 |     def role(self):
 78 |         if g := self._guild:
 79 |             return g.get_role(self.role_id)
 80 | 
 81 |     def emoji(self, _bool: bool = False):
 82 |         return emote.check if _bool else "⚠️"
 83 | 
 84 |     def __str__(self):
 85 |         _f = self.ss_type.value.title()
 86 |         if self.ss_type == SSType.custom:
 87 |             _f += f"(`{self.keywords[0]}`)"
 88 | 
 89 |         return f"{getattr(self.channel,'mention','deleted-channel')} - {_f}"
 90 | 
 91 |     async def is_user_verified(self, user_id: int):
 92 |         return await self.data.filter(author_id=user_id).count() >= self.required_ss
 93 | 
 94 |     async def required_by_user(self, user_id: int):
 95 |         diff = self.required_ss - await self.data.filter(author_id=user_id).count()
 96 |         return 0 if diff <= 0 else diff
 97 | 
 98 |     async def full_delete(self):
 99 |         self.bot.cache.ssverify_channels.discard(self.channel_id)
100 |         data = await self.data.all()
101 | 
102 |         await SSData.filter(pk__in=[d.id for d in data]).delete()
103 |         await self.delete()
104 | 
105 |     @property
106 |     def filtered_keywords(self):
107 |         _l = [self.channel_name.lower().replace(" ", "")]
108 |         for _ in self.keywords:
109 |             _l.append(_.lower().replace(" ", ""))
110 | 
111 |         return _l
112 | 
113 |     async def _add_to_data(self, ctx: Context, img: ImageResponse):
114 |         data = await SSData.create(
115 |             author_id=ctx.author.id,
116 |             channel_id=ctx.channel.id,
117 |             message_id=ctx.message.id,
118 |             dhash=img.dhash,
119 |             phash=img.phash,
120 |         )
121 |         await self.data.add(data)
122 | 
123 |     async def _match_for_duplicate(self, dhash: str, phash: str, author_id: int) -> Tuple[bool, str]:
124 |         _dhash = imagehash.hex_to_hash(dhash)
125 |         async for record in self.data.filter(author_id=author_id).order_by("submitted_at"):
126 |             if _dhash - imagehash.hex_to_hash(record.dhash) <= 7:
127 |                 return (
128 |                     True,
129 |                     f"{self.emoji(False)} | You've already submitted this screenshot [here]({record.jump_url.format(self.guild_id)}).\n",
130 |                 )
131 | 
132 |         if r := await self.data.filter(dhash=dhash, phash=phash).first():
133 |             return (
134 |                 True,
135 |                 f"{self.emoji(False)} | <@{r.author_id}>, already submitted the [same ss]({r.jump_url.format(self.guild_id)}).\n",
136 |             )
137 | 
138 |         return False, False
139 | 
140 |     async def verify_yt(self, ctx: Context, image: ImageResponse):
141 |         if not any(_ in image.lower_text for _ in ("subscribe", "videos")):
142 |             return f"{self.emoji()} | This is not a valid youtube ss.\n"
143 | 
144 |         elif not self.channel_name.lower().replace(" ", "") in image.lower_text:
145 |             return f"{self.emoji()} | Screenshot must belong to [`{self.channel_name}`]({self.channel_link}) channel.\n"
146 | 
147 |         elif "SUBSCRIBE " in image.text.replace("\n", " "):
148 |             return f"{self.emoji()} | You must subscribe [`{self.channel_name}`]({self.channel_link}) to get verified.\n"
149 | 
150 |         await self._add_to_data(ctx, image)
151 |         return f"{self.emoji(True)} | Verified successfully.\n"
152 | 
153 |     async def verify_insta(self, ctx: Context, image: ImageResponse):
154 |         if not "followers" in image.lower_text:
155 |             return f"{self.emoji()} | This is not a valid instagram ss.\n"
156 | 
157 |         elif not self.channel_name.lower().replace(" ", "") in image.lower_text:
158 |             return f"{self.emoji()} | Screenshot must belong to [`{self.channel_name}`]({self.channel_link}) page.\n"
159 | 
160 |         elif "FOLLOW " in image.text.replace("\n", " "):
161 |             return f"{self.emoji()} | You must follow [`{self.channel_name}`]({self.channel_link}) to get verified.\n"
162 | 
163 |         await self._add_to_data(ctx, image)
164 |         return f"{self.emoji(True)} | Verified successfully.\n"
165 | 
166 |     async def verify_loco(self, ctx: Context, image: ImageResponse):
167 |         if not self.channel_name.lower().replace(" ", "") in image.lower_text:
168 |             return f"{self.emoji()} | Screenshot must belong to [`{self.channel_name}`]({self.channel_link}) channel.\n"
169 | 
170 |         elif "FOLLOW" in image.text and not "FOLLOWING" in image.text:
171 |             return f"{self.emoji()} | You must follow [`{self.channel_name}`]({self.channel_link}) to get verified.\n"
172 | 
173 |         await self._add_to_data(ctx, image)
174 |         return f"{self.emoji(True)} | Verified successfully.\n"
175 | 
176 |     async def verify_rooter(self, ctx: Context, image: ImageResponse):
177 |         if not self.channel_name.lower().replace(" ", "") in image.lower_text:
178 |             return f"{self.emoji()} | Screenshot must belong to [`{self.channel_name}`]({self.channel_link}) channel.\n"
179 | 
180 |         elif "FOLLOW" in image.text and not "FOLLOWING" in image.text:
181 |             return f"{self.emoji()} | You must follow [`{self.channel_name}`]({self.channel_link}) to get verified.\n"
182 | 
183 |         await self._add_to_data(ctx, image)
184 |         return f"{self.emoji(True)} | Verified successfully.\n"
185 | 
186 |     async def verify_custom(self, ctx: Context, image: ImageResponse):
187 |         if not any(_ in image.lower_text for _ in self.filtered_keywords):
188 |             return f"{self.emoji()} | This is not a valid {self.keywords[0]} ss.\n"
189 | 
190 |         await self._add_to_data(ctx, image)
191 |         return f"{self.emoji(True)} | Verified successfully.\n"
192 | 


--------------------------------------------------------------------------------
/models/esports/tagcheck.py:
--------------------------------------------------------------------------------
 1 | from typing import Optional
 2 | 
 3 | import discord
 4 | from tortoise import fields
 5 | 
 6 | from models import BaseDbModel
 7 | from models.helpers import *
 8 | 
 9 | 
10 | class TagCheck(BaseDbModel):
11 |     class Meta:
12 |         table = "tagcheck"
13 | 
14 |     id = fields.BigIntField(pk=True)
15 |     guild_id = fields.BigIntField()
16 |     channel_id = fields.BigIntField()
17 |     required_mentions = fields.IntField(default=0)
18 |     delete_after = fields.BooleanField(default=False)
19 | 
20 |     @property
21 |     def _guild(self) -> Optional[discord.Guild]:
22 |         return self.bot.get_guild(self.guild_id)
23 | 
24 |     @property
25 |     def channel(self) -> Optional[discord.TextChannel]:
26 |         return self.bot.get_channel(self.channel_id)
27 | 
28 |     @property
29 |     def ignorerole(self) -> Optional[discord.Role]:
30 |         if not self._guild is None:
31 |             return discord.utils.get(self._guild.roles, name="quotient-tag-ignore")
32 | 
33 |     def __str__(self):
34 |         return f"{getattr(self.channel,'mention','channel-not-found')} (Mentions: `{self.required_mentions}`)"
35 | 
36 | 
37 | class EasyTag(BaseDbModel):
38 |     class Meta:
39 |         table = "easytags"
40 | 
41 |     id = fields.BigIntField(pk=True)
42 |     guild_id = fields.BigIntField()
43 |     channel_id = fields.BigIntField(index=True)
44 |     delete_after = fields.BooleanField(default=False)
45 | 
46 |     @property
47 |     def _guild(self) -> Optional[discord.Guild]:
48 |         return self.bot.get_guild(self.guild_id)
49 | 
50 |     @property
51 |     def channel(self) -> Optional[discord.TextChannel]:
52 |         return self.bot.get_channel(self.channel_id)
53 | 
54 |     @property
55 |     def ignorerole(self) -> Optional[discord.Role]:
56 |         if not self._guild is None:
57 |             return discord.utils.get(self._guild.roles, name="quotient-tag-ignore")
58 | 


--------------------------------------------------------------------------------
/models/esports/tourney.py:
--------------------------------------------------------------------------------
  1 | import io
  2 | from contextlib import suppress
  3 | from typing import List, Optional, Union
  4 | 
  5 | import discord
  6 | from discord.ext.commands import BadArgument
  7 | from tortoise import exceptions, fields
  8 | 
  9 | from models import BaseDbModel
 10 | from models.helpers import *  # noqa: F401, F403
 11 | from utils import split_list
 12 | 
 13 | _dict = {
 14 |     "tick": "\N{WHITE HEAVY CHECK MARK}",
 15 |     "cross": "\N{CROSS MARK}",
 16 | }
 17 | 
 18 | from constants import EsportsLog
 19 | from core import Context
 20 | 
 21 | 
 22 | class Tourney(BaseDbModel):
 23 |     class Meta:
 24 |         table = "tm.tourney"
 25 | 
 26 |     id = fields.BigIntField(pk=True, index=True)
 27 |     guild_id = fields.BigIntField()
 28 |     name = fields.CharField(max_length=30, default="Quotient-Tourney")
 29 |     registration_channel_id = fields.BigIntField(index=True)
 30 |     confirm_channel_id = fields.BigIntField()
 31 |     role_id = fields.BigIntField()
 32 |     required_mentions = fields.SmallIntField(default=4, validators=[ValueRangeValidator(range(0, 11))])
 33 |     total_slots = fields.SmallIntField()
 34 |     banned_users = ArrayField(fields.BigIntField(), default=list)
 35 |     host_id = fields.BigIntField()
 36 |     multiregister = fields.BooleanField(default=False)
 37 |     started_at = fields.DatetimeField(null=True)
 38 |     closed_at = fields.DatetimeField(null=True)
 39 |     open_role_id = fields.BigIntField(null=True)
 40 |     teamname_compulsion = fields.BooleanField(default=False)
 41 | 
 42 |     ping_role_id = fields.BigIntField(null=True)
 43 |     no_duplicate_name = fields.BooleanField(default=True)
 44 |     autodelete_rejected = fields.BooleanField(default=False)
 45 | 
 46 |     slotlist_start = fields.SmallIntField(default=2)
 47 |     group_size = fields.SmallIntField(null=True)
 48 |     success_message = fields.CharField(max_length=500, null=True)
 49 | 
 50 |     emojis = fields.JSONField(default=_dict)
 51 | 
 52 |     slotm_channel_id = fields.BigIntField(null=True)
 53 |     slotm_message_id = fields.BigIntField(null=True)
 54 | 
 55 |     required_lines = fields.SmallIntField(default=0)
 56 |     allow_duplicate_tags = fields.BooleanField(default=True)
 57 | 
 58 |     assigned_slots: fields.ManyToManyRelation["TMSlot"] = fields.ManyToManyField("models.TMSlot")
 59 |     media_partners: fields.ManyToManyRelation["MediaPartner"] = fields.ManyToManyField("models.MediaPartner")
 60 | 
 61 |     def __str__(self):
 62 |         return f"{getattr(self.registration_channel,'mention','deleted-channel')} [ID: `{self.id}`]"
 63 | 
 64 |     @classmethod
 65 |     async def convert(cls, ctx, argument: str):
 66 |         try:
 67 |             argument = int(argument)
 68 |         except ValueError:
 69 |             pass
 70 |         else:
 71 |             try:
 72 |                 return await cls.get(pk=argument, guild_id=ctx.guild.id)
 73 |             except exceptions.DoesNotExist:
 74 |                 pass
 75 | 
 76 |         raise BadArgument(f"This is not a valid Tourney ID.\n\nGet a valid ID with `{ctx.prefix}tourney config`")
 77 | 
 78 |     @property
 79 |     def guild(self) -> Optional[discord.Guild]:
 80 |         return self.bot.get_guild(self.guild_id)
 81 | 
 82 |     @property
 83 |     def logschan(self) -> Optional[discord.TextChannel]:
 84 |         if (g := self.guild) is not None:
 85 |             return discord.utils.get(g.text_channels, name="quotient-tourney-logs")
 86 | 
 87 |     @property
 88 |     def registration_channel(self) -> Optional[discord.TextChannel]:
 89 |         if (g := self.guild) is not None:
 90 |             return g.get_channel(self.registration_channel_id)
 91 | 
 92 |     @property
 93 |     def confirm_channel(self) -> Optional[discord.TextChannel]:
 94 |         if (g := self.guild) is not None:
 95 |             return g.get_channel(self.confirm_channel_id)
 96 | 
 97 |     @property
 98 |     def slotm_channel(self) -> Optional[discord.TextChannel]:
 99 |         if (g := self.guild) is not None:
100 |             return g.get_channel(self.slotm_channel_id)
101 | 
102 |     @property
103 |     def closed(self):
104 |         return bool(self.closed_at)
105 | 
106 |     @property
107 |     def role(self) -> Optional[discord.Role]:
108 |         if (g := self.guild) is not None:
109 |             return g.get_role(self.role_id)
110 | 
111 |     @property
112 |     def open_role(self):
113 |         if (g := self.guild) is not None:
114 |             if self.open_role_id is not None:
115 |                 return g.get_role(self.open_role_id)
116 |             return self.guild.default_role
117 | 
118 |     @property
119 |     def ping_role(self):
120 |         if (g := self.guild) is not None:
121 |             if self.ping_role_id is not None:
122 |                 return g.get_role(self.ping_role_id)
123 |             return None
124 | 
125 |     @property
126 |     def modrole(self):
127 |         if (g := self.guild) is not None:
128 |             return discord.utils.get(g.roles, name="tourney-mod")
129 | 
130 |     @property
131 |     def check_emoji(self):
132 |         return self.emojis.get("tick", "✅")
133 | 
134 |     @property
135 |     def cross_emoji(self):
136 |         return self.emojis.get("cross", "❌")
137 | 
138 |     @staticmethod
139 |     def is_ignorable(member: discord.Member) -> bool:
140 |         return "tourney-mod" in (role.name.lower() for role in member.roles)
141 | 
142 |     async def _get_groups(self) -> List[List["TMSlot"]]:
143 |         return split_list(await self.assigned_slots.all().order_by("num"), self.group_size)
144 | 
145 |     async def get_group(self, num: int) -> List["TMSlot"]:
146 |         _all = await self._get_groups()
147 |         for group in _all:
148 |             if _all.index(group) == num - 1:
149 |                 return group
150 | 
151 |     async def add_assigned_slot(self, slot: "TMSlot", message: discord.Message):
152 |         _e = discord.Embed(color=self.bot.color)
153 |         _e.description = f"**{slot.num}) NAME: [{slot.team_name.upper()}]({slot.jump_url})**\n"
154 | 
155 |         if len(message.mentions) > 0:
156 |             _e.description += f"Team: {', '.join([str(m) for m in message.mentions])}"
157 | 
158 |         if _chan := self.confirm_channel:
159 |             m = await _chan.send(
160 |                 content=message.author.mention, embed=_e, allowed_mentions=discord.AllowedMentions(users=True)
161 |             )
162 | 
163 |             slot.confirm_jump_url = m.jump_url
164 | 
165 |             await slot.save()
166 |             await self.assigned_slots.add(slot)
167 | 
168 |     async def finalize_slot(self, ctx: Context, slot: "TMSlot"):
169 |         """
170 |         Add role to user and reaction to the message
171 |         """
172 |         with suppress(discord.HTTPException):
173 |             if not (_role := self.role) in ctx.author.roles:
174 |                 await ctx.author.add_roles(_role)
175 | 
176 |             await ctx.message.add_reaction(self.check_emoji)
177 | 
178 |             if self.success_message:
179 |                 embed = discord.Embed(color=self.bot.color, description=self.success_message)
180 |                 embed.title = f"Message from {ctx.guild.name}"
181 |                 embed.url = slot.jump_url
182 | 
183 |                 await ctx.author.send(embed=embed, view=ctx.get_dm_view(f"Sent from {ctx.guild.name}"))
184 | 
185 |     async def end_process(self):
186 |         from cogs.esports.helpers.utils import toggle_channel
187 | 
188 |         closed_at = self.bot.current_time
189 | 
190 |         registration_channel = self.registration_channel
191 |         open_role = self.open_role
192 | 
193 |         await Tourney.filter(pk=self.id).update(started_at=None, closed_at=closed_at)
194 |         channel_update = await toggle_channel(registration_channel, open_role, False)
195 |         await registration_channel.send(
196 |             embed=discord.Embed(color=self.bot.color, description="**Registration is now closed!**")
197 |         )
198 | 
199 |         self.bot.dispatch("tourney_log", EsportsLog.closed, self, permission_updated=channel_update)
200 | 
201 |     async def setup_slotm(self):
202 |         from cogs.esports.views.tourney.slotm import TourneySlotManager
203 | 
204 |         _view = TourneySlotManager(self.bot, tourney=self)
205 |         _category = self.registration_channel.category or self.registration_channel.guild
206 |         overwrites = {
207 |             self.guild.default_role: discord.PermissionOverwrite(
208 |                 read_messages=True, send_messages=False, read_message_history=True
209 |             ),
210 |             self.guild.me: discord.PermissionOverwrite(manage_channels=True, manage_permissions=True),
211 |         }
212 | 
213 |         slotm_channel = await _category.create_text_channel(name="tourney-slotmanager", overwrites=overwrites)
214 |         return await slotm_channel.send(embed=TourneySlotManager.initial_embed(self), view=_view)
215 | 
216 |     async def get_csv(self):
217 |         guild = self.guild
218 |         member_ids = [_.id for _ in guild.members]
219 | 
220 |         _x = "Reg Posi,Team Name,Leader,Leader ID,Teammates,Teammates in Server,Jump URL\n"
221 | 
222 |         async for slot in self.assigned_slots.all().order_by("num"):
223 |             _team = " | ".join((f"{str(guild.get_member(m))} ({m})" for m in slot.members))
224 | 
225 |             _x += (
226 |                 f"{slot.num},{slot.team_name},{str(guild.get_member(slot.leader_id))},"
227 |                 f"'{slot.leader_id}',{_team},{sum(1 for i in slot.members if i in member_ids)},{slot.jump_url}\n"
228 |             )
229 | 
230 |         fp = io.BytesIO(_x.encode())
231 | 
232 |         return discord.File(fp, filename=f"tourney_data_{self.id}_{self.bot.current_time.timestamp()}.csv")
233 | 
234 |     async def full_delete(self, member: discord.Member = None) -> None:
235 |         if self.logschan != None:
236 |             member = member.mention if member else "Unknown"
237 |             embed = discord.Embed(color=discord.Color.red())
238 |             embed.title = f"A tournament was completely deleted."
239 |             embed.description = f"Tourney name : {self.name} [{self.id}]" + f"\nDeleted by: {member}"
240 |             await self.logschan.send(embed=embed, file=await self.get_csv())
241 | 
242 |         self.bot.cache.tourney_channels.discard(self.registration_channel_id)
243 |         _data = await self.assigned_slots.all()
244 |         await TMSlot.filter(pk__in=[_.id for _ in _data]).delete()
245 |         await self.delete()
246 | 
247 |         if self.slotm_channel_id:
248 |             with suppress(discord.HTTPException, AttributeError):
249 |                 await self.slotm_channel.delete()
250 | 
251 |     @staticmethod
252 |     async def prompt_selector(ctx: Context, *, tourneys: List["Tourney"] = None, placeholder: str = None):
253 |         placeholder = placeholder or "Choose a tourney to contine..."
254 | 
255 |         from cogs.esports.views.tourney._select import QuotientView, TourneySelector
256 | 
257 |         tourneys = tourneys or await Tourney.filter(guild_id=ctx.guild.id).order_by("id").limit(25)
258 | 
259 |         if not tourneys:
260 |             return None
261 | 
262 |         if len(tourneys) == 1:
263 |             return tourneys[0]
264 | 
265 |         view = QuotientView(ctx)
266 |         view.add_item(TourneySelector(placeholder, tourneys))
267 | 
268 |         view.message = await ctx.send("Choose a tourney from the dropdown below...", view=view)
269 |         await view.wait()
270 |         if view.custom_id:
271 |             await view.message.delete()
272 |             return await Tourney.get_or_none(id=view.custom_id)
273 | 
274 |     async def setup_logs(self):
275 |         _reason = "Created for tournament management."
276 |         _g = self.guild
277 | 
278 |         if not (tourney_mod := self.modrole):
279 |             tourney_mod = await self.guild.create_role(name="tourney-mod", color=self.bot.color, reason=_reason)
280 | 
281 |         overwrite = self.registration_channel.overwrites_for(_g.default_role)
282 |         overwrite.update(read_messages=True, send_messages=True, read_message_history=True)
283 |         await self.registration_channel.set_permissions(tourney_mod, overwrite=overwrite)
284 | 
285 |         if (tourney_log_channel := self.logschan) is None:
286 |             overwrites = {
287 |                 _g.default_role: discord.PermissionOverwrite(read_messages=False),
288 |                 _g.me: discord.PermissionOverwrite(read_messages=True),
289 |                 tourney_mod: discord.PermissionOverwrite(read_messages=True),
290 |             }
291 |             tourney_log_channel = await _g.create_text_channel(
292 |                 name="quotient-tourney-logs",
293 |                 overwrites=overwrites,
294 |                 reason=_reason,
295 |                 topic="**DO NOT RENAME THIS CHANNEL**",
296 |             )
297 | 
298 |             note = await tourney_log_channel.send(
299 |                 embed=discord.Embed(
300 |                     description=f"If events related to tournament i.e opening registrations or adding roles, "
301 |                     f"etc are triggered, then they will be logged in this channel. "
302 |                     f"Also I have created {tourney_mod.mention}, you can give that role to your "
303 |                     f"tourney-moderators. User with {tourney_mod.mention} can also send messages in "
304 |                     f"registration channels and they won't be considered as tourney-registration.\n\n"
305 |                     f"`Note`: **Do not rename/delete this channel.**",
306 |                     color=discord.Color(self.bot.color),
307 |                 )
308 |             )
309 |             await tourney_log_channel.send(f"<@{self.host_id}> **Read This Message 👆**")
310 |             await note.pin()
311 | 
312 |     async def toggle_registrations(self):
313 |         channel, open_role = self.registration_channel, self.open_role
314 |         if not channel:
315 |             return False, f"I cannot find the registration channel. ({self.registration_channel_id})"
316 | 
317 |         if not channel.permissions_for(self.guild.me).manage_permissions:
318 |             return False, f"I don't have permission to manage channel permissions. ({channel.id})"
319 | 
320 |         if not open_role:
321 |             return False, f"I cannot find the open role. ({self.open_role_id})"
322 | 
323 |         if self.started_at:
324 |             return await self.__stop_registrations()
325 | 
326 |         return await self.__start_registrations()
327 | 
328 |     async def __start_registrations(self):
329 |         registration_channel = self.registration_channel
330 | 
331 |         if self.total_slots <= await self.assigned_slots.all().count():
332 |             return False, "Slots are already full, Increase slots to start again."
333 | 
334 |         await Tourney.filter(pk=self.id).update(started_at=self.bot.current_time, closed_at=None)
335 |         self.bot.cache.tourney_channels.add(self.registration_channel_id)
336 | 
337 |         _e = discord.Embed(color=self.bot.color)
338 | 
339 |         _e.description = (
340 |             f"**Registration Open for {self.name}**\n"
341 |             "```"
342 |             f"📣 {self.required_mentions} mentions required.\n"
343 |             f"📣 Total slots: {self.total_slots} [{self.total_slots - await self.assigned_slots.all().count()} slots left]"
344 |             "```"
345 |         )
346 |         _e.set_thumbnail(url=getattr(self.guild.icon, "url", self.bot.user.avatar.url))
347 |         _ping = None
348 |         if p := self.ping_role:
349 |             if p == self.guild.default_role:
350 |                 _ping = "@everyone"
351 | 
352 |             else:
353 |                 _ping = p.mention
354 | 
355 |         await registration_channel.send(
356 |             _ping, embed=_e, allowed_mentions=discord.AllowedMentions(roles=True, everyone=True)
357 |         )
358 | 
359 |         overwrite = registration_channel.overwrites_for(self.open_role)
360 |         overwrite.update(send_messages=True)
361 |         await registration_channel.set_permissions(
362 |             self.open_role,
363 |             overwrite=overwrite,
364 |             reason="Open for Registrations!",
365 |         )
366 |         return True, True
367 | 
368 |     async def __stop_registrations(self):
369 |         registration_channel = self.registration_channel
370 | 
371 |         overwrite = registration_channel.overwrites_for(self.open_role)
372 |         overwrite.update(send_messages=False)
373 |         await registration_channel.set_permissions(
374 |             self.open_role,
375 |             overwrite=overwrite,
376 |             reason="Closed Registrations!",
377 |         )
378 | 
379 |         await registration_channel.send(
380 |             embed=discord.Embed(color=self.bot.color, description=f"**{self.name} registration paused.**")
381 |         )
382 |         await Tourney.filter(pk=self.id).update(started_at=None, closed_at=self.bot.current_time)
383 |         return True, True
384 | 
385 |     async def ban_user(self, user: Union[discord.Member, discord.User]):
386 |         await Tourney.filter(pk=self.id).update(banned_users=ArrayAppend("banned_users", user.id))
387 | 
388 |     async def unban_user(self, user: Union[discord.Member, discord.User]):
389 |         await Tourney.filter(pk=self.id).update(banned_users=ArrayRemove("banned_users", user.id))
390 | 
391 |     async def remove_slot(self, slot: "TMSlot"):
392 |         if slot.confirm_jump_url:
393 |             self.bot.loop.create_task(self.update_confirmed_message(slot.confirm_jump_url))
394 | 
395 |         await slot.delete()
396 | 
397 |         if not await self.assigned_slots.filter(leader_id=slot.leader_id).exists():
398 |             m = self.guild.get_member(slot.leader_id)
399 |             if m:
400 |                 await m.remove_roles(discord.Object(id=self.role_id))
401 | 
402 |     async def update_confirmed_message(self, link: str):
403 |         _ids = [int(i) for i in link.split("/")[5:]]
404 | 
405 |         with suppress(discord.HTTPException, IndexError):
406 |             message = await self.guild.get_channel(_ids[0]).fetch_message(_ids[1])
407 | 
408 |             if message:
409 |                 e = message.embeds[0]
410 | 
411 |                 e.description = "~~" + e.description.strip() + "~~"
412 |                 e.title = "Cancelled Slot"
413 |                 e.color = discord.Color.red()
414 | 
415 |                 await message.edit(embed=e)
416 | 
417 |     async def make_changes(self, **kwargs):
418 |         return await Tourney.filter(pk=self.id).update(**kwargs)
419 | 
420 |     async def refresh_slotlm(self):
421 |         from cogs.esports.views.tourney import TourneySlotManager
422 | 
423 |         msg = await self.bot.get_or_fetch_message(self.slotm_channel, self.slotm_message_id)
424 |         _view = TourneySlotManager(self.bot, tourney=self)
425 |         _e = TourneySlotManager.initial_embed(self)
426 | 
427 |         try:
428 |             await msg.edit(embed=_e, view=_view)
429 |         except discord.HTTPException:
430 |             msg = await self.slotm_channel.send(embed=_e, view=_view)
431 |             await self.make_changes(slotm_message_id=msg.id)
432 | 
433 |         finally:
434 |             return True
435 | 
436 |     async def check_fake_tags(self, message: discord.Message):
437 |         query = """
438 |         SELECT *
439 |             FROM PUBLIC."tm.tourney_tm.register" AS ASSIGNED_SLOT
440 |             INNER JOIN PUBLIC."tm.register" AS SLOTS ON SLOTS.ID = ASSIGNED_SLOT.TMSLOT_ID
441 |         WHERE ASSIGNED_SLOT."tm.tourney_id" = $1
442 |         AND $2 && SLOTS.MEMBERS;
443 | 
444 |         """
445 |         return await self.bot.db.fetch(query, self.id, [i.id for i in message.mentions])
446 | 
447 | 
448 | class TMSlot(BaseDbModel):
449 |     class Meta:
450 |         table = "tm.register"
451 | 
452 |     id = fields.BigIntField(pk=True)
453 |     num = fields.IntField()
454 |     team_name = fields.TextField()
455 |     leader_id = fields.BigIntField()
456 |     message_id = fields.BigIntField(null=True)
457 |     members = ArrayField(fields.BigIntField(), default=list)
458 |     confirm_jump_url = fields.CharField(max_length=300, null=True)
459 |     jump_url = fields.TextField(null=True)
460 | 
461 | 
462 | class MediaPartner(BaseDbModel):
463 |     class Meta:
464 |         table = "tm.media_partners"
465 | 
466 |     channel_id = fields.BigIntField(pk=True, generated=False)
467 |     tourney_id = fields.IntField()
468 |     slots: fields.ManyToManyRelation["PartnerSlot"] = fields.ManyToManyField("models.PartnerSlot")
469 | 
470 |     @property
471 |     def channel(self) -> Optional[discord.TextChannel]:
472 |         return self.bot.get_channel(self.channel_id)
473 | 
474 | 
475 | class PartnerSlot(BaseDbModel):
476 |     class Meta:
477 |         table = "tm.media_partner_users"
478 | 
479 |     id = fields.IntField(pk=True)
480 |     user_id = fields.BigIntField()
481 |     message_id = fields.BigIntField()
482 |     jump_url = fields.CharField(max_length=300, null=True)
483 |     members = ArrayField(fields.BigIntField(), default=list)
484 | 
485 | 
486 | class TGroupList(BaseDbModel):
487 |     class Meta:
488 |         table = "tourney_groups"
489 | 
490 |     message_id = fields.BigIntField(pk=True)
491 |     tourney_id = fields.IntField()
492 |     channel_id = fields.BigIntField()
493 |     group_number = fields.SmallIntField()
494 |     refresh_at = fields.DatetimeField(auto_now=True)
495 | 
496 |     @property
497 |     def channel(self):
498 |         return self.bot.get_channel(self.channel_id)
499 | 
500 |     @property
501 |     def jump_url(self):
502 |         if c := self.channel:
503 |             return f"https://discord.com/channels/{c.guild.id}/{self.channel_id}/{self.pk}"
504 | 


--------------------------------------------------------------------------------
/models/helpers/__init__.py:
--------------------------------------------------------------------------------
1 | from .cfields import *  # noqa: F401, F403
2 | from .functions import *  # noqa: F401, F403
3 | from .validators import *  # noqa: F401, F403
4 | 


--------------------------------------------------------------------------------
/models/helpers/__pycache__/__init__.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/helpers/__pycache__/__init__.cpython-312.pyc


--------------------------------------------------------------------------------
/models/helpers/__pycache__/cfields.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/helpers/__pycache__/cfields.cpython-312.pyc


--------------------------------------------------------------------------------
/models/helpers/__pycache__/functions.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/helpers/__pycache__/functions.cpython-312.pyc


--------------------------------------------------------------------------------
/models/helpers/__pycache__/validators.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/helpers/__pycache__/validators.cpython-312.pyc


--------------------------------------------------------------------------------
/models/helpers/cfields.py:
--------------------------------------------------------------------------------
 1 | from typing import Any
 2 | 
 3 | from tortoise.fields.base import Field
 4 | 
 5 | 
 6 | class ArrayField(Field, list):
 7 |     def __init__(self, field: Field, **kwargs) -> None:
 8 |         super().__init__(**kwargs)
 9 |         self.sub_field = field
10 |         self.SQL_TYPE = "%s[]" % field.SQL_TYPE
11 | 
12 |     def to_python_value(self, value: Any) -> Any:
13 |         return list(map(self.sub_field.to_python_value, value))
14 | 
15 |     def to_db_value(self, value: Any, instance: Any) -> Any:
16 |         return [self.sub_field.to_db_value(val, instance) for val in value]
17 | 


--------------------------------------------------------------------------------
/models/helpers/functions.py:
--------------------------------------------------------------------------------
 1 | import typing
 2 | from enum import Enum
 3 | 
 4 | from pypika.terms import Function
 5 | from tortoise.expressions import F
 6 | 
 7 | __all__ = (
 8 |     "ArrayAppend",
 9 |     "ArrayRemove",
10 | )
11 | 
12 | 
13 | class ArrayAppend(Function):
14 |     def __init__(self, field: str, value: typing.Any) -> None:
15 |         if isinstance(value, Enum):
16 |             value = value.value
17 | 
18 |         super().__init__("ARRAY_APPEND", F(field), str(value))
19 | 
20 | 
21 | class ArrayRemove(Function):
22 |     def __init__(self, field: str, value: typing.Any) -> None:
23 |         if isinstance(value, Enum):
24 |             value = value.value
25 | 
26 |         super().__init__("ARRAY_REMOVE", F(field), str(value))
27 | 


--------------------------------------------------------------------------------
/models/helpers/validators.py:
--------------------------------------------------------------------------------
 1 | from tortoise.exceptions import ValidationError
 2 | from tortoise.validators import Validator
 3 | 
 4 | 
 5 | class ValueRangeValidator(Validator):
 6 |     """
 7 |     A validator to validate whether the given value is in given range or not.
 8 |     """
 9 | 
10 |     def __init__(self, _range: range):
11 |         self._range = _range
12 | 
13 |     def __call__(self, value: int):
14 |         if not value in self._range:
15 |             raise ValidationError(f"The value must be a number between `{self._range.start}` and `{self._range.stop}`.")
16 | 


--------------------------------------------------------------------------------
/models/misc/AutoPurge.py:
--------------------------------------------------------------------------------
 1 | from tortoise import fields, models
 2 | 
 3 | 
 4 | class AutoPurge(models.Model):
 5 |     class Meta:
 6 |         table = "autopurge"
 7 | 
 8 |     id = fields.BigIntField(pk=True)
 9 |     guild_id = fields.BigIntField()
10 |     channel_id = fields.BigIntField()
11 |     delete_after = fields.IntField(default=10)
12 | 
13 |     @property
14 |     def channel(self):
15 |         return self.bot.get_channel(self.channel_id)
16 | 


--------------------------------------------------------------------------------
/models/misc/Autorole.py:
--------------------------------------------------------------------------------
 1 | from typing import Optional
 2 | 
 3 | import discord
 4 | from tortoise import fields, models
 5 | 
 6 | from models.helpers import ArrayField
 7 | 
 8 | 
 9 | class Autorole(models.Model):
10 |     class Meta:
11 |         table = "autoroles"
12 | 
13 |     guild_id = fields.BigIntField(pk=True, index=True)
14 |     humans = ArrayField(fields.BigIntField(), default=list)
15 |     bots = ArrayField(fields.BigIntField(), default=list)
16 | 
17 |     @property
18 |     def _guild(self) -> Optional[discord.Guild]:
19 |         return self.bot.get_guild(self.guild_id)
20 | 
21 |     @property
22 |     def human_roles(self):
23 |         if self._guild is not None:
24 |             return tuple(map(lambda x: getattr(self._guild.get_role(x), "mention", "Deleted"), self.humans))
25 | 
26 |     @property
27 |     def bot_roles(self):
28 |         if self._guild is not None:
29 |             return tuple(map(lambda x: getattr(self._guild.get_role(x), "mention", "Deleted"), self.bots))
30 | 


--------------------------------------------------------------------------------
/models/misc/Commands.py:
--------------------------------------------------------------------------------
 1 | from tortoise import fields, models
 2 | 
 3 | 
 4 | class Commands(models.Model):
 5 |     class Meta:
 6 |         table = "commands"
 7 | 
 8 |     id = fields.BigIntField(pk=True)
 9 |     guild_id = fields.BigIntField(index=True)
10 |     channel_id = fields.BigIntField()
11 |     user_id = fields.BigIntField(index=True)
12 |     cmd = fields.CharField(max_length=100, index=True)
13 |     used_at = fields.DatetimeField(auto_now=True)
14 |     prefix = fields.CharField(max_length=100)
15 |     failed = fields.BooleanField(default=False)
16 | 


--------------------------------------------------------------------------------
/models/misc/Lockdown.py:
--------------------------------------------------------------------------------
 1 | from tortoise import fields, models
 2 | 
 3 | import constants
 4 | from models.helpers import ArrayField
 5 | 
 6 | 
 7 | class Lockdown(models.Model):
 8 |     class Meta:
 9 |         table = "lockdown"
10 | 
11 |     id = fields.BigIntField(pk=True)
12 |     guild_id = fields.BigIntField(index=True)
13 |     type = fields.CharEnumField(constants.LockType, max_length=20)
14 |     role_id = fields.BigIntField(null=True)
15 |     channel_id = fields.BigIntField(null=True)
16 |     channel_ids = ArrayField(fields.BigIntField(), default=list, index=True)
17 |     expire_time = fields.DatetimeField(null=True)
18 |     author_id = fields.BigIntField()
19 | 
20 |     @property
21 |     def _guild(self):
22 |         return self.bot.get_guild(self.guild_id)
23 | 
24 |     @property
25 |     def roles(self):
26 |         if self._guild is not None:
27 |             return self._guild.get_role(self.role_id)
28 | 
29 |     @property
30 |     def channels(self):
31 |         return map(self.bot.get_channel, self.channel_ids)
32 | 


--------------------------------------------------------------------------------
/models/misc/Snipe.py:
--------------------------------------------------------------------------------
 1 | from tortoise import fields, models
 2 | 
 3 | 
 4 | class Snipe(models.Model):
 5 |     class Meta:
 6 |         table = "snipes"
 7 | 
 8 |     channel_id = fields.BigIntField(pk=True)
 9 |     author_id = fields.BigIntField()
10 |     content = fields.TextField()
11 |     delete_time = fields.DatetimeField(auto_now=True)
12 |     nsfw = fields.BooleanField(default=False)
13 | 
14 |     @property
15 |     def author(self):
16 |         return self.bot.get_user(self.author_id)
17 | 


--------------------------------------------------------------------------------
/models/misc/Tag.py:
--------------------------------------------------------------------------------
 1 | from tortoise import fields, models
 2 | 
 3 | 
 4 | class Tag(models.Model):
 5 |     class Meta:
 6 |         table = "tags"
 7 | 
 8 |     id = fields.BigIntField(pk=True)
 9 |     guild_id = fields.BigIntField()
10 |     name = fields.CharField(max_length=100)
11 |     content = fields.TextField()
12 |     is_embed = fields.BooleanField(default=False)
13 |     is_nsfw = fields.BooleanField(default=False)
14 |     owner_id = fields.BigIntField()
15 |     created_at = fields.DatetimeField(auto_now=True)
16 |     usage = fields.IntField(default=0)
17 | 
18 |     @property
19 |     def owner(self):
20 |         return self.bot.get_user(self.owner_id)
21 | 


--------------------------------------------------------------------------------
/models/misc/Timer.py:
--------------------------------------------------------------------------------
 1 | from tortoise import fields, models
 2 | 
 3 | 
 4 | class Timer(models.Model):
 5 |     id = fields.BigIntField(pk=True)
 6 |     expires = fields.DatetimeField(index=True)
 7 |     created = fields.DatetimeField(auto_now=True)
 8 |     event = fields.TextField()
 9 |     extra = fields.JSONField(default=dict)
10 | 
11 |     @property
12 |     def kwargs(self):
13 |         return self.extra.get("kwargs", {})
14 | 
15 |     @property
16 |     def args(self):
17 |         return self.extra.get("args", ())
18 | 


--------------------------------------------------------------------------------
/models/misc/User.py:
--------------------------------------------------------------------------------
 1 | from tortoise import fields, models
 2 | 
 3 | from models.helpers import ArrayField
 4 | 
 5 | 
 6 | # TODO: make manytomany field in user_data for redeem codes.
 7 | class User(models.Model):
 8 |     class Meta:
 9 |         table = "user_data"
10 | 
11 |     user_id = fields.BigIntField(pk=True, index=True)
12 |     is_premium = fields.BooleanField(default=False, index=True)
13 |     premium_expire_time = fields.DatetimeField(null=True)
14 |     made_premium = ArrayField(fields.BigIntField(), default=list)  # a list of servers this user boosted
15 |     premiums = fields.IntField(default=0)
16 |     premium_notified = fields.BooleanField(default=False)
17 |     public_profile = fields.BooleanField(default=True)
18 |     # badges = CharVarArrayField(default=list)
19 |     money = fields.IntField(default=0)
20 | 


--------------------------------------------------------------------------------
/models/misc/Votes.py:
--------------------------------------------------------------------------------
 1 | from tortoise import fields, models
 2 | 
 3 | 
 4 | class Votes(models.Model):
 5 |     class Meta:
 6 |         table = "votes"
 7 | 
 8 |     user_id = fields.BigIntField(pk=True)
 9 |     is_voter = fields.BooleanField(default=False, index=True)
10 |     expire_time = fields.DatetimeField(null=True)
11 |     reminder = fields.BooleanField(default=False)
12 |     notified = fields.BooleanField(default=False, index=True)
13 |     public_profile = fields.BooleanField(default=True)
14 |     total_votes = fields.IntField(default=0)
15 | 


--------------------------------------------------------------------------------
/models/misc/__init__.py:
--------------------------------------------------------------------------------
 1 | from .alerts import *
 2 | from .AutoPurge import *
 3 | from .Autorole import *
 4 | from .block import *
 5 | from .Commands import *
 6 | from .guild import *  # noqa: F401, F403
 7 | from .Lockdown import *
 8 | from .premium import *
 9 | from .Snipe import *
10 | from .Tag import *
11 | from .Timer import *
12 | from .User import *
13 | from .Votes import *
14 | 


--------------------------------------------------------------------------------
/models/misc/__pycache__/AutoPurge.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/AutoPurge.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/Autorole.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/Autorole.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/Commands.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/Commands.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/Lockdown.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/Lockdown.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/Snipe.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/Snipe.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/Tag.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/Tag.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/Timer.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/Timer.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/User.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/User.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/Votes.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/Votes.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/__init__.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/__init__.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/alerts.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/alerts.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/block.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/block.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/guild.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/guild.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/__pycache__/premium.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/models/misc/__pycache__/premium.cpython-312.pyc


--------------------------------------------------------------------------------
/models/misc/alerts.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from tortoise import fields
 4 | 
 5 | from models import BaseDbModel
 6 | from models.helpers import *
 7 | 
 8 | 
 9 | class Alert(BaseDbModel):
10 |     class Meta:
11 |         table = "alerts"
12 | 
13 |     id = fields.IntField(pk=True)
14 |     author_id = fields.BigIntField()
15 |     created_at = fields.DatetimeField(auto_now=True)
16 |     active = fields.BooleanField(default=True)
17 |     message = fields.JSONField(default=dict)
18 |     conditions = ArrayField(fields.CharField(max_length=100), default=list)
19 |     prompts: fields.ManyToManyRelation["Prompt"] = fields.ManyToManyField("models.Prompt")
20 |     reads: fields.ManyToManyRelation["Read"] = fields.ManyToManyField("models.Read")
21 | 
22 | 
23 | class Prompt(BaseDbModel):
24 |     class Meta:
25 |         table = "alert_prompts"
26 | 
27 |     id = fields.IntField(pk=True)
28 |     user_id = fields.BigIntField()
29 |     prompted_at = fields.DatetimeField(auto_now=True)
30 | 
31 | 
32 | class Read(BaseDbModel):
33 |     class Meta:
34 |         table = "alert_reads"
35 | 
36 |     id = fields.IntField(pk=True)
37 |     user_id = fields.BigIntField()
38 |     read_at = fields.DatetimeField(auto_now=True)
39 | 


--------------------------------------------------------------------------------
/models/misc/block.py:
--------------------------------------------------------------------------------
 1 | from enum import IntEnum
 2 | 
 3 | from tortoise import fields
 4 | 
 5 | from models import BaseDbModel
 6 | 
 7 | __all__ = ("BlockList", "BlockIdType")
 8 | 
 9 | 
10 | class BlockIdType(IntEnum):
11 |     USER = 1
12 |     GUILD = 2
13 | 
14 | 
15 | class BlockList(BaseDbModel):
16 |     class Meta:
17 |         table = "block_list"
18 | 
19 |     id = fields.IntField(pk=True)
20 |     block_id = fields.BigIntField()
21 |     block_id_type = fields.IntEnumField(BlockIdType)
22 |     blocked_by = fields.BigIntField(null=True)
23 |     reason = fields.CharField(max_length=250, null=True)
24 |     timestamp = fields.DatetimeField(auto_now=True)
25 | 


--------------------------------------------------------------------------------
/models/misc/guild.py:
--------------------------------------------------------------------------------
 1 | import discord
 2 | from tortoise import fields
 3 | 
 4 | import config
 5 | from models import BaseDbModel
 6 | from models.helpers import *
 7 | 
 8 | _dict = {"embed": [], "scrims": [], "tourney": [], "slotm": []}
 9 | 
10 | 
11 | class Guild(BaseDbModel):
12 |     class Meta:
13 |         table = "guild_data"
14 | 
15 |     guild_id = fields.BigIntField(pk=True, index=True)
16 | 
17 |     prefix = fields.CharField(default="q", max_length=5)
18 |     embed_color = fields.IntField(default=65459, null=True)
19 |     embed_footer = fields.TextField(default=config.FOOTER)
20 | 
21 |     tag_enabled_for_everyone = fields.BooleanField(default=True)  # ye naam maine ni rkha sachi
22 | 
23 |     is_premium = fields.BooleanField(default=False)
24 |     made_premium_by = fields.BigIntField(null=True)
25 |     premium_end_time = fields.DatetimeField(null=True)
26 |     premium_notified = fields.BooleanField(default=False)
27 | 
28 |     public_profile = fields.BooleanField(default=True)  # whether to list the server on global leaderboards
29 | 
30 |     private_channel = fields.BigIntField(null=True)
31 | 
32 |     dashboard_access = fields.JSONField(default=_dict)
33 | 
34 |     @property
35 |     def _guild(self) -> discord.Guild:
36 |         return self.bot.get_guild(self.guild_id)
37 | 
38 |     @property
39 |     def private_ch(self) -> discord.TextChannel:
40 |         if (g := self._guild) is not None:
41 |             return g.get_channel(self.private_channel)
42 | 
43 |     @property
44 |     def booster(self):
45 |         return self.bot.get_user(self.made_premium_by)
46 | 


--------------------------------------------------------------------------------
/models/misc/premium.py:
--------------------------------------------------------------------------------
 1 | import os
 2 | from datetime import timedelta
 3 | 
 4 | from tortoise import fields
 5 | 
 6 | from models import BaseDbModel
 7 | 
 8 | __all__ = ("PremiumTxn", "PremiumPlan")
 9 | 
10 | 
11 | class PremiumPlan(BaseDbModel):
12 |     class Meta:
13 |         table = "premium_plans"
14 | 
15 |     id = fields.IntField(pk=True)
16 |     name = fields.CharField(max_length=50)
17 |     description = fields.CharField(max_length=250, null=True)
18 |     price = fields.IntField()
19 |     duration = fields.TimeDeltaField()
20 | 
21 |     @staticmethod
22 |     async def insert_plans():
23 |         await PremiumPlan.all().delete()
24 |         await PremiumPlan.create(name="Trial (7d)", description="Duration: 7 days", price=29, duration=timedelta(days=7))
25 |         await PremiumPlan.create(
26 |             name="Basic (1m)", description="Duration: 28 days", price=79, duration=timedelta(days=28)
27 |         )
28 |         await PremiumPlan.create(
29 |             name="Professional (3m)", description="Duration: 84 days", price=229, duration=timedelta(days=84)
30 |         )
31 |         await PremiumPlan.create(
32 |             name="Enterprise (6m)", description="Duration: 168 days", price=469, duration=timedelta(days=168)
33 |         )
34 |         await PremiumPlan.create(
35 |             name="GodLike (Lifetime)", description="Duration: 69 years", price=4999, duration=timedelta(days=25185)
36 |         )
37 | 
38 | 
39 | class PremiumTxn(BaseDbModel):
40 |     class Meta:
41 |         table = "premium_txns"
42 | 
43 |     id = fields.IntField(pk=True)
44 |     txnid = fields.CharField(max_length=100)
45 |     user_id = fields.BigIntField()
46 |     guild_id = fields.BigIntField()
47 |     plan_id = fields.IntField()
48 | 
49 |     created_at = fields.DatetimeField(auto_now=True)
50 |     completed_at = fields.DatetimeField(null=True)
51 |     raw_data = fields.JSONField(default=dict)
52 | 
53 |     @staticmethod
54 |     async def gen_txnid() -> str:
55 |         txnid = None
56 | 
57 |         while txnid == None:
58 |             _id = "QP_" + os.urandom(16).hex()
59 |             if not await PremiumTxn.filter(txnid=_id).exists():
60 |                 txnid = _id
61 | 
62 |         return txnid
63 | 


--------------------------------------------------------------------------------
/requirements.txt:
--------------------------------------------------------------------------------
 1 | git+https://github.com/Rapptz/discord.py.git
 2 | tortoise-orm
 3 | colorama
 4 | asyncpg
 5 | dateparser
 6 | aerich
 7 | parsedatetime
 8 | Pillow
 9 | mystbin.py
10 | prettytable
11 | psutil
12 | PyNaCl
13 | Quart
14 | requests
15 | dblpy
16 | jishaku
17 | humanize
18 | pygit2
19 | async-property
20 | colour
21 | imgkit
22 | aiocache
23 | ujson
24 | ImageHash
25 | pytesseract
26 | python-socketio
27 | aiohttp-asgi
28 | fastapi
29 | python-multipart
30 | lru-dict
31 | pypika
32 | 


--------------------------------------------------------------------------------
/server/__init__.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing as T
 4 | 
 5 | if T.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from aiohttp import web
 9 | from aiohttp_asgi import ASGIResource
10 | from discord.ext.commands import Cog
11 | 
12 | import config
13 | 
14 | from .app import fastapi_app
15 | 
16 | 
17 | class ApiServer(Cog):
18 |     app: web.Application
19 |     app_started: bool = False
20 |     webserver: web.TCPSite
21 | 
22 |     def __init__(self, bot: Quotient):
23 |         self.bot = bot
24 | 
25 |     async def cog_load(self) -> None:
26 |         self.app, self.webserver = await self.init_application()
27 |         self.app_started = True
28 | 
29 |     async def cog_unload(self) -> None:
30 |         if self.app_started:
31 |             print("[Server] Closing...")
32 |             await self.webserver.stop()
33 |             await self.app.shutdown()
34 |             await self.app.cleanup()
35 | 
36 |     async def init_application(self) -> T.Tuple[web.Application, web.TCPSite]:
37 |         aiohttp_app = web.Application()
38 |         asgi_resource = ASGIResource(fastapi_app, root_path="")  # type: ignore
39 |         aiohttp_app.router.register_resource(asgi_resource)
40 | 
41 |         runner = web.AppRunner(app=aiohttp_app)
42 |         await runner.setup()
43 |         webserver = web.TCPSite(runner, "0.0.0.0", config.SERVER_PORT)
44 |         await webserver.start()
45 |         print("[Server] Asgi server started")
46 |         return aiohttp_app, webserver
47 | 
48 | 
49 | async def setup(bot: Quotient):
50 |     await bot.add_cog(ApiServer(bot))
51 | 


--------------------------------------------------------------------------------
/server/app/__init__.py:
--------------------------------------------------------------------------------
 1 | from fastapi import FastAPI
 2 | 
 3 | fastapi_app = FastAPI()
 4 | 
 5 | 
 6 | @fastapi_app.get("/")
 7 | async def root():
 8 |     return {"ping": "pong"}
 9 | 
10 | 
11 | from .payment import router as payment_router
12 | 
13 | fastapi_app.include_router(payment_router)
14 | 


--------------------------------------------------------------------------------
/server/app/payment.py:
--------------------------------------------------------------------------------
  1 | import hashlib
  2 | from datetime import datetime
  3 | 
  4 | from fastapi import APIRouter, Request
  5 | from fastapi.templating import Jinja2Templates
  6 | 
  7 | import config
  8 | import constants
  9 | from models import ArrayAppend, Guild, PremiumPlan, PremiumTxn, User
 10 | 
 11 | router = APIRouter()
 12 | template = Jinja2Templates(directory="src/server/templates")
 13 | 
 14 | 
 15 | def create_hash(txnId: str, amount: str, productInfo: str, firstName: str, email: str):
 16 |     # sha512(key|txnid|amount|productinfo|firstname|email|udf1|udf2|udf3|udf4|udf5||||||salt)
 17 | 
 18 |     return hashlib.sha512(
 19 |         f"{config.PAYU_KEY}|{txnId}|{amount}|{productInfo}|{firstName}|{email}|||||||||||{config.PAYU_SALT}".encode(
 20 |             "utf-8"
 21 |         )
 22 |     ).hexdigest()
 23 | 
 24 | 
 25 | @router.get("/getpremium")
 26 | async def get_premium(request: Request, txnId: str):
 27 |     record = await PremiumTxn.get_or_none(txnid=txnId)
 28 | 
 29 |     if not record:
 30 |         return {"error": "Invalid Transaction ID"}
 31 | 
 32 |     if record.completed_at:
 33 |         return {"error": "Transaction already completed"}
 34 | 
 35 |     plan = await PremiumPlan.get(pk=record.plan_id)
 36 | 
 37 |     payu_hash = create_hash(txnId, plan.price, "premium", record.user_id, "abcd@gmail.com")
 38 | 
 39 |     data = {
 40 |         "key": config.PAYU_KEY,
 41 |         "txnid": txnId,
 42 |         "amount": plan.price,
 43 |         "productinfo": "premium",
 44 |         "firstname": record.user_id,
 45 |         "email": "abcd@gmail.com",
 46 |         "surl": f"{config.SUCCESS_URL}{txnId}",
 47 |         "furl": f"{config.FAILED_URL}{txnId}",
 48 |         "phone": "9999999999",
 49 |         "action": config.PAYU_PAYMENT_LINK,
 50 |         "hash": payu_hash,
 51 |     }
 52 | 
 53 |     return template.TemplateResponse("payu.html", {"request": request, "posted": data})
 54 | 
 55 | 
 56 | @router.post("/premium_success")
 57 | async def premium_success(request: Request, txnId: str):
 58 |     from core import bot
 59 | 
 60 |     try:
 61 |         form = await request.form()
 62 |     except:
 63 |         return {"error": "Invalid Request."}
 64 | 
 65 |     if not "payu" in request.headers.get("origin"):
 66 |         return {"error": "Invalid Request Origin."}
 67 | 
 68 |     if not form.get("status") == "success":
 69 |         return {"error": f"Transaction Status: {form.get('status')}"}
 70 | 
 71 |     record = await PremiumTxn.get_or_none(txnid=txnId)
 72 |     if not record:
 73 |         return {"error": "Transaction Id is invalid."}
 74 | 
 75 |     if record.completed_at:
 76 |         return {"error": "Transaction is already complete."}
 77 | 
 78 |     await PremiumTxn.get(txnid=txnId).update(raw_data=dict(form), completed_at=datetime.now(constants.IST))
 79 |     u, b = await User.get_or_create(user_id=record.user_id)
 80 |     plan = await PremiumPlan.get(pk=record.plan_id)
 81 | 
 82 |     end_time = u.premium_expire_time + plan.duration if u.is_premium else datetime.now(constants.IST) + plan.duration
 83 | 
 84 |     await User.get(pk=u.pk).update(is_premium=True, premium_expire_time=end_time)
 85 |     await User.get(pk=u.user_id).update(made_premium=ArrayAppend("made_premium", u.user_id))
 86 | 
 87 |     bot.dispatch("premium_purchase", record.txnid)
 88 | 
 89 |     guild = await Guild.get(pk=record.guild_id)
 90 |     end_time = guild.premium_end_time + plan.duration if guild.is_premium else datetime.now(constants.IST) + plan.duration
 91 |     await Guild.get(pk=guild.pk).update(is_premium=True, premium_end_time=end_time, made_premium_by=u.user_id)
 92 | 
 93 |     return {"success": "Transaction was successful. Please return to discord App."}
 94 | 
 95 | 
 96 | @router.post("/premium_failed")
 97 | async def premium_failed(request: Request, txnId: str):
 98 |     try:
 99 |         form = await request.form()
100 |     except:
101 |         return {"error": "Invalid Request."}
102 | 
103 |     if not "payu" in request.headers.get("origin"):
104 |         return {"error": "Invalid Request Origin."}
105 | 
106 |     await PremiumTxn.get(txnid=txnId).update(completed_at=datetime.now(constants.IST), raw_data=dict(form))
107 | 
108 |     return {"error": "Transaction Cancelled."}
109 | 


--------------------------------------------------------------------------------
/server/templates/payu.html:
--------------------------------------------------------------------------------
 1 | <html>
 2 |     <head>
 3 |         <title>Loading...</title>
 4 |     </head>
 5 |   
 6 |     <body onload="document.payuForm.submit()">
 7 |         <form action={{ posted.action }} method="post" name="payuForm">
 8 |             <input type="hidden" name="key" value="{{posted.key}}" />
 9 |             <input type="hidden" name="hash" value="{{ posted.hash }}" />
10 |             <input type="hidden" name="txnid" value="{{ posted.txnid }}" />
11 | 
12 |             <input type="hidden" name="productinfo" value="{{ posted.productinfo }}" />
13 | 
14 |             <input type="hidden" name="amount" value="{{ posted.amount }}" /></td>
15 |             <input type="hidden" name="firstname" id="firstname" value="{{ posted.firstname }}" /></td>
16 |             <input type="hidden" name="email" id="email" value="{{ posted.email}}" /></td>
17 | 
18 |             <input type="hidden" name="surl" value="{{ posted.surl }}" size="64" /></td>
19 |             <input type="hidden" name="furl" value="{{ posted.furl }}" size="64" /></td>
20 | 
21 |         </form>
22 |     </body>
23 |     </html>


--------------------------------------------------------------------------------
/server/templates/response.html:
--------------------------------------------------------------------------------
 1 | <!DOCTYPE html>
 2 | <html lang="en">
 3 | 
 4 | <head>
 5 |     <meta charset="UTF-8">
 6 |     <meta name="viewport" content="width=device-width, initial-scale=1.0">
 7 |     <title>Payment Response</title>
 8 |     <style>
 9 |         body {
10 |             font-family: Arial, sans-serif;
11 |             display: flex;
12 |             background-color: #222;
13 |             justify-content: center;
14 |             align-items: center;
15 |             height: 100vh;
16 |             margin: 0;
17 |         }
18 | 
19 |         .container {
20 |             background-color: black;
21 |             padding: 20px;
22 |             text-align: center;
23 |             border-radius: 30px;
24 |         }
25 | 
26 |         .success-message {
27 |             color: #00ffb3;
28 |         }
29 | 
30 |         .error-message {
31 |             color: #e74c3c;
32 |         }
33 |         p{
34 |             color: white    ;
35 |         }
36 |         img{
37 |             height: 70px;
38 |             width: 70px;
39 |         }
40 | 
41 |     </style>
42 | </head>
43 | 
44 | <body>
45 |     <div class="container">
46 |         {% if success %}
47 |         <h1 class="success-message">Transaction was Successful!</h1>
48 |         <img src="https://quotientbot.xyz/static/media/favicon.b181bf099887fa60b39b.png">
49 |         <p>Please return to the Discord App.</p>
50 |         {% else %}
51 |         <h1 class="error-message">An Error occurred during the Transaction.</h1>
52 |         <img src="https://quotientbot.xyz/static/media/favicon.b181bf099887fa60b39b.png">
53 |         <p>Please try again later or contact support.</p>
54 |         {% endif %}
55 |     </div>
56 | </body>
57 | 
58 | </html>
59 | 


--------------------------------------------------------------------------------
/sockets/__init__.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from socketio import AsyncClient
 9 | 
10 | from core import Cog
11 | 
12 | from .app import sio
13 | from .events import DashboardGate, SocketScrims, SockGuild, SockPrime, SockSettings
14 | 
15 | 
16 | class SocketConnection(Cog):
17 |     connected: bool = False
18 |     sio: AsyncClient
19 | 
20 |     def __init__(self, bot: Quotient):
21 |         self.bot = bot
22 |         self.task = self.bot.loop.create_task(self.__make_connection())
23 | 
24 |     def cog_unload(self) -> None:
25 |         self.bot.loop.create_task(self.__close_connection())
26 | 
27 |     async def __make_connection(self):
28 |         await sio.connect(self.bot.config.SOCKET_URL, auth={"token": self.bot.config.SOCKET_AUTH})
29 | 
30 |         sio.bot, self.bot.sio = self.bot, sio
31 |         self.connected = True
32 | 
33 |     async def __close_connection(self):
34 |         if self.connected:
35 |             await sio.disconnect()
36 |             self.connected = False
37 | 
38 | 
39 | async def setup(bot: Quotient):
40 |     await bot.add_cog(SocketConnection(bot))
41 |     await bot.add_cog(DashboardGate(bot))
42 |     await bot.add_cog(SocketScrims(bot))
43 |     await bot.add_cog(SockSettings(bot))
44 |     await bot.add_cog(SockPrime(bot))
45 |     await bot.add_cog(SockGuild(bot))
46 | 


--------------------------------------------------------------------------------
/sockets/app/__init__.py:
--------------------------------------------------------------------------------
1 | from .app import sio
2 | 


--------------------------------------------------------------------------------
/sockets/app/app.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | import socketio
 9 | 
10 | 
11 | class QuoSocket(socketio.AsyncClient):
12 |     bot: Quotient
13 | 
14 |     def __init__(self, **kwargs):
15 |         super().__init__(**kwargs)
16 | 
17 |     async def emit(self, event, data=None, namespace=None, callback=None):
18 |         return await super().emit("response__" + event, data=data, namespace=namespace, callback=callback)
19 | 
20 |     async def request(self, event, data=None, namespace=None, callback=None):
21 |         return await super().emit(event, data=data, namespace=namespace, callback=callback)
22 | 
23 |     @staticmethod
24 |     def int_parse(data):
25 |         if not isinstance(data, dict):
26 |             return data
27 | 
28 |         for x, y in data.items():
29 |             if isinstance(y, str) and y.isdigit():
30 |                 data[x] = int(y)
31 | 
32 |         return data
33 | 
34 | 
35 | sio = QuoSocket(logger=True, engineio_logger=True)
36 | ignored = ("update_total_votes", "update_votes_leaderboard")
37 | 
38 | 
39 | @sio.on("*")
40 | async def catch_all(event, data):
41 |     if event in ignored:
42 |         return
43 | 
44 |     data = QuoSocket.int_parse(data)
45 | 
46 |     r, e, u = event.split("__")
47 |     data["user__id"] = u
48 |     sio.bot.dispatch(r + "__" + e, u, data)
49 | 


--------------------------------------------------------------------------------
/sockets/events/__init__.py:
--------------------------------------------------------------------------------
1 | from .dashgate import *  # noqa: F401, F403
2 | from .guilds import *  # noqa: F401, F403
3 | from .premium import *  # noqa: F401, F403
4 | from .scrims import *  # noqa: F401, F403
5 | from .settings import *  # noqa: F401, F403
6 | 


--------------------------------------------------------------------------------
/sockets/events/dashgate.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from typing import TYPE_CHECKING
 4 | 
 5 | if TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from core import Cog
 9 | from models import Guild
10 | 
11 | __all__ = ("DashboardGate",)
12 | 
13 | 
14 | class DashboardGate(Cog):
15 |     def __init__(self, bot: Quotient):
16 |         self.bot = bot
17 | 
18 |     @Cog.listener()
19 |     async def on_request__latency(self, u, data):
20 |         return await self.bot.sio.emit("latency__{0}".format(u), {})
21 | 
22 |     @Cog.listener()
23 |     async def on_request__guild_permissions(self, u, data):
24 |         guild_ids = data["guild_ids"]
25 |         user_id = data["user_id"]
26 | 
27 |         result = {}
28 | 
29 |         for guild_id in guild_ids:
30 |             guild_id = int(guild_id)
31 | 
32 |             guild = self.bot.get_guild(guild_id)
33 |             if not guild:
34 |                 result[guild_id] = -1
35 |                 continue
36 | 
37 |             if not guild.chunked:
38 |                 self.bot.loop.create_task(guild.chunk())
39 | 
40 |             member = await self.bot.get_or_fetch_member(guild, user_id)
41 |             if not member:
42 |                 result[guild_id] = -1
43 |                 continue
44 | 
45 |             perms = 1
46 | 
47 |             if member.guild_permissions.manage_guild:
48 |                 result[guild_id] = 2
49 |                 continue
50 | 
51 |             g_record = await Guild.get(pk=guild_id)
52 |             _roles = [str(_.id) for _ in member.roles]
53 | 
54 |             if any(i in g_record.dashboard_access["embed"] for i in _roles):
55 |                 perms *= 3
56 | 
57 |             if any(i in g_record.dashboard_access["scrims"] for i in _roles):
58 |                 perms *= 5
59 | 
60 |             if any(i in g_record.dashboard_access["tourney"] for i in _roles):
61 |                 perms *= 7
62 | 
63 |             if any(i in g_record.dashboard_access["slotm"] for i in _roles):
64 |                 perms *= 11
65 | 
66 |             result[guild_id] = perms
67 | 
68 |         await self.bot.sio.emit(f"guild_permissions__{u}", result)
69 | 


--------------------------------------------------------------------------------
/sockets/events/guilds.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing as T
 4 | 
 5 | import discord
 6 | 
 7 | if T.TYPE_CHECKING:
 8 |     from core import Quotient
 9 | 
10 | from core import Cog
11 | from models import Guild
12 | 
13 | from ..schemas import QGuild
14 | 
15 | __all__ = ("SockGuild",)
16 | 
17 | 
18 | class SockGuild(Cog):
19 |     def __init__(self, bot: Quotient):
20 |         self.bot = bot
21 | 
22 |     @Cog.listener()
23 |     async def on_request__get_guilds(self, u, data: dict):
24 |         guild_ids = data["guild_ids"]
25 |         user_id = data["user_id"]
26 | 
27 |         results: T.Dict[str, T.List[QGuild]] = {}
28 | 
29 |         for _id in guild_ids:
30 |             guild = self.bot.get_guild(int(_id))
31 |             if not guild:
32 |                 continue
33 | 
34 |             member = await self.bot.get_or_fetch_member(guild, user_id)
35 |             if not member:
36 |                 continue
37 | 
38 |             results[str(_id)] = (await QGuild.from_guild(guild, await self.__guild_permissions(guild, member))).dict()
39 | 
40 |         await self.bot.sio.emit("get_guilds__{0}".format(u), results)
41 | 
42 |     async def __guild_permissions(self, guild: discord.Guild, user: discord.Member):
43 |         perms = 1
44 | 
45 |         if user.guild_permissions.manage_guild:
46 |             return 2
47 | 
48 |         g = await Guild.get(pk=guild.id)
49 |         _roles = [str(_.id) for _ in user.roles]
50 | 
51 |         if any(i in g.dashboard_access["embed"] for i in _roles):
52 |             perms *= 3
53 | 
54 |         if any(i in g.dashboard_access["scrims"] for i in _roles):
55 |             perms *= 5
56 | 
57 |         if any(i in g.dashboard_access["tourney"] for i in _roles):
58 |             perms *= 7
59 | 
60 |         if any(i in g.dashboard_access["slotm"] for i in _roles):
61 |             perms *= 11
62 | 
63 |         return perms
64 | 


--------------------------------------------------------------------------------
/sockets/events/premium.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import typing as T
  4 | from contextlib import suppress
  5 | 
  6 | if T.TYPE_CHECKING:
  7 |     from core import Quotient
  8 | 
  9 | import discord
 10 | 
 11 | from constants import random_greeting, random_thanks
 12 | from core import Cog
 13 | 
 14 | __all__ = ("SockPrime",)
 15 | 
 16 | 
 17 | class SockPrime(Cog):
 18 |     def __init__(self, bot: Quotient):
 19 |         self.bot = bot
 20 |         self.hook = discord.Webhook.from_url(self.bot.config.PUBLIC_LOG, session=self.bot.session)
 21 | 
 22 |     @Cog.listener()
 23 |     async def on_request__perks(self, u, data):
 24 |         return await self.bot.sio.emit(
 25 |             f"perks__{u}",
 26 |             [
 27 |                 "Unlimited Scrims (3 for free)",
 28 |                 "Unlimited tournaments (1 for free)",
 29 |                 "Remind Me & Transfer Id-Pass button in Scrims Slotm.",
 30 |                 "Unlimited tagcheck and easytag channels.",
 31 |                 "Custom reactions for tourney and scrims.",
 32 |                 "Unlimited media partner channels.",
 33 |                 "Unlimited ssverification channels.",
 34 |                 "Premium role in our server + several other benefits...",
 35 |             ],
 36 |         )
 37 | 
 38 |     @Cog.listener()
 39 |     async def on_request__new_premium(self, u, data: dict):
 40 |         await self.bot.sio.emit("new_premium__{0}".format(u), {})
 41 | 
 42 |         if not data.get("is_verified"):
 43 |             return await self.__transaction_failed(int(u))
 44 | 
 45 |         user_id = int(u)
 46 |         invoice = data["invoice_link"]
 47 | 
 48 |         prime = "https://discord.com/oauth2/authorize?client_id=902856923311919104&scope=applications.commands%20bot&permissions=536737213566"
 49 | 
 50 |         member = await self.bot.get_or_fetch_member(self.bot.server, user_id)
 51 |         if member is not None:
 52 |             await member.add_roles(discord.Object(id=self.bot.config.PREMIUM_ROLE), reason="They purchased premium.")
 53 | 
 54 |         else:
 55 |             member = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, user_id)
 56 | 
 57 |         _e = discord.Embed(color=self.bot.color)
 58 |         _e.description = (
 59 |             f"{random_greeting()} {member.mention},\n"
 60 |             "Thanks for purchasing Quotient Premium.\n\n"
 61 |             f"[Invite Quotient Pro]({prime}) | [Support Server]({self.bot.config.SERVER_LINK}) | [Download Invoice]({invoice})"
 62 |         )
 63 | 
 64 |         _e.set_image(url=random_thanks())
 65 | 
 66 |         try:
 67 |             await member.send(embed=_e)
 68 |         except discord.HTTPException:
 69 |             pass
 70 | 
 71 |         finally:
 72 |             _e = discord.Embed(
 73 |                 color=discord.Color.gold(), description=f"Thanks **{member}** for purchasing Quotient Premium."
 74 |             )
 75 |             _e.set_image(url=random_thanks())
 76 |             await self.hook.send(embed=_e, username="premium-logs", avatar_url=self.bot.config.PREMIUM_AVATAR)
 77 | 
 78 |             # if data["details"]["amount"] != "29.00":
 79 |             #     await self.give_rilp_premium(member)
 80 | 
 81 |     async def __transaction_failed(self, user_id: int) -> None:
 82 |         ...
 83 | 
 84 |     # async def give_rilp_premium(self, member: discord.Member | discord.User) -> None:
 85 | 
 86 |     #     async with self.bot.session.post(
 87 |     #         self.bot.config.RILP_PREMIUM,
 88 |     #         headers=self.bot.config.RILP_HEADERS,
 89 |     #         json={"userId": str(member.id), "subscriptionId": "Q_{}".format(self.bot.current_time.timestamp())},
 90 |     #     ) as res:
 91 |     #         if not res.status == 200:
 92 |     #             return
 93 | 
 94 |     #         res = await res.json()
 95 |     #         _f = discord.Embed(color=self.bot.color, title="Quotient x RILP BOT", url=self.bot.config.SERVER_LINK)
 96 |     #         _f.description = (
 97 |     #             "Quotient has partnered with Rilp Bot, a multipurpose bot that features Automoderation, "
 98 |     #             "Invite Tracking, Starboard, Welcome and Leave messages, Giveaways, Polls, Moderation, "
 99 |     #             "Captcha Security, and much more.\n\n"
100 |     #             "With this Quotient Pro purchase, you have received **Rilp Bot Premium (30 days)**"
101 |     #             "\n\n__Please follow these steps:__\n"
102 |     #             "➜ Head over to dashboard <https://rilp-bot.tech>\n"
103 |     #             "➜ Login with your discord account from which you bought Quotient Pro.\n"
104 |     #             "➜ Click on the dropdown beside avatar and then head over to `Manage Subscription`\n"
105 |     #             "➜ Click on 'Select Server' and choose your server to activate premium.\n\n"
106 |     #             "To Invite RILP BOT - <https://rilp-bot.tech/invite>\n"
107 |     #             "Dashboard - https://rilp-bot.tech\n"
108 |     #             "Support Server - <https://rilp-bot.tech/support>\n"
109 |     #         )
110 | 
111 |     #         _f.set_image(
112 |     #             url="https://cdn.discordapp.com/attachments/1001770455016935536/1002246506981625947/rilpxquotient.jpg"
113 |     #         )
114 |     #         try:
115 |     #             await member.send(embed=_f)
116 | 
117 |     #         except discord.Forbidden:
118 |     #             return
119 | 


--------------------------------------------------------------------------------
/sockets/events/scrims.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import typing
 4 | 
 5 | if typing.TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from core import Cog
 9 | from models import Scrim
10 | 
11 | from ..schemas import BaseScrim, SockResponse
12 | 
13 | __all__ = ("SocketScrims",)
14 | 
15 | 
16 | class SocketScrims(Cog):
17 |     def __init__(self, bot: Quotient):
18 |         self.bot = bot
19 | 
20 |     @Cog.listener()
21 |     async def on_request__bot_scrim_create(self, u: str, data: dict):
22 |         data: BaseScrim = BaseScrim(**data)
23 | 
24 |         _v = await data.validate_perms(self.bot)
25 | 
26 |         if all(_v):
27 |             _v = await data.create_scrim(self.bot)
28 | 
29 |         if not all(_v):
30 |             return await self.bot.sio.emit("bot_scrim_create__{0}".format(u), SockResponse(ok=False, error=_v[1]).dict())
31 | 
32 |         await self.bot.sio.emit("bot_scrim_create__{0}".format(u), SockResponse(data={"id": _v[1].id}).dict())
33 | 
34 |     @Cog.listener()
35 |     async def on_request__bot_scrim_edit(self, u: str, data: dict):
36 |         data: BaseScrim = BaseScrim(**data)
37 | 
38 |         _v = await data.validate_perms(self.bot)
39 | 
40 |         if not all(_v):
41 |             return await self.bot.sio.emit("bot_scrim_edit__{0}".format(u), SockResponse(ok=False, error=_v[1]).dict())
42 | 
43 |         await data.update_scrim(self.bot)
44 |         await self.bot.sio.emit(f"bot_scrim_edit__{u}", SockResponse().dict())
45 | 
46 |     @Cog.listener()
47 |     async def on_request__bot_scrim_delete(self, u: str, data: dict):
48 |         guild_id, scrim_id = data["guild_id"], data["scrim_id"]
49 |         if scrim_id:
50 |             scrim = await Scrim.get_or_none(pk=scrim_id)
51 |             if scrim:
52 |                 await scrim.full_delete()
53 | 
54 |         else:
55 |             scrims = await Scrim.filter(guild_id=guild_id)
56 |             for scrim in scrims:
57 |                 await scrim.full_delete()
58 | 
59 |         return await self.bot.sio.emit(f"bot_scrim_delete__{u}", SockResponse().dict())
60 | 


--------------------------------------------------------------------------------
/sockets/events/settings.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from typing import TYPE_CHECKING
 4 | 
 5 | if TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from contextlib import suppress
 9 | 
10 | import discord
11 | 
12 | import constants
13 | from core import Cog
14 | from models import Votes
15 | 
16 | from ..schemas import SockResponse
17 | 
18 | 
19 | class SockSettings(Cog):
20 |     def __init__(self, bot: Quotient):
21 |         self.bot = bot
22 |         self.hook = discord.Webhook.from_url(self.bot.config.PUBLIC_LOG, session=self.bot.session)
23 | 
24 |     @Cog.listener()
25 |     async def on_request__prefix_change(self, u, data: dict):
26 |         guild_id = data.get("guild_id")
27 |         await self.bot.cache.update_guild_cache(int(guild_id))
28 |         await self.bot.sio.emit("prefix_change__{0}".format(u), SockResponse().dict())
29 | 
30 |     @Cog.listener()
31 |     async def on_request__new_vote(self, u, data: dict):
32 |         user_id = int(data.get("user_id"))
33 |         record = await Votes.get(pk=user_id)
34 | 
35 |         await self.bot.reminders.create_timer(record.expire_time, "vote", user_id=record.user_id)
36 | 
37 |         member = self.bot.server.get_member(record.user_id)
38 |         if member is not None:
39 |             await member.add_roles(discord.Object(id=self.bot.config.VOTER_ROLE), reason="They voted for me.")
40 | 
41 |         else:
42 |             member = await self.bot.getch(self.bot.get_user, self.bot.fetch_user, record.pk)
43 | 
44 |         with suppress(discord.HTTPException, AttributeError):
45 |             embed = discord.Embed(color=discord.Color.green(), description=f"Thanks **{member}** for voting.")
46 |             embed.set_image(url=constants.random_thanks())
47 |             embed.set_footer(text=f"Your total votes: {record.total_votes}")
48 |             await self.hook.send(embed=embed, username="vote-logs", avatar_url=self.bot.user.display_avatar.url)
49 | 
50 |     @Cog.listener()
51 |     async def on_request__get_usernames(self, u, data: dict):
52 |         _dict = {}
53 |         for _ in data.get("users"):
54 |             _dict[str(_)] = str(await self.bot.getch(self.bot.get_user, self.bot.fetch_user, int(_)))
55 | 
56 |         await self.bot.sio.emit("get_usernames__{0}".format(u), SockResponse(data=_dict).dict())
57 | 


--------------------------------------------------------------------------------
/sockets/events/tourney.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from typing import TYPE_CHECKING
 4 | 
 5 | if TYPE_CHECKING:
 6 |     from core import Quotient
 7 | 
 8 | from core import Cog
 9 | from models import Tourney
10 | 
11 | from ..schemas import SockTourney
12 | 
13 | __all__ = ("SockTourney",)
14 | 
15 | 
16 | class SockTourney(Cog):
17 |     def __init__(self, bot: Quotient):
18 |         self.bot = bot
19 | 
20 |     @Cog.listener()
21 |     async def on_request__bot_tourney_create(self, u: str, data: dict):
22 |         data: SockTourney = SockTourney(**data)
23 | 
24 |     @Cog.listener()
25 |     async def on_request__bot_tourney_edit(self, u: str, data: dict):
26 |         data: SockTourney = SockTourney(**data)
27 | 
28 |     @Cog.listener()
29 |     async def on_request__bot_tourney_delete(self, u: str, data: dict):
30 |         guild_id, tourney_id = data["guild_id"], data["tourney_id"]
31 |         if tourney_id:
32 |             tourney = await Tourney.get_or_none(pk=tourney_id)
33 |             if tourney:
34 |                 await tourney.full_delete()
35 | 
36 |         else:
37 |             tourneys = await Tourney.filter(guild_id=guild_id)
38 |             for tourney in tourneys:
39 |                 await tourney.full_delete()
40 | 
41 |         return await self.bot.sio.emit("bot_tourney_delete__{0}".format(u), SockTourney().dict())
42 | 


--------------------------------------------------------------------------------
/sockets/schemas/__init__.py:
--------------------------------------------------------------------------------
1 | from ._guild import *
2 | from ._resp import *
3 | from ._scrim import *
4 | from ._tourney import *
5 | 


--------------------------------------------------------------------------------
/sockets/schemas/_guild.py:
--------------------------------------------------------------------------------
 1 | import typing as T
 2 | 
 3 | import discord
 4 | from pydantic import BaseModel
 5 | 
 6 | from models import Guild
 7 | 
 8 | __all__ = ("QGuild",)
 9 | 
10 | 
11 | class QGuild(BaseModel):
12 |     id: str
13 |     name: str
14 |     icon: str
15 |     channels: T.List[dict]
16 |     roles: T.List[dict]
17 |     boosted_by: dict
18 |     dashboard_access: int
19 | 
20 |     @staticmethod
21 |     async def from_guild(guild: discord.Guild, perms: int):
22 |         _d = {
23 |             "id": str(guild.id),
24 |             "name": guild.name,
25 |             "dashboard_access": perms,
26 |             "icon": getattr(guild.icon, "url", "https://cdn.discordapp.com/embed/avatars/0.png"),
27 |         }
28 | 
29 |         _d["channels"] = [{"id": str(c.id), "name": c.name} for c in guild.text_channels]
30 | 
31 |         _d["roles"] = [
32 |             {"id": str(r.id), "name": r.name, "color": int(r.color), "managed": r.managed} for r in guild.roles
33 |         ]
34 |         _d["boosted_by"] = {}
35 | 
36 |         record = await Guild.get(pk=guild.id)
37 | 
38 |         if record.is_premium:
39 |             booster = await record.bot.get_or_fetch_member(guild, record.made_premium_by)
40 |             _d["boosted_by"] = {
41 |                 "id": str(getattr(booster, "id", 12345)),
42 |                 "username": getattr(booster, "name", "Unknown User"),
43 |                 "discriminator": getattr(booster, "discriminator", "#0000"),
44 |                 "avatar": booster.display_avatar.url if booster else "https://cdn.discordapp.com/embed/avatars/0.png",
45 |             }
46 | 
47 |         return QGuild(**_d)
48 | 


--------------------------------------------------------------------------------
/sockets/schemas/_resp.py:
--------------------------------------------------------------------------------
 1 | from pydantic import BaseModel
 2 | 
 3 | __all__ = ("SockResponse",)
 4 | 
 5 | 
 6 | class SockResponse(BaseModel):
 7 |     ok: bool = True
 8 |     error: str = None
 9 |     data: dict = None
10 | 


--------------------------------------------------------------------------------
/sockets/schemas/_scrim.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from datetime import datetime
  4 | from typing import TYPE_CHECKING, List, Tuple, Union
  5 | 
  6 | from pydantic import BaseModel, validator
  7 | 
  8 | if TYPE_CHECKING:
  9 |     from core import Quotient
 10 | 
 11 | from datetime import datetime, timedelta
 12 | 
 13 | import dateparser
 14 | 
 15 | from constants import IST, AutocleanType, Day
 16 | from models import Guild, Scrim, Timer
 17 | 
 18 | __all__ = ("BaseScrim",)
 19 | 
 20 | 
 21 | def str_to_time(_t: str = None):
 22 |     if not _t:
 23 |         return datetime.now(IST).replace(hour=4, minute=0, second=0, microsecond=0) + timedelta(days=1)
 24 | 
 25 |     parsed = dateparser.parse(
 26 |         _t,
 27 |         settings={
 28 |             # "RELATIVE_BASE": datetime.now(tz=IST),
 29 |             "TIMEZONE": "Asia/Kolkata",
 30 |             "RETURN_AS_TIMEZONE_AWARE": True,
 31 |         },
 32 |     )
 33 |     if datetime.now(tz=IST) > parsed:
 34 |         parsed = parsed + timedelta(hours=24)
 35 | 
 36 |     return parsed
 37 | 
 38 | 
 39 | class BaseScrim(BaseModel):
 40 |     id: int = None
 41 |     guild_id: int
 42 |     name: str = "Quotient-Scrims"
 43 |     registration_channel_id: int
 44 |     slotlist_channel_id: int
 45 |     role_id: int
 46 |     required_mentions: int
 47 |     start_from: int = 1
 48 |     total_slots: int
 49 |     host_id: int
 50 |     open_time: datetime
 51 |     autoclean: List[AutocleanType] = list(AutocleanType)
 52 |     autoclean_time: datetime = datetime.now(IST).replace(hour=4, minute=0, second=0, microsecond=0) + timedelta(days=1)
 53 | 
 54 |     autoslotlist: bool = True
 55 |     ping_role_id: int = None
 56 |     multiregister: bool = False
 57 |     open_role_id: int = None
 58 | 
 59 |     autodelete_rejects: bool = False
 60 |     autodelete_extras: bool = True
 61 |     teamname_compulsion: bool = True
 62 | 
 63 |     show_time_elapsed: bool = True
 64 |     open_days: List[Day] = list(Day)
 65 |     no_duplicate_name: bool = False
 66 |     open_message: dict = {}
 67 |     close_message: dict = {}
 68 | 
 69 |     banlog_channel_id: int = None
 70 |     match_time: datetime = None
 71 | 
 72 |     # validators
 73 |     _open_time = validator("open_time", pre=True, allow_reuse=True)(str_to_time)
 74 |     _autoclean_time = validator("autoclean_time", pre=True, allow_reuse=True)(str_to_time)
 75 |     _match_time = validator("match_time", pre=True, allow_reuse=True)(str_to_time)
 76 | 
 77 |     async def validate_perms(self, bot: Quotient) -> Tuple[bool, Union[bool, str]]:
 78 |         v = await self.__check_bot_perms(bot)
 79 |         if not all(v):
 80 |             return v
 81 | 
 82 |         guild = bot.get_guild(self.guild_id)
 83 | 
 84 |         reg_channel = bot.get_channel(self.registration_channel_id)
 85 |         if not reg_channel:
 86 |             return False, "Quotient can't see your registration channel. Give Perms."
 87 | 
 88 |         _p = reg_channel.permissions_for(guild.me)
 89 |         if not all((_p.manage_channels, _p.manage_permissions, _p.manage_messages)):
 90 |             return False, "Quotient can't manage this registration channel. Give Perms."
 91 | 
 92 |         role = guild.get_role(self.role_id)
 93 |         if not role:
 94 |             return False, "Quotient couldn't find your sucess role."
 95 | 
 96 |         if role >= guild.me.top_role:
 97 |             return False, "Drag Quotent role above your success role."
 98 | 
 99 |         _p = role.permissions
100 |         if any((_p.administrator, _p.manage_channels, _p.manage_roles, _p.kick_members, _p.ban_members)):
101 |             return False, "Success role has dangerous permissions."
102 | 
103 |         return True, True
104 | 
105 |     async def create_scrim(self, bot: Quotient):
106 |         if not await Guild.filter(guild_id=self.guild_id, is_premium=True).exists():
107 |             if await Scrim.filter(guild_id=self.guild_id).count() >= 3:
108 |                 return False, "Cannot create more than 3 scrims without Premium."
109 | 
110 |         if await Scrim.filter(registration_channel_id=self.registration_channel_id).exists():
111 |             return False, "Another scrim is using this registration channel."
112 | 
113 |         _d = self.dict()
114 |         del _d["id"]
115 | 
116 |         scrim = await Scrim.create(**_d)
117 | 
118 |         await bot.reminders.create_timer(scrim.open_time, "scrim_open", scrim_id=scrim.id)
119 | 
120 |         await bot.reminders.create_timer(scrim.autoclean_time, "autoclean", scrim_id=scrim.id)
121 |         bot.loop.create_task(scrim.setup_logs())
122 |         return True, scrim
123 | 
124 |     async def update_scrim(self, bot: Quotient):
125 |         scrim = await Scrim.get_or_none(pk=self.id)
126 |         if not scrim:
127 |             return False, "Scrim not found."
128 | 
129 |         await Timer.filter(extra={"args": [], "kwargs": {"scrim_id": self.id}}, event="autoclean").delete()
130 |         await Timer.filter(extra={"args": [], "kwargs": {"scrim_id": self.id}}, event="scrim_open").delete()
131 |         await bot.reminders.create_timer(self.open_time, "scrim_open", scrim_id=self.id)
132 | 
133 |         await bot.reminders.create_timer(self.autoclean_time, "autoclean", scrim_id=self.id)
134 | 
135 |         _d = self.dict()
136 |         del _d["id"]
137 |         del _d["open_days"]
138 |         del _d["autoclean"]
139 | 
140 |         await Scrim.filter(pk=self.id).update(**_d)
141 | 
142 |         _w = """UPDATE public."sm.scrims" SET autoclean = $1 , open_days = $2 WHERE id = $3"""
143 |         await bot.db.execute(_w, [_.value for _ in self.autoclean], [_.value for _ in self.open_days], self.id)
144 | 
145 |         bot.loop.create_task(scrim.setup_logs())
146 |         return True, True
147 | 
148 |     async def __check_bot_perms(self, bot: Quotient):
149 |         g = await bot.getch(bot.get_guild, bot.fetch_guild, self.guild_id)
150 | 
151 |         if g:
152 |             g_perms = g.me.guild_permissions
153 | 
154 |         if not g:
155 |             return False, "Couldn't find your server. Try again in a few minutes."
156 | 
157 |         if not all((g_perms.manage_channels, g_perms.manage_roles, g_perms.manage_messages)):
158 |             return False, "Quotient needs manage channels, manage roles permission."
159 | 
160 |         if not all((g_perms.add_reactions, g_perms.embed_links)):
161 |             return False, "Quotient needs add reacions & embed links permission."
162 | 
163 |         return True, True
164 | 


--------------------------------------------------------------------------------
/sockets/schemas/_tourney.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | from typing import List, Optional
 4 | 
 5 | from pydantic import BaseModel
 6 | 
 7 | 
 8 | class SockTourney(BaseModel):
 9 |     id: Optional[int] = None
10 |     guild_id: int
11 |     name: str = "Quotient-Tourney"
12 |     registration_channel_id: int
13 |     confirm_channel_id: int
14 |     role_id: int
15 |     required_mentions: int = 4
16 |     total_slots: int
17 |     banned_users: List[int]
18 |     host_id: int
19 |     multiregister: bool = False
20 |     open_role_id: Optional[int] = None
21 |     teamname_compulsion: bool = False
22 |     ping_role_id: Optional[int] = None
23 |     no_duplicate_name: bool = True
24 |     autodelete_rejected: bool = True
25 |     success_message: Optional[str] = None
26 | 


--------------------------------------------------------------------------------
/utils/__init__.py:
--------------------------------------------------------------------------------
1 | from .buttons import *
2 | from .converters import *
3 | from .default import *
4 | from .emote import *
5 | from .formats import *
6 | from .inputs import *
7 | from .paginator import *
8 | from .time import *
9 | 


--------------------------------------------------------------------------------
/utils/__pycache__/__init__.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/utils/__pycache__/__init__.cpython-312.pyc


--------------------------------------------------------------------------------
/utils/__pycache__/buttons.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/utils/__pycache__/buttons.cpython-312.pyc


--------------------------------------------------------------------------------
/utils/__pycache__/converters.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/utils/__pycache__/converters.cpython-312.pyc


--------------------------------------------------------------------------------
/utils/__pycache__/default.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/utils/__pycache__/default.cpython-312.pyc


--------------------------------------------------------------------------------
/utils/__pycache__/emote.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/utils/__pycache__/emote.cpython-312.pyc


--------------------------------------------------------------------------------
/utils/__pycache__/exceptions.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/utils/__pycache__/exceptions.cpython-312.pyc


--------------------------------------------------------------------------------
/utils/__pycache__/formats.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/utils/__pycache__/formats.cpython-312.pyc


--------------------------------------------------------------------------------
/utils/__pycache__/inputs.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/utils/__pycache__/inputs.cpython-312.pyc


--------------------------------------------------------------------------------
/utils/__pycache__/paginator.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/utils/__pycache__/paginator.cpython-312.pyc


--------------------------------------------------------------------------------
/utils/__pycache__/regex.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/utils/__pycache__/regex.cpython-312.pyc


--------------------------------------------------------------------------------
/utils/__pycache__/time.cpython-312.pyc:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/NICK-FURY-6023/Quotient-copy/18b2ff6afef8c89ea2265963e59822285084a52c/utils/__pycache__/time.cpython-312.pyc


--------------------------------------------------------------------------------
/utils/buttons.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | from typing import List, NamedTuple, Optional, Union
  4 | 
  5 | import discord
  6 | 
  7 | from .emote import TextChannel, VoiceChannel
  8 | 
  9 | 
 10 | class LinkType(NamedTuple):
 11 |     name: Optional[str] = None
 12 |     url: Optional[str] = None
 13 |     emoji: Optional[str] = None
 14 | 
 15 | 
 16 | class LinkButton(discord.ui.View):
 17 |     def __init__(self, links: Union[LinkType, List[LinkType]]):
 18 |         super().__init__()
 19 | 
 20 |         links = links if isinstance(links, list) else [links]
 21 | 
 22 |         for link in links:
 23 |             self.add_item(discord.ui.Button(label=link.name, url=link.url, emoji=link.emoji))
 24 | 
 25 | 
 26 | class Prompt(discord.ui.View):
 27 |     def __init__(self, user_id, timeout=30.0):
 28 |         super().__init__(timeout=timeout)
 29 |         self.user_id = user_id
 30 |         self.value = None
 31 | 
 32 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
 33 |         if interaction.user.id != self.user_id:
 34 |             await interaction.response.send_message(
 35 |                 "Sorry, you can't use this interaction as it is not started by you.", ephemeral=True
 36 |             )
 37 |             return False
 38 |         return True
 39 | 
 40 |     @discord.ui.button(label="Confirm", style=discord.ButtonStyle.green)
 41 |     async def confirm(self, interaction: discord.Interaction, _: discord.ui.Button):
 42 |         await interaction.response.defer()
 43 |         self.value = True
 44 |         self.stop()
 45 | 
 46 |     @discord.ui.button(label="Cancel", style=discord.ButtonStyle.grey)
 47 |     async def cancel(self, interaction: discord.Interaction, _: discord.ui.Button):
 48 |         await interaction.response.defer()
 49 |         self.value = False
 50 |         self.stop()
 51 | 
 52 | 
 53 | class BaseSelector(discord.ui.View):
 54 |     message: discord.Message
 55 | 
 56 |     def __init__(self, author_id, selector: discord.ui.Select, **kwargs):
 57 |         self.author_id = author_id
 58 |         self.custom_id = None
 59 |         super().__init__(timeout=30.0)
 60 | 
 61 |         self.add_item(selector(**kwargs))
 62 | 
 63 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
 64 |         if interaction.user.id != self.author_id:
 65 |             await interaction.response.send_message(
 66 |                 "Sorry, you can't use this interaction as it is not started by you.", ephemeral=True
 67 |             )
 68 |             return False
 69 |         return True
 70 | 
 71 |     async def on_timeout(self) -> None:
 72 |         if hasattr(self, "message"):
 73 |             await self.message.delete()
 74 | 
 75 | 
 76 | class ChannelSelector(discord.ui.Select):
 77 |     def __init__(self, placeholder: str, channels: List[Union[discord.TextChannel, discord.VoiceChannel]]):
 78 |         _options = []
 79 |         for channel in channels:
 80 |             _options.append(
 81 |                 discord.SelectOption(
 82 |                     label=channel.name,
 83 |                     value=channel.id,
 84 |                     description=f"{channel.name} ({channel.id})",
 85 |                     emoji=TextChannel if isinstance(channel, discord.TextChannel) else VoiceChannel,
 86 |                 )
 87 |             )
 88 | 
 89 |         super().__init__(placeholder=placeholder, options=_options)
 90 | 
 91 |     async def callback(self, interaction: discord.Interaction):
 92 |         await interaction.response.defer()
 93 |         self.view.custom_id = interaction.data["values"][0]
 94 |         self.view.stop()
 95 | 
 96 | 
 97 | class CustomSelector(discord.ui.Select):
 98 |     def __init__(self, placeholder: str, options: List[discord.SelectOption]):
 99 |         super().__init__(placeholder=placeholder, options=options)
100 | 
101 |     async def callback(self, interaction: discord.Interaction):
102 |         await interaction.response.defer()
103 |         self.view.custom_id = interaction.data["values"][0]
104 |         self.view.stop()
105 | 


--------------------------------------------------------------------------------
/utils/checks.py:
--------------------------------------------------------------------------------
  1 | from typing import Union
  2 | 
  3 | from discord.ext import commands
  4 | from discord.ext.commands import CheckFailure, Context, has_any_role
  5 | 
  6 | from models import Guild, User
  7 | 
  8 | from .exceptions import *
  9 | 
 10 | 
 11 | def has_done_setup():
 12 |     async def predicate(ctx: Context):
 13 |         check = await Guild.get_or_none(pk=ctx.guild.id)
 14 |         if not check.private_ch:
 15 |             raise NotSetup()
 16 | 
 17 |         else:
 18 |             return True
 19 | 
 20 |     return commands.check(predicate)
 21 | 
 22 | 
 23 | def is_premium_guild():
 24 |     async def predictate(ctx: Context):
 25 |         check = await Guild.get_or_none(guild_id=ctx.guild.id)
 26 |         if not check or check.is_premium is False:
 27 |             raise NotPremiumGuild()
 28 | 
 29 |         else:
 30 |             return True
 31 | 
 32 |     return commands.check(predictate)
 33 | 
 34 | 
 35 | def is_premium_user():
 36 |     async def predicate(ctx: Context):
 37 |         check = await User.get_or_none(user_id=ctx.author.id)
 38 |         if not check or check.is_premium is False:
 39 |             raise NotPremiumUser()
 40 | 
 41 |         else:
 42 |             return True
 43 | 
 44 |     return commands.check(predicate)
 45 | 
 46 | 
 47 | def can_use_sm():
 48 |     """
 49 |     Returns True if the user has manage roles or scrim-mod role in the server.
 50 |     """
 51 | 
 52 |     async def predicate(ctx: Context):
 53 |         if ctx.author.guild_permissions.manage_guild or "scrims-mod" in (role.name.lower() for role in ctx.author.roles):
 54 |             return True
 55 |         raise SMNotUsable()
 56 | 
 57 |     return commands.check(predicate)
 58 | 
 59 | 
 60 | def can_use_tm():
 61 |     """
 62 |     Returns True if the user has manage roles or scrim-mod role in the server.
 63 |     """
 64 | 
 65 |     async def predicate(ctx: Context):
 66 |         if ctx.author.guild_permissions.manage_guild or "tourney-mod" in (role.name.lower() for role in ctx.author.roles):
 67 |             return True
 68 |         raise TMNotUsable()
 69 | 
 70 |     return commands.check(predicate)
 71 | 
 72 | 
 73 | async def has_any_role_check(ctx: Context, *roles: Union[str, int]) -> bool:
 74 |     """
 75 |     Returns True if the context's author has any of the specified roles.
 76 |     `roles` are the names or IDs of the roles for which to check.
 77 |     False is always returns if the context is outside a guild.
 78 |     """
 79 |     try:
 80 |         return await has_any_role(*roles).predicate(ctx)
 81 |     except CheckFailure:
 82 |         return False
 83 | 
 84 | 
 85 | async def check_guild_permissions(ctx: Context, perms, *, check=all):
 86 |     is_owner = await ctx.bot.is_owner(ctx.author)
 87 |     if is_owner:
 88 |         return True
 89 | 
 90 |     if ctx.guild is None:
 91 |         return False
 92 | 
 93 |     resolved = ctx.author.guild_permissions
 94 |     return check(getattr(resolved, name, None) == value for name, value in perms.items())
 95 | 
 96 | 
 97 | def is_mod():
 98 |     async def pred(ctx):
 99 |         return await check_guild_permissions(ctx, {"manage_guild": True})
100 | 
101 |     return commands.check(pred)
102 | 
103 | 
104 | def is_admin():
105 |     async def pred(ctx):
106 |         return await check_guild_permissions(ctx, {"administrator": True})
107 | 
108 |     return commands.check(pred)
109 | 
110 | 
111 | async def check_permissions(ctx: Context, perms, *, check=all):
112 |     is_owner = await ctx.bot.is_owner(ctx.author)
113 |     if is_owner:
114 |         return True
115 | 
116 |     resolved = ctx.channel.permissions_for(ctx.author)
117 |     return check(getattr(resolved, name, None) == value for name, value in perms.items())
118 | 
119 | 
120 | def has_permissions(*, check=all, **perms):
121 |     async def pred(ctx):
122 |         return await check_permissions(ctx, perms, check=check)
123 | 
124 |     return commands.check(pred)
125 | 


--------------------------------------------------------------------------------
/utils/converters.py:
--------------------------------------------------------------------------------
  1 | import asyncio
  2 | import contextlib
  3 | import re
  4 | from concurrent.futures import ThreadPoolExecutor
  5 | from functools import partial, wraps
  6 | from typing import Optional
  7 | 
  8 | import discord
  9 | from discord.ext import commands
 10 | from PIL import ImageColor
 11 | 
 12 | __all__ = (
 13 |     "BannedMember",
 14 |     "ActionReason",
 15 |     "MemberID",
 16 |     "QuoRole",
 17 |     "QuoMember",
 18 |     "QuoUser",
 19 |     "QuoColor",
 20 |     "QuoCategory",
 21 |     "QuoTextChannel",
 22 |     "to_async",
 23 | )
 24 | 
 25 | 
 26 | class to_async:
 27 |     def __init__(self, *, executor: Optional[ThreadPoolExecutor] = None):
 28 |         self.executor = executor
 29 | 
 30 |     def __call__(self, blocking):
 31 |         @wraps(blocking)
 32 |         async def wrapper(*args, **kwargs):
 33 |             loop = asyncio.get_event_loop()
 34 |             if not self.executor:
 35 |                 self.executor = ThreadPoolExecutor()
 36 | 
 37 |             func = partial(blocking, *args, **kwargs)
 38 | 
 39 |             return await loop.run_in_executor(self.executor, func)
 40 | 
 41 |         return wrapper
 42 | 
 43 | 
 44 | class QuoColor:
 45 |     @classmethod
 46 |     async def convert(cls, ctx, arg):
 47 |         match, check = None, False
 48 |         with contextlib.suppress(AttributeError):
 49 |             match = re.match(r"\(?(\d+),?\s*(\d+),?\s*(\d+)\)?", arg)
 50 |             check = all(0 <= int(x) <= 255 for x in match.groups())
 51 | 
 52 |         if match and check:
 53 |             return discord.Color.from_rgb(*[int(i) for i in match.groups()])
 54 | 
 55 |         _converter = commands.ColorConverter()
 56 |         result = None
 57 | 
 58 |         try:
 59 |             result = await _converter.convert(ctx, arg)
 60 |         except commands.BadColorArgument:
 61 |             with contextlib.suppress(ValueError):
 62 |                 color = ImageColor.getrgb(arg)
 63 |                 result = discord.Color.from_rgb(*color)
 64 | 
 65 |         if result:
 66 |             return result
 67 | 
 68 |         return await ctx.error(f"`{arg}` isn't a valid color.", 4)
 69 | 
 70 | 
 71 | class BannedMember(commands.Converter):
 72 |     async def convert(self, ctx, argument):
 73 |         if argument.isdigit():
 74 |             member_id = int(argument, base=10)
 75 |             try:
 76 |                 return await ctx.guild.fetch_ban(discord.Object(id=member_id))
 77 |             except discord.NotFound:
 78 |                 raise commands.BadArgument("This member has not been banned before.") from None
 79 | 
 80 |         ban_list = await ctx.guild.bans()
 81 |         entity = discord.utils.find(lambda u: str(u.user) == argument, ban_list)
 82 | 
 83 |         if entity is None:
 84 |             raise commands.BadArgument("This member has not been banned before.")
 85 |         return entity
 86 | 
 87 | 
 88 | class ActionReason(commands.Converter):
 89 |     async def convert(self, ctx, argument):
 90 |         ret = f"{ctx.author} (ID: {ctx.author.id}): {argument}"
 91 | 
 92 |         if len(ret) > 512:
 93 |             reason_max = 512 - len(ret) + len(argument)
 94 |             raise commands.BadArgument(f"Reason is too long ({len(argument)}/{reason_max})")
 95 |         return ret
 96 | 
 97 | 
 98 | def can_execute_action(ctx, user, target):
 99 |     return user.id == ctx.bot.owner_id or user == ctx.guild.owner or user.top_role > target.top_role
100 | 
101 | 
102 | class MemberID(commands.Converter):
103 |     async def convert(self, ctx, argument):
104 |         try:
105 |             m = await QuoMember().convert(ctx, argument)
106 |         except commands.BadArgument:
107 |             try:
108 |                 member_id = int(argument, base=10)
109 |             except ValueError:
110 |                 raise commands.BadArgument(f"{argument} is not a valid member or member ID.") from None
111 |             else:
112 |                 m = await ctx.bot.get_or_fetch_member(ctx.guild, member_id)
113 |                 if m is None:
114 |                     # hackban case
115 |                     return type("_Hackban", (), {"id": member_id, "__str__": lambda s: f"Member ID {s.id}"})()
116 | 
117 |         if not can_execute_action(ctx, ctx.author, m):
118 |             raise commands.BadArgument("You cannot do this action on this user due to role hierarchy.")
119 | 
120 |         elif not can_execute_action(ctx, ctx.me, m):
121 |             raise commands.BadArgument("I cannot do this action on this user due to role hierarchy.")
122 | 
123 |         return m
124 | 
125 | 
126 | class QuoRole(commands.Converter):
127 |     async def convert(self, ctx, argument) -> Optional[discord.Role]:
128 |         """
129 |         Return Role, this works without taking case sensitivity into account.
130 | 
131 |         Raises commands.RoleNotFound if cannot find the role.
132 |         """
133 |         try:
134 |             return await commands.RoleConverter().convert(ctx, argument)
135 |         except commands.RoleNotFound:
136 | 
137 |             def check(role):
138 |                 return role.name.lower() == argument.lower() or str(role).lower() == argument.lower()
139 | 
140 |             if found := discord.utils.find(check, ctx.guild.roles):
141 |                 return found
142 | 
143 |             raise commands.RoleNotFound(argument)
144 | 
145 | 
146 | class QuoMember(commands.Converter):
147 |     async def convert(self, ctx, argument) -> Optional[discord.Member]:
148 |         """
149 |         Returns Member , it is better that commands.MemberConverter() because it finds member without
150 |         taking case sensitivity into account.
151 | 
152 |         Raises commands.MemberNotFound
153 |         """
154 |         argument = argument.strip()
155 |         try:
156 |             return await commands.MemberConverter().convert(ctx, argument)
157 |         except commands.MemberNotFound:
158 | 
159 |             def check(member):
160 |                 return (
161 |                     member.name.lower() == argument.lower()
162 |                     or member.display_name.lower() == argument.lower()
163 |                     or str(member).lower() == argument.lower()
164 |                 )
165 | 
166 |             if found := discord.utils.find(check, ctx.guild.members):
167 |                 return found
168 | 
169 |             raise commands.MemberNotFound(argument)
170 | 
171 | 
172 | class QuoUser(commands.Converter):
173 |     async def convert(self, ctx, argument):
174 |         """
175 |         This will return Member if member exists in the guild else will returns User.
176 |         Raises commands.UserNotFound
177 |         """
178 |         argument = argument.strip()
179 |         if ctx.guild:
180 |             try:
181 |                 return await QuoMember().convert(ctx, argument)
182 | 
183 |             except commands.MemberNotFound:
184 |                 pass
185 | 
186 |         try:
187 |             return await commands.UserConverter().convert(ctx, argument)
188 | 
189 |         except commands.UserNotFound:
190 | 
191 |             def check(user):
192 |                 return (
193 |                     user.name.lower() == argument.lower()
194 |                     or str(user).lower() == argument.lower()
195 |                     or user.id == str(argument)
196 |                 )
197 | 
198 |             if found := discord.utils.find(check, ctx.bot.users):
199 |                 return found
200 |             raise commands.UserNotFound(argument)
201 | 
202 | 
203 | class QuoCategory(commands.Converter):
204 |     async def convert(self, ctx: commands.Context, argument):
205 |         try:
206 |             return await commands.CategoryChannelConverter().convert(ctx, argument)
207 |         except commands.ChannelNotFound:
208 | 
209 |             def check(category):
210 |                 return category.name.lower() == argument.lower()
211 | 
212 |             if found := discord.utils.find(check, ctx.guild.categories):
213 |                 return found
214 | 
215 |             raise commands.ChannelNotFound(argument)
216 | 
217 | 
218 | class QuoTextChannel(commands.Converter):
219 |     async def convert(self, ctx: commands.Context, argument):
220 |         try:
221 |             return await commands.TextChannelConverter().convert(ctx, argument)
222 |         except commands.ChannelNotFound:
223 | 
224 |             def check(channel: discord.TextChannel):
225 |                 return channel.name.lower() == argument.lower()
226 | 
227 |             if found := discord.utils.find(check, ctx.guild.text_channels):
228 |                 return found
229 | 
230 |             raise commands.ChannelNotFound(argument)
231 | 


--------------------------------------------------------------------------------
/utils/default.py:
--------------------------------------------------------------------------------
 1 | from __future__ import annotations
 2 | 
 3 | import re
 4 | from datetime import datetime
 5 | from itertools import islice
 6 | from typing import Union
 7 | from unicodedata import normalize as nm
 8 | 
 9 | import discord
10 | 
11 | from constants import IST
12 | 
13 | 
14 | def get_chunks(iterable, size: int):
15 |     it = iter(iterable)
16 |     return iter(lambda: tuple(islice(it, size)), ())
17 | 
18 | 
19 | def split_list(data: list, per_list: int):
20 |     data = list(data)
21 | 
22 |     new = []
23 | 
24 |     for i in range(0, len(data), per_list):
25 |         new.append(data[i : i + per_list])
26 | 
27 |     return new
28 | 
29 | 
30 | def find_team(message: discord.Message):
31 |     """
32 |     Finds team name from a message
33 |     """
34 |     author = message.author
35 |     teamname = re.search(r"team.*", message.content)
36 |     if teamname is None:
37 |         return f"{author}'s team"
38 | 
39 |     # teamname = (re.sub(r"\b[0-9]+\b\s*|team|name|[^\w\s]", "", teamname.group())).strip()
40 |     teamname: str = re.sub(r"<@*#*!*&*\d+>|team|name|[^\w\s]", "", teamname.group()).strip()
41 | 
42 |     teamname = f"Team {teamname.title()}" if teamname else f"{author}'s team"
43 |     return teamname
44 | 
45 | 
46 | def find_drop_location(message: discord.Message):
47 |     """
48 |     Find team's drop location from message, if provided.
49 |     """
50 |     drop_location = re.search(r"drop.*", message.content)
51 |     if drop_location is None:
52 |         return None
53 | 
54 |     drop_location = re.sub(r"<@*#*!*&*\d+>|drop|location|[^\w\s]", "", drop_location.group()).strip()
55 | 
56 |     return drop_location.title() if drop_location else None
57 | 
58 | 
59 | def regional_indicator(c: str) -> str:
60 |     """Returns a regional indicator emoji given a character."""
61 |     return chr(0x1F1E6 - ord("A") + ord(c.upper()))
62 | 
63 | 
64 | def keycap_digit(c: Union[int, str]) -> str:
65 |     """Returns a keycap digit emoji given a character."""
66 |     c = int(c)
67 |     if 0 < c < 10:
68 |         return str(c) + "\U0000FE0F\U000020E3"
69 |     if c == 10:
70 |         return "\U000FE83B"
71 |     raise ValueError("Invalid keycap digit")
72 | 
73 | 
74 | async def aenumerate(asequence, start=0):
75 |     """Asynchronously enumerate an async iterator from a given start value"""
76 |     n = start
77 |     async for elem in asequence:
78 |         yield n, elem
79 |         n += 1
80 | 
81 | 
82 | def get_ipm(bot):
83 |     """Returns Quotient's cmds invoke rate per minute"""
84 |     time = (datetime.now(tz=IST) - bot.start_time).total_seconds()
85 |     per_second = bot.cmd_invokes / time
86 |     per_minute = per_second * 60
87 |     return per_minute
88 | 


--------------------------------------------------------------------------------
/utils/emote.py:
--------------------------------------------------------------------------------
 1 | # never ask me to remove these :c
 2 | red = "<:red:775586906599456779>"
 3 | green = "<:green:775586905580240946>"
 4 | yellow = "<:yellow:775586904439128064>"
 5 | invisible = "<:invisible:775586907680931860>"
 6 | 
 7 | scrimscheck = "<:scrimscheck:839554647861755946>"
 8 | scrimsxmark = "<:scrimscross:839554689778712576>"
 9 | 
10 | info = "<:info2:899020593188462693>"
11 | trash = "<:trashcan:896382424529907742>"
12 | exit = "<:exit:926048897548300339>"
13 | 
14 | 
15 | add = "<:add:844825523003850772>"
16 | remove = "<:remove:844825861295046661>"
17 | edit = "<:edit:844826616735727616>"
18 | 
19 | diamond = "<a:diamond:899295009289949235>"
20 | 
21 | error = "❗"
22 | 
23 | server = "<:server:775586933396078612>"
24 | privacy = "<:privacy:775586938659799060>"
25 | 
26 | one = "1️⃣"
27 | two = "2️⃣"
28 | three = "3️⃣"
29 | four = "4️⃣"
30 | five = "5️⃣"
31 | 
32 | 
33 | rps = "<:rps:833993433415811083>"
34 | 
35 | 
36 | bravery = "<:bravery:833991097222299678>"
37 | brilliance = "<:brilliance:833991154839191573>"
38 | balance = "<:balance:833991183087829012>"
39 | 
40 | supporter = "<:supporter:833991451872198696>"
41 | staff = "<:staff:833991411313147915>"
42 | partner = "<:partner:833991367130087464>"
43 | hypesquad = "<:hypesquad:833991496545206282>"
44 | hypesquad_events = "<:hypesquad_events:833991530418667540>"
45 | bug_hunter = "<:bug_hunter:833991572613234718>"
46 | BugHunterLvl2 = "<:bug_hunter2:833991610357514240>"
47 | bot = "<:bot:833991659133992991>"
48 | bot_devloper = "<:bot_devloper:833991714637217803>"
49 | verified_bot = "<:verifiedbot1:833991773248290817><:verifiedbot2:833991793683070996>"
50 | 
51 | check = "<:check:807913701151342592>"
52 | xmark = "<:xmark:807913737805234176>"
53 | loading = "<a:loading:815826684262744124>"
54 | VoiceChannel = "<:voice:815827186116198430>"
55 | TextChannel = "<:text:815827264679706624>"
56 | category = "<:category:815831557507776583>"
57 | pain = "<:blobpain:831771526368985098>"
58 | settings_yes = "<:settings_mark_off:815169498319159337><:settings_check_on:815169424566517791>"
59 | settings_no = "<:set_no_on:815169465259786241><:set_yes_off:815169360393404436>"
60 | 
61 | 
62 | pstop = "<:stop:829602188593856574>"
63 | pprevious = "<:previous:829602188565151744>"
64 | pnext = "<:next:829602188653101056>"
65 | plast = "<:last:829602188435128331>"
66 | pfirst = "<:first:829602188598312990>"
67 | 
68 | 
69 | red1 = "<:red1:870909062227845122>"
70 | red2 = "<:red2:870909062513061899>"
71 | red3 = "<:red3:870909062877966376>"
72 | red4 = "<:red4:870909062341099572>"
73 | red5 = "<:red5:870909062437548072>"
74 | 
75 | 
76 | green1 = "<:green1:870909061514792991>"
77 | green2 = "<:green2:870909061225390131>"
78 | green3 = "<:green3:870909061661605969>"
79 | green4 = "<:green4:870909062320099329>"
80 | green5 = "<:green5:870909062345281546>"
81 | 
82 | BADGES = {
83 |     "creator": "<:creator:807911084069617674>",
84 |     "dev": "<:dev:807911284040531999>",
85 |     "donator": "<a:donator:807913325861142578>",
86 |     "messenger": "<a:messenger:807912019130974242>",
87 |     "premium": "<a:premium:807911675981201459>",
88 |     "contributor": "<a:contributor:807911226432028704>",
89 |     "staff": "<:staff:807911358549065738>",
90 |     "top_user": "<a:top_user:807911932299837460>",
91 |     "voter": "<:voter:807912082142003220>",
92 | }
93 | 
94 | p = "\U0001f1f5"
95 | e = "\U0001f1ea"
96 | r = "\U0001f1f7"
97 | eye = "👀"
98 | 


--------------------------------------------------------------------------------
/utils/exceptions.py:
--------------------------------------------------------------------------------
 1 | from discord.ext import commands
 2 | 
 3 | 
 4 | class QuotientError(commands.CheckFailure):
 5 |     pass
 6 | 
 7 | 
 8 | class NotSetup(QuotientError):
 9 |     def __init__(self):
10 |         super().__init__(
11 |             "This command requires you to have Quotient's private channel.\nKindly run `{ctx.prefix}setup` and try again."
12 |         )
13 | 
14 | 
15 | class NotPremiumGuild(QuotientError):
16 |     def __init__(self):
17 |         super().__init__(
18 |             "This command requires this server to be premium.\n\nCheckout Quotient Premium [here]({ctx.bot.prime_link})"
19 |         )
20 | 
21 | 
22 | class NotPremiumUser(QuotientError):
23 |     def __init__(self):
24 |         super().__init__(
25 |             "This command requires you to be a premium user.\nCheckout Quotient Premium [here]({ctx.bot.prime_link})"
26 |         )
27 | 
28 | 
29 | class InputError(QuotientError):
30 |     pass
31 | 
32 | 
33 | class SMNotUsable(QuotientError):
34 |     def __init__(self):
35 |         super().__init__("You need either the `scrims-mod` role or `Manage Server` permissions to use this command.")
36 | 
37 | 
38 | class TMNotUsable(QuotientError):
39 |     def __init__(self):
40 |         super().__init__("You need either the `tourney-mod` role or `Manage Server` permissions to use tourney manager.")
41 | 
42 | 
43 | class PastTime(QuotientError):
44 |     def __init__(self):
45 |         super().__init__(
46 |             f"The time you entered seems to be in past.\n\nKindly try again, use times like: `tomorrow` , `friday 9pm`"
47 |         )
48 | 
49 | 
50 | TimeInPast = PastTime
51 | 
52 | 
53 | class InvalidTime(QuotientError):
54 |     def __init__(self):
55 |         super().__init__(f"The time you entered seems to be invalid.\n\nKindly try again.")
56 | 


--------------------------------------------------------------------------------
/utils/formats.py:
--------------------------------------------------------------------------------
 1 | def truncate_string(value, max_length=128, suffix="..."):
 2 |     string_value = str(value)
 3 |     string_truncated = string_value[: min(len(string_value), (max_length - len(suffix)))]
 4 |     suffix = suffix if len(string_value) > max_length else ""
 5 |     return string_truncated + suffix
 6 | 
 7 | 
 8 | class plural:
 9 |     def __init__(self, value):
10 |         self.value = value
11 | 
12 |         if isinstance(self.value, list):
13 |             self.value = len(self.value)
14 | 
15 |     def __format__(self, format_spec):
16 |         v = self.value
17 |         singular, sep, plural = format_spec.partition("|")
18 |         plural = plural or f"{singular}s"
19 |         if abs(v) != 1:
20 |             return f"{v} {plural}"
21 |         return f"{v} {singular}"
22 | 


--------------------------------------------------------------------------------
/utils/inputs.py:
--------------------------------------------------------------------------------
  1 | from __future__ import annotations
  2 | 
  3 | import asyncio
  4 | from contextlib import suppress
  5 | from datetime import datetime, timedelta
  6 | 
  7 | import aiohttp
  8 | import dateparser
  9 | import discord
 10 | from discord.ext.commands import Context
 11 | from discord.ext.commands.converter import MemberConverter, RoleConverter, TextChannelConverter
 12 | 
 13 | from constants import IST
 14 | from utils import keycap_digit
 15 | 
 16 | from .exceptions import InputError
 17 | 
 18 | 
 19 | async def safe_delete(message) -> bool:
 20 |     try:
 21 |         await message.delete()
 22 |     except (discord.Forbidden, discord.NotFound):
 23 |         return False
 24 |     else:
 25 |         return True
 26 | 
 27 | 
 28 | async def channel_input(ctx: Context, check=None, timeout=120, delete_after=False, check_perms=True):
 29 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
 30 |     try:
 31 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
 32 |     except asyncio.TimeoutError:
 33 |         raise InputError("You failed to select a channel in time. Try again!")
 34 | 
 35 |     else:
 36 |         channel = await TextChannelConverter().convert(ctx, message.content)
 37 | 
 38 |         perms = channel.permissions_for(ctx.me)
 39 | 
 40 |         if not all((perms.read_messages, perms.send_messages, perms.embed_links)):
 41 |             raise InputError(
 42 |                 f"Please make sure I have the following perms in {channel.mention}:\n"
 43 |                 "`read_messages`,`send_messages`,`embed_links`."
 44 |             )
 45 | 
 46 |         if check_perms:
 47 |             if not all(
 48 |                 (
 49 |                     perms.manage_channels,
 50 |                     perms.add_reactions,
 51 |                     perms.use_external_emojis,
 52 |                     perms.manage_permissions,
 53 |                     perms.manage_messages,
 54 |                 )
 55 |             ):
 56 |                 raise InputError(
 57 |                     f"Please make sure I have the following perms in {channel.mention}:\n"
 58 |                     "- `add reactions`\n- `use external emojis`\n- `manage channel`\n- `manage permissions`\n"
 59 |                     "- `manage messages`"
 60 |                 )
 61 |         if delete_after:
 62 |             await safe_delete(message)
 63 | 
 64 |         return channel
 65 | 
 66 | 
 67 | async def role_input(ctx: Context, check=None, timeout=120, hierarchy=True, check_perms=True, delete_after=False):
 68 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
 69 | 
 70 |     try:
 71 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
 72 |         role = await RoleConverter().convert(ctx, message.content)
 73 |     except asyncio.TimeoutError:
 74 |         raise InputError("You failed to select a role in time. Try again!")
 75 | 
 76 |     else:
 77 |         if role.managed:
 78 |             raise InputError(f"Role is an integrated role and cannot be added manually.")
 79 |         if hierarchy:
 80 |             if role > ctx.me.top_role:
 81 |                 raise InputError(
 82 |                     f"The position of {role.mention} is above my top role. So I can't give it to anyone.\nKindly move {ctx.me.top_role.mention} above {role.mention} in Server Settings."
 83 |                 )
 84 | 
 85 |             if ctx.author.id != ctx.guild.owner_id:
 86 |                 if role > ctx.author.top_role:
 87 |                     raise InputError(
 88 |                         f"The position of {role.mention} is above your top role {ctx.author.top_role.mention}."
 89 |                     )
 90 | 
 91 |         if check_perms:
 92 |             _perms = role.permissions
 93 |             if any(
 94 |                 (
 95 |                     _perms.administrator,
 96 |                     _perms.manage_channels,
 97 |                     _perms.manage_roles,
 98 |                     _perms.kick_members,
 99 |                     _perms.ban_members,
100 |                 )
101 |             ):
102 |                 raise InputError(f"{role.mention} has dangerous permissions.")
103 | 
104 |         if delete_after:
105 |             await safe_delete(message)
106 | 
107 |         return role
108 | 
109 | 
110 | async def member_input(ctx: Context, check=None, timeout=120, delete_after=False):
111 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
112 | 
113 |     try:
114 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
115 |         member = await MemberConverter().convert(ctx, message.content)
116 | 
117 |     except asyncio.TimeoutError:
118 |         raise InputError("You failed to mention a member in time. Try again!")
119 | 
120 |     else:
121 |         if delete_after:
122 |             await safe_delete(message)
123 | 
124 |         return member
125 | 
126 | 
127 | async def integer_input(ctx: Context, check=None, timeout=120, limits=(None, None), delete_after=False):
128 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
129 | 
130 |     def new_check(message: discord.Message):
131 |         if not check(message):
132 |             return False
133 | 
134 |         try:
135 |             if limits[1] is not None:
136 |                 if len(message.content) > len(str(limits[1])):  # This is for safe side, memory errors u know :)
137 |                     return False
138 | 
139 |             digit = int(message.content)
140 | 
141 |         except ValueError:
142 |             return False
143 |         else:
144 |             if not any(limits):  # No Limits
145 |                 return True
146 | 
147 |             low, high = limits
148 | 
149 |             if all(limits):
150 |                 return low <= digit <= high
151 |             if low is not None:
152 |                 return low <= digit
153 |             return high <= digit
154 | 
155 |     try:
156 |         message: discord.Message = await ctx.bot.wait_for("message", check=new_check, timeout=timeout)
157 |     except asyncio.TimeoutError:
158 |         raise InputError("You failed to select a number in time. Try again!")
159 |     else:
160 |         if delete_after:
161 |             await safe_delete(message)
162 | 
163 |         return int(message.content)
164 | 
165 | 
166 | async def time_input(ctx: Context, check=None, timeout=120, delete_after=False):
167 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
168 | 
169 |     try:
170 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
171 |     except asyncio.TimeoutError:
172 |         raise InputError("Timeout, You have't responsed in time. Try again!")
173 |     else:
174 |         try:
175 |             parsed = dateparser.parse(
176 |                 message.content,
177 |                 settings={
178 |                     # "RELATIVE_BASE": datetime.now(tz=IST),
179 |                     "TIMEZONE": "Asia/Kolkata",
180 |                     "RETURN_AS_TIMEZONE_AWARE": True,
181 |                 },
182 |             )
183 | 
184 |             if delete_after:
185 |                 await safe_delete(message)
186 | 
187 |             while datetime.now(tz=IST) > parsed:
188 |                 parsed = parsed + timedelta(hours=24)
189 | 
190 |             return parsed
191 | 
192 |         except TypeError:
193 |             raise InputError("This isn't valid time format.")
194 | 
195 | 
196 | async def string_input(ctx: Context, check=None, timeout=120, delete_after=False):
197 |     check = check or (lambda m: m.channel == ctx.channel and m.author == ctx.author)
198 | 
199 |     try:
200 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
201 |     except asyncio.TimeoutError:
202 |         raise InputError("Took too long. Good Bye.")  # This would sound cooler.
203 |     else:
204 |         if delete_after:
205 |             await safe_delete(message)
206 | 
207 |         return message.content
208 | 
209 | 
210 | async def image_input(ctx: Context, check, timeout=120, delete_after=False):
211 |     try:
212 |         message: discord.Message = await ctx.bot.wait_for("message", check=check, timeout=timeout)
213 |     except asyncio.TimeoutError:
214 |         raise InputError("Took too long. Good Bye.")
215 | 
216 |     else:
217 |         if delete_after:
218 |             await safe_delete(message)
219 | 
220 |         if message.content.strip().lower() == "none":
221 |             return None
222 | 
223 |         _image_formats = ("image/png", "image/jpeg", "image/jpg", "image/gif")
224 | 
225 |         if message.attachments and message.attachments[0].content_type in _image_formats:
226 |             return message.attachments[0].proxy_url
227 | 
228 |         result = None
229 |         with suppress(aiohttp.InvalidURL):
230 |             res = await ctx.bot.session.get(message.content)
231 |             if res.headers["content-type"] in _image_formats:
232 |                 result = message.content
233 | 
234 |         return result
235 | 
236 | 
237 | async def text_or_embed(ctx: Context, check, timeout=120, delete_after=False):
238 |     reactions = (keycap_digit(1), keycap_digit(2))
239 | 
240 |     def react_check(reaction, user):
241 |         return user == ctx.author and str(reaction.emoji) in reactions
242 | 
243 |     msg = await ctx.simple(
244 |         f"What do you want the content to be?\n\n{keycap_digit(1)} | Simple Text\n{keycap_digit(2)} | Embed"
245 |     )
246 | 
247 |     for reaction in reactions:
248 |         await msg.add_reaction(reaction)
249 | 
250 |     reaction, user = await ctx.bot.wait_for("reaction_add", timeout=15, check=react_check)
251 | 
252 |     if delete_after:
253 |         await safe_delete(msg)
254 | 
255 |     if str(reaction.emoji) == keycap_digit(1):
256 |         msg = await ctx.simple("Kindly enter the text now.")
257 |         text = await string_input(ctx, check, delete_after=True)
258 | 
259 |         if delete_after:
260 |             await safe_delete(msg)
261 | 
262 |         return text
263 | 
264 |     if str(reaction.emoji) == keycap_digit(2):
265 |         msg = await ctx.simple(f"embed ki .......")
266 | 


--------------------------------------------------------------------------------
/utils/paginator.py:
--------------------------------------------------------------------------------
  1 | from contextlib import suppress
  2 | from typing import NamedTuple, Optional
  3 | 
  4 | import discord
  5 | 
  6 | from .default import get_chunks
  7 | 
  8 | 
  9 | class Page(NamedTuple):
 10 |     index: int
 11 |     content: str
 12 | 
 13 | 
 14 | class Pages:
 15 |     def __init__(self, pages: list):
 16 |         self.pages = pages
 17 |         self.cur_page = 1
 18 | 
 19 |     @property
 20 |     def current_page(self) -> Page:
 21 |         return Page(self.cur_page, self.pages[self.cur_page - 1])
 22 | 
 23 |     @property
 24 |     def next_page(self) -> Optional[Page]:
 25 |         if self.cur_page == self.total:
 26 |             return None
 27 | 
 28 |         self.cur_page += 1
 29 |         return self.current_page
 30 | 
 31 |     @property
 32 |     def previous_page(self) -> Optional[Page]:
 33 |         if self.cur_page == 1:
 34 |             return None
 35 | 
 36 |         self.cur_page -= 1
 37 |         return self.current_page
 38 | 
 39 |     @property
 40 |     def first_page(self) -> Page:
 41 |         self.cur_page = 1
 42 |         return self.current_page
 43 | 
 44 |     @property
 45 |     def last_page(self) -> Page:
 46 |         self.cur_page = self.total
 47 |         return self.current_page
 48 | 
 49 |     @property
 50 |     def total(self):
 51 |         return len(self.pages)
 52 | 
 53 | 
 54 | class QuoPaginator:
 55 |     def __init__(self, ctx, *, per_page=10, timeout=60.0, title=None, show_page_count=True):
 56 |         self.ctx = ctx
 57 |         self.per_page = per_page
 58 |         self.timeout = timeout
 59 |         self.title = title
 60 |         self.show_page_count = show_page_count
 61 | 
 62 |         self.lines = []
 63 |         self.pages = None
 64 | 
 65 |     def add_line(self, line: str, sep="\n"):
 66 |         self.lines.append(f"{line}{sep}")
 67 | 
 68 |     @property
 69 |     def embed(self):
 70 |         page = self.pages.current_page
 71 | 
 72 |         e = discord.Embed(color=self.ctx.bot.color)
 73 |         if self.title:
 74 |             e.title = self.title
 75 | 
 76 |         e.description = page.content
 77 | 
 78 |         if self.show_page_count:
 79 |             e.set_footer(text=f"Page {page.index} of {self.pages.total}")
 80 | 
 81 |         return e
 82 | 
 83 |     async def start(self):
 84 |         _pages = []
 85 |         for page in get_chunks(self.lines, self.per_page):
 86 |             _pages.append("".join(page))
 87 | 
 88 |         self.pages = Pages(_pages)
 89 | 
 90 |         if not self.pages.total > 1:
 91 |             return await self.ctx.send(embed=self.embed)
 92 | 
 93 |         view = PaginatorView(
 94 |             self.ctx, pages=self.pages, embed=self.embed, timeout=self.timeout, show_page_count=self.show_page_count
 95 |         )
 96 |         view.message = await self.ctx.send(embed=self.embed, view=view)
 97 | 
 98 | 
 99 | class PaginatorView(discord.ui.View):
100 |     message: discord.Message
101 | 
102 |     def __init__(self, ctx, pages: Pages, embed, timeout, show_page_count):
103 |         super().__init__(timeout=timeout)
104 | 
105 |         self.ctx = ctx
106 |         self.pages = pages
107 |         self.embed: discord.Embed = embed
108 |         self.show_page_count = show_page_count
109 | 
110 |         if self.pages.cur_page == 1:
111 |             self.children[0].disabled = True
112 |             self.children[1].disabled = True
113 | 
114 |     def lock_bro(self):
115 |         if self.pages.cur_page == self.pages.total:
116 |             self.children[0].disabled = False
117 |             self.children[1].disabled = False
118 | 
119 |             self.children[2].disabled = True
120 |             self.children[3].disabled = True
121 | 
122 |         elif self.pages.cur_page == 1:
123 |             self.children[0].disabled = True
124 |             self.children[1].disabled = True
125 | 
126 |             self.children[2].disabled = False
127 |             self.children[3].disabled = False
128 | 
129 |         elif 1 < self.pages.cur_page < self.pages.total:
130 |             for b in self.children:
131 |                 b.disabled = False
132 | 
133 |     def update_embed(self, page: Page):
134 |         if self.show_page_count:
135 |             self.embed.set_footer(text=f"Page {page.index} of {self.pages.total}")
136 | 
137 |         self.embed.description = page.content
138 | 
139 |     async def interaction_check(self, interaction: discord.Interaction) -> bool:
140 |         if interaction.user.id != self.ctx.author.id:
141 |             await interaction.response.send_message(
142 |                 "Sorry, you can't use this interaction as it is not started by you.", ephemeral=True
143 |             )
144 |             return False
145 |         return True
146 | 
147 |     async def on_timeout(self) -> None:
148 |         for b in self.children:
149 |             b.style, b.disabled = discord.ButtonStyle.grey, True
150 | 
151 |         with suppress(discord.HTTPException):
152 |             await self.message.edit(view=self)
153 | 
154 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="first", emoji="<:double_left:878668594530099220>")
155 |     async def first(self, interaction: discord.Interaction, button: discord.ui.Button):
156 |         await interaction.response.defer()
157 |         page = self.pages.first_page
158 | 
159 |         self.update_embed(page)
160 |         self.lock_bro()
161 |         await interaction.message.edit(embed=self.embed, view=self)
162 | 
163 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="previous", emoji="<:left:878668491660623872>")
164 |     async def previous(self, interaction: discord.Interaction, button: discord.ui.Button):
165 |         await interaction.response.defer()
166 |         page = self.pages.previous_page
167 |         self.update_embed(page)
168 |         self.lock_bro()
169 |         await interaction.message.edit(embed=self.embed, view=self)
170 | 
171 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="next", emoji="<:right:878668370331983913>")
172 |     async def next(self, interaction: discord.Interaction, button: discord.ui.Button):
173 |         await interaction.response.defer()
174 |         page = self.pages.next_page
175 |         self.update_embed(page)
176 | 
177 |         self.lock_bro()
178 |         await interaction.message.edit(embed=self.embed, view=self)
179 | 
180 |     @discord.ui.button(style=discord.ButtonStyle.green, custom_id="last", emoji="<:double_right:878668437193359392>")
181 |     async def last(self, interaction: discord.Interaction, button: discord.ui.Button):
182 |         await interaction.response.defer()
183 |         page = self.pages.last_page
184 | 
185 |         self.update_embed(page)
186 |         self.lock_bro()
187 |         await interaction.message.edit(embed=self.embed, view=self)
188 | 


--------------------------------------------------------------------------------
/utils/regex.py:
--------------------------------------------------------------------------------
 1 | import re
 2 | 
 3 | """
 4 | Regex compiled by pythondiscord.com
 5 | Helper regex for moderation
 6 | """
 7 | 
 8 | INVITE_RE = re.compile(
 9 |     r"(?:discord(?:[\.,]|dot)gg|"  # Could be discord.gg/
10 |     r"discord(?:[\.,]|dot)com(?:\/|slash)invite|"  # or discord.com/invite/
11 |     r"discordapp(?:[\.,]|dot)com(?:\/|slash)invite|"  # or discordapp.com/invite/
12 |     r"discord(?:[\.,]|dot)me|"  # or discord.me
13 |     r"discord(?:[\.,]|dot)io"  # or discord.io.
14 |     r")(?:[\/]|slash)"  # / or 'slash'
15 |     r"([a-zA-Z0-9\-]+)",  # the invite code itself
16 |     flags=re.IGNORECASE,
17 | )
18 | 
19 | 
20 | TIME_REGEX = re.compile(r"(?:(\d{1,5})(h|s|m|d))+?")
21 | 


--------------------------------------------------------------------------------
/utils/time.py:
--------------------------------------------------------------------------------
  1 | import datetime as dtm
  2 | import re
  3 | 
  4 | import dateparser
  5 | import parsedatetime as pdt
  6 | from dateutil.parser import ParserError, parse
  7 | from dateutil.relativedelta import relativedelta
  8 | from discord.ext import commands
  9 | 
 10 | from constants import IST
 11 | from core import Context
 12 | from utils import exceptions
 13 | 
 14 | from .formats import plural
 15 | from .regex import TIME_REGEX
 16 | 
 17 | units = pdt.pdtLocales["en_US"].units
 18 | 
 19 | 
 20 | class PastDate(commands.Converter):
 21 |     async def convert(self, ctx, argument):
 22 |         try:
 23 |             dt = parse(argument, ignoretz=True)
 24 |         except ParserError:
 25 |             raise commands.BadArgument(
 26 |                 "The date format you entered seems to be Invalid.\n\n"
 27 |                 "The day can be human readable date like `11 May` or maybe a more concrete one such as '4-05-2021'"
 28 |             )
 29 | 
 30 |         else:
 31 |             if dt.date() > dtm.datetime.now().date():
 32 |                 raise commands.BadArgument(
 33 |                     "This date seems to be in future, either write today's date or some date that is in past."
 34 |                 )
 35 | 
 36 |             return IST.localize(dt.replace(hour=0, minute=0, second=0, microsecond=0))
 37 | 
 38 | 
 39 | class ShortTime:
 40 |     compiled = re.compile(
 41 |         """(?:(?P<years>[0-9])(?:years?|y))?             # e.g. 2y
 42 |                              (?:(?P<months>[0-9]{1,2})(?:months?|mo))?     # e.g. 2months
 43 |                              (?:(?P<weeks>[0-9]{1,4})(?:weeks?|w))?        # e.g. 10w
 44 |                              (?:(?P<days>[0-9]{1,5})(?:days?|d))?          # e.g. 14d
 45 |                              (?:(?P<hours>[0-9]{1,5})(?:hours?|h))?        # e.g. 12h
 46 |                              (?:(?P<minutes>[0-9]{1,5})(?:minutes?|m))?    # e.g. 10m
 47 |                              (?:(?P<seconds>[0-9]{1,5})(?:seconds?|s))?    # e.g. 15s
 48 |                           """,
 49 |         re.VERBOSE,
 50 |     )
 51 | 
 52 |     def __init__(self, argument, *, now=None):
 53 |         match = self.compiled.fullmatch(argument)
 54 |         if match is None or not match.group(0):
 55 |             raise exceptions.InvalidTime()
 56 | 
 57 |         data = {k: int(v) for k, v in match.groupdict(default=0).items()}
 58 |         now = dtm.datetime.now(tz=IST)
 59 |         self.dt = now + relativedelta(**data)
 60 | 
 61 |     @classmethod
 62 |     async def convert(cls, ctx, argument):
 63 |         return cls(argument, now=dtm.datetime.now(tz=IST))
 64 | 
 65 | 
 66 | class HumanTime:
 67 |     calendar = pdt.Calendar(version=pdt.VERSION_CONTEXT_STYLE)
 68 | 
 69 |     def __init__(self, argument, *, now=None):
 70 |         now = now or dtm.datetime.now(tz=IST)
 71 |         dt, status = self.calendar.parseDT(argument, sourceTime=now)
 72 |         if not status.hasDateOrTime:
 73 |             raise exceptions.InvalidTime()
 74 | 
 75 |         dt = dt.replace(tzinfo=IST)
 76 | 
 77 |         if not status.hasTime:
 78 |             # replace it with the current time
 79 |             dt = dt.replace(hour=now.hour, minute=now.minute, second=now.second, microsecond=now.microsecond)
 80 | 
 81 |         self.dt = dt
 82 |         self._past = dt < now
 83 | 
 84 |     @classmethod
 85 |     async def convert(cls, ctx, argument):
 86 |         return cls(argument, now=ctx.message.created_at)
 87 | 
 88 | 
 89 | class Time(HumanTime):
 90 |     def __init__(self, argument, *, now=None):
 91 |         try:
 92 |             o = ShortTime(argument, now=now)
 93 |         except Exception as e:
 94 |             super().__init__(argument)
 95 |         else:
 96 |             self.dt = o.dt
 97 |             self._past = False
 98 | 
 99 | 
100 | class FutureTime(Time):
101 |     def __init__(self, argument, *, now=None):
102 |         super().__init__(argument, now=dtm.datetime.now(tz=IST))
103 | 
104 |         if self._past:
105 |             raise exceptions.PastTime()
106 | 
107 | 
108 | class BetterFutureTime:
109 |     @classmethod
110 |     async def convert(cls, ctx, argument: str):
111 |         if not "in" in argument:
112 |             argument = "in " + argument
113 | 
114 |         parsed = dateparser.parse(
115 |             argument,
116 |             settings={
117 |                 # "RELATIVE_BASE": dtm.datetime.now(tz=IST),
118 |                 "TIMEZONE": "Asia/Kolkata",
119 |                 "RETURN_AS_TIMEZONE_AWARE": True,
120 |             },
121 |         )
122 |         if not parsed:
123 |             raise exceptions.InvalidTime()
124 | 
125 |         if dtm.datetime.now(tz=IST) > parsed:
126 |             parsed = parsed + dtm.timedelta(hours=24)
127 | 
128 |         if parsed < dtm.datetime.now(tz=IST):
129 |             raise exceptions.PastTime()
130 | 
131 |         return parsed
132 | 
133 | 
134 | def time(target):
135 |     return target.strftime("%d-%b-%Y %I:%M %p")
136 | 
137 | 
138 | def day_today():
139 |     return dtm.datetime.now().strftime("%A").lower()
140 | 
141 | 
142 | def strtime(target):
143 |     return target.strftime("%d-%b-%Y %I:%M %p")
144 | 
145 | 
146 | def discord_timestamp(time_to_convert, mode="R"):
147 |     formated_strftime = f"<t:{int(time_to_convert.timestamp())}:{mode}>"
148 | 
149 |     return formated_strftime
150 | 
151 | 
152 | # def strtime(target):
153 | #     return f"<t:{int(target.timestamp())}:R>"
154 | 
155 | 
156 | def human_join(seq, delim=", ", final="or"):
157 |     size = len(seq)
158 |     if size == 0:
159 |         return ""
160 | 
161 |     if size == 1:
162 |         return seq[0]
163 | 
164 |     if size == 2:
165 |         return f"{seq[0]} {final} {seq[1]}"
166 | 
167 |     return delim.join(seq[:-1]) + f" {final} {seq[-1]}"
168 | 
169 | 
170 | def human_timedelta(dt, *, source=None, accuracy=3, brief=False, suffix=True):
171 |     now = source or dtm.datetime.now(tz=IST)
172 |     # Microsecond free zone
173 |     now = now.replace(microsecond=0)
174 |     dt = dt.replace(microsecond=0)
175 | 
176 |     # This implementation uses relativedelta instead of the much more obvious
177 |     # divmod approach with seconds because the seconds approach is not entirely
178 |     # accurate once you go over 1 week in terms of accuracy since you have to
179 |     # hardcode a month as 30 or 31 days.
180 |     # A query like "11 months" can be interpreted as "!1 months and 6 days"
181 |     if dt > now:
182 |         delta = relativedelta(dt, now)
183 |         suffix = ""
184 |     else:
185 |         delta = relativedelta(now, dt)
186 |         suffix = " ago" if suffix else ""
187 | 
188 |     attrs = [
189 |         ("year", "y"),
190 |         ("month", "mo"),
191 |         ("day", "d"),
192 |         ("hour", "h"),
193 |         ("minute", "m"),
194 |         ("second", "s"),
195 |     ]
196 | 
197 |     output = []
198 |     for attr, brief_attr in attrs:
199 |         elem = getattr(delta, attr + "s")
200 |         if not elem:
201 |             continue
202 | 
203 |         if attr == "day":
204 |             weeks = delta.weeks
205 |             if weeks:
206 |                 elem -= weeks * 7
207 |                 if not brief:
208 |                     output.append(format(plural(weeks), "week"))
209 |                 else:
210 |                     output.append(f"{weeks}w")
211 | 
212 |         if elem <= 0:
213 |             continue
214 | 
215 |         if brief:
216 |             output.append(f"{elem}{brief_attr}")
217 |         else:
218 |             output.append(format(plural(elem), attr))
219 | 
220 |     if accuracy is not None:
221 |         output = output[:accuracy]
222 | 
223 |     if len(output) == 0:
224 |         return "now"
225 |     if not brief:
226 |         return human_join(output, final="and") + suffix
227 |     return " ".join(output) + suffix
228 | 
229 | 
230 | time_dict = {"h": 3600, "s": 1, "m": 60, "d": 86400}
231 | 
232 | 
233 | def simple_convert(argument):
234 |     args = argument.lower()
235 |     matches = re.findall(TIME_REGEX, args)
236 |     time = 0
237 |     for key, value in matches:
238 |         try:
239 |             time += time_dict[value] * float(key)
240 |         except KeyError:
241 |             raise commands.BadArgument(f"{value} is an invalid time key! h|m|s|d are valid arguments")
242 |         except ValueError:
243 |             raise commands.BadArgument(f"{key} is not a number!")
244 | 
245 |     return round(time)
246 | 
247 | 
248 | class TimeText(commands.Converter):
249 |     def __init__(self, converter=None):
250 |         self.converter = converter
251 | 
252 |     def __final_checks(self, dt, remaining=None):
253 |         self.arg = remaining
254 |         if remaining and remaining.strip() == "":
255 |             self.arg = None
256 | 
257 |         self.dt = dt
258 |         if self.dt:
259 |             while self.dt < dtm.datetime.now():
260 |                 self.dt += dtm.timedelta(days=1)
261 | 
262 |             self.dt = IST.localize(self.dt)
263 |         return self
264 | 
265 |     async def convert(self, ctx: Context, argument: str):
266 |         try:
267 |             calendar = HumanTime.calendar
268 |             regex = ShortTime.compiled
269 |             now = dtm.datetime.now()
270 | 
271 |             match = regex.match(argument)
272 |             if match is not None and match.group(0):
273 |                 data = {k: int(v) for k, v in match.groupdict(default=0).items()}
274 |                 remaining = argument[match.end() :].strip()
275 |                 dt = now + relativedelta(**data)
276 | 
277 |                 return self.__final_checks(dt, remaining)
278 | 
279 |             if argument.endswith("from now"):
280 |                 argument = argument[:-8].strip()
281 | 
282 |             if argument[0:2] == "me":
283 |                 # starts with "me to", "me in", or "me at "
284 |                 if argument[0:6] in ("me to ", "me in ", "me at "):
285 |                     argument = argument[6:]
286 | 
287 |             elements = calendar.nlp(argument, sourceTime=now)
288 |             if elements is None or len(elements) == 0:
289 |                 return self.__final_checks(None, argument)
290 | 
291 |             dt, status, begin, end, dt_string = elements[0]
292 | 
293 |             if begin in (0, 1):
294 |                 if begin == 1:
295 |                     remaining = argument[end + 1 :].lstrip(" ,.!")
296 |                 else:
297 |                     remaining = argument[end:].lstrip(" ,.!")
298 | 
299 |             elif len(argument) == end:
300 |                 remaining = argument[:begin].strip()
301 | 
302 |             if not status.hasDateOrTime:
303 |                 return self.__final_checks(None, remaining)
304 | 
305 |             if status.accuracy == pdt.pdtContext.ACU_HALFDAY:
306 |                 dt = dt.replace(day=now.day + 1)
307 | 
308 |             return self.__final_checks(dt, remaining)
309 | 
310 |         except:
311 |             import traceback
312 | 
313 |             traceback.print_exc()
314 |             raise
315 | 


--------------------------------------------------------------------------------